"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turf+tin@6.5.0";
exports.ids = ["vendor-chunks/@turf+tin@6.5.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@turf+tin@6.5.0/node_modules/@turf/tin/dist/es/index.js":
/*!************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+tin@6.5.0/node_modules/@turf/tin/dist/es/index.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ tin)\n/* harmony export */ });\n/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ \"(ssr)/./node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js\");\n// http://en.wikipedia.org/wiki/Delaunay_triangulation\n// https://github.com/ironwallaby/delaunay\n\n/**\n * Takes a set of {@link Point|points} and creates a\n * [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),\n * or a TIN for short, returned as a collection of Polygons. These are often used\n * for developing elevation contour maps or stepped heat visualizations.\n *\n * If an optional z-value property is provided then it is added as properties called `a`, `b`,\n * and `c` representing its value at each of the points that represent the corners of the\n * triangle.\n *\n * @name tin\n * @param {FeatureCollection<Point>} points input points\n * @param {String} [z] name of the property from which to pull z values\n * This is optional: if not given, then there will be no extra data added to the derived triangles.\n * @returns {FeatureCollection<Polygon>} TIN output\n * @example\n * // generate some random point data\n * var points = turf.randomPoint(30, {bbox: [50, 30, 70, 50]});\n *\n * // add a random property to each point between 0 and 9\n * for (var i = 0; i < points.features.length; i++) {\n *   points.features[i].properties.z = ~~(Math.random() * 9);\n * }\n * var tin = turf.tin(points, 'z');\n *\n * //addToMap\n * var addToMap = [tin, points]\n * for (var i = 0; i < tin.features.length; i++) {\n *   var properties  = tin.features[i].properties;\n *   properties.fill = '#' + properties.a + properties.b + properties.c;\n * }\n */\nfunction tin(points, z) {\n    // break down points\n    var isPointZ = false;\n    return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.featureCollection)(triangulate(points.features.map(function (p) {\n        var point = {\n            x: p.geometry.coordinates[0],\n            y: p.geometry.coordinates[1],\n        };\n        if (z) {\n            point.z = p.properties[z];\n        }\n        else if (p.geometry.coordinates.length === 3) {\n            isPointZ = true;\n            point.z = p.geometry.coordinates[2];\n        }\n        return point;\n    })).map(function (triangle) {\n        var a = [triangle.a.x, triangle.a.y];\n        var b = [triangle.b.x, triangle.b.y];\n        var c = [triangle.c.x, triangle.c.y];\n        var properties = {};\n        // Add z coordinates to triangle points if user passed\n        // them in that way otherwise add it as a property.\n        if (isPointZ) {\n            a.push(triangle.a.z);\n            b.push(triangle.b.z);\n            c.push(triangle.c.z);\n        }\n        else {\n            properties = {\n                a: triangle.a.z,\n                b: triangle.b.z,\n                c: triangle.c.z,\n            };\n        }\n        return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.polygon)([[a, b, c, a]], properties);\n    }));\n}\nvar Triangle = /** @class */ (function () {\n    function Triangle(a, b, c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        var A = b.x - a.x;\n        var B = b.y - a.y;\n        var C = c.x - a.x;\n        var D = c.y - a.y;\n        var E = A * (a.x + b.x) + B * (a.y + b.y);\n        var F = C * (a.x + c.x) + D * (a.y + c.y);\n        var G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\n        var dx;\n        var dy;\n        // If the points of the triangle are collinear, then just find the\n        // extremes and use the midpoint as the center of the circumcircle.\n        this.x = (D * E - B * F) / G;\n        this.y = (A * F - C * E) / G;\n        dx = this.x - a.x;\n        dy = this.y - a.y;\n        this.r = dx * dx + dy * dy;\n    }\n    return Triangle;\n}());\nfunction byX(a, b) {\n    return b.x - a.x;\n}\nfunction dedup(edges) {\n    var j = edges.length;\n    var a;\n    var b;\n    var i;\n    var m;\n    var n;\n    outer: while (j) {\n        b = edges[--j];\n        a = edges[--j];\n        i = j;\n        while (i) {\n            n = edges[--i];\n            m = edges[--i];\n            if ((a === m && b === n) || (a === n && b === m)) {\n                edges.splice(j, 2);\n                edges.splice(i, 2);\n                j -= 2;\n                continue outer;\n            }\n        }\n    }\n}\nfunction triangulate(vertices) {\n    // Bail if there aren't enough vertices to form any triangles.\n    if (vertices.length < 3) {\n        return [];\n    }\n    // Ensure the vertex array is in order of descending X coordinate\n    // (which is needed to ensure a subquadratic runtime), and then find\n    // the bounding box around the points.\n    vertices.sort(byX);\n    var i = vertices.length - 1;\n    var xmin = vertices[i].x;\n    var xmax = vertices[0].x;\n    var ymin = vertices[i].y;\n    var ymax = ymin;\n    var epsilon = 1e-12;\n    var a;\n    var b;\n    var c;\n    var A;\n    var B;\n    var G;\n    while (i--) {\n        if (vertices[i].y < ymin) {\n            ymin = vertices[i].y;\n        }\n        if (vertices[i].y > ymax) {\n            ymax = vertices[i].y;\n        }\n    }\n    // Find a supertriangle, which is a triangle that surrounds all the\n    // vertices. This is used like something of a sentinel value to remove\n    // cases in the main algorithm, and is removed before we return any\n    // results.\n    // Once found, put it in the \"open\" list. (The \"open\" list is for\n    // triangles who may still need to be considered; the \"closed\" list is\n    // for triangles which do not.)\n    var dx = xmax - xmin;\n    var dy = ymax - ymin;\n    var dmax = dx > dy ? dx : dy;\n    var xmid = (xmax + xmin) * 0.5;\n    var ymid = (ymax + ymin) * 0.5;\n    var open = [\n        new Triangle({\n            __sentinel: true,\n            x: xmid - 20 * dmax,\n            y: ymid - dmax,\n        }, {\n            __sentinel: true,\n            x: xmid,\n            y: ymid + 20 * dmax,\n        }, {\n            __sentinel: true,\n            x: xmid + 20 * dmax,\n            y: ymid - dmax,\n        }),\n    ];\n    var closed = [];\n    var edges = [];\n    var j;\n    // Incrementally add each vertex to the mesh.\n    i = vertices.length;\n    while (i--) {\n        // For each open triangle, check to see if the current point is\n        // inside it's circumcircle. If it is, remove the triangle and add\n        // it's edges to an edge list.\n        edges.length = 0;\n        j = open.length;\n        while (j--) {\n            // If this point is to the right of this triangle's circumcircle,\n            // then this triangle should never get checked again. Remove it\n            // from the open list, add it to the closed list, and skip.\n            dx = vertices[i].x - open[j].x;\n            if (dx > 0 && dx * dx > open[j].r) {\n                closed.push(open[j]);\n                open.splice(j, 1);\n                continue;\n            }\n            // If not, skip this triangle.\n            dy = vertices[i].y - open[j].y;\n            if (dx * dx + dy * dy > open[j].r) {\n                continue;\n            }\n            // Remove the triangle and add it's edges to the edge list.\n            edges.push(open[j].a, open[j].b, open[j].b, open[j].c, open[j].c, open[j].a);\n            open.splice(j, 1);\n        }\n        // Remove any doubled edges.\n        dedup(edges);\n        // Add a new triangle for each edge.\n        j = edges.length;\n        while (j) {\n            b = edges[--j];\n            a = edges[--j];\n            c = vertices[i];\n            // Avoid adding colinear triangles (which have error-prone\n            // circumcircles)\n            A = b.x - a.x;\n            B = b.y - a.y;\n            G = 2 * (A * (c.y - b.y) - B * (c.x - b.x));\n            if (Math.abs(G) > epsilon) {\n                open.push(new Triangle(a, b, c));\n            }\n        }\n    }\n    // Copy any remaining open triangles to the closed list, and then\n    // remove any triangles that share a vertex with the supertriangle.\n    Array.prototype.push.apply(closed, open);\n    i = closed.length;\n    while (i--) {\n        if (closed[i].a.__sentinel ||\n            closed[i].b.__sentinel ||\n            closed[i].c.__sentinel) {\n            closed.splice(i, 1);\n        }\n    }\n    return closed;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrdGluQDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi90aW4vZGlzdC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDMkQ7QUFDM0Q7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMEJBQTBCO0FBQ3JDLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsNEJBQTRCO0FBQ3pDO0FBQ0E7QUFDQSxzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQSxXQUFXLGdFQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBTztBQUN0QixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrdGluQDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi90aW4vZGlzdC9lcy9pbmRleC5qcz8zYzllIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsYXVuYXlfdHJpYW5ndWxhdGlvblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2lyb253YWxsYWJ5L2RlbGF1bmF5XG5pbXBvcnQgeyBmZWF0dXJlQ29sbGVjdGlvbiwgcG9seWdvbiB9IGZyb20gXCJAdHVyZi9oZWxwZXJzXCI7XG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCBjcmVhdGVzIGFcbiAqIFtUcmlhbmd1bGF0ZWQgSXJyZWd1bGFyIE5ldHdvcmtdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJpYW5ndWxhdGVkX2lycmVndWxhcl9uZXR3b3JrKSxcbiAqIG9yIGEgVElOIGZvciBzaG9ydCwgcmV0dXJuZWQgYXMgYSBjb2xsZWN0aW9uIG9mIFBvbHlnb25zLiBUaGVzZSBhcmUgb2Z0ZW4gdXNlZFxuICogZm9yIGRldmVsb3BpbmcgZWxldmF0aW9uIGNvbnRvdXIgbWFwcyBvciBzdGVwcGVkIGhlYXQgdmlzdWFsaXphdGlvbnMuXG4gKlxuICogSWYgYW4gb3B0aW9uYWwgei12YWx1ZSBwcm9wZXJ0eSBpcyBwcm92aWRlZCB0aGVuIGl0IGlzIGFkZGVkIGFzIHByb3BlcnRpZXMgY2FsbGVkIGBhYCwgYGJgLFxuICogYW5kIGBjYCByZXByZXNlbnRpbmcgaXRzIHZhbHVlIGF0IGVhY2ggb2YgdGhlIHBvaW50cyB0aGF0IHJlcHJlc2VudCB0aGUgY29ybmVycyBvZiB0aGVcbiAqIHRyaWFuZ2xlLlxuICpcbiAqIEBuYW1lIHRpblxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7U3RyaW5nfSBbel0gbmFtZSBvZiB0aGUgcHJvcGVydHkgZnJvbSB3aGljaCB0byBwdWxsIHogdmFsdWVzXG4gKiBUaGlzIGlzIG9wdGlvbmFsOiBpZiBub3QgZ2l2ZW4sIHRoZW4gdGhlcmUgd2lsbCBiZSBubyBleHRyYSBkYXRhIGFkZGVkIHRvIHRoZSBkZXJpdmVkIHRyaWFuZ2xlcy5cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gVElOIG91dHB1dFxuICogQGV4YW1wbGVcbiAqIC8vIGdlbmVyYXRlIHNvbWUgcmFuZG9tIHBvaW50IGRhdGFcbiAqIHZhciBwb2ludHMgPSB0dXJmLnJhbmRvbVBvaW50KDMwLCB7YmJveDogWzUwLCAzMCwgNzAsIDUwXX0pO1xuICpcbiAqIC8vIGFkZCBhIHJhbmRvbSBwcm9wZXJ0eSB0byBlYWNoIHBvaW50IGJldHdlZW4gMCBhbmQgOVxuICogZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAqICAgcG9pbnRzLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMueiA9IH5+KE1hdGgucmFuZG9tKCkgKiA5KTtcbiAqIH1cbiAqIHZhciB0aW4gPSB0dXJmLnRpbihwb2ludHMsICd6Jyk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW3RpbiwgcG9pbnRzXVxuICogZm9yICh2YXIgaSA9IDA7IGkgPCB0aW4uZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAqICAgdmFyIHByb3BlcnRpZXMgID0gdGluLmZlYXR1cmVzW2ldLnByb3BlcnRpZXM7XG4gKiAgIHByb3BlcnRpZXMuZmlsbCA9ICcjJyArIHByb3BlcnRpZXMuYSArIHByb3BlcnRpZXMuYiArIHByb3BlcnRpZXMuYztcbiAqIH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdGluKHBvaW50cywgeikge1xuICAgIC8vIGJyZWFrIGRvd24gcG9pbnRzXG4gICAgdmFyIGlzUG9pbnRaID0gZmFsc2U7XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKHRyaWFuZ3VsYXRlKHBvaW50cy5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgICAgeDogcC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgICAgIHk6IHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh6KSB7XG4gICAgICAgICAgICBwb2ludC56ID0gcC5wcm9wZXJ0aWVzW3pdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoID09PSAzKSB7XG4gICAgICAgICAgICBpc1BvaW50WiA9IHRydWU7XG4gICAgICAgICAgICBwb2ludC56ID0gcC5nZW9tZXRyeS5jb29yZGluYXRlc1syXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfSkpLm1hcChmdW5jdGlvbiAodHJpYW5nbGUpIHtcbiAgICAgICAgdmFyIGEgPSBbdHJpYW5nbGUuYS54LCB0cmlhbmdsZS5hLnldO1xuICAgICAgICB2YXIgYiA9IFt0cmlhbmdsZS5iLngsIHRyaWFuZ2xlLmIueV07XG4gICAgICAgIHZhciBjID0gW3RyaWFuZ2xlLmMueCwgdHJpYW5nbGUuYy55XTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgLy8gQWRkIHogY29vcmRpbmF0ZXMgdG8gdHJpYW5nbGUgcG9pbnRzIGlmIHVzZXIgcGFzc2VkXG4gICAgICAgIC8vIHRoZW0gaW4gdGhhdCB3YXkgb3RoZXJ3aXNlIGFkZCBpdCBhcyBhIHByb3BlcnR5LlxuICAgICAgICBpZiAoaXNQb2ludFopIHtcbiAgICAgICAgICAgIGEucHVzaCh0cmlhbmdsZS5hLnopO1xuICAgICAgICAgICAgYi5wdXNoKHRyaWFuZ2xlLmIueik7XG4gICAgICAgICAgICBjLnB1c2godHJpYW5nbGUuYy56KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7XG4gICAgICAgICAgICAgICAgYTogdHJpYW5nbGUuYS56LFxuICAgICAgICAgICAgICAgIGI6IHRyaWFuZ2xlLmIueixcbiAgICAgICAgICAgICAgICBjOiB0cmlhbmdsZS5jLnosXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2x5Z29uKFtbYSwgYiwgYywgYV1dLCBwcm9wZXJ0aWVzKTtcbiAgICB9KSk7XG59XG52YXIgVHJpYW5nbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJpYW5nbGUoYSwgYiwgYykge1xuICAgICAgICB0aGlzLmEgPSBhO1xuICAgICAgICB0aGlzLmIgPSBiO1xuICAgICAgICB0aGlzLmMgPSBjO1xuICAgICAgICB2YXIgQSA9IGIueCAtIGEueDtcbiAgICAgICAgdmFyIEIgPSBiLnkgLSBhLnk7XG4gICAgICAgIHZhciBDID0gYy54IC0gYS54O1xuICAgICAgICB2YXIgRCA9IGMueSAtIGEueTtcbiAgICAgICAgdmFyIEUgPSBBICogKGEueCArIGIueCkgKyBCICogKGEueSArIGIueSk7XG4gICAgICAgIHZhciBGID0gQyAqIChhLnggKyBjLngpICsgRCAqIChhLnkgKyBjLnkpO1xuICAgICAgICB2YXIgRyA9IDIgKiAoQSAqIChjLnkgLSBiLnkpIC0gQiAqIChjLnggLSBiLngpKTtcbiAgICAgICAgdmFyIGR4O1xuICAgICAgICB2YXIgZHk7XG4gICAgICAgIC8vIElmIHRoZSBwb2ludHMgb2YgdGhlIHRyaWFuZ2xlIGFyZSBjb2xsaW5lYXIsIHRoZW4ganVzdCBmaW5kIHRoZVxuICAgICAgICAvLyBleHRyZW1lcyBhbmQgdXNlIHRoZSBtaWRwb2ludCBhcyB0aGUgY2VudGVyIG9mIHRoZSBjaXJjdW1jaXJjbGUuXG4gICAgICAgIHRoaXMueCA9IChEICogRSAtIEIgKiBGKSAvIEc7XG4gICAgICAgIHRoaXMueSA9IChBICogRiAtIEMgKiBFKSAvIEc7XG4gICAgICAgIGR4ID0gdGhpcy54IC0gYS54O1xuICAgICAgICBkeSA9IHRoaXMueSAtIGEueTtcbiAgICAgICAgdGhpcy5yID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfVxuICAgIHJldHVybiBUcmlhbmdsZTtcbn0oKSk7XG5mdW5jdGlvbiBieVgoYSwgYikge1xuICAgIHJldHVybiBiLnggLSBhLng7XG59XG5mdW5jdGlvbiBkZWR1cChlZGdlcykge1xuICAgIHZhciBqID0gZWRnZXMubGVuZ3RoO1xuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIHZhciBpO1xuICAgIHZhciBtO1xuICAgIHZhciBuO1xuICAgIG91dGVyOiB3aGlsZSAoaikge1xuICAgICAgICBiID0gZWRnZXNbLS1qXTtcbiAgICAgICAgYSA9IGVkZ2VzWy0tal07XG4gICAgICAgIGkgPSBqO1xuICAgICAgICB3aGlsZSAoaSkge1xuICAgICAgICAgICAgbiA9IGVkZ2VzWy0taV07XG4gICAgICAgICAgICBtID0gZWRnZXNbLS1pXTtcbiAgICAgICAgICAgIGlmICgoYSA9PT0gbSAmJiBiID09PSBuKSB8fCAoYSA9PT0gbiAmJiBiID09PSBtKSkge1xuICAgICAgICAgICAgICAgIGVkZ2VzLnNwbGljZShqLCAyKTtcbiAgICAgICAgICAgICAgICBlZGdlcy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICAgICAgaiAtPSAyO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdHJpYW5ndWxhdGUodmVydGljZXMpIHtcbiAgICAvLyBCYWlsIGlmIHRoZXJlIGFyZW4ndCBlbm91Z2ggdmVydGljZXMgdG8gZm9ybSBhbnkgdHJpYW5nbGVzLlxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgLy8gRW5zdXJlIHRoZSB2ZXJ0ZXggYXJyYXkgaXMgaW4gb3JkZXIgb2YgZGVzY2VuZGluZyBYIGNvb3JkaW5hdGVcbiAgICAvLyAod2hpY2ggaXMgbmVlZGVkIHRvIGVuc3VyZSBhIHN1YnF1YWRyYXRpYyBydW50aW1lKSwgYW5kIHRoZW4gZmluZFxuICAgIC8vIHRoZSBib3VuZGluZyBib3ggYXJvdW5kIHRoZSBwb2ludHMuXG4gICAgdmVydGljZXMuc29ydChieVgpO1xuICAgIHZhciBpID0gdmVydGljZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgeG1pbiA9IHZlcnRpY2VzW2ldLng7XG4gICAgdmFyIHhtYXggPSB2ZXJ0aWNlc1swXS54O1xuICAgIHZhciB5bWluID0gdmVydGljZXNbaV0ueTtcbiAgICB2YXIgeW1heCA9IHltaW47XG4gICAgdmFyIGVwc2lsb24gPSAxZS0xMjtcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICB2YXIgYztcbiAgICB2YXIgQTtcbiAgICB2YXIgQjtcbiAgICB2YXIgRztcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGlmICh2ZXJ0aWNlc1tpXS55IDwgeW1pbikge1xuICAgICAgICAgICAgeW1pbiA9IHZlcnRpY2VzW2ldLnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZlcnRpY2VzW2ldLnkgPiB5bWF4KSB7XG4gICAgICAgICAgICB5bWF4ID0gdmVydGljZXNbaV0ueTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBGaW5kIGEgc3VwZXJ0cmlhbmdsZSwgd2hpY2ggaXMgYSB0cmlhbmdsZSB0aGF0IHN1cnJvdW5kcyBhbGwgdGhlXG4gICAgLy8gdmVydGljZXMuIFRoaXMgaXMgdXNlZCBsaWtlIHNvbWV0aGluZyBvZiBhIHNlbnRpbmVsIHZhbHVlIHRvIHJlbW92ZVxuICAgIC8vIGNhc2VzIGluIHRoZSBtYWluIGFsZ29yaXRobSwgYW5kIGlzIHJlbW92ZWQgYmVmb3JlIHdlIHJldHVybiBhbnlcbiAgICAvLyByZXN1bHRzLlxuICAgIC8vIE9uY2UgZm91bmQsIHB1dCBpdCBpbiB0aGUgXCJvcGVuXCIgbGlzdC4gKFRoZSBcIm9wZW5cIiBsaXN0IGlzIGZvclxuICAgIC8vIHRyaWFuZ2xlcyB3aG8gbWF5IHN0aWxsIG5lZWQgdG8gYmUgY29uc2lkZXJlZDsgdGhlIFwiY2xvc2VkXCIgbGlzdCBpc1xuICAgIC8vIGZvciB0cmlhbmdsZXMgd2hpY2ggZG8gbm90LilcbiAgICB2YXIgZHggPSB4bWF4IC0geG1pbjtcbiAgICB2YXIgZHkgPSB5bWF4IC0geW1pbjtcbiAgICB2YXIgZG1heCA9IGR4ID4gZHkgPyBkeCA6IGR5O1xuICAgIHZhciB4bWlkID0gKHhtYXggKyB4bWluKSAqIDAuNTtcbiAgICB2YXIgeW1pZCA9ICh5bWF4ICsgeW1pbikgKiAwLjU7XG4gICAgdmFyIG9wZW4gPSBbXG4gICAgICAgIG5ldyBUcmlhbmdsZSh7XG4gICAgICAgICAgICBfX3NlbnRpbmVsOiB0cnVlLFxuICAgICAgICAgICAgeDogeG1pZCAtIDIwICogZG1heCxcbiAgICAgICAgICAgIHk6IHltaWQgLSBkbWF4LFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBfX3NlbnRpbmVsOiB0cnVlLFxuICAgICAgICAgICAgeDogeG1pZCxcbiAgICAgICAgICAgIHk6IHltaWQgKyAyMCAqIGRtYXgsXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIF9fc2VudGluZWw6IHRydWUsXG4gICAgICAgICAgICB4OiB4bWlkICsgMjAgKiBkbWF4LFxuICAgICAgICAgICAgeTogeW1pZCAtIGRtYXgsXG4gICAgICAgIH0pLFxuICAgIF07XG4gICAgdmFyIGNsb3NlZCA9IFtdO1xuICAgIHZhciBlZGdlcyA9IFtdO1xuICAgIHZhciBqO1xuICAgIC8vIEluY3JlbWVudGFsbHkgYWRkIGVhY2ggdmVydGV4IHRvIHRoZSBtZXNoLlxuICAgIGkgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICAvLyBGb3IgZWFjaCBvcGVuIHRyaWFuZ2xlLCBjaGVjayB0byBzZWUgaWYgdGhlIGN1cnJlbnQgcG9pbnQgaXNcbiAgICAgICAgLy8gaW5zaWRlIGl0J3MgY2lyY3VtY2lyY2xlLiBJZiBpdCBpcywgcmVtb3ZlIHRoZSB0cmlhbmdsZSBhbmQgYWRkXG4gICAgICAgIC8vIGl0J3MgZWRnZXMgdG8gYW4gZWRnZSBsaXN0LlxuICAgICAgICBlZGdlcy5sZW5ndGggPSAwO1xuICAgICAgICBqID0gb3Blbi5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgcG9pbnQgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgdHJpYW5nbGUncyBjaXJjdW1jaXJjbGUsXG4gICAgICAgICAgICAvLyB0aGVuIHRoaXMgdHJpYW5nbGUgc2hvdWxkIG5ldmVyIGdldCBjaGVja2VkIGFnYWluLiBSZW1vdmUgaXRcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIG9wZW4gbGlzdCwgYWRkIGl0IHRvIHRoZSBjbG9zZWQgbGlzdCwgYW5kIHNraXAuXG4gICAgICAgICAgICBkeCA9IHZlcnRpY2VzW2ldLnggLSBvcGVuW2pdLng7XG4gICAgICAgICAgICBpZiAoZHggPiAwICYmIGR4ICogZHggPiBvcGVuW2pdLnIpIHtcbiAgICAgICAgICAgICAgICBjbG9zZWQucHVzaChvcGVuW2pdKTtcbiAgICAgICAgICAgICAgICBvcGVuLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vdCwgc2tpcCB0aGlzIHRyaWFuZ2xlLlxuICAgICAgICAgICAgZHkgPSB2ZXJ0aWNlc1tpXS55IC0gb3BlbltqXS55O1xuICAgICAgICAgICAgaWYgKGR4ICogZHggKyBkeSAqIGR5ID4gb3BlbltqXS5yKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHRyaWFuZ2xlIGFuZCBhZGQgaXQncyBlZGdlcyB0byB0aGUgZWRnZSBsaXN0LlxuICAgICAgICAgICAgZWRnZXMucHVzaChvcGVuW2pdLmEsIG9wZW5bal0uYiwgb3BlbltqXS5iLCBvcGVuW2pdLmMsIG9wZW5bal0uYywgb3BlbltqXS5hKTtcbiAgICAgICAgICAgIG9wZW4uc3BsaWNlKGosIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZG91YmxlZCBlZGdlcy5cbiAgICAgICAgZGVkdXAoZWRnZXMpO1xuICAgICAgICAvLyBBZGQgYSBuZXcgdHJpYW5nbGUgZm9yIGVhY2ggZWRnZS5cbiAgICAgICAgaiA9IGVkZ2VzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGopIHtcbiAgICAgICAgICAgIGIgPSBlZGdlc1stLWpdO1xuICAgICAgICAgICAgYSA9IGVkZ2VzWy0tal07XG4gICAgICAgICAgICBjID0gdmVydGljZXNbaV07XG4gICAgICAgICAgICAvLyBBdm9pZCBhZGRpbmcgY29saW5lYXIgdHJpYW5nbGVzICh3aGljaCBoYXZlIGVycm9yLXByb25lXG4gICAgICAgICAgICAvLyBjaXJjdW1jaXJjbGVzKVxuICAgICAgICAgICAgQSA9IGIueCAtIGEueDtcbiAgICAgICAgICAgIEIgPSBiLnkgLSBhLnk7XG4gICAgICAgICAgICBHID0gMiAqIChBICogKGMueSAtIGIueSkgLSBCICogKGMueCAtIGIueCkpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKEcpID4gZXBzaWxvbikge1xuICAgICAgICAgICAgICAgIG9wZW4ucHVzaChuZXcgVHJpYW5nbGUoYSwgYiwgYykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENvcHkgYW55IHJlbWFpbmluZyBvcGVuIHRyaWFuZ2xlcyB0byB0aGUgY2xvc2VkIGxpc3QsIGFuZCB0aGVuXG4gICAgLy8gcmVtb3ZlIGFueSB0cmlhbmdsZXMgdGhhdCBzaGFyZSBhIHZlcnRleCB3aXRoIHRoZSBzdXBlcnRyaWFuZ2xlLlxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNsb3NlZCwgb3Blbik7XG4gICAgaSA9IGNsb3NlZC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAoY2xvc2VkW2ldLmEuX19zZW50aW5lbCB8fFxuICAgICAgICAgICAgY2xvc2VkW2ldLmIuX19zZW50aW5lbCB8fFxuICAgICAgICAgICAgY2xvc2VkW2ldLmMuX19zZW50aW5lbCkge1xuICAgICAgICAgICAgY2xvc2VkLnNwbGljZShpLCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2xvc2VkO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+tin@6.5.0/node_modules/@turf/tin/dist/es/index.js\n");

/***/ })

};
;
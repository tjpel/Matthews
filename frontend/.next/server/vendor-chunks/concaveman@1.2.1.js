"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/concaveman@1.2.1";
exports.ids = ["vendor-chunks/concaveman@1.2.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/concaveman@1.2.1/node_modules/concaveman/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/concaveman@1.2.1/node_modules/concaveman/index.js ***!
  \******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar RBush = __webpack_require__(/*! rbush */ \"(ssr)/./node_modules/.pnpm/rbush@3.0.1/node_modules/rbush/rbush.js\");\nvar Queue = __webpack_require__(/*! tinyqueue */ \"(ssr)/./node_modules/.pnpm/tinyqueue@2.0.3/node_modules/tinyqueue/tinyqueue.js\");\nvar pointInPolygon = __webpack_require__(/*! point-in-polygon */ \"(ssr)/./node_modules/.pnpm/point-in-polygon@1.1.0/node_modules/point-in-polygon/index.js\");\nvar orient = (__webpack_require__(/*! robust-predicates/umd/orient2d.min.js */ \"(ssr)/./node_modules/.pnpm/robust-predicates@2.0.4/node_modules/robust-predicates/umd/orient2d.min.js\").orient2d);\n\n// Fix for require issue in webpack https://github.com/mapbox/concaveman/issues/18\nif (Queue.default) {\n    Queue = Queue.default;\n}\n\nmodule.exports = concaveman;\nmodule.exports[\"default\"] = concaveman;\n\nfunction concaveman(points, concavity, lengthThreshold) {\n    // a relative measure of concavity; higher value means simpler hull\n    concavity = Math.max(0, concavity === undefined ? 2 : concavity);\n\n    // when a segment goes below this length threshold, it won't be drilled down further\n    lengthThreshold = lengthThreshold || 0;\n\n    // start with a convex hull of the points\n    var hull = fastConvexHull(points);\n\n    // index the points with an R-tree\n    var tree = new RBush(16);\n    tree.toBBox = function (a) {\n        return {\n            minX: a[0],\n            minY: a[1],\n            maxX: a[0],\n            maxY: a[1]\n        };\n    };\n    tree.compareMinX = function (a, b) { return a[0] - b[0]; };\n    tree.compareMinY = function (a, b) { return a[1] - b[1]; };\n\n    tree.load(points);\n\n    // turn the convex hull into a linked list and populate the initial edge queue with the nodes\n    var queue = [];\n    for (var i = 0, last; i < hull.length; i++) {\n        var p = hull[i];\n        tree.remove(p);\n        last = insertNode(p, last);\n        queue.push(last);\n    }\n\n    // index the segments with an R-tree (for intersection checks)\n    var segTree = new RBush(16);\n    for (i = 0; i < queue.length; i++) segTree.insert(updateBBox(queue[i]));\n\n    var sqConcavity = concavity * concavity;\n    var sqLenThreshold = lengthThreshold * lengthThreshold;\n\n    // process edges one by one\n    while (queue.length) {\n        var node = queue.shift();\n        var a = node.p;\n        var b = node.next.p;\n\n        // skip the edge if it's already short enough\n        var sqLen = getSqDist(a, b);\n        if (sqLen < sqLenThreshold) continue;\n\n        var maxSqLen = sqLen / sqConcavity;\n\n        // find the best connection point for the current edge to flex inward to\n        p = findCandidate(tree, node.prev.p, a, b, node.next.next.p, maxSqLen, segTree);\n\n        // if we found a connection and it satisfies our concavity measure\n        if (p && Math.min(getSqDist(p, a), getSqDist(p, b)) <= maxSqLen) {\n            // connect the edge endpoints through this point and add 2 new edges to the queue\n            queue.push(node);\n            queue.push(insertNode(p, node));\n\n            // update point and segment indexes\n            tree.remove(p);\n            segTree.remove(node);\n            segTree.insert(updateBBox(node));\n            segTree.insert(updateBBox(node.next));\n        }\n    }\n\n    // convert the resulting hull linked list to an array of points\n    node = last;\n    var concave = [];\n    do {\n        concave.push(node.p);\n        node = node.next;\n    } while (node !== last);\n\n    concave.push(node.p);\n\n    return concave;\n}\n\nfunction findCandidate(tree, a, b, c, d, maxDist, segTree) {\n    var queue = new Queue([], compareDist);\n    var node = tree.data;\n\n    // search through the point R-tree with a depth-first search using a priority queue\n    // in the order of distance to the edge (b, c)\n    while (node) {\n        for (var i = 0; i < node.children.length; i++) {\n            var child = node.children[i];\n\n            var dist = node.leaf ? sqSegDist(child, b, c) : sqSegBoxDist(b, c, child);\n            if (dist > maxDist) continue; // skip the node if it's farther than we ever need\n\n            queue.push({\n                node: child,\n                dist: dist\n            });\n        }\n\n        while (queue.length && !queue.peek().node.children) {\n            var item = queue.pop();\n            var p = item.node;\n\n            // skip all points that are as close to adjacent edges (a,b) and (c,d),\n            // and points that would introduce self-intersections when connected\n            var d0 = sqSegDist(p, a, b);\n            var d1 = sqSegDist(p, c, d);\n            if (item.dist < d0 && item.dist < d1 &&\n                noIntersections(b, p, segTree) &&\n                noIntersections(c, p, segTree)) return p;\n        }\n\n        node = queue.pop();\n        if (node) node = node.node;\n    }\n\n    return null;\n}\n\nfunction compareDist(a, b) {\n    return a.dist - b.dist;\n}\n\n// square distance from a segment bounding box to the given one\nfunction sqSegBoxDist(a, b, bbox) {\n    if (inside(a, bbox) || inside(b, bbox)) return 0;\n    var d1 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.maxX, bbox.minY);\n    if (d1 === 0) return 0;\n    var d2 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.minY, bbox.minX, bbox.maxY);\n    if (d2 === 0) return 0;\n    var d3 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY);\n    if (d3 === 0) return 0;\n    var d4 = sqSegSegDist(a[0], a[1], b[0], b[1], bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY);\n    if (d4 === 0) return 0;\n    return Math.min(d1, d2, d3, d4);\n}\n\nfunction inside(a, bbox) {\n    return a[0] >= bbox.minX &&\n           a[0] <= bbox.maxX &&\n           a[1] >= bbox.minY &&\n           a[1] <= bbox.maxY;\n}\n\n// check if the edge (a,b) doesn't intersect any other edges\nfunction noIntersections(a, b, segTree) {\n    var minX = Math.min(a[0], b[0]);\n    var minY = Math.min(a[1], b[1]);\n    var maxX = Math.max(a[0], b[0]);\n    var maxY = Math.max(a[1], b[1]);\n\n    var edges = segTree.search({minX: minX, minY: minY, maxX: maxX, maxY: maxY});\n    for (var i = 0; i < edges.length; i++) {\n        if (intersects(edges[i].p, edges[i].next.p, a, b)) return false;\n    }\n    return true;\n}\n\nfunction cross(p1, p2, p3) {\n    return orient(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);\n}\n\n// check if the edges (p1,q1) and (p2,q2) intersect\nfunction intersects(p1, q1, p2, q2) {\n    return p1 !== q2 && q1 !== p2 &&\n        cross(p1, q1, p2) > 0 !== cross(p1, q1, q2) > 0 &&\n        cross(p2, q2, p1) > 0 !== cross(p2, q2, q1) > 0;\n}\n\n// update the bounding box of a node's edge\nfunction updateBBox(node) {\n    var p1 = node.p;\n    var p2 = node.next.p;\n    node.minX = Math.min(p1[0], p2[0]);\n    node.minY = Math.min(p1[1], p2[1]);\n    node.maxX = Math.max(p1[0], p2[0]);\n    node.maxY = Math.max(p1[1], p2[1]);\n    return node;\n}\n\n// speed up convex hull by filtering out points inside quadrilateral formed by 4 extreme points\nfunction fastConvexHull(points) {\n    var left = points[0];\n    var top = points[0];\n    var right = points[0];\n    var bottom = points[0];\n\n    // find the leftmost, rightmost, topmost and bottommost points\n    for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        if (p[0] < left[0]) left = p;\n        if (p[0] > right[0]) right = p;\n        if (p[1] < top[1]) top = p;\n        if (p[1] > bottom[1]) bottom = p;\n    }\n\n    // filter out points that are inside the resulting quadrilateral\n    var cull = [left, top, right, bottom];\n    var filtered = cull.slice();\n    for (i = 0; i < points.length; i++) {\n        if (!pointInPolygon(points[i], cull)) filtered.push(points[i]);\n    }\n\n    // get convex hull around the filtered points\n    return convexHull(filtered);\n}\n\n// create a new node in a doubly linked list\nfunction insertNode(p, prev) {\n    var node = {\n        p: p,\n        prev: null,\n        next: null,\n        minX: 0,\n        minY: 0,\n        maxX: 0,\n        maxY: 0\n    };\n\n    if (!prev) {\n        node.prev = node;\n        node.next = node;\n\n    } else {\n        node.next = prev.next;\n        node.prev = prev;\n        prev.next.prev = node;\n        prev.next = node;\n    }\n    return node;\n}\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n\n    var dx = p1[0] - p2[0],\n        dy = p1[1] - p2[1];\n\n    return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction sqSegDist(p, p1, p2) {\n\n    var x = p1[0],\n        y = p1[1],\n        dx = p2[0] - x,\n        dy = p2[1] - y;\n\n    if (dx !== 0 || dy !== 0) {\n\n        var t = ((p[0] - x) * dx + (p[1] - y) * dy) / (dx * dx + dy * dy);\n\n        if (t > 1) {\n            x = p2[0];\n            y = p2[1];\n\n        } else if (t > 0) {\n            x += dx * t;\n            y += dy * t;\n        }\n    }\n\n    dx = p[0] - x;\n    dy = p[1] - y;\n\n    return dx * dx + dy * dy;\n}\n\n// segment to segment distance, ported from http://geomalgorithms.com/a07-_distance.html by Dan Sunday\nfunction sqSegSegDist(x0, y0, x1, y1, x2, y2, x3, y3) {\n    var ux = x1 - x0;\n    var uy = y1 - y0;\n    var vx = x3 - x2;\n    var vy = y3 - y2;\n    var wx = x0 - x2;\n    var wy = y0 - y2;\n    var a = ux * ux + uy * uy;\n    var b = ux * vx + uy * vy;\n    var c = vx * vx + vy * vy;\n    var d = ux * wx + uy * wy;\n    var e = vx * wx + vy * wy;\n    var D = a * c - b * b;\n\n    var sc, sN, tc, tN;\n    var sD = D;\n    var tD = D;\n\n    if (D === 0) {\n        sN = 0;\n        sD = 1;\n        tN = e;\n        tD = c;\n    } else {\n        sN = b * e - c * d;\n        tN = a * e - b * d;\n        if (sN < 0) {\n            sN = 0;\n            tN = e;\n            tD = c;\n        } else if (sN > sD) {\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {\n        tN = 0.0;\n        if (-d < 0.0) sN = 0.0;\n        else if (-d > a) sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    } else if (tN > tD) {\n        tN = tD;\n        if ((-d + b) < 0.0) sN = 0;\n        else if (-d + b > a) sN = sD;\n        else {\n            sN = -d + b;\n            sD = a;\n        }\n    }\n\n    sc = sN === 0 ? 0 : sN / sD;\n    tc = tN === 0 ? 0 : tN / tD;\n\n    var cx = (1 - sc) * x0 + sc * x1;\n    var cy = (1 - sc) * y0 + sc * y1;\n    var cx2 = (1 - tc) * x2 + tc * x3;\n    var cy2 = (1 - tc) * y2 + tc * y3;\n    var dx = cx2 - cx;\n    var dy = cy2 - cy;\n\n    return dx * dx + dy * dy;\n}\n\nfunction compareByX(a, b) {\n    return a[0] === b[0] ? a[1] - b[1] : a[0] - b[0];\n}\n\nfunction convexHull(points) {\n    points.sort(compareByX);\n\n    var lower = [];\n    for (var i = 0; i < points.length; i++) {\n        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n            lower.pop();\n        }\n        lower.push(points[i]);\n    }\n\n    var upper = [];\n    for (var ii = points.length - 1; ii >= 0; ii--) {\n        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[ii]) <= 0) {\n            upper.pop();\n        }\n        upper.push(points[ii]);\n    }\n\n    upper.pop();\n    lower.pop();\n    return lower.concat(upper);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vY29uY2F2ZW1hbkAxLjIuMS9ub2RlX21vZHVsZXMvY29uY2F2ZW1hbi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixZQUFZLG1CQUFPLENBQUMsaUZBQU87QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGlHQUFXO0FBQy9CLHFCQUFxQixtQkFBTyxDQUFDLGtIQUFrQjtBQUMvQyxhQUFhLG9MQUF5RDs7QUFFdEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBc0I7O0FBRXRCO0FBQ0Esd0NBQXdDO0FBQ3hDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6Qyx5Q0FBeUM7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDs7QUFFQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQywrQ0FBK0M7QUFDL0Usb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBbUI7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZnZhbHVlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2NvbmNhdmVtYW5AMS4yLjEvbm9kZV9tb2R1bGVzL2NvbmNhdmVtYW4vaW5kZXguanM/MWUzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBSQnVzaCA9IHJlcXVpcmUoJ3JidXNoJyk7XG52YXIgUXVldWUgPSByZXF1aXJlKCd0aW55cXVldWUnKTtcbnZhciBwb2ludEluUG9seWdvbiA9IHJlcXVpcmUoJ3BvaW50LWluLXBvbHlnb24nKTtcbnZhciBvcmllbnQgPSByZXF1aXJlKCdyb2J1c3QtcHJlZGljYXRlcy91bWQvb3JpZW50MmQubWluLmpzJykub3JpZW50MmQ7XG5cbi8vIEZpeCBmb3IgcmVxdWlyZSBpc3N1ZSBpbiB3ZWJwYWNrIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvY29uY2F2ZW1hbi9pc3N1ZXMvMThcbmlmIChRdWV1ZS5kZWZhdWx0KSB7XG4gICAgUXVldWUgPSBRdWV1ZS5kZWZhdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdmVtYW47XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gY29uY2F2ZW1hbjtcblxuZnVuY3Rpb24gY29uY2F2ZW1hbihwb2ludHMsIGNvbmNhdml0eSwgbGVuZ3RoVGhyZXNob2xkKSB7XG4gICAgLy8gYSByZWxhdGl2ZSBtZWFzdXJlIG9mIGNvbmNhdml0eTsgaGlnaGVyIHZhbHVlIG1lYW5zIHNpbXBsZXIgaHVsbFxuICAgIGNvbmNhdml0eSA9IE1hdGgubWF4KDAsIGNvbmNhdml0eSA9PT0gdW5kZWZpbmVkID8gMiA6IGNvbmNhdml0eSk7XG5cbiAgICAvLyB3aGVuIGEgc2VnbWVudCBnb2VzIGJlbG93IHRoaXMgbGVuZ3RoIHRocmVzaG9sZCwgaXQgd29uJ3QgYmUgZHJpbGxlZCBkb3duIGZ1cnRoZXJcbiAgICBsZW5ndGhUaHJlc2hvbGQgPSBsZW5ndGhUaHJlc2hvbGQgfHwgMDtcblxuICAgIC8vIHN0YXJ0IHdpdGggYSBjb252ZXggaHVsbCBvZiB0aGUgcG9pbnRzXG4gICAgdmFyIGh1bGwgPSBmYXN0Q29udmV4SHVsbChwb2ludHMpO1xuXG4gICAgLy8gaW5kZXggdGhlIHBvaW50cyB3aXRoIGFuIFItdHJlZVxuICAgIHZhciB0cmVlID0gbmV3IFJCdXNoKDE2KTtcbiAgICB0cmVlLnRvQkJveCA9IGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5YOiBhWzBdLFxuICAgICAgICAgICAgbWluWTogYVsxXSxcbiAgICAgICAgICAgIG1heFg6IGFbMF0sXG4gICAgICAgICAgICBtYXhZOiBhWzFdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICB0cmVlLmNvbXBhcmVNaW5YID0gZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGFbMF0gLSBiWzBdOyB9O1xuICAgIHRyZWUuY29tcGFyZU1pblkgPSBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVsxXSAtIGJbMV07IH07XG5cbiAgICB0cmVlLmxvYWQocG9pbnRzKTtcblxuICAgIC8vIHR1cm4gdGhlIGNvbnZleCBodWxsIGludG8gYSBsaW5rZWQgbGlzdCBhbmQgcG9wdWxhdGUgdGhlIGluaXRpYWwgZWRnZSBxdWV1ZSB3aXRoIHRoZSBub2Rlc1xuICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsYXN0OyBpIDwgaHVsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcCA9IGh1bGxbaV07XG4gICAgICAgIHRyZWUucmVtb3ZlKHApO1xuICAgICAgICBsYXN0ID0gaW5zZXJ0Tm9kZShwLCBsYXN0KTtcbiAgICAgICAgcXVldWUucHVzaChsYXN0KTtcbiAgICB9XG5cbiAgICAvLyBpbmRleCB0aGUgc2VnbWVudHMgd2l0aCBhbiBSLXRyZWUgKGZvciBpbnRlcnNlY3Rpb24gY2hlY2tzKVxuICAgIHZhciBzZWdUcmVlID0gbmV3IFJCdXNoKDE2KTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHNlZ1RyZWUuaW5zZXJ0KHVwZGF0ZUJCb3gocXVldWVbaV0pKTtcblxuICAgIHZhciBzcUNvbmNhdml0eSA9IGNvbmNhdml0eSAqIGNvbmNhdml0eTtcbiAgICB2YXIgc3FMZW5UaHJlc2hvbGQgPSBsZW5ndGhUaHJlc2hvbGQgKiBsZW5ndGhUaHJlc2hvbGQ7XG5cbiAgICAvLyBwcm9jZXNzIGVkZ2VzIG9uZSBieSBvbmVcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGEgPSBub2RlLnA7XG4gICAgICAgIHZhciBiID0gbm9kZS5uZXh0LnA7XG5cbiAgICAgICAgLy8gc2tpcCB0aGUgZWRnZSBpZiBpdCdzIGFscmVhZHkgc2hvcnQgZW5vdWdoXG4gICAgICAgIHZhciBzcUxlbiA9IGdldFNxRGlzdChhLCBiKTtcbiAgICAgICAgaWYgKHNxTGVuIDwgc3FMZW5UaHJlc2hvbGQpIGNvbnRpbnVlO1xuXG4gICAgICAgIHZhciBtYXhTcUxlbiA9IHNxTGVuIC8gc3FDb25jYXZpdHk7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBjb25uZWN0aW9uIHBvaW50IGZvciB0aGUgY3VycmVudCBlZGdlIHRvIGZsZXggaW53YXJkIHRvXG4gICAgICAgIHAgPSBmaW5kQ2FuZGlkYXRlKHRyZWUsIG5vZGUucHJldi5wLCBhLCBiLCBub2RlLm5leHQubmV4dC5wLCBtYXhTcUxlbiwgc2VnVHJlZSk7XG5cbiAgICAgICAgLy8gaWYgd2UgZm91bmQgYSBjb25uZWN0aW9uIGFuZCBpdCBzYXRpc2ZpZXMgb3VyIGNvbmNhdml0eSBtZWFzdXJlXG4gICAgICAgIGlmIChwICYmIE1hdGgubWluKGdldFNxRGlzdChwLCBhKSwgZ2V0U3FEaXN0KHAsIGIpKSA8PSBtYXhTcUxlbikge1xuICAgICAgICAgICAgLy8gY29ubmVjdCB0aGUgZWRnZSBlbmRwb2ludHMgdGhyb3VnaCB0aGlzIHBvaW50IGFuZCBhZGQgMiBuZXcgZWRnZXMgdG8gdGhlIHF1ZXVlXG4gICAgICAgICAgICBxdWV1ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgcXVldWUucHVzaChpbnNlcnROb2RlKHAsIG5vZGUpKTtcblxuICAgICAgICAgICAgLy8gdXBkYXRlIHBvaW50IGFuZCBzZWdtZW50IGluZGV4ZXNcbiAgICAgICAgICAgIHRyZWUucmVtb3ZlKHApO1xuICAgICAgICAgICAgc2VnVHJlZS5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICBzZWdUcmVlLmluc2VydCh1cGRhdGVCQm94KG5vZGUpKTtcbiAgICAgICAgICAgIHNlZ1RyZWUuaW5zZXJ0KHVwZGF0ZUJCb3gobm9kZS5uZXh0KSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IHRoZSByZXN1bHRpbmcgaHVsbCBsaW5rZWQgbGlzdCB0byBhbiBhcnJheSBvZiBwb2ludHNcbiAgICBub2RlID0gbGFzdDtcbiAgICB2YXIgY29uY2F2ZSA9IFtdO1xuICAgIGRvIHtcbiAgICAgICAgY29uY2F2ZS5wdXNoKG5vZGUucCk7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgfSB3aGlsZSAobm9kZSAhPT0gbGFzdCk7XG5cbiAgICBjb25jYXZlLnB1c2gobm9kZS5wKTtcblxuICAgIHJldHVybiBjb25jYXZlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ2FuZGlkYXRlKHRyZWUsIGEsIGIsIGMsIGQsIG1heERpc3QsIHNlZ1RyZWUpIHtcbiAgICB2YXIgcXVldWUgPSBuZXcgUXVldWUoW10sIGNvbXBhcmVEaXN0KTtcbiAgICB2YXIgbm9kZSA9IHRyZWUuZGF0YTtcblxuICAgIC8vIHNlYXJjaCB0aHJvdWdoIHRoZSBwb2ludCBSLXRyZWUgd2l0aCBhIGRlcHRoLWZpcnN0IHNlYXJjaCB1c2luZyBhIHByaW9yaXR5IHF1ZXVlXG4gICAgLy8gaW4gdGhlIG9yZGVyIG9mIGRpc3RhbmNlIHRvIHRoZSBlZGdlIChiLCBjKVxuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcblxuICAgICAgICAgICAgdmFyIGRpc3QgPSBub2RlLmxlYWYgPyBzcVNlZ0Rpc3QoY2hpbGQsIGIsIGMpIDogc3FTZWdCb3hEaXN0KGIsIGMsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChkaXN0ID4gbWF4RGlzdCkgY29udGludWU7IC8vIHNraXAgdGhlIG5vZGUgaWYgaXQncyBmYXJ0aGVyIHRoYW4gd2UgZXZlciBuZWVkXG5cbiAgICAgICAgICAgIHF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIG5vZGU6IGNoaWxkLFxuICAgICAgICAgICAgICAgIGRpc3Q6IGRpc3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCAmJiAhcXVldWUucGVlaygpLm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICB2YXIgcCA9IGl0ZW0ubm9kZTtcblxuICAgICAgICAgICAgLy8gc2tpcCBhbGwgcG9pbnRzIHRoYXQgYXJlIGFzIGNsb3NlIHRvIGFkamFjZW50IGVkZ2VzIChhLGIpIGFuZCAoYyxkKSxcbiAgICAgICAgICAgIC8vIGFuZCBwb2ludHMgdGhhdCB3b3VsZCBpbnRyb2R1Y2Ugc2VsZi1pbnRlcnNlY3Rpb25zIHdoZW4gY29ubmVjdGVkXG4gICAgICAgICAgICB2YXIgZDAgPSBzcVNlZ0Rpc3QocCwgYSwgYik7XG4gICAgICAgICAgICB2YXIgZDEgPSBzcVNlZ0Rpc3QocCwgYywgZCk7XG4gICAgICAgICAgICBpZiAoaXRlbS5kaXN0IDwgZDAgJiYgaXRlbS5kaXN0IDwgZDEgJiZcbiAgICAgICAgICAgICAgICBub0ludGVyc2VjdGlvbnMoYiwgcCwgc2VnVHJlZSkgJiZcbiAgICAgICAgICAgICAgICBub0ludGVyc2VjdGlvbnMoYywgcCwgc2VnVHJlZSkpIHJldHVybiBwO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICBpZiAobm9kZSkgbm9kZSA9IG5vZGUubm9kZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURpc3QoYSwgYikge1xuICAgIHJldHVybiBhLmRpc3QgLSBiLmRpc3Q7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgc2VnbWVudCBib3VuZGluZyBib3ggdG8gdGhlIGdpdmVuIG9uZVxuZnVuY3Rpb24gc3FTZWdCb3hEaXN0KGEsIGIsIGJib3gpIHtcbiAgICBpZiAoaW5zaWRlKGEsIGJib3gpIHx8IGluc2lkZShiLCBiYm94KSkgcmV0dXJuIDA7XG4gICAgdmFyIGQxID0gc3FTZWdTZWdEaXN0KGFbMF0sIGFbMV0sIGJbMF0sIGJbMV0sIGJib3gubWluWCwgYmJveC5taW5ZLCBiYm94Lm1heFgsIGJib3gubWluWSk7XG4gICAgaWYgKGQxID09PSAwKSByZXR1cm4gMDtcbiAgICB2YXIgZDIgPSBzcVNlZ1NlZ0Rpc3QoYVswXSwgYVsxXSwgYlswXSwgYlsxXSwgYmJveC5taW5YLCBiYm94Lm1pblksIGJib3gubWluWCwgYmJveC5tYXhZKTtcbiAgICBpZiAoZDIgPT09IDApIHJldHVybiAwO1xuICAgIHZhciBkMyA9IHNxU2VnU2VnRGlzdChhWzBdLCBhWzFdLCBiWzBdLCBiWzFdLCBiYm94Lm1heFgsIGJib3gubWluWSwgYmJveC5tYXhYLCBiYm94Lm1heFkpO1xuICAgIGlmIChkMyA9PT0gMCkgcmV0dXJuIDA7XG4gICAgdmFyIGQ0ID0gc3FTZWdTZWdEaXN0KGFbMF0sIGFbMV0sIGJbMF0sIGJbMV0sIGJib3gubWluWCwgYmJveC5tYXhZLCBiYm94Lm1heFgsIGJib3gubWF4WSk7XG4gICAgaWYgKGQ0ID09PSAwKSByZXR1cm4gMDtcbiAgICByZXR1cm4gTWF0aC5taW4oZDEsIGQyLCBkMywgZDQpO1xufVxuXG5mdW5jdGlvbiBpbnNpZGUoYSwgYmJveCkge1xuICAgIHJldHVybiBhWzBdID49IGJib3gubWluWCAmJlxuICAgICAgICAgICBhWzBdIDw9IGJib3gubWF4WCAmJlxuICAgICAgICAgICBhWzFdID49IGJib3gubWluWSAmJlxuICAgICAgICAgICBhWzFdIDw9IGJib3gubWF4WTtcbn1cblxuLy8gY2hlY2sgaWYgdGhlIGVkZ2UgKGEsYikgZG9lc24ndCBpbnRlcnNlY3QgYW55IG90aGVyIGVkZ2VzXG5mdW5jdGlvbiBub0ludGVyc2VjdGlvbnMoYSwgYiwgc2VnVHJlZSkge1xuICAgIHZhciBtaW5YID0gTWF0aC5taW4oYVswXSwgYlswXSk7XG4gICAgdmFyIG1pblkgPSBNYXRoLm1pbihhWzFdLCBiWzFdKTtcbiAgICB2YXIgbWF4WCA9IE1hdGgubWF4KGFbMF0sIGJbMF0pO1xuICAgIHZhciBtYXhZID0gTWF0aC5tYXgoYVsxXSwgYlsxXSk7XG5cbiAgICB2YXIgZWRnZXMgPSBzZWdUcmVlLnNlYXJjaCh7bWluWDogbWluWCwgbWluWTogbWluWSwgbWF4WDogbWF4WCwgbWF4WTogbWF4WX0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGludGVyc2VjdHMoZWRnZXNbaV0ucCwgZWRnZXNbaV0ubmV4dC5wLCBhLCBiKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY3Jvc3MocDEsIHAyLCBwMykge1xuICAgIHJldHVybiBvcmllbnQocDFbMF0sIHAxWzFdLCBwMlswXSwgcDJbMV0sIHAzWzBdLCBwM1sxXSk7XG59XG5cbi8vIGNoZWNrIGlmIHRoZSBlZGdlcyAocDEscTEpIGFuZCAocDIscTIpIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHJldHVybiBwMSAhPT0gcTIgJiYgcTEgIT09IHAyICYmXG4gICAgICAgIGNyb3NzKHAxLCBxMSwgcDIpID4gMCAhPT0gY3Jvc3MocDEsIHExLCBxMikgPiAwICYmXG4gICAgICAgIGNyb3NzKHAyLCBxMiwgcDEpID4gMCAhPT0gY3Jvc3MocDIsIHEyLCBxMSkgPiAwO1xufVxuXG4vLyB1cGRhdGUgdGhlIGJvdW5kaW5nIGJveCBvZiBhIG5vZGUncyBlZGdlXG5mdW5jdGlvbiB1cGRhdGVCQm94KG5vZGUpIHtcbiAgICB2YXIgcDEgPSBub2RlLnA7XG4gICAgdmFyIHAyID0gbm9kZS5uZXh0LnA7XG4gICAgbm9kZS5taW5YID0gTWF0aC5taW4ocDFbMF0sIHAyWzBdKTtcbiAgICBub2RlLm1pblkgPSBNYXRoLm1pbihwMVsxXSwgcDJbMV0pO1xuICAgIG5vZGUubWF4WCA9IE1hdGgubWF4KHAxWzBdLCBwMlswXSk7XG4gICAgbm9kZS5tYXhZID0gTWF0aC5tYXgocDFbMV0sIHAyWzFdKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLy8gc3BlZWQgdXAgY29udmV4IGh1bGwgYnkgZmlsdGVyaW5nIG91dCBwb2ludHMgaW5zaWRlIHF1YWRyaWxhdGVyYWwgZm9ybWVkIGJ5IDQgZXh0cmVtZSBwb2ludHNcbmZ1bmN0aW9uIGZhc3RDb252ZXhIdWxsKHBvaW50cykge1xuICAgIHZhciBsZWZ0ID0gcG9pbnRzWzBdO1xuICAgIHZhciB0b3AgPSBwb2ludHNbMF07XG4gICAgdmFyIHJpZ2h0ID0gcG9pbnRzWzBdO1xuICAgIHZhciBib3R0b20gPSBwb2ludHNbMF07XG5cbiAgICAvLyBmaW5kIHRoZSBsZWZ0bW9zdCwgcmlnaHRtb3N0LCB0b3Btb3N0IGFuZCBib3R0b21tb3N0IHBvaW50c1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwID0gcG9pbnRzW2ldO1xuICAgICAgICBpZiAocFswXSA8IGxlZnRbMF0pIGxlZnQgPSBwO1xuICAgICAgICBpZiAocFswXSA+IHJpZ2h0WzBdKSByaWdodCA9IHA7XG4gICAgICAgIGlmIChwWzFdIDwgdG9wWzFdKSB0b3AgPSBwO1xuICAgICAgICBpZiAocFsxXSA+IGJvdHRvbVsxXSkgYm90dG9tID0gcDtcbiAgICB9XG5cbiAgICAvLyBmaWx0ZXIgb3V0IHBvaW50cyB0aGF0IGFyZSBpbnNpZGUgdGhlIHJlc3VsdGluZyBxdWFkcmlsYXRlcmFsXG4gICAgdmFyIGN1bGwgPSBbbGVmdCwgdG9wLCByaWdodCwgYm90dG9tXTtcbiAgICB2YXIgZmlsdGVyZWQgPSBjdWxsLnNsaWNlKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXBvaW50SW5Qb2x5Z29uKHBvaW50c1tpXSwgY3VsbCkpIGZpbHRlcmVkLnB1c2gocG9pbnRzW2ldKTtcbiAgICB9XG5cbiAgICAvLyBnZXQgY29udmV4IGh1bGwgYXJvdW5kIHRoZSBmaWx0ZXJlZCBwb2ludHNcbiAgICByZXR1cm4gY29udmV4SHVsbChmaWx0ZXJlZCk7XG59XG5cbi8vIGNyZWF0ZSBhIG5ldyBub2RlIGluIGEgZG91Ymx5IGxpbmtlZCBsaXN0XG5mdW5jdGlvbiBpbnNlcnROb2RlKHAsIHByZXYpIHtcbiAgICB2YXIgbm9kZSA9IHtcbiAgICAgICAgcDogcCxcbiAgICAgICAgcHJldjogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgbWluWDogMCxcbiAgICAgICAgbWluWTogMCxcbiAgICAgICAgbWF4WDogMCxcbiAgICAgICAgbWF4WTogMFxuICAgIH07XG5cbiAgICBpZiAoIXByZXYpIHtcbiAgICAgICAgbm9kZS5wcmV2ID0gbm9kZTtcbiAgICAgICAgbm9kZS5uZXh0ID0gbm9kZTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUubmV4dCA9IHByZXYubmV4dDtcbiAgICAgICAgbm9kZS5wcmV2ID0gcHJldjtcbiAgICAgICAgcHJldi5uZXh0LnByZXYgPSBub2RlO1xuICAgICAgICBwcmV2Lm5leHQgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGJldHdlZW4gMiBwb2ludHNcbmZ1bmN0aW9uIGdldFNxRGlzdChwMSwgcDIpIHtcblxuICAgIHZhciBkeCA9IHAxWzBdIC0gcDJbMF0sXG4gICAgICAgIGR5ID0gcDFbMV0gLSBwMlsxXTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIHNxU2VnRGlzdChwLCBwMSwgcDIpIHtcblxuICAgIHZhciB4ID0gcDFbMF0sXG4gICAgICAgIHkgPSBwMVsxXSxcbiAgICAgICAgZHggPSBwMlswXSAtIHgsXG4gICAgICAgIGR5ID0gcDJbMV0gLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHBbMF0gLSB4KSAqIGR4ICsgKHBbMV0gLSB5KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICB4ID0gcDJbMF07XG4gICAgICAgICAgICB5ID0gcDJbMV07XG5cbiAgICAgICAgfSBlbHNlIGlmICh0ID4gMCkge1xuICAgICAgICAgICAgeCArPSBkeCAqIHQ7XG4gICAgICAgICAgICB5ICs9IGR5ICogdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGR4ID0gcFswXSAtIHg7XG4gICAgZHkgPSBwWzFdIC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLy8gc2VnbWVudCB0byBzZWdtZW50IGRpc3RhbmNlLCBwb3J0ZWQgZnJvbSBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNy1fZGlzdGFuY2UuaHRtbCBieSBEYW4gU3VuZGF5XG5mdW5jdGlvbiBzcVNlZ1NlZ0Rpc3QoeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKSB7XG4gICAgdmFyIHV4ID0geDEgLSB4MDtcbiAgICB2YXIgdXkgPSB5MSAtIHkwO1xuICAgIHZhciB2eCA9IHgzIC0geDI7XG4gICAgdmFyIHZ5ID0geTMgLSB5MjtcbiAgICB2YXIgd3ggPSB4MCAtIHgyO1xuICAgIHZhciB3eSA9IHkwIC0geTI7XG4gICAgdmFyIGEgPSB1eCAqIHV4ICsgdXkgKiB1eTtcbiAgICB2YXIgYiA9IHV4ICogdnggKyB1eSAqIHZ5O1xuICAgIHZhciBjID0gdnggKiB2eCArIHZ5ICogdnk7XG4gICAgdmFyIGQgPSB1eCAqIHd4ICsgdXkgKiB3eTtcbiAgICB2YXIgZSA9IHZ4ICogd3ggKyB2eSAqIHd5O1xuICAgIHZhciBEID0gYSAqIGMgLSBiICogYjtcblxuICAgIHZhciBzYywgc04sIHRjLCB0TjtcbiAgICB2YXIgc0QgPSBEO1xuICAgIHZhciB0RCA9IEQ7XG5cbiAgICBpZiAoRCA9PT0gMCkge1xuICAgICAgICBzTiA9IDA7XG4gICAgICAgIHNEID0gMTtcbiAgICAgICAgdE4gPSBlO1xuICAgICAgICB0RCA9IGM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc04gPSBiICogZSAtIGMgKiBkO1xuICAgICAgICB0TiA9IGEgKiBlIC0gYiAqIGQ7XG4gICAgICAgIGlmIChzTiA8IDApIHtcbiAgICAgICAgICAgIHNOID0gMDtcbiAgICAgICAgICAgIHROID0gZTtcbiAgICAgICAgICAgIHREID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChzTiA+IHNEKSB7XG4gICAgICAgICAgICBzTiA9IHNEO1xuICAgICAgICAgICAgdE4gPSBlICsgYjtcbiAgICAgICAgICAgIHREID0gYztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0TiA8IDAuMCkge1xuICAgICAgICB0TiA9IDAuMDtcbiAgICAgICAgaWYgKC1kIDwgMC4wKSBzTiA9IDAuMDtcbiAgICAgICAgZWxzZSBpZiAoLWQgPiBhKSBzTiA9IHNEO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNOID0gLWQ7XG4gICAgICAgICAgICBzRCA9IGE7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHROID4gdEQpIHtcbiAgICAgICAgdE4gPSB0RDtcbiAgICAgICAgaWYgKCgtZCArIGIpIDwgMC4wKSBzTiA9IDA7XG4gICAgICAgIGVsc2UgaWYgKC1kICsgYiA+IGEpIHNOID0gc0Q7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc04gPSAtZCArIGI7XG4gICAgICAgICAgICBzRCA9IGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzYyA9IHNOID09PSAwID8gMCA6IHNOIC8gc0Q7XG4gICAgdGMgPSB0TiA9PT0gMCA/IDAgOiB0TiAvIHREO1xuXG4gICAgdmFyIGN4ID0gKDEgLSBzYykgKiB4MCArIHNjICogeDE7XG4gICAgdmFyIGN5ID0gKDEgLSBzYykgKiB5MCArIHNjICogeTE7XG4gICAgdmFyIGN4MiA9ICgxIC0gdGMpICogeDIgKyB0YyAqIHgzO1xuICAgIHZhciBjeTIgPSAoMSAtIHRjKSAqIHkyICsgdGMgKiB5MztcbiAgICB2YXIgZHggPSBjeDIgLSBjeDtcbiAgICB2YXIgZHkgPSBjeTIgLSBjeTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUJ5WChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gPyBhWzFdIC0gYlsxXSA6IGFbMF0gLSBiWzBdO1xufVxuXG5mdW5jdGlvbiBjb252ZXhIdWxsKHBvaW50cykge1xuICAgIHBvaW50cy5zb3J0KGNvbXBhcmVCeVgpO1xuXG4gICAgdmFyIGxvd2VyID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2hpbGUgKGxvd2VyLmxlbmd0aCA+PSAyICYmIGNyb3NzKGxvd2VyW2xvd2VyLmxlbmd0aCAtIDJdLCBsb3dlcltsb3dlci5sZW5ndGggLSAxXSwgcG9pbnRzW2ldKSA8PSAwKSB7XG4gICAgICAgICAgICBsb3dlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBsb3dlci5wdXNoKHBvaW50c1tpXSk7XG4gICAgfVxuXG4gICAgdmFyIHVwcGVyID0gW107XG4gICAgZm9yICh2YXIgaWkgPSBwb2ludHMubGVuZ3RoIC0gMTsgaWkgPj0gMDsgaWktLSkge1xuICAgICAgICB3aGlsZSAodXBwZXIubGVuZ3RoID49IDIgJiYgY3Jvc3ModXBwZXJbdXBwZXIubGVuZ3RoIC0gMl0sIHVwcGVyW3VwcGVyLmxlbmd0aCAtIDFdLCBwb2ludHNbaWldKSA8PSAwKSB7XG4gICAgICAgICAgICB1cHBlci5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICB1cHBlci5wdXNoKHBvaW50c1tpaV0pO1xuICAgIH1cblxuICAgIHVwcGVyLnBvcCgpO1xuICAgIGxvd2VyLnBvcCgpO1xuICAgIHJldHVybiBsb3dlci5jb25jYXQodXBwZXIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/concaveman@1.2.1/node_modules/concaveman/index.js\n");

/***/ })

};
;
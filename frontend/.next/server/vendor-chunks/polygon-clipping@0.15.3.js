"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/polygon-clipping@0.15.3";
exports.ids = ["vendor-chunks/polygon-clipping@0.15.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/polygon-clipping@0.15.3/node_modules/polygon-clipping/dist/polygon-clipping.cjs.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/polygon-clipping@0.15.3/node_modules/polygon-clipping/dist/polygon-clipping.cjs.js ***!
  \***************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nvar SplayTree = __webpack_require__(/*! splaytree */ \"(ssr)/./node_modules/.pnpm/splaytree@3.1.2/node_modules/splaytree/dist/splay.js\");\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }\n\nvar SplayTree__default = /*#__PURE__*/_interopDefaultLegacy(SplayTree);\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\n/**\n * A bounding box has the format:\n *\n *  { ll: { x: xmin, y: ymin }, ur: { x: xmax, y: ymax } }\n *\n */\nvar isInBbox = function isInBbox(bbox, point) {\n  return bbox.ll.x <= point.x && point.x <= bbox.ur.x && bbox.ll.y <= point.y && point.y <= bbox.ur.y;\n};\n/* Returns either null, or a bbox (aka an ordered pair of points)\n * If there is only one point of overlap, a bbox with identical points\n * will be returned */\n\nvar getBboxOverlap = function getBboxOverlap(b1, b2) {\n  // check if the bboxes overlap at all\n  if (b2.ur.x < b1.ll.x || b1.ur.x < b2.ll.x || b2.ur.y < b1.ll.y || b1.ur.y < b2.ll.y) return null; // find the middle two X values\n\n  var lowerX = b1.ll.x < b2.ll.x ? b2.ll.x : b1.ll.x;\n  var upperX = b1.ur.x < b2.ur.x ? b1.ur.x : b2.ur.x; // find the middle two Y values\n\n  var lowerY = b1.ll.y < b2.ll.y ? b2.ll.y : b1.ll.y;\n  var upperY = b1.ur.y < b2.ur.y ? b1.ur.y : b2.ur.y; // put those middle values together to get the overlap\n\n  return {\n    ll: {\n      x: lowerX,\n      y: lowerY\n    },\n    ur: {\n      x: upperX,\n      y: upperY\n    }\n  };\n};\n\n/* Javascript doesn't do integer math. Everything is\n * floating point with percision Number.EPSILON.\n *\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON\n */\nvar epsilon = Number.EPSILON; // IE Polyfill\n\nif (epsilon === undefined) epsilon = Math.pow(2, -52);\nvar EPSILON_SQ = epsilon * epsilon;\n/* FLP comparator */\n\nvar cmp = function cmp(a, b) {\n  // check if they're both 0\n  if (-epsilon < a && a < epsilon) {\n    if (-epsilon < b && b < epsilon) {\n      return 0;\n    }\n  } // check if they're flp equal\n\n\n  var ab = a - b;\n\n  if (ab * ab < EPSILON_SQ * a * b) {\n    return 0;\n  } // normal comparison\n\n\n  return a < b ? -1 : 1;\n};\n\n/**\n * This class rounds incoming values sufficiently so that\n * floating points problems are, for the most part, avoided.\n *\n * Incoming points are have their x & y values tested against\n * all previously seen x & y values. If either is 'too close'\n * to a previously seen value, it's value is 'snapped' to the\n * previously seen value.\n *\n * All points should be rounded by this class before being\n * stored in any data structures in the rest of this algorithm.\n */\n\nvar PtRounder = /*#__PURE__*/function () {\n  function PtRounder() {\n    _classCallCheck(this, PtRounder);\n\n    this.reset();\n  }\n\n  _createClass(PtRounder, [{\n    key: \"reset\",\n    value: function reset() {\n      this.xRounder = new CoordRounder();\n      this.yRounder = new CoordRounder();\n    }\n  }, {\n    key: \"round\",\n    value: function round(x, y) {\n      return {\n        x: this.xRounder.round(x),\n        y: this.yRounder.round(y)\n      };\n    }\n  }]);\n\n  return PtRounder;\n}();\n\nvar CoordRounder = /*#__PURE__*/function () {\n  function CoordRounder() {\n    _classCallCheck(this, CoordRounder);\n\n    this.tree = new SplayTree__default['default'](); // preseed with 0 so we don't end up with values < Number.EPSILON\n\n    this.round(0);\n  } // Note: this can rounds input values backwards or forwards.\n  //       You might ask, why not restrict this to just rounding\n  //       forwards? Wouldn't that allow left endpoints to always\n  //       remain left endpoints during splitting (never change to\n  //       right). No - it wouldn't, because we snap intersections\n  //       to endpoints (to establish independence from the segment\n  //       angle for t-intersections).\n\n\n  _createClass(CoordRounder, [{\n    key: \"round\",\n    value: function round(coord) {\n      var node = this.tree.add(coord);\n      var prevNode = this.tree.prev(node);\n\n      if (prevNode !== null && cmp(node.key, prevNode.key) === 0) {\n        this.tree.remove(coord);\n        return prevNode.key;\n      }\n\n      var nextNode = this.tree.next(node);\n\n      if (nextNode !== null && cmp(node.key, nextNode.key) === 0) {\n        this.tree.remove(coord);\n        return nextNode.key;\n      }\n\n      return coord;\n    }\n  }]);\n\n  return CoordRounder;\n}(); // singleton available by import\n\n\nvar rounder = new PtRounder();\n\n/* Cross Product of two vectors with first point at origin */\n\nvar crossProduct = function crossProduct(a, b) {\n  return a.x * b.y - a.y * b.x;\n};\n/* Dot Product of two vectors with first point at origin */\n\nvar dotProduct = function dotProduct(a, b) {\n  return a.x * b.x + a.y * b.y;\n};\n/* Comparator for two vectors with same starting point */\n\nvar compareVectorAngles = function compareVectorAngles(basePt, endPt1, endPt2) {\n  var v1 = {\n    x: endPt1.x - basePt.x,\n    y: endPt1.y - basePt.y\n  };\n  var v2 = {\n    x: endPt2.x - basePt.x,\n    y: endPt2.y - basePt.y\n  };\n  var kross = crossProduct(v1, v2);\n  return cmp(kross, 0);\n};\nvar length = function length(v) {\n  return Math.sqrt(dotProduct(v, v));\n};\n/* Get the sine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar sineOfAngle = function sineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return crossProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the cosine of the angle from pShared -> pAngle to pShaed -> pBase */\n\nvar cosineOfAngle = function cosineOfAngle(pShared, pBase, pAngle) {\n  var vBase = {\n    x: pBase.x - pShared.x,\n    y: pBase.y - pShared.y\n  };\n  var vAngle = {\n    x: pAngle.x - pShared.x,\n    y: pAngle.y - pShared.y\n  };\n  return dotProduct(vAngle, vBase) / length(vAngle) / length(vBase);\n};\n/* Get the x coordinate where the given line (defined by a point and vector)\n * crosses the horizontal line with the given y coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar horizontalIntersection = function horizontalIntersection(pt, v, y) {\n  if (v.y === 0) return null;\n  return {\n    x: pt.x + v.x / v.y * (y - pt.y),\n    y: y\n  };\n};\n/* Get the y coordinate where the given line (defined by a point and vector)\n * crosses the vertical line with the given x coordiante.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar verticalIntersection = function verticalIntersection(pt, v, x) {\n  if (v.x === 0) return null;\n  return {\n    x: x,\n    y: pt.y + v.y / v.x * (x - pt.x)\n  };\n};\n/* Get the intersection of two lines, each defined by a base point and a vector.\n * In the case of parrallel lines (including overlapping ones) returns null. */\n\nvar intersection = function intersection(pt1, v1, pt2, v2) {\n  // take some shortcuts for vertical and horizontal lines\n  // this also ensures we don't calculate an intersection and then discover\n  // it's actually outside the bounding box of the line\n  if (v1.x === 0) return verticalIntersection(pt2, v2, pt1.x);\n  if (v2.x === 0) return verticalIntersection(pt1, v1, pt2.x);\n  if (v1.y === 0) return horizontalIntersection(pt2, v2, pt1.y);\n  if (v2.y === 0) return horizontalIntersection(pt1, v1, pt2.y); // General case for non-overlapping segments.\n  // This algorithm is based on Schneider and Eberly.\n  // http://www.cimec.org.ar/~ncalvo/Schneider_Eberly.pdf - pg 244\n\n  var kross = crossProduct(v1, v2);\n  if (kross == 0) return null;\n  var ve = {\n    x: pt2.x - pt1.x,\n    y: pt2.y - pt1.y\n  };\n  var d1 = crossProduct(ve, v1) / kross;\n  var d2 = crossProduct(ve, v2) / kross; // take the average of the two calculations to minimize rounding error\n\n  var x1 = pt1.x + d2 * v1.x,\n      x2 = pt2.x + d1 * v2.x;\n  var y1 = pt1.y + d2 * v1.y,\n      y2 = pt2.y + d1 * v2.y;\n  var x = (x1 + x2) / 2;\n  var y = (y1 + y2) / 2;\n  return {\n    x: x,\n    y: y\n  };\n};\n\nvar SweepEvent = /*#__PURE__*/function () {\n  _createClass(SweepEvent, null, [{\n    key: \"compare\",\n    // for ordering sweep events in the sweep event queue\n    value: function compare(a, b) {\n      // favor event with a point that the sweep line hits first\n      var ptCmp = SweepEvent.comparePoints(a.point, b.point);\n      if (ptCmp !== 0) return ptCmp; // the points are the same, so link them if needed\n\n      if (a.point !== b.point) a.link(b); // favor right events over left\n\n      if (a.isLeft !== b.isLeft) return a.isLeft ? 1 : -1; // we have two matching left or right endpoints\n      // ordering of this case is the same as for their segments\n\n      return Segment.compare(a.segment, b.segment);\n    } // for ordering points in sweep line order\n\n  }, {\n    key: \"comparePoints\",\n    value: function comparePoints(aPt, bPt) {\n      if (aPt.x < bPt.x) return -1;\n      if (aPt.x > bPt.x) return 1;\n      if (aPt.y < bPt.y) return -1;\n      if (aPt.y > bPt.y) return 1;\n      return 0;\n    } // Warning: 'point' input will be modified and re-used (for performance)\n\n  }]);\n\n  function SweepEvent(point, isLeft) {\n    _classCallCheck(this, SweepEvent);\n\n    if (point.events === undefined) point.events = [this];else point.events.push(this);\n    this.point = point;\n    this.isLeft = isLeft; // this.segment, this.otherSE set by factory\n  }\n\n  _createClass(SweepEvent, [{\n    key: \"link\",\n    value: function link(other) {\n      if (other.point === this.point) {\n        throw new Error('Tried to link already linked events');\n      }\n\n      var otherEvents = other.point.events;\n\n      for (var i = 0, iMax = otherEvents.length; i < iMax; i++) {\n        var evt = otherEvents[i];\n        this.point.events.push(evt);\n        evt.point = this.point;\n      }\n\n      this.checkForConsuming();\n    }\n    /* Do a pass over our linked events and check to see if any pair\n     * of segments match, and should be consumed. */\n\n  }, {\n    key: \"checkForConsuming\",\n    value: function checkForConsuming() {\n      // FIXME: The loops in this method run O(n^2) => no good.\n      //        Maintain little ordered sweep event trees?\n      //        Can we maintaining an ordering that avoids the need\n      //        for the re-sorting with getLeftmostComparator in geom-out?\n      // Compare each pair of events to see if other events also match\n      var numEvents = this.point.events.length;\n\n      for (var i = 0; i < numEvents; i++) {\n        var evt1 = this.point.events[i];\n        if (evt1.segment.consumedBy !== undefined) continue;\n\n        for (var j = i + 1; j < numEvents; j++) {\n          var evt2 = this.point.events[j];\n          if (evt2.consumedBy !== undefined) continue;\n          if (evt1.otherSE.point.events !== evt2.otherSE.point.events) continue;\n          evt1.segment.consume(evt2.segment);\n        }\n      }\n    }\n  }, {\n    key: \"getAvailableLinkedEvents\",\n    value: function getAvailableLinkedEvents() {\n      // point.events is always of length 2 or greater\n      var events = [];\n\n      for (var i = 0, iMax = this.point.events.length; i < iMax; i++) {\n        var evt = this.point.events[i];\n\n        if (evt !== this && !evt.segment.ringOut && evt.segment.isInResult()) {\n          events.push(evt);\n        }\n      }\n\n      return events;\n    }\n    /**\n     * Returns a comparator function for sorting linked events that will\n     * favor the event that will give us the smallest left-side angle.\n     * All ring construction starts as low as possible heading to the right,\n     * so by always turning left as sharp as possible we'll get polygons\n     * without uncessary loops & holes.\n     *\n     * The comparator function has a compute cache such that it avoids\n     * re-computing already-computed values.\n     */\n\n  }, {\n    key: \"getLeftmostComparator\",\n    value: function getLeftmostComparator(baseEvent) {\n      var _this = this;\n\n      var cache = new Map();\n\n      var fillCache = function fillCache(linkedEvent) {\n        var nextEvent = linkedEvent.otherSE;\n        cache.set(linkedEvent, {\n          sine: sineOfAngle(_this.point, baseEvent.point, nextEvent.point),\n          cosine: cosineOfAngle(_this.point, baseEvent.point, nextEvent.point)\n        });\n      };\n\n      return function (a, b) {\n        if (!cache.has(a)) fillCache(a);\n        if (!cache.has(b)) fillCache(b);\n\n        var _cache$get = cache.get(a),\n            asine = _cache$get.sine,\n            acosine = _cache$get.cosine;\n\n        var _cache$get2 = cache.get(b),\n            bsine = _cache$get2.sine,\n            bcosine = _cache$get2.cosine; // both on or above x-axis\n\n\n        if (asine >= 0 && bsine >= 0) {\n          if (acosine < bcosine) return 1;\n          if (acosine > bcosine) return -1;\n          return 0;\n        } // both below x-axis\n\n\n        if (asine < 0 && bsine < 0) {\n          if (acosine < bcosine) return -1;\n          if (acosine > bcosine) return 1;\n          return 0;\n        } // one above x-axis, one below\n\n\n        if (bsine < asine) return -1;\n        if (bsine > asine) return 1;\n        return 0;\n      };\n    }\n  }]);\n\n  return SweepEvent;\n}();\n\n// segments and sweep events when all else is identical\n\nvar segmentId = 0;\n\nvar Segment = /*#__PURE__*/function () {\n  _createClass(Segment, null, [{\n    key: \"compare\",\n\n    /* This compare() function is for ordering segments in the sweep\n     * line tree, and does so according to the following criteria:\n     *\n     * Consider the vertical line that lies an infinestimal step to the\n     * right of the right-more of the two left endpoints of the input\n     * segments. Imagine slowly moving a point up from negative infinity\n     * in the increasing y direction. Which of the two segments will that\n     * point intersect first? That segment comes 'before' the other one.\n     *\n     * If neither segment would be intersected by such a line, (if one\n     * or more of the segments are vertical) then the line to be considered\n     * is directly on the right-more of the two left inputs.\n     */\n    value: function compare(a, b) {\n      var alx = a.leftSE.point.x;\n      var blx = b.leftSE.point.x;\n      var arx = a.rightSE.point.x;\n      var brx = b.rightSE.point.x; // check if they're even in the same vertical plane\n\n      if (brx < alx) return 1;\n      if (arx < blx) return -1;\n      var aly = a.leftSE.point.y;\n      var bly = b.leftSE.point.y;\n      var ary = a.rightSE.point.y;\n      var bry = b.rightSE.point.y; // is left endpoint of segment B the right-more?\n\n      if (alx < blx) {\n        // are the two segments in the same horizontal plane?\n        if (bly < aly && bly < ary) return 1;\n        if (bly > aly && bly > ary) return -1; // is the B left endpoint colinear to segment A?\n\n        var aCmpBLeft = a.comparePoint(b.leftSE.point);\n        if (aCmpBLeft < 0) return 1;\n        if (aCmpBLeft > 0) return -1; // is the A right endpoint colinear to segment B ?\n\n        var bCmpARight = b.comparePoint(a.rightSE.point);\n        if (bCmpARight !== 0) return bCmpARight; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return -1;\n      } // is left endpoint of segment A the right-more?\n\n\n      if (alx > blx) {\n        if (aly < bly && aly < bry) return -1;\n        if (aly > bly && aly > bry) return 1; // is the A left endpoint colinear to segment B?\n\n        var bCmpALeft = b.comparePoint(a.leftSE.point);\n        if (bCmpALeft !== 0) return bCmpALeft; // is the B right endpoint colinear to segment A?\n\n        var aCmpBRight = a.comparePoint(b.rightSE.point);\n        if (aCmpBRight < 0) return 1;\n        if (aCmpBRight > 0) return -1; // colinear segments, consider the one with left-more\n        // left endpoint to be first (arbitrary?)\n\n        return 1;\n      } // if we get here, the two left endpoints are in the same\n      // vertical plane, ie alx === blx\n      // consider the lower left-endpoint to come first\n\n\n      if (aly < bly) return -1;\n      if (aly > bly) return 1; // left endpoints are identical\n      // check for colinearity by using the left-more right endpoint\n      // is the A right endpoint more left-more?\n\n      if (arx < brx) {\n        var _bCmpARight = b.comparePoint(a.rightSE.point);\n\n        if (_bCmpARight !== 0) return _bCmpARight;\n      } // is the B right endpoint more left-more?\n\n\n      if (arx > brx) {\n        var _aCmpBRight = a.comparePoint(b.rightSE.point);\n\n        if (_aCmpBRight < 0) return 1;\n        if (_aCmpBRight > 0) return -1;\n      }\n\n      if (arx !== brx) {\n        // are these two [almost] vertical segments with opposite orientation?\n        // if so, the one with the lower right endpoint comes first\n        var ay = ary - aly;\n        var ax = arx - alx;\n        var by = bry - bly;\n        var bx = brx - blx;\n        if (ay > ax && by < bx) return 1;\n        if (ay < ax && by > bx) return -1;\n      } // we have colinear segments with matching orientation\n      // consider the one with more left-more right endpoint to be first\n\n\n      if (arx > brx) return 1;\n      if (arx < brx) return -1; // if we get here, two two right endpoints are in the same\n      // vertical plane, ie arx === brx\n      // consider the lower right-endpoint to come first\n\n      if (ary < bry) return -1;\n      if (ary > bry) return 1; // right endpoints identical as well, so the segments are idential\n      // fall back on creation order as consistent tie-breaker\n\n      if (a.id < b.id) return -1;\n      if (a.id > b.id) return 1; // identical segment, ie a === b\n\n      return 0;\n    }\n    /* Warning: a reference to ringWindings input will be stored,\n     *  and possibly will be later modified */\n\n  }]);\n\n  function Segment(leftSE, rightSE, rings, windings) {\n    _classCallCheck(this, Segment);\n\n    this.id = ++segmentId;\n    this.leftSE = leftSE;\n    leftSE.segment = this;\n    leftSE.otherSE = rightSE;\n    this.rightSE = rightSE;\n    rightSE.segment = this;\n    rightSE.otherSE = leftSE;\n    this.rings = rings;\n    this.windings = windings; // left unset for performance, set later in algorithm\n    // this.ringOut, this.consumedBy, this.prev\n  }\n\n  _createClass(Segment, [{\n    key: \"replaceRightSE\",\n\n    /* When a segment is split, the rightSE is replaced with a new sweep event */\n    value: function replaceRightSE(newRightSE) {\n      this.rightSE = newRightSE;\n      this.rightSE.segment = this;\n      this.rightSE.otherSE = this.leftSE;\n      this.leftSE.otherSE = this.rightSE;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var y1 = this.leftSE.point.y;\n      var y2 = this.rightSE.point.y;\n      return {\n        ll: {\n          x: this.leftSE.point.x,\n          y: y1 < y2 ? y1 : y2\n        },\n        ur: {\n          x: this.rightSE.point.x,\n          y: y1 > y2 ? y1 : y2\n        }\n      };\n    }\n    /* A vector from the left point to the right */\n\n  }, {\n    key: \"vector\",\n    value: function vector() {\n      return {\n        x: this.rightSE.point.x - this.leftSE.point.x,\n        y: this.rightSE.point.y - this.leftSE.point.y\n      };\n    }\n  }, {\n    key: \"isAnEndpoint\",\n    value: function isAnEndpoint(pt) {\n      return pt.x === this.leftSE.point.x && pt.y === this.leftSE.point.y || pt.x === this.rightSE.point.x && pt.y === this.rightSE.point.y;\n    }\n    /* Compare this segment with a point.\n     *\n     * A point P is considered to be colinear to a segment if there\n     * exists a distance D such that if we travel along the segment\n     * from one * endpoint towards the other a distance D, we find\n     * ourselves at point P.\n     *\n     * Return value indicates:\n     *\n     *   1: point lies above the segment (to the left of vertical)\n     *   0: point is colinear to segment\n     *  -1: point lies below the segment (to the right of vertical)\n     */\n\n  }, {\n    key: \"comparePoint\",\n    value: function comparePoint(point) {\n      if (this.isAnEndpoint(point)) return 0;\n      var lPt = this.leftSE.point;\n      var rPt = this.rightSE.point;\n      var v = this.vector(); // Exactly vertical segments.\n\n      if (lPt.x === rPt.x) {\n        if (point.x === lPt.x) return 0;\n        return point.x < lPt.x ? 1 : -1;\n      } // Nearly vertical segments with an intersection.\n      // Check to see where a point on the line with matching Y coordinate is.\n\n\n      var yDist = (point.y - lPt.y) / v.y;\n      var xFromYDist = lPt.x + yDist * v.x;\n      if (point.x === xFromYDist) return 0; // General case.\n      // Check to see where a point on the line with matching X coordinate is.\n\n      var xDist = (point.x - lPt.x) / v.x;\n      var yFromXDist = lPt.y + xDist * v.y;\n      if (point.y === yFromXDist) return 0;\n      return point.y < yFromXDist ? -1 : 1;\n    }\n    /**\n     * Given another segment, returns the first non-trivial intersection\n     * between the two segments (in terms of sweep line ordering), if it exists.\n     *\n     * A 'non-trivial' intersection is one that will cause one or both of the\n     * segments to be split(). As such, 'trivial' vs. 'non-trivial' intersection:\n     *\n     *   * endpoint of segA with endpoint of segB --> trivial\n     *   * endpoint of segA with point along segB --> non-trivial\n     *   * endpoint of segB with point along segA --> non-trivial\n     *   * point along segA with point along segB --> non-trivial\n     *\n     * If no non-trivial intersection exists, return null\n     * Else, return null.\n     */\n\n  }, {\n    key: \"getIntersection\",\n    value: function getIntersection(other) {\n      // If bboxes don't overlap, there can't be any intersections\n      var tBbox = this.bbox();\n      var oBbox = other.bbox();\n      var bboxOverlap = getBboxOverlap(tBbox, oBbox);\n      if (bboxOverlap === null) return null; // We first check to see if the endpoints can be considered intersections.\n      // This will 'snap' intersections to endpoints if possible, and will\n      // handle cases of colinearity.\n\n      var tlp = this.leftSE.point;\n      var trp = this.rightSE.point;\n      var olp = other.leftSE.point;\n      var orp = other.rightSE.point; // does each endpoint touch the other segment?\n      // note that we restrict the 'touching' definition to only allow segments\n      // to touch endpoints that lie forward from where we are in the sweep line pass\n\n      var touchesOtherLSE = isInBbox(tBbox, olp) && this.comparePoint(olp) === 0;\n      var touchesThisLSE = isInBbox(oBbox, tlp) && other.comparePoint(tlp) === 0;\n      var touchesOtherRSE = isInBbox(tBbox, orp) && this.comparePoint(orp) === 0;\n      var touchesThisRSE = isInBbox(oBbox, trp) && other.comparePoint(trp) === 0; // do left endpoints match?\n\n      if (touchesThisLSE && touchesOtherLSE) {\n        // these two cases are for colinear segments with matching left\n        // endpoints, and one segment being longer than the other\n        if (touchesThisRSE && !touchesOtherRSE) return trp;\n        if (!touchesThisRSE && touchesOtherRSE) return orp; // either the two segments match exactly (two trival intersections)\n        // or just on their left endpoint (one trivial intersection\n\n        return null;\n      } // does this left endpoint matches (other doesn't)\n\n\n      if (touchesThisLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesOtherRSE) {\n          if (tlp.x === orp.x && tlp.y === orp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return tlp;\n      } // does other left endpoint matches (this doesn't)\n\n\n      if (touchesOtherLSE) {\n        // check for segments that just intersect on opposing endpoints\n        if (touchesThisRSE) {\n          if (trp.x === olp.x && trp.y === olp.y) return null;\n        } // t-intersection on left endpoint\n\n\n        return olp;\n      } // trivial intersection on right endpoints\n\n\n      if (touchesThisRSE && touchesOtherRSE) return null; // t-intersections on just one right endpoint\n\n      if (touchesThisRSE) return trp;\n      if (touchesOtherRSE) return orp; // None of our endpoints intersect. Look for a general intersection between\n      // infinite lines laid over the segments\n\n      var pt = intersection(tlp, this.vector(), olp, other.vector()); // are the segments parrallel? Note that if they were colinear with overlap,\n      // they would have an endpoint intersection and that case was already handled above\n\n      if (pt === null) return null; // is the intersection found between the lines not on the segments?\n\n      if (!isInBbox(bboxOverlap, pt)) return null; // round the the computed point if needed\n\n      return rounder.round(pt.x, pt.y);\n    }\n    /**\n     * Split the given segment into multiple segments on the given points.\n     *  * Each existing segment will retain its leftSE and a new rightSE will be\n     *    generated for it.\n     *  * A new segment will be generated which will adopt the original segment's\n     *    rightSE, and a new leftSE will be generated for it.\n     *  * If there are more than two points given to split on, new segments\n     *    in the middle will be generated with new leftSE and rightSE's.\n     *  * An array of the newly generated SweepEvents will be returned.\n     *\n     * Warning: input array of points is modified\n     */\n\n  }, {\n    key: \"split\",\n    value: function split(point) {\n      var newEvents = [];\n      var alreadyLinked = point.events !== undefined;\n      var newLeftSE = new SweepEvent(point, true);\n      var newRightSE = new SweepEvent(point, false);\n      var oldRightSE = this.rightSE;\n      this.replaceRightSE(newRightSE);\n      newEvents.push(newRightSE);\n      newEvents.push(newLeftSE);\n      var newSeg = new Segment(newLeftSE, oldRightSE, this.rings.slice(), this.windings.slice()); // when splitting a nearly vertical downward-facing segment,\n      // sometimes one of the resulting new segments is vertical, in which\n      // case its left and right events may need to be swapped\n\n      if (SweepEvent.comparePoints(newSeg.leftSE.point, newSeg.rightSE.point) > 0) {\n        newSeg.swapEvents();\n      }\n\n      if (SweepEvent.comparePoints(this.leftSE.point, this.rightSE.point) > 0) {\n        this.swapEvents();\n      } // in the point we just used to create new sweep events with was already\n      // linked to other events, we need to check if either of the affected\n      // segments should be consumed\n\n\n      if (alreadyLinked) {\n        newLeftSE.checkForConsuming();\n        newRightSE.checkForConsuming();\n      }\n\n      return newEvents;\n    }\n    /* Swap which event is left and right */\n\n  }, {\n    key: \"swapEvents\",\n    value: function swapEvents() {\n      var tmpEvt = this.rightSE;\n      this.rightSE = this.leftSE;\n      this.leftSE = tmpEvt;\n      this.leftSE.isLeft = true;\n      this.rightSE.isLeft = false;\n\n      for (var i = 0, iMax = this.windings.length; i < iMax; i++) {\n        this.windings[i] *= -1;\n      }\n    }\n    /* Consume another segment. We take their rings under our wing\n     * and mark them as consumed. Use for perfectly overlapping segments */\n\n  }, {\n    key: \"consume\",\n    value: function consume(other) {\n      var consumer = this;\n      var consumee = other;\n\n      while (consumer.consumedBy) {\n        consumer = consumer.consumedBy;\n      }\n\n      while (consumee.consumedBy) {\n        consumee = consumee.consumedBy;\n      }\n\n      var cmp = Segment.compare(consumer, consumee);\n      if (cmp === 0) return; // already consumed\n      // the winner of the consumption is the earlier segment\n      // according to sweep line ordering\n\n      if (cmp > 0) {\n        var tmp = consumer;\n        consumer = consumee;\n        consumee = tmp;\n      } // make sure a segment doesn't consume it's prev\n\n\n      if (consumer.prev === consumee) {\n        var _tmp = consumer;\n        consumer = consumee;\n        consumee = _tmp;\n      }\n\n      for (var i = 0, iMax = consumee.rings.length; i < iMax; i++) {\n        var ring = consumee.rings[i];\n        var winding = consumee.windings[i];\n        var index = consumer.rings.indexOf(ring);\n\n        if (index === -1) {\n          consumer.rings.push(ring);\n          consumer.windings.push(winding);\n        } else consumer.windings[index] += winding;\n      }\n\n      consumee.rings = null;\n      consumee.windings = null;\n      consumee.consumedBy = consumer; // mark sweep events consumed as to maintain ordering in sweep event queue\n\n      consumee.leftSE.consumedBy = consumer.leftSE;\n      consumee.rightSE.consumedBy = consumer.rightSE;\n    }\n    /* The first segment previous segment chain that is in the result */\n\n  }, {\n    key: \"prevInResult\",\n    value: function prevInResult() {\n      if (this._prevInResult !== undefined) return this._prevInResult;\n      if (!this.prev) this._prevInResult = null;else if (this.prev.isInResult()) this._prevInResult = this.prev;else this._prevInResult = this.prev.prevInResult();\n      return this._prevInResult;\n    }\n  }, {\n    key: \"beforeState\",\n    value: function beforeState() {\n      if (this._beforeState !== undefined) return this._beforeState;\n      if (!this.prev) this._beforeState = {\n        rings: [],\n        windings: [],\n        multiPolys: []\n      };else {\n        var seg = this.prev.consumedBy || this.prev;\n        this._beforeState = seg.afterState();\n      }\n      return this._beforeState;\n    }\n  }, {\n    key: \"afterState\",\n    value: function afterState() {\n      if (this._afterState !== undefined) return this._afterState;\n      var beforeState = this.beforeState();\n      this._afterState = {\n        rings: beforeState.rings.slice(0),\n        windings: beforeState.windings.slice(0),\n        multiPolys: []\n      };\n      var ringsAfter = this._afterState.rings;\n      var windingsAfter = this._afterState.windings;\n      var mpsAfter = this._afterState.multiPolys; // calculate ringsAfter, windingsAfter\n\n      for (var i = 0, iMax = this.rings.length; i < iMax; i++) {\n        var ring = this.rings[i];\n        var winding = this.windings[i];\n        var index = ringsAfter.indexOf(ring);\n\n        if (index === -1) {\n          ringsAfter.push(ring);\n          windingsAfter.push(winding);\n        } else windingsAfter[index] += winding;\n      } // calcualte polysAfter\n\n\n      var polysAfter = [];\n      var polysExclude = [];\n\n      for (var _i = 0, _iMax = ringsAfter.length; _i < _iMax; _i++) {\n        if (windingsAfter[_i] === 0) continue; // non-zero rule\n\n        var _ring = ringsAfter[_i];\n        var poly = _ring.poly;\n        if (polysExclude.indexOf(poly) !== -1) continue;\n        if (_ring.isExterior) polysAfter.push(poly);else {\n          if (polysExclude.indexOf(poly) === -1) polysExclude.push(poly);\n\n          var _index = polysAfter.indexOf(_ring.poly);\n\n          if (_index !== -1) polysAfter.splice(_index, 1);\n        }\n      } // calculate multiPolysAfter\n\n\n      for (var _i2 = 0, _iMax2 = polysAfter.length; _i2 < _iMax2; _i2++) {\n        var mp = polysAfter[_i2].multiPoly;\n        if (mpsAfter.indexOf(mp) === -1) mpsAfter.push(mp);\n      }\n\n      return this._afterState;\n    }\n    /* Is this segment part of the final result? */\n\n  }, {\n    key: \"isInResult\",\n    value: function isInResult() {\n      // if we've been consumed, we're not in the result\n      if (this.consumedBy) return false;\n      if (this._isInResult !== undefined) return this._isInResult;\n      var mpsBefore = this.beforeState().multiPolys;\n      var mpsAfter = this.afterState().multiPolys;\n\n      switch (operation.type) {\n        case 'union':\n          {\n            // UNION - included iff:\n            //  * On one side of us there is 0 poly interiors AND\n            //  * On the other side there is 1 or more.\n            var noBefores = mpsBefore.length === 0;\n            var noAfters = mpsAfter.length === 0;\n            this._isInResult = noBefores !== noAfters;\n            break;\n          }\n\n        case 'intersection':\n          {\n            // INTERSECTION - included iff:\n            //  * on one side of us all multipolys are rep. with poly interiors AND\n            //  * on the other side of us, not all multipolys are repsented\n            //    with poly interiors\n            var least;\n            var most;\n\n            if (mpsBefore.length < mpsAfter.length) {\n              least = mpsBefore.length;\n              most = mpsAfter.length;\n            } else {\n              least = mpsAfter.length;\n              most = mpsBefore.length;\n            }\n\n            this._isInResult = most === operation.numMultiPolys && least < most;\n            break;\n          }\n\n        case 'xor':\n          {\n            // XOR - included iff:\n            //  * the difference between the number of multipolys represented\n            //    with poly interiors on our two sides is an odd number\n            var diff = Math.abs(mpsBefore.length - mpsAfter.length);\n            this._isInResult = diff % 2 === 1;\n            break;\n          }\n\n        case 'difference':\n          {\n            // DIFFERENCE included iff:\n            //  * on exactly one side, we have just the subject\n            var isJustSubject = function isJustSubject(mps) {\n              return mps.length === 1 && mps[0].isSubject;\n            };\n\n            this._isInResult = isJustSubject(mpsBefore) !== isJustSubject(mpsAfter);\n            break;\n          }\n\n        default:\n          throw new Error(\"Unrecognized operation type found \".concat(operation.type));\n      }\n\n      return this._isInResult;\n    }\n  }], [{\n    key: \"fromRing\",\n    value: function fromRing(pt1, pt2, ring) {\n      var leftPt, rightPt, winding; // ordering the two points according to sweep line ordering\n\n      var cmpPts = SweepEvent.comparePoints(pt1, pt2);\n\n      if (cmpPts < 0) {\n        leftPt = pt1;\n        rightPt = pt2;\n        winding = 1;\n      } else if (cmpPts > 0) {\n        leftPt = pt2;\n        rightPt = pt1;\n        winding = -1;\n      } else throw new Error(\"Tried to create degenerate segment at [\".concat(pt1.x, \", \").concat(pt1.y, \"]\"));\n\n      var leftSE = new SweepEvent(leftPt, true);\n      var rightSE = new SweepEvent(rightPt, false);\n      return new Segment(leftSE, rightSE, [ring], [winding]);\n    }\n  }]);\n\n  return Segment;\n}();\n\nvar RingIn = /*#__PURE__*/function () {\n  function RingIn(geomRing, poly, isExterior) {\n    _classCallCheck(this, RingIn);\n\n    if (!Array.isArray(geomRing) || geomRing.length === 0) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.poly = poly;\n    this.isExterior = isExterior;\n    this.segments = [];\n\n    if (typeof geomRing[0][0] !== 'number' || typeof geomRing[0][1] !== 'number') {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    var firstPoint = rounder.round(geomRing[0][0], geomRing[0][1]);\n    this.bbox = {\n      ll: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      },\n      ur: {\n        x: firstPoint.x,\n        y: firstPoint.y\n      }\n    };\n    var prevPoint = firstPoint;\n\n    for (var i = 1, iMax = geomRing.length; i < iMax; i++) {\n      if (typeof geomRing[i][0] !== 'number' || typeof geomRing[i][1] !== 'number') {\n        throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n      }\n\n      var point = rounder.round(geomRing[i][0], geomRing[i][1]); // skip repeated points\n\n      if (point.x === prevPoint.x && point.y === prevPoint.y) continue;\n      this.segments.push(Segment.fromRing(prevPoint, point, this));\n      if (point.x < this.bbox.ll.x) this.bbox.ll.x = point.x;\n      if (point.y < this.bbox.ll.y) this.bbox.ll.y = point.y;\n      if (point.x > this.bbox.ur.x) this.bbox.ur.x = point.x;\n      if (point.y > this.bbox.ur.y) this.bbox.ur.y = point.y;\n      prevPoint = point;\n    } // add segment from last to first if last is not the same as first\n\n\n    if (firstPoint.x !== prevPoint.x || firstPoint.y !== prevPoint.y) {\n      this.segments.push(Segment.fromRing(prevPoint, firstPoint, this));\n    }\n  }\n\n  _createClass(RingIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.segments.length; i < iMax; i++) {\n        var segment = this.segments[i];\n        sweepEvents.push(segment.leftSE);\n        sweepEvents.push(segment.rightSE);\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return RingIn;\n}();\nvar PolyIn = /*#__PURE__*/function () {\n  function PolyIn(geomPoly, multiPoly) {\n    _classCallCheck(this, PolyIn);\n\n    if (!Array.isArray(geomPoly)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    this.exteriorRing = new RingIn(geomPoly[0], this, true); // copy by value\n\n    this.bbox = {\n      ll: {\n        x: this.exteriorRing.bbox.ll.x,\n        y: this.exteriorRing.bbox.ll.y\n      },\n      ur: {\n        x: this.exteriorRing.bbox.ur.x,\n        y: this.exteriorRing.bbox.ur.y\n      }\n    };\n    this.interiorRings = [];\n\n    for (var i = 1, iMax = geomPoly.length; i < iMax; i++) {\n      var ring = new RingIn(geomPoly[i], this, false);\n      if (ring.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = ring.bbox.ll.x;\n      if (ring.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = ring.bbox.ll.y;\n      if (ring.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = ring.bbox.ur.x;\n      if (ring.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = ring.bbox.ur.y;\n      this.interiorRings.push(ring);\n    }\n\n    this.multiPoly = multiPoly;\n  }\n\n  _createClass(PolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = this.exteriorRing.getSweepEvents();\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringSweepEvents = this.interiorRings[i].getSweepEvents();\n\n        for (var j = 0, jMax = ringSweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(ringSweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return PolyIn;\n}();\nvar MultiPolyIn = /*#__PURE__*/function () {\n  function MultiPolyIn(geom, isSubject) {\n    _classCallCheck(this, MultiPolyIn);\n\n    if (!Array.isArray(geom)) {\n      throw new Error('Input geometry is not a valid Polygon or MultiPolygon');\n    }\n\n    try {\n      // if the input looks like a polygon, convert it to a multipolygon\n      if (typeof geom[0][0][0] === 'number') geom = [geom];\n    } catch (ex) {// The input is either malformed or has empty arrays.\n      // In either case, it will be handled later on.\n    }\n\n    this.polys = [];\n    this.bbox = {\n      ll: {\n        x: Number.POSITIVE_INFINITY,\n        y: Number.POSITIVE_INFINITY\n      },\n      ur: {\n        x: Number.NEGATIVE_INFINITY,\n        y: Number.NEGATIVE_INFINITY\n      }\n    };\n\n    for (var i = 0, iMax = geom.length; i < iMax; i++) {\n      var poly = new PolyIn(geom[i], this);\n      if (poly.bbox.ll.x < this.bbox.ll.x) this.bbox.ll.x = poly.bbox.ll.x;\n      if (poly.bbox.ll.y < this.bbox.ll.y) this.bbox.ll.y = poly.bbox.ll.y;\n      if (poly.bbox.ur.x > this.bbox.ur.x) this.bbox.ur.x = poly.bbox.ur.x;\n      if (poly.bbox.ur.y > this.bbox.ur.y) this.bbox.ur.y = poly.bbox.ur.y;\n      this.polys.push(poly);\n    }\n\n    this.isSubject = isSubject;\n  }\n\n  _createClass(MultiPolyIn, [{\n    key: \"getSweepEvents\",\n    value: function getSweepEvents() {\n      var sweepEvents = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polySweepEvents = this.polys[i].getSweepEvents();\n\n        for (var j = 0, jMax = polySweepEvents.length; j < jMax; j++) {\n          sweepEvents.push(polySweepEvents[j]);\n        }\n      }\n\n      return sweepEvents;\n    }\n  }]);\n\n  return MultiPolyIn;\n}();\n\nvar RingOut = /*#__PURE__*/function () {\n  _createClass(RingOut, null, [{\n    key: \"factory\",\n\n    /* Given the segments from the sweep line pass, compute & return a series\n     * of closed rings from all the segments marked to be part of the result */\n    value: function factory(allSegments) {\n      var ringsOut = [];\n\n      for (var i = 0, iMax = allSegments.length; i < iMax; i++) {\n        var segment = allSegments[i];\n        if (!segment.isInResult() || segment.ringOut) continue;\n        var prevEvent = null;\n        var event = segment.leftSE;\n        var nextEvent = segment.rightSE;\n        var events = [event];\n        var startingPoint = event.point;\n        var intersectionLEs = [];\n        /* Walk the chain of linked events to form a closed ring */\n\n        while (true) {\n          prevEvent = event;\n          event = nextEvent;\n          events.push(event);\n          /* Is the ring complete? */\n\n          if (event.point === startingPoint) break;\n\n          while (true) {\n            var availableLEs = event.getAvailableLinkedEvents();\n            /* Did we hit a dead end? This shouldn't happen. Indicates some earlier\n             * part of the algorithm malfunctioned... please file a bug report. */\n\n            if (availableLEs.length === 0) {\n              var firstPt = events[0].point;\n              var lastPt = events[events.length - 1].point;\n              throw new Error(\"Unable to complete output ring starting at [\".concat(firstPt.x, \",\") + \" \".concat(firstPt.y, \"]. Last matching segment found ends at\") + \" [\".concat(lastPt.x, \", \").concat(lastPt.y, \"].\"));\n            }\n            /* Only one way to go, so cotinue on the path */\n\n\n            if (availableLEs.length === 1) {\n              nextEvent = availableLEs[0].otherSE;\n              break;\n            }\n            /* We must have an intersection. Check for a completed loop */\n\n\n            var indexLE = null;\n\n            for (var j = 0, jMax = intersectionLEs.length; j < jMax; j++) {\n              if (intersectionLEs[j].point === event.point) {\n                indexLE = j;\n                break;\n              }\n            }\n            /* Found a completed loop. Cut that off and make a ring */\n\n\n            if (indexLE !== null) {\n              var intersectionLE = intersectionLEs.splice(indexLE)[0];\n              var ringEvents = events.splice(intersectionLE.index);\n              ringEvents.unshift(ringEvents[0].otherSE);\n              ringsOut.push(new RingOut(ringEvents.reverse()));\n              continue;\n            }\n            /* register the intersection */\n\n\n            intersectionLEs.push({\n              index: events.length,\n              point: event.point\n            });\n            /* Choose the left-most option to continue the walk */\n\n            var comparator = event.getLeftmostComparator(prevEvent);\n            nextEvent = availableLEs.sort(comparator)[0].otherSE;\n            break;\n          }\n        }\n\n        ringsOut.push(new RingOut(events));\n      }\n\n      return ringsOut;\n    }\n  }]);\n\n  function RingOut(events) {\n    _classCallCheck(this, RingOut);\n\n    this.events = events;\n\n    for (var i = 0, iMax = events.length; i < iMax; i++) {\n      events[i].segment.ringOut = this;\n    }\n\n    this.poly = null;\n  }\n\n  _createClass(RingOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      // Remove superfluous points (ie extra points along a straight line),\n      var prevPt = this.events[0].point;\n      var points = [prevPt];\n\n      for (var i = 1, iMax = this.events.length - 1; i < iMax; i++) {\n        var _pt = this.events[i].point;\n        var _nextPt = this.events[i + 1].point;\n        if (compareVectorAngles(_pt, prevPt, _nextPt) === 0) continue;\n        points.push(_pt);\n        prevPt = _pt;\n      } // ring was all (within rounding error of angle calc) colinear points\n\n\n      if (points.length === 1) return null; // check if the starting point is necessary\n\n      var pt = points[0];\n      var nextPt = points[1];\n      if (compareVectorAngles(pt, prevPt, nextPt) === 0) points.shift();\n      points.push(points[0]);\n      var step = this.isExteriorRing() ? 1 : -1;\n      var iStart = this.isExteriorRing() ? 0 : points.length - 1;\n      var iEnd = this.isExteriorRing() ? points.length : -1;\n      var orderedPoints = [];\n\n      for (var _i = iStart; _i != iEnd; _i += step) {\n        orderedPoints.push([points[_i].x, points[_i].y]);\n      }\n\n      return orderedPoints;\n    }\n  }, {\n    key: \"isExteriorRing\",\n    value: function isExteriorRing() {\n      if (this._isExteriorRing === undefined) {\n        var enclosing = this.enclosingRing();\n        this._isExteriorRing = enclosing ? !enclosing.isExteriorRing() : true;\n      }\n\n      return this._isExteriorRing;\n    }\n  }, {\n    key: \"enclosingRing\",\n    value: function enclosingRing() {\n      if (this._enclosingRing === undefined) {\n        this._enclosingRing = this._calcEnclosingRing();\n      }\n\n      return this._enclosingRing;\n    }\n    /* Returns the ring that encloses this one, if any */\n\n  }, {\n    key: \"_calcEnclosingRing\",\n    value: function _calcEnclosingRing() {\n      // start with the ealier sweep line event so that the prevSeg\n      // chain doesn't lead us inside of a loop of ours\n      var leftMostEvt = this.events[0];\n\n      for (var i = 1, iMax = this.events.length; i < iMax; i++) {\n        var evt = this.events[i];\n        if (SweepEvent.compare(leftMostEvt, evt) > 0) leftMostEvt = evt;\n      }\n\n      var prevSeg = leftMostEvt.segment.prevInResult();\n      var prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n\n      while (true) {\n        // no segment found, thus no ring can enclose us\n        if (!prevSeg) return null; // no segments below prev segment found, thus the ring of the prev\n        // segment must loop back around and enclose us\n\n        if (!prevPrevSeg) return prevSeg.ringOut; // if the two segments are of different rings, the ring of the prev\n        // segment must either loop around us or the ring of the prev prev\n        // seg, which would make us and the ring of the prev peers\n\n        if (prevPrevSeg.ringOut !== prevSeg.ringOut) {\n          if (prevPrevSeg.ringOut.enclosingRing() !== prevSeg.ringOut) {\n            return prevSeg.ringOut;\n          } else return prevSeg.ringOut.enclosingRing();\n        } // two segments are from the same ring, so this was a penisula\n        // of that ring. iterate downward, keep searching\n\n\n        prevSeg = prevPrevSeg.prevInResult();\n        prevPrevSeg = prevSeg ? prevSeg.prevInResult() : null;\n      }\n    }\n  }]);\n\n  return RingOut;\n}();\nvar PolyOut = /*#__PURE__*/function () {\n  function PolyOut(exteriorRing) {\n    _classCallCheck(this, PolyOut);\n\n    this.exteriorRing = exteriorRing;\n    exteriorRing.poly = this;\n    this.interiorRings = [];\n  }\n\n  _createClass(PolyOut, [{\n    key: \"addInterior\",\n    value: function addInterior(ring) {\n      this.interiorRings.push(ring);\n      ring.poly = this;\n    }\n  }, {\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [this.exteriorRing.getGeom()]; // exterior ring was all (within rounding error of angle calc) colinear points\n\n      if (geom[0] === null) return null;\n\n      for (var i = 0, iMax = this.interiorRings.length; i < iMax; i++) {\n        var ringGeom = this.interiorRings[i].getGeom(); // interior ring was all (within rounding error of angle calc) colinear points\n\n        if (ringGeom === null) continue;\n        geom.push(ringGeom);\n      }\n\n      return geom;\n    }\n  }]);\n\n  return PolyOut;\n}();\nvar MultiPolyOut = /*#__PURE__*/function () {\n  function MultiPolyOut(rings) {\n    _classCallCheck(this, MultiPolyOut);\n\n    this.rings = rings;\n    this.polys = this._composePolys(rings);\n  }\n\n  _createClass(MultiPolyOut, [{\n    key: \"getGeom\",\n    value: function getGeom() {\n      var geom = [];\n\n      for (var i = 0, iMax = this.polys.length; i < iMax; i++) {\n        var polyGeom = this.polys[i].getGeom(); // exterior ring was all (within rounding error of angle calc) colinear points\n\n        if (polyGeom === null) continue;\n        geom.push(polyGeom);\n      }\n\n      return geom;\n    }\n  }, {\n    key: \"_composePolys\",\n    value: function _composePolys(rings) {\n      var polys = [];\n\n      for (var i = 0, iMax = rings.length; i < iMax; i++) {\n        var ring = rings[i];\n        if (ring.poly) continue;\n        if (ring.isExteriorRing()) polys.push(new PolyOut(ring));else {\n          var enclosingRing = ring.enclosingRing();\n          if (!enclosingRing.poly) polys.push(new PolyOut(enclosingRing));\n          enclosingRing.poly.addInterior(ring);\n        }\n      }\n\n      return polys;\n    }\n  }]);\n\n  return MultiPolyOut;\n}();\n\n/**\n * NOTE:  We must be careful not to change any segments while\n *        they are in the SplayTree. AFAIK, there's no way to tell\n *        the tree to rebalance itself - thus before splitting\n *        a segment that's in the tree, we remove it from the tree,\n *        do the split, then re-insert it. (Even though splitting a\n *        segment *shouldn't* change its correct position in the\n *        sweep line tree, the reality is because of rounding errors,\n *        it sometimes does.)\n */\n\nvar SweepLine = /*#__PURE__*/function () {\n  function SweepLine(queue) {\n    var comparator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Segment.compare;\n\n    _classCallCheck(this, SweepLine);\n\n    this.queue = queue;\n    this.tree = new SplayTree__default['default'](comparator);\n    this.segments = [];\n  }\n\n  _createClass(SweepLine, [{\n    key: \"process\",\n    value: function process(event) {\n      var segment = event.segment;\n      var newEvents = []; // if we've already been consumed by another segment,\n      // clean up our body parts and get out\n\n      if (event.consumedBy) {\n        if (event.isLeft) this.queue.remove(event.otherSE);else this.tree.remove(segment);\n        return newEvents;\n      }\n\n      var node = event.isLeft ? this.tree.insert(segment) : this.tree.find(segment);\n      if (!node) throw new Error(\"Unable to find segment #\".concat(segment.id, \" \") + \"[\".concat(segment.leftSE.point.x, \", \").concat(segment.leftSE.point.y, \"] -> \") + \"[\".concat(segment.rightSE.point.x, \", \").concat(segment.rightSE.point.y, \"] \") + 'in SweepLine tree. Please submit a bug report.');\n      var prevNode = node;\n      var nextNode = node;\n      var prevSeg = undefined;\n      var nextSeg = undefined; // skip consumed segments still in tree\n\n      while (prevSeg === undefined) {\n        prevNode = this.tree.prev(prevNode);\n        if (prevNode === null) prevSeg = null;else if (prevNode.key.consumedBy === undefined) prevSeg = prevNode.key;\n      } // skip consumed segments still in tree\n\n\n      while (nextSeg === undefined) {\n        nextNode = this.tree.next(nextNode);\n        if (nextNode === null) nextSeg = null;else if (nextNode.key.consumedBy === undefined) nextSeg = nextNode.key;\n      }\n\n      if (event.isLeft) {\n        // Check for intersections against the previous segment in the sweep line\n        var prevMySplitter = null;\n\n        if (prevSeg) {\n          var prevInter = prevSeg.getIntersection(segment);\n\n          if (prevInter !== null) {\n            if (!segment.isAnEndpoint(prevInter)) prevMySplitter = prevInter;\n\n            if (!prevSeg.isAnEndpoint(prevInter)) {\n              var newEventsFromSplit = this._splitSafely(prevSeg, prevInter);\n\n              for (var i = 0, iMax = newEventsFromSplit.length; i < iMax; i++) {\n                newEvents.push(newEventsFromSplit[i]);\n              }\n            }\n          }\n        } // Check for intersections against the next segment in the sweep line\n\n\n        var nextMySplitter = null;\n\n        if (nextSeg) {\n          var nextInter = nextSeg.getIntersection(segment);\n\n          if (nextInter !== null) {\n            if (!segment.isAnEndpoint(nextInter)) nextMySplitter = nextInter;\n\n            if (!nextSeg.isAnEndpoint(nextInter)) {\n              var _newEventsFromSplit = this._splitSafely(nextSeg, nextInter);\n\n              for (var _i = 0, _iMax = _newEventsFromSplit.length; _i < _iMax; _i++) {\n                newEvents.push(_newEventsFromSplit[_i]);\n              }\n            }\n          }\n        } // For simplicity, even if we find more than one intersection we only\n        // spilt on the 'earliest' (sweep-line style) of the intersections.\n        // The other intersection will be handled in a future process().\n\n\n        if (prevMySplitter !== null || nextMySplitter !== null) {\n          var mySplitter = null;\n          if (prevMySplitter === null) mySplitter = nextMySplitter;else if (nextMySplitter === null) mySplitter = prevMySplitter;else {\n            var cmpSplitters = SweepEvent.comparePoints(prevMySplitter, nextMySplitter);\n            mySplitter = cmpSplitters <= 0 ? prevMySplitter : nextMySplitter;\n          } // Rounding errors can cause changes in ordering,\n          // so remove afected segments and right sweep events before splitting\n\n          this.queue.remove(segment.rightSE);\n          newEvents.push(segment.rightSE);\n\n          var _newEventsFromSplit2 = segment.split(mySplitter);\n\n          for (var _i2 = 0, _iMax2 = _newEventsFromSplit2.length; _i2 < _iMax2; _i2++) {\n            newEvents.push(_newEventsFromSplit2[_i2]);\n          }\n        }\n\n        if (newEvents.length > 0) {\n          // We found some intersections, so re-do the current event to\n          // make sure sweep line ordering is totally consistent for later\n          // use with the segment 'prev' pointers\n          this.tree.remove(segment);\n          newEvents.push(event);\n        } else {\n          // done with left event\n          this.segments.push(segment);\n          segment.prev = prevSeg;\n        }\n      } else {\n        // event.isRight\n        // since we're about to be removed from the sweep line, check for\n        // intersections between our previous and next segments\n        if (prevSeg && nextSeg) {\n          var inter = prevSeg.getIntersection(nextSeg);\n\n          if (inter !== null) {\n            if (!prevSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit3 = this._splitSafely(prevSeg, inter);\n\n              for (var _i3 = 0, _iMax3 = _newEventsFromSplit3.length; _i3 < _iMax3; _i3++) {\n                newEvents.push(_newEventsFromSplit3[_i3]);\n              }\n            }\n\n            if (!nextSeg.isAnEndpoint(inter)) {\n              var _newEventsFromSplit4 = this._splitSafely(nextSeg, inter);\n\n              for (var _i4 = 0, _iMax4 = _newEventsFromSplit4.length; _i4 < _iMax4; _i4++) {\n                newEvents.push(_newEventsFromSplit4[_i4]);\n              }\n            }\n          }\n        }\n\n        this.tree.remove(segment);\n      }\n\n      return newEvents;\n    }\n    /* Safely split a segment that is currently in the datastructures\n     * IE - a segment other than the one that is currently being processed. */\n\n  }, {\n    key: \"_splitSafely\",\n    value: function _splitSafely(seg, pt) {\n      // Rounding errors can cause changes in ordering,\n      // so remove afected segments and right sweep events before splitting\n      // removeNode() doesn't work, so have re-find the seg\n      // https://github.com/w8r/splay-tree/pull/5\n      this.tree.remove(seg);\n      var rightSE = seg.rightSE;\n      this.queue.remove(rightSE);\n      var newEvents = seg.split(pt);\n      newEvents.push(rightSE); // splitting can trigger consumption\n\n      if (seg.consumedBy === undefined) this.tree.insert(seg);\n      return newEvents;\n    }\n  }]);\n\n  return SweepLine;\n}();\n\nvar POLYGON_CLIPPING_MAX_QUEUE_SIZE = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_QUEUE_SIZE || 1000000;\nvar POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS = typeof process !== 'undefined' && process.env.POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS || 1000000;\nvar Operation = /*#__PURE__*/function () {\n  function Operation() {\n    _classCallCheck(this, Operation);\n  }\n\n  _createClass(Operation, [{\n    key: \"run\",\n    value: function run(type, geom, moreGeoms) {\n      operation.type = type;\n      rounder.reset();\n      /* Convert inputs to MultiPoly objects */\n\n      var multipolys = [new MultiPolyIn(geom, true)];\n\n      for (var i = 0, iMax = moreGeoms.length; i < iMax; i++) {\n        multipolys.push(new MultiPolyIn(moreGeoms[i], false));\n      }\n\n      operation.numMultiPolys = multipolys.length;\n      /* BBox optimization for difference operation\n       * If the bbox of a multipolygon that's part of the clipping doesn't\n       * intersect the bbox of the subject at all, we can just drop that\n       * multiploygon. */\n\n      if (operation.type === 'difference') {\n        // in place removal\n        var subject = multipolys[0];\n        var _i = 1;\n\n        while (_i < multipolys.length) {\n          if (getBboxOverlap(multipolys[_i].bbox, subject.bbox) !== null) _i++;else multipolys.splice(_i, 1);\n        }\n      }\n      /* BBox optimization for intersection operation\n       * If we can find any pair of multipolygons whose bbox does not overlap,\n       * then the result will be empty. */\n\n\n      if (operation.type === 'intersection') {\n        // TODO: this is O(n^2) in number of polygons. By sorting the bboxes,\n        //       it could be optimized to O(n * ln(n))\n        for (var _i2 = 0, _iMax = multipolys.length; _i2 < _iMax; _i2++) {\n          var mpA = multipolys[_i2];\n\n          for (var j = _i2 + 1, jMax = multipolys.length; j < jMax; j++) {\n            if (getBboxOverlap(mpA.bbox, multipolys[j].bbox) === null) return [];\n          }\n        }\n      }\n      /* Put segment endpoints in a priority queue */\n\n\n      var queue = new SplayTree__default['default'](SweepEvent.compare);\n\n      for (var _i3 = 0, _iMax2 = multipolys.length; _i3 < _iMax2; _i3++) {\n        var sweepEvents = multipolys[_i3].getSweepEvents();\n\n        for (var _j = 0, _jMax = sweepEvents.length; _j < _jMax; _j++) {\n          queue.insert(sweepEvents[_j]);\n\n          if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n            // prevents an infinite loop, an otherwise common manifestation of bugs\n            throw new Error('Infinite loop when putting segment endpoints in a priority queue ' + '(queue size too big). Please file a bug report.');\n          }\n        }\n      }\n      /* Pass the sweep line over those endpoints */\n\n\n      var sweepLine = new SweepLine(queue);\n      var prevQueueSize = queue.size;\n      var node = queue.pop();\n\n      while (node) {\n        var evt = node.key;\n\n        if (queue.size === prevQueueSize) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          var seg = evt.segment;\n          throw new Error(\"Unable to pop() \".concat(evt.isLeft ? 'left' : 'right', \" SweepEvent \") + \"[\".concat(evt.point.x, \", \").concat(evt.point.y, \"] from segment #\").concat(seg.id, \" \") + \"[\".concat(seg.leftSE.point.x, \", \").concat(seg.leftSE.point.y, \"] -> \") + \"[\".concat(seg.rightSE.point.x, \", \").concat(seg.rightSE.point.y, \"] from queue. \") + 'Please file a bug report.');\n        }\n\n        if (queue.size > POLYGON_CLIPPING_MAX_QUEUE_SIZE) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(queue size too big). Please file a bug report.');\n        }\n\n        if (sweepLine.segments.length > POLYGON_CLIPPING_MAX_SWEEPLINE_SEGMENTS) {\n          // prevents an infinite loop, an otherwise common manifestation of bugs\n          throw new Error('Infinite loop when passing sweep line over endpoints ' + '(too many sweep line segments). Please file a bug report.');\n        }\n\n        var newEvents = sweepLine.process(evt);\n\n        for (var _i4 = 0, _iMax3 = newEvents.length; _i4 < _iMax3; _i4++) {\n          var _evt = newEvents[_i4];\n          if (_evt.consumedBy === undefined) queue.insert(_evt);\n        }\n\n        prevQueueSize = queue.size;\n        node = queue.pop();\n      } // free some memory we don't need anymore\n\n\n      rounder.reset();\n      /* Collect and compile segments we're keeping into a multipolygon */\n\n      var ringsOut = RingOut.factory(sweepLine.segments);\n      var result = new MultiPolyOut(ringsOut);\n      return result.getGeom();\n    }\n  }]);\n\n  return Operation;\n}(); // singleton available by import\n\nvar operation = new Operation();\n\nvar union = function union(geom) {\n  for (var _len = arguments.length, moreGeoms = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    moreGeoms[_key - 1] = arguments[_key];\n  }\n\n  return operation.run('union', geom, moreGeoms);\n};\n\nvar intersection$1 = function intersection(geom) {\n  for (var _len2 = arguments.length, moreGeoms = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    moreGeoms[_key2 - 1] = arguments[_key2];\n  }\n\n  return operation.run('intersection', geom, moreGeoms);\n};\n\nvar xor = function xor(geom) {\n  for (var _len3 = arguments.length, moreGeoms = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    moreGeoms[_key3 - 1] = arguments[_key3];\n  }\n\n  return operation.run('xor', geom, moreGeoms);\n};\n\nvar difference = function difference(subjectGeom) {\n  for (var _len4 = arguments.length, clippingGeoms = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    clippingGeoms[_key4 - 1] = arguments[_key4];\n  }\n\n  return operation.run('difference', subjectGeom, clippingGeoms);\n};\n\nvar index = {\n  union: union,\n  intersection: intersection$1,\n  xor: xor,\n  difference: difference\n};\n\nmodule.exports = index;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcG9seWdvbi1jbGlwcGluZ0AwLjE1LjMvbm9kZV9tb2R1bGVzL3BvbHlnb24tY2xpcHBpbmcvZGlzdC9wb2x5Z29uLWNsaXBwaW5nLmNqcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixnQkFBZ0IsbUJBQU8sQ0FBQyxrR0FBVzs7QUFFbkMscUNBQXFDLDREQUE0RDs7QUFFakc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLE1BQU0sa0JBQWtCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUdBQXFHOztBQUVyRztBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQSxzREFBc0Q7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQSxxREFBcUQ7O0FBRXJEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUMsSUFBSTs7O0FBR0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7O0FBRXJDLDBDQUEwQzs7QUFFMUMsMkRBQTJEO0FBQzNEOztBQUVBO0FBQ0EsTUFBTTs7QUFFTixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOLEdBQUc7O0FBRUg7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtB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YztBQUNsRTs7QUFFQSxxREFBcUQsWUFBWTtBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxxREFBcUQsY0FBYztBQUNuRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQyxJQUFJOztBQUVMOztBQUVBO0FBQ0EsOEZBQThGLGFBQWE7QUFDM0c7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0dBQWtHLGVBQWU7QUFDakg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0dBQWtHLGVBQWU7QUFDakg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0dBQXNHLGVBQWU7QUFDckg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vcG9seWdvbi1jbGlwcGluZ0AwLjE1LjMvbm9kZV9tb2R1bGVzL3BvbHlnb24tY2xpcHBpbmcvZGlzdC9wb2x5Z29uLWNsaXBwaW5nLmNqcy5qcz9jNGJiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFNwbGF5VHJlZSA9IHJlcXVpcmUoJ3NwbGF5dHJlZScpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcERlZmF1bHRMZWdhY3kgKGUpIHsgcmV0dXJuIGUgJiYgdHlwZW9mIGUgPT09ICdvYmplY3QnICYmICdkZWZhdWx0JyBpbiBlID8gZSA6IHsgJ2RlZmF1bHQnOiBlIH07IH1cblxudmFyIFNwbGF5VHJlZV9fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9faW50ZXJvcERlZmF1bHRMZWdhY3koU3BsYXlUcmVlKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG4vKipcbiAqIEEgYm91bmRpbmcgYm94IGhhcyB0aGUgZm9ybWF0OlxuICpcbiAqICB7IGxsOiB7IHg6IHhtaW4sIHk6IHltaW4gfSwgdXI6IHsgeDogeG1heCwgeTogeW1heCB9IH1cbiAqXG4gKi9cbnZhciBpc0luQmJveCA9IGZ1bmN0aW9uIGlzSW5CYm94KGJib3gsIHBvaW50KSB7XG4gIHJldHVybiBiYm94LmxsLnggPD0gcG9pbnQueCAmJiBwb2ludC54IDw9IGJib3gudXIueCAmJiBiYm94LmxsLnkgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IGJib3gudXIueTtcbn07XG4vKiBSZXR1cm5zIGVpdGhlciBudWxsLCBvciBhIGJib3ggKGFrYSBhbiBvcmRlcmVkIHBhaXIgb2YgcG9pbnRzKVxuICogSWYgdGhlcmUgaXMgb25seSBvbmUgcG9pbnQgb2Ygb3ZlcmxhcCwgYSBiYm94IHdpdGggaWRlbnRpY2FsIHBvaW50c1xuICogd2lsbCBiZSByZXR1cm5lZCAqL1xuXG52YXIgZ2V0QmJveE92ZXJsYXAgPSBmdW5jdGlvbiBnZXRCYm94T3ZlcmxhcChiMSwgYjIpIHtcbiAgLy8gY2hlY2sgaWYgdGhlIGJib3hlcyBvdmVybGFwIGF0IGFsbFxuICBpZiAoYjIudXIueCA8IGIxLmxsLnggfHwgYjEudXIueCA8IGIyLmxsLnggfHwgYjIudXIueSA8IGIxLmxsLnkgfHwgYjEudXIueSA8IGIyLmxsLnkpIHJldHVybiBudWxsOyAvLyBmaW5kIHRoZSBtaWRkbGUgdHdvIFggdmFsdWVzXG5cbiAgdmFyIGxvd2VyWCA9IGIxLmxsLnggPCBiMi5sbC54ID8gYjIubGwueCA6IGIxLmxsLng7XG4gIHZhciB1cHBlclggPSBiMS51ci54IDwgYjIudXIueCA/IGIxLnVyLnggOiBiMi51ci54OyAvLyBmaW5kIHRoZSBtaWRkbGUgdHdvIFkgdmFsdWVzXG5cbiAgdmFyIGxvd2VyWSA9IGIxLmxsLnkgPCBiMi5sbC55ID8gYjIubGwueSA6IGIxLmxsLnk7XG4gIHZhciB1cHBlclkgPSBiMS51ci55IDwgYjIudXIueSA/IGIxLnVyLnkgOiBiMi51ci55OyAvLyBwdXQgdGhvc2UgbWlkZGxlIHZhbHVlcyB0b2dldGhlciB0byBnZXQgdGhlIG92ZXJsYXBcblxuICByZXR1cm4ge1xuICAgIGxsOiB7XG4gICAgICB4OiBsb3dlclgsXG4gICAgICB5OiBsb3dlcllcbiAgICB9LFxuICAgIHVyOiB7XG4gICAgICB4OiB1cHBlclgsXG4gICAgICB5OiB1cHBlcllcbiAgICB9XG4gIH07XG59O1xuXG4vKiBKYXZhc2NyaXB0IGRvZXNuJ3QgZG8gaW50ZWdlciBtYXRoLiBFdmVyeXRoaW5nIGlzXG4gKiBmbG9hdGluZyBwb2ludCB3aXRoIHBlcmNpc2lvbiBOdW1iZXIuRVBTSUxPTi5cbiAqXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9OdW1iZXIvRVBTSUxPTlxuICovXG52YXIgZXBzaWxvbiA9IE51bWJlci5FUFNJTE9OOyAvLyBJRSBQb2x5ZmlsbFxuXG5pZiAoZXBzaWxvbiA9PT0gdW5kZWZpbmVkKSBlcHNpbG9uID0gTWF0aC5wb3coMiwgLTUyKTtcbnZhciBFUFNJTE9OX1NRID0gZXBzaWxvbiAqIGVwc2lsb247XG4vKiBGTFAgY29tcGFyYXRvciAqL1xuXG52YXIgY21wID0gZnVuY3Rpb24gY21wKGEsIGIpIHtcbiAgLy8gY2hlY2sgaWYgdGhleSdyZSBib3RoIDBcbiAgaWYgKC1lcHNpbG9uIDwgYSAmJiBhIDwgZXBzaWxvbikge1xuICAgIGlmICgtZXBzaWxvbiA8IGIgJiYgYiA8IGVwc2lsb24pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSAvLyBjaGVjayBpZiB0aGV5J3JlIGZscCBlcXVhbFxuXG5cbiAgdmFyIGFiID0gYSAtIGI7XG5cbiAgaWYgKGFiICogYWIgPCBFUFNJTE9OX1NRICogYSAqIGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSAvLyBub3JtYWwgY29tcGFyaXNvblxuXG5cbiAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xufTtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJvdW5kcyBpbmNvbWluZyB2YWx1ZXMgc3VmZmljaWVudGx5IHNvIHRoYXRcbiAqIGZsb2F0aW5nIHBvaW50cyBwcm9ibGVtcyBhcmUsIGZvciB0aGUgbW9zdCBwYXJ0LCBhdm9pZGVkLlxuICpcbiAqIEluY29taW5nIHBvaW50cyBhcmUgaGF2ZSB0aGVpciB4ICYgeSB2YWx1ZXMgdGVzdGVkIGFnYWluc3RcbiAqIGFsbCBwcmV2aW91c2x5IHNlZW4geCAmIHkgdmFsdWVzLiBJZiBlaXRoZXIgaXMgJ3RvbyBjbG9zZSdcbiAqIHRvIGEgcHJldmlvdXNseSBzZWVuIHZhbHVlLCBpdCdzIHZhbHVlIGlzICdzbmFwcGVkJyB0byB0aGVcbiAqIHByZXZpb3VzbHkgc2VlbiB2YWx1ZS5cbiAqXG4gKiBBbGwgcG9pbnRzIHNob3VsZCBiZSByb3VuZGVkIGJ5IHRoaXMgY2xhc3MgYmVmb3JlIGJlaW5nXG4gKiBzdG9yZWQgaW4gYW55IGRhdGEgc3RydWN0dXJlcyBpbiB0aGUgcmVzdCBvZiB0aGlzIGFsZ29yaXRobS5cbiAqL1xuXG52YXIgUHRSb3VuZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHRSb3VuZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdFJvdW5kZXIpO1xuXG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFB0Um91bmRlciwgW3tcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB0aGlzLnhSb3VuZGVyID0gbmV3IENvb3JkUm91bmRlcigpO1xuICAgICAgdGhpcy55Um91bmRlciA9IG5ldyBDb29yZFJvdW5kZXIoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmQoeCwgeSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy54Um91bmRlci5yb3VuZCh4KSxcbiAgICAgICAgeTogdGhpcy55Um91bmRlci5yb3VuZCh5KVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUHRSb3VuZGVyO1xufSgpO1xuXG52YXIgQ29vcmRSb3VuZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ29vcmRSb3VuZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb29yZFJvdW5kZXIpO1xuXG4gICAgdGhpcy50cmVlID0gbmV3IFNwbGF5VHJlZV9fZGVmYXVsdFsnZGVmYXVsdCddKCk7IC8vIHByZXNlZWQgd2l0aCAwIHNvIHdlIGRvbid0IGVuZCB1cCB3aXRoIHZhbHVlcyA8IE51bWJlci5FUFNJTE9OXG5cbiAgICB0aGlzLnJvdW5kKDApO1xuICB9IC8vIE5vdGU6IHRoaXMgY2FuIHJvdW5kcyBpbnB1dCB2YWx1ZXMgYmFja3dhcmRzIG9yIGZvcndhcmRzLlxuICAvLyAgICAgICBZb3UgbWlnaHQgYXNrLCB3aHkgbm90IHJlc3RyaWN0IHRoaXMgdG8ganVzdCByb3VuZGluZ1xuICAvLyAgICAgICBmb3J3YXJkcz8gV291bGRuJ3QgdGhhdCBhbGxvdyBsZWZ0IGVuZHBvaW50cyB0byBhbHdheXNcbiAgLy8gICAgICAgcmVtYWluIGxlZnQgZW5kcG9pbnRzIGR1cmluZyBzcGxpdHRpbmcgKG5ldmVyIGNoYW5nZSB0b1xuICAvLyAgICAgICByaWdodCkuIE5vIC0gaXQgd291bGRuJ3QsIGJlY2F1c2Ugd2Ugc25hcCBpbnRlcnNlY3Rpb25zXG4gIC8vICAgICAgIHRvIGVuZHBvaW50cyAodG8gZXN0YWJsaXNoIGluZGVwZW5kZW5jZSBmcm9tIHRoZSBzZWdtZW50XG4gIC8vICAgICAgIGFuZ2xlIGZvciB0LWludGVyc2VjdGlvbnMpLlxuXG5cbiAgX2NyZWF0ZUNsYXNzKENvb3JkUm91bmRlciwgW3tcbiAgICBrZXk6IFwicm91bmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcm91bmQoY29vcmQpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy50cmVlLmFkZChjb29yZCk7XG4gICAgICB2YXIgcHJldk5vZGUgPSB0aGlzLnRyZWUucHJldihub2RlKTtcblxuICAgICAgaWYgKHByZXZOb2RlICE9PSBudWxsICYmIGNtcChub2RlLmtleSwgcHJldk5vZGUua2V5KSA9PT0gMCkge1xuICAgICAgICB0aGlzLnRyZWUucmVtb3ZlKGNvb3JkKTtcbiAgICAgICAgcmV0dXJuIHByZXZOb2RlLmtleTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHROb2RlID0gdGhpcy50cmVlLm5leHQobm9kZSk7XG5cbiAgICAgIGlmIChuZXh0Tm9kZSAhPT0gbnVsbCAmJiBjbXAobm9kZS5rZXksIG5leHROb2RlLmtleSkgPT09IDApIHtcbiAgICAgICAgdGhpcy50cmVlLnJlbW92ZShjb29yZCk7XG4gICAgICAgIHJldHVybiBuZXh0Tm9kZS5rZXk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb29yZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ29vcmRSb3VuZGVyO1xufSgpOyAvLyBzaW5nbGV0b24gYXZhaWxhYmxlIGJ5IGltcG9ydFxuXG5cbnZhciByb3VuZGVyID0gbmV3IFB0Um91bmRlcigpO1xuXG4vKiBDcm9zcyBQcm9kdWN0IG9mIHR3byB2ZWN0b3JzIHdpdGggZmlyc3QgcG9pbnQgYXQgb3JpZ2luICovXG5cbnZhciBjcm9zc1Byb2R1Y3QgPSBmdW5jdGlvbiBjcm9zc1Byb2R1Y3QoYSwgYikge1xuICByZXR1cm4gYS54ICogYi55IC0gYS55ICogYi54O1xufTtcbi8qIERvdCBQcm9kdWN0IG9mIHR3byB2ZWN0b3JzIHdpdGggZmlyc3QgcG9pbnQgYXQgb3JpZ2luICovXG5cbnZhciBkb3RQcm9kdWN0ID0gZnVuY3Rpb24gZG90UHJvZHVjdChhLCBiKSB7XG4gIHJldHVybiBhLnggKiBiLnggKyBhLnkgKiBiLnk7XG59O1xuLyogQ29tcGFyYXRvciBmb3IgdHdvIHZlY3RvcnMgd2l0aCBzYW1lIHN0YXJ0aW5nIHBvaW50ICovXG5cbnZhciBjb21wYXJlVmVjdG9yQW5nbGVzID0gZnVuY3Rpb24gY29tcGFyZVZlY3RvckFuZ2xlcyhiYXNlUHQsIGVuZFB0MSwgZW5kUHQyKSB7XG4gIHZhciB2MSA9IHtcbiAgICB4OiBlbmRQdDEueCAtIGJhc2VQdC54LFxuICAgIHk6IGVuZFB0MS55IC0gYmFzZVB0LnlcbiAgfTtcbiAgdmFyIHYyID0ge1xuICAgIHg6IGVuZFB0Mi54IC0gYmFzZVB0LngsXG4gICAgeTogZW5kUHQyLnkgLSBiYXNlUHQueVxuICB9O1xuICB2YXIga3Jvc3MgPSBjcm9zc1Byb2R1Y3QodjEsIHYyKTtcbiAgcmV0dXJuIGNtcChrcm9zcywgMCk7XG59O1xudmFyIGxlbmd0aCA9IGZ1bmN0aW9uIGxlbmd0aCh2KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZG90UHJvZHVjdCh2LCB2KSk7XG59O1xuLyogR2V0IHRoZSBzaW5lIG9mIHRoZSBhbmdsZSBmcm9tIHBTaGFyZWQgLT4gcEFuZ2xlIHRvIHBTaGFlZCAtPiBwQmFzZSAqL1xuXG52YXIgc2luZU9mQW5nbGUgPSBmdW5jdGlvbiBzaW5lT2ZBbmdsZShwU2hhcmVkLCBwQmFzZSwgcEFuZ2xlKSB7XG4gIHZhciB2QmFzZSA9IHtcbiAgICB4OiBwQmFzZS54IC0gcFNoYXJlZC54LFxuICAgIHk6IHBCYXNlLnkgLSBwU2hhcmVkLnlcbiAgfTtcbiAgdmFyIHZBbmdsZSA9IHtcbiAgICB4OiBwQW5nbGUueCAtIHBTaGFyZWQueCxcbiAgICB5OiBwQW5nbGUueSAtIHBTaGFyZWQueVxuICB9O1xuICByZXR1cm4gY3Jvc3NQcm9kdWN0KHZBbmdsZSwgdkJhc2UpIC8gbGVuZ3RoKHZBbmdsZSkgLyBsZW5ndGgodkJhc2UpO1xufTtcbi8qIEdldCB0aGUgY29zaW5lIG9mIHRoZSBhbmdsZSBmcm9tIHBTaGFyZWQgLT4gcEFuZ2xlIHRvIHBTaGFlZCAtPiBwQmFzZSAqL1xuXG52YXIgY29zaW5lT2ZBbmdsZSA9IGZ1bmN0aW9uIGNvc2luZU9mQW5nbGUocFNoYXJlZCwgcEJhc2UsIHBBbmdsZSkge1xuICB2YXIgdkJhc2UgPSB7XG4gICAgeDogcEJhc2UueCAtIHBTaGFyZWQueCxcbiAgICB5OiBwQmFzZS55IC0gcFNoYXJlZC55XG4gIH07XG4gIHZhciB2QW5nbGUgPSB7XG4gICAgeDogcEFuZ2xlLnggLSBwU2hhcmVkLngsXG4gICAgeTogcEFuZ2xlLnkgLSBwU2hhcmVkLnlcbiAgfTtcbiAgcmV0dXJuIGRvdFByb2R1Y3QodkFuZ2xlLCB2QmFzZSkgLyBsZW5ndGgodkFuZ2xlKSAvIGxlbmd0aCh2QmFzZSk7XG59O1xuLyogR2V0IHRoZSB4IGNvb3JkaW5hdGUgd2hlcmUgdGhlIGdpdmVuIGxpbmUgKGRlZmluZWQgYnkgYSBwb2ludCBhbmQgdmVjdG9yKVxuICogY3Jvc3NlcyB0aGUgaG9yaXpvbnRhbCBsaW5lIHdpdGggdGhlIGdpdmVuIHkgY29vcmRpYW50ZS5cbiAqIEluIHRoZSBjYXNlIG9mIHBhcnJhbGxlbCBsaW5lcyAoaW5jbHVkaW5nIG92ZXJsYXBwaW5nIG9uZXMpIHJldHVybnMgbnVsbC4gKi9cblxudmFyIGhvcml6b250YWxJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBob3Jpem9udGFsSW50ZXJzZWN0aW9uKHB0LCB2LCB5KSB7XG4gIGlmICh2LnkgPT09IDApIHJldHVybiBudWxsO1xuICByZXR1cm4ge1xuICAgIHg6IHB0LnggKyB2LnggLyB2LnkgKiAoeSAtIHB0LnkpLFxuICAgIHk6IHlcbiAgfTtcbn07XG4vKiBHZXQgdGhlIHkgY29vcmRpbmF0ZSB3aGVyZSB0aGUgZ2l2ZW4gbGluZSAoZGVmaW5lZCBieSBhIHBvaW50IGFuZCB2ZWN0b3IpXG4gKiBjcm9zc2VzIHRoZSB2ZXJ0aWNhbCBsaW5lIHdpdGggdGhlIGdpdmVuIHggY29vcmRpYW50ZS5cbiAqIEluIHRoZSBjYXNlIG9mIHBhcnJhbGxlbCBsaW5lcyAoaW5jbHVkaW5nIG92ZXJsYXBwaW5nIG9uZXMpIHJldHVybnMgbnVsbC4gKi9cblxudmFyIHZlcnRpY2FsSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gdmVydGljYWxJbnRlcnNlY3Rpb24ocHQsIHYsIHgpIHtcbiAgaWYgKHYueCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIHJldHVybiB7XG4gICAgeDogeCxcbiAgICB5OiBwdC55ICsgdi55IC8gdi54ICogKHggLSBwdC54KVxuICB9O1xufTtcbi8qIEdldCB0aGUgaW50ZXJzZWN0aW9uIG9mIHR3byBsaW5lcywgZWFjaCBkZWZpbmVkIGJ5IGEgYmFzZSBwb2ludCBhbmQgYSB2ZWN0b3IuXG4gKiBJbiB0aGUgY2FzZSBvZiBwYXJyYWxsZWwgbGluZXMgKGluY2x1ZGluZyBvdmVybGFwcGluZyBvbmVzKSByZXR1cm5zIG51bGwuICovXG5cbnZhciBpbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ocHQxLCB2MSwgcHQyLCB2Mikge1xuICAvLyB0YWtlIHNvbWUgc2hvcnRjdXRzIGZvciB2ZXJ0aWNhbCBhbmQgaG9yaXpvbnRhbCBsaW5lc1xuICAvLyB0aGlzIGFsc28gZW5zdXJlcyB3ZSBkb24ndCBjYWxjdWxhdGUgYW4gaW50ZXJzZWN0aW9uIGFuZCB0aGVuIGRpc2NvdmVyXG4gIC8vIGl0J3MgYWN0dWFsbHkgb3V0c2lkZSB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBsaW5lXG4gIGlmICh2MS54ID09PSAwKSByZXR1cm4gdmVydGljYWxJbnRlcnNlY3Rpb24ocHQyLCB2MiwgcHQxLngpO1xuICBpZiAodjIueCA9PT0gMCkgcmV0dXJuIHZlcnRpY2FsSW50ZXJzZWN0aW9uKHB0MSwgdjEsIHB0Mi54KTtcbiAgaWYgKHYxLnkgPT09IDApIHJldHVybiBob3Jpem9udGFsSW50ZXJzZWN0aW9uKHB0MiwgdjIsIHB0MS55KTtcbiAgaWYgKHYyLnkgPT09IDApIHJldHVybiBob3Jpem9udGFsSW50ZXJzZWN0aW9uKHB0MSwgdjEsIHB0Mi55KTsgLy8gR2VuZXJhbCBjYXNlIGZvciBub24tb3ZlcmxhcHBpbmcgc2VnbWVudHMuXG4gIC8vIFRoaXMgYWxnb3JpdGhtIGlzIGJhc2VkIG9uIFNjaG5laWRlciBhbmQgRWJlcmx5LlxuICAvLyBodHRwOi8vd3d3LmNpbWVjLm9yZy5hci9+bmNhbHZvL1NjaG5laWRlcl9FYmVybHkucGRmIC0gcGcgMjQ0XG5cbiAgdmFyIGtyb3NzID0gY3Jvc3NQcm9kdWN0KHYxLCB2Mik7XG4gIGlmIChrcm9zcyA9PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHZlID0ge1xuICAgIHg6IHB0Mi54IC0gcHQxLngsXG4gICAgeTogcHQyLnkgLSBwdDEueVxuICB9O1xuICB2YXIgZDEgPSBjcm9zc1Byb2R1Y3QodmUsIHYxKSAvIGtyb3NzO1xuICB2YXIgZDIgPSBjcm9zc1Byb2R1Y3QodmUsIHYyKSAvIGtyb3NzOyAvLyB0YWtlIHRoZSBhdmVyYWdlIG9mIHRoZSB0d28gY2FsY3VsYXRpb25zIHRvIG1pbmltaXplIHJvdW5kaW5nIGVycm9yXG5cbiAgdmFyIHgxID0gcHQxLnggKyBkMiAqIHYxLngsXG4gICAgICB4MiA9IHB0Mi54ICsgZDEgKiB2Mi54O1xuICB2YXIgeTEgPSBwdDEueSArIGQyICogdjEueSxcbiAgICAgIHkyID0gcHQyLnkgKyBkMSAqIHYyLnk7XG4gIHZhciB4ID0gKHgxICsgeDIpIC8gMjtcbiAgdmFyIHkgPSAoeTEgKyB5MikgLyAyO1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufTtcblxudmFyIFN3ZWVwRXZlbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBfY3JlYXRlQ2xhc3MoU3dlZXBFdmVudCwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIC8vIGZvciBvcmRlcmluZyBzd2VlcCBldmVudHMgaW4gdGhlIHN3ZWVwIGV2ZW50IHF1ZXVlXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgLy8gZmF2b3IgZXZlbnQgd2l0aCBhIHBvaW50IHRoYXQgdGhlIHN3ZWVwIGxpbmUgaGl0cyBmaXJzdFxuICAgICAgdmFyIHB0Q21wID0gU3dlZXBFdmVudC5jb21wYXJlUG9pbnRzKGEucG9pbnQsIGIucG9pbnQpO1xuICAgICAgaWYgKHB0Q21wICE9PSAwKSByZXR1cm4gcHRDbXA7IC8vIHRoZSBwb2ludHMgYXJlIHRoZSBzYW1lLCBzbyBsaW5rIHRoZW0gaWYgbmVlZGVkXG5cbiAgICAgIGlmIChhLnBvaW50ICE9PSBiLnBvaW50KSBhLmxpbmsoYik7IC8vIGZhdm9yIHJpZ2h0IGV2ZW50cyBvdmVyIGxlZnRcblxuICAgICAgaWYgKGEuaXNMZWZ0ICE9PSBiLmlzTGVmdCkgcmV0dXJuIGEuaXNMZWZ0ID8gMSA6IC0xOyAvLyB3ZSBoYXZlIHR3byBtYXRjaGluZyBsZWZ0IG9yIHJpZ2h0IGVuZHBvaW50c1xuICAgICAgLy8gb3JkZXJpbmcgb2YgdGhpcyBjYXNlIGlzIHRoZSBzYW1lIGFzIGZvciB0aGVpciBzZWdtZW50c1xuXG4gICAgICByZXR1cm4gU2VnbWVudC5jb21wYXJlKGEuc2VnbWVudCwgYi5zZWdtZW50KTtcbiAgICB9IC8vIGZvciBvcmRlcmluZyBwb2ludHMgaW4gc3dlZXAgbGluZSBvcmRlclxuXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGFyZVBvaW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlUG9pbnRzKGFQdCwgYlB0KSB7XG4gICAgICBpZiAoYVB0LnggPCBiUHQueCkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGFQdC54ID4gYlB0LngpIHJldHVybiAxO1xuICAgICAgaWYgKGFQdC55IDwgYlB0LnkpIHJldHVybiAtMTtcbiAgICAgIGlmIChhUHQueSA+IGJQdC55KSByZXR1cm4gMTtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gLy8gV2FybmluZzogJ3BvaW50JyBpbnB1dCB3aWxsIGJlIG1vZGlmaWVkIGFuZCByZS11c2VkIChmb3IgcGVyZm9ybWFuY2UpXG5cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFN3ZWVwRXZlbnQocG9pbnQsIGlzTGVmdCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTd2VlcEV2ZW50KTtcblxuICAgIGlmIChwb2ludC5ldmVudHMgPT09IHVuZGVmaW5lZCkgcG9pbnQuZXZlbnRzID0gW3RoaXNdO2Vsc2UgcG9pbnQuZXZlbnRzLnB1c2godGhpcyk7XG4gICAgdGhpcy5wb2ludCA9IHBvaW50O1xuICAgIHRoaXMuaXNMZWZ0ID0gaXNMZWZ0OyAvLyB0aGlzLnNlZ21lbnQsIHRoaXMub3RoZXJTRSBzZXQgYnkgZmFjdG9yeVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN3ZWVwRXZlbnQsIFt7XG4gICAga2V5OiBcImxpbmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbGluayhvdGhlcikge1xuICAgICAgaWYgKG90aGVyLnBvaW50ID09PSB0aGlzLnBvaW50KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVHJpZWQgdG8gbGluayBhbHJlYWR5IGxpbmtlZCBldmVudHMnKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG90aGVyRXZlbnRzID0gb3RoZXIucG9pbnQuZXZlbnRzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IG90aGVyRXZlbnRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICB2YXIgZXZ0ID0gb3RoZXJFdmVudHNbaV07XG4gICAgICAgIHRoaXMucG9pbnQuZXZlbnRzLnB1c2goZXZ0KTtcbiAgICAgICAgZXZ0LnBvaW50ID0gdGhpcy5wb2ludDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jaGVja0ZvckNvbnN1bWluZygpO1xuICAgIH1cbiAgICAvKiBEbyBhIHBhc3Mgb3ZlciBvdXIgbGlua2VkIGV2ZW50cyBhbmQgY2hlY2sgdG8gc2VlIGlmIGFueSBwYWlyXG4gICAgICogb2Ygc2VnbWVudHMgbWF0Y2gsIGFuZCBzaG91bGQgYmUgY29uc3VtZWQuICovXG5cbiAgfSwge1xuICAgIGtleTogXCJjaGVja0ZvckNvbnN1bWluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0ZvckNvbnN1bWluZygpIHtcbiAgICAgIC8vIEZJWE1FOiBUaGUgbG9vcHMgaW4gdGhpcyBtZXRob2QgcnVuIE8obl4yKSA9PiBubyBnb29kLlxuICAgICAgLy8gICAgICAgIE1haW50YWluIGxpdHRsZSBvcmRlcmVkIHN3ZWVwIGV2ZW50IHRyZWVzP1xuICAgICAgLy8gICAgICAgIENhbiB3ZSBtYWludGFpbmluZyBhbiBvcmRlcmluZyB0aGF0IGF2b2lkcyB0aGUgbmVlZFxuICAgICAgLy8gICAgICAgIGZvciB0aGUgcmUtc29ydGluZyB3aXRoIGdldExlZnRtb3N0Q29tcGFyYXRvciBpbiBnZW9tLW91dD9cbiAgICAgIC8vIENvbXBhcmUgZWFjaCBwYWlyIG9mIGV2ZW50cyB0byBzZWUgaWYgb3RoZXIgZXZlbnRzIGFsc28gbWF0Y2hcbiAgICAgIHZhciBudW1FdmVudHMgPSB0aGlzLnBvaW50LmV2ZW50cy5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtRXZlbnRzOyBpKyspIHtcbiAgICAgICAgdmFyIGV2dDEgPSB0aGlzLnBvaW50LmV2ZW50c1tpXTtcbiAgICAgICAgaWYgKGV2dDEuc2VnbWVudC5jb25zdW1lZEJ5ICE9PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuXG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IG51bUV2ZW50czsgaisrKSB7XG4gICAgICAgICAgdmFyIGV2dDIgPSB0aGlzLnBvaW50LmV2ZW50c1tqXTtcbiAgICAgICAgICBpZiAoZXZ0Mi5jb25zdW1lZEJ5ICE9PSB1bmRlZmluZWQpIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChldnQxLm90aGVyU0UucG9pbnQuZXZlbnRzICE9PSBldnQyLm90aGVyU0UucG9pbnQuZXZlbnRzKSBjb250aW51ZTtcbiAgICAgICAgICBldnQxLnNlZ21lbnQuY29uc3VtZShldnQyLnNlZ21lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF2YWlsYWJsZUxpbmtlZEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdmFpbGFibGVMaW5rZWRFdmVudHMoKSB7XG4gICAgICAvLyBwb2ludC5ldmVudHMgaXMgYWx3YXlzIG9mIGxlbmd0aCAyIG9yIGdyZWF0ZXJcbiAgICAgIHZhciBldmVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlNYXggPSB0aGlzLnBvaW50LmV2ZW50cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgdmFyIGV2dCA9IHRoaXMucG9pbnQuZXZlbnRzW2ldO1xuXG4gICAgICAgIGlmIChldnQgIT09IHRoaXMgJiYgIWV2dC5zZWdtZW50LnJpbmdPdXQgJiYgZXZ0LnNlZ21lbnQuaXNJblJlc3VsdCgpKSB7XG4gICAgICAgICAgZXZlbnRzLnB1c2goZXZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXZlbnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgY29tcGFyYXRvciBmdW5jdGlvbiBmb3Igc29ydGluZyBsaW5rZWQgZXZlbnRzIHRoYXQgd2lsbFxuICAgICAqIGZhdm9yIHRoZSBldmVudCB0aGF0IHdpbGwgZ2l2ZSB1cyB0aGUgc21hbGxlc3QgbGVmdC1zaWRlIGFuZ2xlLlxuICAgICAqIEFsbCByaW5nIGNvbnN0cnVjdGlvbiBzdGFydHMgYXMgbG93IGFzIHBvc3NpYmxlIGhlYWRpbmcgdG8gdGhlIHJpZ2h0LFxuICAgICAqIHNvIGJ5IGFsd2F5cyB0dXJuaW5nIGxlZnQgYXMgc2hhcnAgYXMgcG9zc2libGUgd2UnbGwgZ2V0IHBvbHlnb25zXG4gICAgICogd2l0aG91dCB1bmNlc3NhcnkgbG9vcHMgJiBob2xlcy5cbiAgICAgKlxuICAgICAqIFRoZSBjb21wYXJhdG9yIGZ1bmN0aW9uIGhhcyBhIGNvbXB1dGUgY2FjaGUgc3VjaCB0aGF0IGl0IGF2b2lkc1xuICAgICAqIHJlLWNvbXB1dGluZyBhbHJlYWR5LWNvbXB1dGVkIHZhbHVlcy5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImdldExlZnRtb3N0Q29tcGFyYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMZWZ0bW9zdENvbXBhcmF0b3IoYmFzZUV2ZW50KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2FjaGUgPSBuZXcgTWFwKCk7XG5cbiAgICAgIHZhciBmaWxsQ2FjaGUgPSBmdW5jdGlvbiBmaWxsQ2FjaGUobGlua2VkRXZlbnQpIHtcbiAgICAgICAgdmFyIG5leHRFdmVudCA9IGxpbmtlZEV2ZW50Lm90aGVyU0U7XG4gICAgICAgIGNhY2hlLnNldChsaW5rZWRFdmVudCwge1xuICAgICAgICAgIHNpbmU6IHNpbmVPZkFuZ2xlKF90aGlzLnBvaW50LCBiYXNlRXZlbnQucG9pbnQsIG5leHRFdmVudC5wb2ludCksXG4gICAgICAgICAgY29zaW5lOiBjb3NpbmVPZkFuZ2xlKF90aGlzLnBvaW50LCBiYXNlRXZlbnQucG9pbnQsIG5leHRFdmVudC5wb2ludClcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgaWYgKCFjYWNoZS5oYXMoYSkpIGZpbGxDYWNoZShhKTtcbiAgICAgICAgaWYgKCFjYWNoZS5oYXMoYikpIGZpbGxDYWNoZShiKTtcblxuICAgICAgICB2YXIgX2NhY2hlJGdldCA9IGNhY2hlLmdldChhKSxcbiAgICAgICAgICAgIGFzaW5lID0gX2NhY2hlJGdldC5zaW5lLFxuICAgICAgICAgICAgYWNvc2luZSA9IF9jYWNoZSRnZXQuY29zaW5lO1xuXG4gICAgICAgIHZhciBfY2FjaGUkZ2V0MiA9IGNhY2hlLmdldChiKSxcbiAgICAgICAgICAgIGJzaW5lID0gX2NhY2hlJGdldDIuc2luZSxcbiAgICAgICAgICAgIGJjb3NpbmUgPSBfY2FjaGUkZ2V0Mi5jb3NpbmU7IC8vIGJvdGggb24gb3IgYWJvdmUgeC1heGlzXG5cblxuICAgICAgICBpZiAoYXNpbmUgPj0gMCAmJiBic2luZSA+PSAwKSB7XG4gICAgICAgICAgaWYgKGFjb3NpbmUgPCBiY29zaW5lKSByZXR1cm4gMTtcbiAgICAgICAgICBpZiAoYWNvc2luZSA+IGJjb3NpbmUpIHJldHVybiAtMTtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSAvLyBib3RoIGJlbG93IHgtYXhpc1xuXG5cbiAgICAgICAgaWYgKGFzaW5lIDwgMCAmJiBic2luZSA8IDApIHtcbiAgICAgICAgICBpZiAoYWNvc2luZSA8IGJjb3NpbmUpIHJldHVybiAtMTtcbiAgICAgICAgICBpZiAoYWNvc2luZSA+IGJjb3NpbmUpIHJldHVybiAxO1xuICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9IC8vIG9uZSBhYm92ZSB4LWF4aXMsIG9uZSBiZWxvd1xuXG5cbiAgICAgICAgaWYgKGJzaW5lIDwgYXNpbmUpIHJldHVybiAtMTtcbiAgICAgICAgaWYgKGJzaW5lID4gYXNpbmUpIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN3ZWVwRXZlbnQ7XG59KCk7XG5cbi8vIHNlZ21lbnRzIGFuZCBzd2VlcCBldmVudHMgd2hlbiBhbGwgZWxzZSBpcyBpZGVudGljYWxcblxudmFyIHNlZ21lbnRJZCA9IDA7XG5cbnZhciBTZWdtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgX2NyZWF0ZUNsYXNzKFNlZ21lbnQsIG51bGwsIFt7XG4gICAga2V5OiBcImNvbXBhcmVcIixcblxuICAgIC8qIFRoaXMgY29tcGFyZSgpIGZ1bmN0aW9uIGlzIGZvciBvcmRlcmluZyBzZWdtZW50cyBpbiB0aGUgc3dlZXBcbiAgICAgKiBsaW5lIHRyZWUsIGFuZCBkb2VzIHNvIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIGNyaXRlcmlhOlxuICAgICAqXG4gICAgICogQ29uc2lkZXIgdGhlIHZlcnRpY2FsIGxpbmUgdGhhdCBsaWVzIGFuIGluZmluZXN0aW1hbCBzdGVwIHRvIHRoZVxuICAgICAqIHJpZ2h0IG9mIHRoZSByaWdodC1tb3JlIG9mIHRoZSB0d28gbGVmdCBlbmRwb2ludHMgb2YgdGhlIGlucHV0XG4gICAgICogc2VnbWVudHMuIEltYWdpbmUgc2xvd2x5IG1vdmluZyBhIHBvaW50IHVwIGZyb20gbmVnYXRpdmUgaW5maW5pdHlcbiAgICAgKiBpbiB0aGUgaW5jcmVhc2luZyB5IGRpcmVjdGlvbi4gV2hpY2ggb2YgdGhlIHR3byBzZWdtZW50cyB3aWxsIHRoYXRcbiAgICAgKiBwb2ludCBpbnRlcnNlY3QgZmlyc3Q/IFRoYXQgc2VnbWVudCBjb21lcyAnYmVmb3JlJyB0aGUgb3RoZXIgb25lLlxuICAgICAqXG4gICAgICogSWYgbmVpdGhlciBzZWdtZW50IHdvdWxkIGJlIGludGVyc2VjdGVkIGJ5IHN1Y2ggYSBsaW5lLCAoaWYgb25lXG4gICAgICogb3IgbW9yZSBvZiB0aGUgc2VnbWVudHMgYXJlIHZlcnRpY2FsKSB0aGVuIHRoZSBsaW5lIHRvIGJlIGNvbnNpZGVyZWRcbiAgICAgKiBpcyBkaXJlY3RseSBvbiB0aGUgcmlnaHQtbW9yZSBvZiB0aGUgdHdvIGxlZnQgaW5wdXRzLlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgICAgIHZhciBhbHggPSBhLmxlZnRTRS5wb2ludC54O1xuICAgICAgdmFyIGJseCA9IGIubGVmdFNFLnBvaW50Lng7XG4gICAgICB2YXIgYXJ4ID0gYS5yaWdodFNFLnBvaW50Lng7XG4gICAgICB2YXIgYnJ4ID0gYi5yaWdodFNFLnBvaW50Lng7IC8vIGNoZWNrIGlmIHRoZXkncmUgZXZlbiBpbiB0aGUgc2FtZSB2ZXJ0aWNhbCBwbGFuZVxuXG4gICAgICBpZiAoYnJ4IDwgYWx4KSByZXR1cm4gMTtcbiAgICAgIGlmIChhcnggPCBibHgpIHJldHVybiAtMTtcbiAgICAgIHZhciBhbHkgPSBhLmxlZnRTRS5wb2ludC55O1xuICAgICAgdmFyIGJseSA9IGIubGVmdFNFLnBvaW50Lnk7XG4gICAgICB2YXIgYXJ5ID0gYS5yaWdodFNFLnBvaW50Lnk7XG4gICAgICB2YXIgYnJ5ID0gYi5yaWdodFNFLnBvaW50Lnk7IC8vIGlzIGxlZnQgZW5kcG9pbnQgb2Ygc2VnbWVudCBCIHRoZSByaWdodC1tb3JlP1xuXG4gICAgICBpZiAoYWx4IDwgYmx4KSB7XG4gICAgICAgIC8vIGFyZSB0aGUgdHdvIHNlZ21lbnRzIGluIHRoZSBzYW1lIGhvcml6b250YWwgcGxhbmU/XG4gICAgICAgIGlmIChibHkgPCBhbHkgJiYgYmx5IDwgYXJ5KSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGJseSA+IGFseSAmJiBibHkgPiBhcnkpIHJldHVybiAtMTsgLy8gaXMgdGhlIEIgbGVmdCBlbmRwb2ludCBjb2xpbmVhciB0byBzZWdtZW50IEE/XG5cbiAgICAgICAgdmFyIGFDbXBCTGVmdCA9IGEuY29tcGFyZVBvaW50KGIubGVmdFNFLnBvaW50KTtcbiAgICAgICAgaWYgKGFDbXBCTGVmdCA8IDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYUNtcEJMZWZ0ID4gMCkgcmV0dXJuIC0xOyAvLyBpcyB0aGUgQSByaWdodCBlbmRwb2ludCBjb2xpbmVhciB0byBzZWdtZW50IEIgP1xuXG4gICAgICAgIHZhciBiQ21wQVJpZ2h0ID0gYi5jb21wYXJlUG9pbnQoYS5yaWdodFNFLnBvaW50KTtcbiAgICAgICAgaWYgKGJDbXBBUmlnaHQgIT09IDApIHJldHVybiBiQ21wQVJpZ2h0OyAvLyBjb2xpbmVhciBzZWdtZW50cywgY29uc2lkZXIgdGhlIG9uZSB3aXRoIGxlZnQtbW9yZVxuICAgICAgICAvLyBsZWZ0IGVuZHBvaW50IHRvIGJlIGZpcnN0IChhcmJpdHJhcnk/KVxuXG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH0gLy8gaXMgbGVmdCBlbmRwb2ludCBvZiBzZWdtZW50IEEgdGhlIHJpZ2h0LW1vcmU/XG5cblxuICAgICAgaWYgKGFseCA+IGJseCkge1xuICAgICAgICBpZiAoYWx5IDwgYmx5ICYmIGFseSA8IGJyeSkgcmV0dXJuIC0xO1xuICAgICAgICBpZiAoYWx5ID4gYmx5ICYmIGFseSA+IGJyeSkgcmV0dXJuIDE7IC8vIGlzIHRoZSBBIGxlZnQgZW5kcG9pbnQgY29saW5lYXIgdG8gc2VnbWVudCBCP1xuXG4gICAgICAgIHZhciBiQ21wQUxlZnQgPSBiLmNvbXBhcmVQb2ludChhLmxlZnRTRS5wb2ludCk7XG4gICAgICAgIGlmIChiQ21wQUxlZnQgIT09IDApIHJldHVybiBiQ21wQUxlZnQ7IC8vIGlzIHRoZSBCIHJpZ2h0IGVuZHBvaW50IGNvbGluZWFyIHRvIHNlZ21lbnQgQT9cblxuICAgICAgICB2YXIgYUNtcEJSaWdodCA9IGEuY29tcGFyZVBvaW50KGIucmlnaHRTRS5wb2ludCk7XG4gICAgICAgIGlmIChhQ21wQlJpZ2h0IDwgMCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChhQ21wQlJpZ2h0ID4gMCkgcmV0dXJuIC0xOyAvLyBjb2xpbmVhciBzZWdtZW50cywgY29uc2lkZXIgdGhlIG9uZSB3aXRoIGxlZnQtbW9yZVxuICAgICAgICAvLyBsZWZ0IGVuZHBvaW50IHRvIGJlIGZpcnN0IChhcmJpdHJhcnk/KVxuXG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSAvLyBpZiB3ZSBnZXQgaGVyZSwgdGhlIHR3byBsZWZ0IGVuZHBvaW50cyBhcmUgaW4gdGhlIHNhbWVcbiAgICAgIC8vIHZlcnRpY2FsIHBsYW5lLCBpZSBhbHggPT09IGJseFxuICAgICAgLy8gY29uc2lkZXIgdGhlIGxvd2VyIGxlZnQtZW5kcG9pbnQgdG8gY29tZSBmaXJzdFxuXG5cbiAgICAgIGlmIChhbHkgPCBibHkpIHJldHVybiAtMTtcbiAgICAgIGlmIChhbHkgPiBibHkpIHJldHVybiAxOyAvLyBsZWZ0IGVuZHBvaW50cyBhcmUgaWRlbnRpY2FsXG4gICAgICAvLyBjaGVjayBmb3IgY29saW5lYXJpdHkgYnkgdXNpbmcgdGhlIGxlZnQtbW9yZSByaWdodCBlbmRwb2ludFxuICAgICAgLy8gaXMgdGhlIEEgcmlnaHQgZW5kcG9pbnQgbW9yZSBsZWZ0LW1vcmU/XG5cbiAgICAgIGlmIChhcnggPCBicngpIHtcbiAgICAgICAgdmFyIF9iQ21wQVJpZ2h0ID0gYi5jb21wYXJlUG9pbnQoYS5yaWdodFNFLnBvaW50KTtcblxuICAgICAgICBpZiAoX2JDbXBBUmlnaHQgIT09IDApIHJldHVybiBfYkNtcEFSaWdodDtcbiAgICAgIH0gLy8gaXMgdGhlIEIgcmlnaHQgZW5kcG9pbnQgbW9yZSBsZWZ0LW1vcmU/XG5cblxuICAgICAgaWYgKGFyeCA+IGJyeCkge1xuICAgICAgICB2YXIgX2FDbXBCUmlnaHQgPSBhLmNvbXBhcmVQb2ludChiLnJpZ2h0U0UucG9pbnQpO1xuXG4gICAgICAgIGlmIChfYUNtcEJSaWdodCA8IDApIHJldHVybiAxO1xuICAgICAgICBpZiAoX2FDbXBCUmlnaHQgPiAwKSByZXR1cm4gLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChhcnggIT09IGJyeCkge1xuICAgICAgICAvLyBhcmUgdGhlc2UgdHdvIFthbG1vc3RdIHZlcnRpY2FsIHNlZ21lbnRzIHdpdGggb3Bwb3NpdGUgb3JpZW50YXRpb24/XG4gICAgICAgIC8vIGlmIHNvLCB0aGUgb25lIHdpdGggdGhlIGxvd2VyIHJpZ2h0IGVuZHBvaW50IGNvbWVzIGZpcnN0XG4gICAgICAgIHZhciBheSA9IGFyeSAtIGFseTtcbiAgICAgICAgdmFyIGF4ID0gYXJ4IC0gYWx4O1xuICAgICAgICB2YXIgYnkgPSBicnkgLSBibHk7XG4gICAgICAgIHZhciBieCA9IGJyeCAtIGJseDtcbiAgICAgICAgaWYgKGF5ID4gYXggJiYgYnkgPCBieCkgcmV0dXJuIDE7XG4gICAgICAgIGlmIChheSA8IGF4ICYmIGJ5ID4gYngpIHJldHVybiAtMTtcbiAgICAgIH0gLy8gd2UgaGF2ZSBjb2xpbmVhciBzZWdtZW50cyB3aXRoIG1hdGNoaW5nIG9yaWVudGF0aW9uXG4gICAgICAvLyBjb25zaWRlciB0aGUgb25lIHdpdGggbW9yZSBsZWZ0LW1vcmUgcmlnaHQgZW5kcG9pbnQgdG8gYmUgZmlyc3RcblxuXG4gICAgICBpZiAoYXJ4ID4gYnJ4KSByZXR1cm4gMTtcbiAgICAgIGlmIChhcnggPCBicngpIHJldHVybiAtMTsgLy8gaWYgd2UgZ2V0IGhlcmUsIHR3byB0d28gcmlnaHQgZW5kcG9pbnRzIGFyZSBpbiB0aGUgc2FtZVxuICAgICAgLy8gdmVydGljYWwgcGxhbmUsIGllIGFyeCA9PT0gYnJ4XG4gICAgICAvLyBjb25zaWRlciB0aGUgbG93ZXIgcmlnaHQtZW5kcG9pbnQgdG8gY29tZSBmaXJzdFxuXG4gICAgICBpZiAoYXJ5IDwgYnJ5KSByZXR1cm4gLTE7XG4gICAgICBpZiAoYXJ5ID4gYnJ5KSByZXR1cm4gMTsgLy8gcmlnaHQgZW5kcG9pbnRzIGlkZW50aWNhbCBhcyB3ZWxsLCBzbyB0aGUgc2VnbWVudHMgYXJlIGlkZW50aWFsXG4gICAgICAvLyBmYWxsIGJhY2sgb24gY3JlYXRpb24gb3JkZXIgYXMgY29uc2lzdGVudCB0aWUtYnJlYWtlclxuXG4gICAgICBpZiAoYS5pZCA8IGIuaWQpIHJldHVybiAtMTtcbiAgICAgIGlmIChhLmlkID4gYi5pZCkgcmV0dXJuIDE7IC8vIGlkZW50aWNhbCBzZWdtZW50LCBpZSBhID09PSBiXG5cbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKiBXYXJuaW5nOiBhIHJlZmVyZW5jZSB0byByaW5nV2luZGluZ3MgaW5wdXQgd2lsbCBiZSBzdG9yZWQsXG4gICAgICogIGFuZCBwb3NzaWJseSB3aWxsIGJlIGxhdGVyIG1vZGlmaWVkICovXG5cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFNlZ21lbnQobGVmdFNFLCByaWdodFNFLCByaW5ncywgd2luZGluZ3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VnbWVudCk7XG5cbiAgICB0aGlzLmlkID0gKytzZWdtZW50SWQ7XG4gICAgdGhpcy5sZWZ0U0UgPSBsZWZ0U0U7XG4gICAgbGVmdFNFLnNlZ21lbnQgPSB0aGlzO1xuICAgIGxlZnRTRS5vdGhlclNFID0gcmlnaHRTRTtcbiAgICB0aGlzLnJpZ2h0U0UgPSByaWdodFNFO1xuICAgIHJpZ2h0U0Uuc2VnbWVudCA9IHRoaXM7XG4gICAgcmlnaHRTRS5vdGhlclNFID0gbGVmdFNFO1xuICAgIHRoaXMucmluZ3MgPSByaW5ncztcbiAgICB0aGlzLndpbmRpbmdzID0gd2luZGluZ3M7IC8vIGxlZnQgdW5zZXQgZm9yIHBlcmZvcm1hbmNlLCBzZXQgbGF0ZXIgaW4gYWxnb3JpdGhtXG4gICAgLy8gdGhpcy5yaW5nT3V0LCB0aGlzLmNvbnN1bWVkQnksIHRoaXMucHJldlxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNlZ21lbnQsIFt7XG4gICAga2V5OiBcInJlcGxhY2VSaWdodFNFXCIsXG5cbiAgICAvKiBXaGVuIGEgc2VnbWVudCBpcyBzcGxpdCwgdGhlIHJpZ2h0U0UgaXMgcmVwbGFjZWQgd2l0aCBhIG5ldyBzd2VlcCBldmVudCAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiByZXBsYWNlUmlnaHRTRShuZXdSaWdodFNFKSB7XG4gICAgICB0aGlzLnJpZ2h0U0UgPSBuZXdSaWdodFNFO1xuICAgICAgdGhpcy5yaWdodFNFLnNlZ21lbnQgPSB0aGlzO1xuICAgICAgdGhpcy5yaWdodFNFLm90aGVyU0UgPSB0aGlzLmxlZnRTRTtcbiAgICAgIHRoaXMubGVmdFNFLm90aGVyU0UgPSB0aGlzLnJpZ2h0U0U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJib3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmJveCgpIHtcbiAgICAgIHZhciB5MSA9IHRoaXMubGVmdFNFLnBvaW50Lnk7XG4gICAgICB2YXIgeTIgPSB0aGlzLnJpZ2h0U0UucG9pbnQueTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxsOiB7XG4gICAgICAgICAgeDogdGhpcy5sZWZ0U0UucG9pbnQueCxcbiAgICAgICAgICB5OiB5MSA8IHkyID8geTEgOiB5MlxuICAgICAgICB9LFxuICAgICAgICB1cjoge1xuICAgICAgICAgIHg6IHRoaXMucmlnaHRTRS5wb2ludC54LFxuICAgICAgICAgIHk6IHkxID4geTIgPyB5MSA6IHkyXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIC8qIEEgdmVjdG9yIGZyb20gdGhlIGxlZnQgcG9pbnQgdG8gdGhlIHJpZ2h0ICovXG5cbiAgfSwge1xuICAgIGtleTogXCJ2ZWN0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVjdG9yKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy5yaWdodFNFLnBvaW50LnggLSB0aGlzLmxlZnRTRS5wb2ludC54LFxuICAgICAgICB5OiB0aGlzLnJpZ2h0U0UucG9pbnQueSAtIHRoaXMubGVmdFNFLnBvaW50LnlcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQW5FbmRwb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FuRW5kcG9pbnQocHQpIHtcbiAgICAgIHJldHVybiBwdC54ID09PSB0aGlzLmxlZnRTRS5wb2ludC54ICYmIHB0LnkgPT09IHRoaXMubGVmdFNFLnBvaW50LnkgfHwgcHQueCA9PT0gdGhpcy5yaWdodFNFLnBvaW50LnggJiYgcHQueSA9PT0gdGhpcy5yaWdodFNFLnBvaW50Lnk7XG4gICAgfVxuICAgIC8qIENvbXBhcmUgdGhpcyBzZWdtZW50IHdpdGggYSBwb2ludC5cbiAgICAgKlxuICAgICAqIEEgcG9pbnQgUCBpcyBjb25zaWRlcmVkIHRvIGJlIGNvbGluZWFyIHRvIGEgc2VnbWVudCBpZiB0aGVyZVxuICAgICAqIGV4aXN0cyBhIGRpc3RhbmNlIEQgc3VjaCB0aGF0IGlmIHdlIHRyYXZlbCBhbG9uZyB0aGUgc2VnbWVudFxuICAgICAqIGZyb20gb25lICogZW5kcG9pbnQgdG93YXJkcyB0aGUgb3RoZXIgYSBkaXN0YW5jZSBELCB3ZSBmaW5kXG4gICAgICogb3Vyc2VsdmVzIGF0IHBvaW50IFAuXG4gICAgICpcbiAgICAgKiBSZXR1cm4gdmFsdWUgaW5kaWNhdGVzOlxuICAgICAqXG4gICAgICogICAxOiBwb2ludCBsaWVzIGFib3ZlIHRoZSBzZWdtZW50ICh0byB0aGUgbGVmdCBvZiB2ZXJ0aWNhbClcbiAgICAgKiAgIDA6IHBvaW50IGlzIGNvbGluZWFyIHRvIHNlZ21lbnRcbiAgICAgKiAgLTE6IHBvaW50IGxpZXMgYmVsb3cgdGhlIHNlZ21lbnQgKHRvIHRoZSByaWdodCBvZiB2ZXJ0aWNhbClcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbXBhcmVQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlUG9pbnQocG9pbnQpIHtcbiAgICAgIGlmICh0aGlzLmlzQW5FbmRwb2ludChwb2ludCkpIHJldHVybiAwO1xuICAgICAgdmFyIGxQdCA9IHRoaXMubGVmdFNFLnBvaW50O1xuICAgICAgdmFyIHJQdCA9IHRoaXMucmlnaHRTRS5wb2ludDtcbiAgICAgIHZhciB2ID0gdGhpcy52ZWN0b3IoKTsgLy8gRXhhY3RseSB2ZXJ0aWNhbCBzZWdtZW50cy5cblxuICAgICAgaWYgKGxQdC54ID09PSByUHQueCkge1xuICAgICAgICBpZiAocG9pbnQueCA9PT0gbFB0LngpIHJldHVybiAwO1xuICAgICAgICByZXR1cm4gcG9pbnQueCA8IGxQdC54ID8gMSA6IC0xO1xuICAgICAgfSAvLyBOZWFybHkgdmVydGljYWwgc2VnbWVudHMgd2l0aCBhbiBpbnRlcnNlY3Rpb24uXG4gICAgICAvLyBDaGVjayB0byBzZWUgd2hlcmUgYSBwb2ludCBvbiB0aGUgbGluZSB3aXRoIG1hdGNoaW5nIFkgY29vcmRpbmF0ZSBpcy5cblxuXG4gICAgICB2YXIgeURpc3QgPSAocG9pbnQueSAtIGxQdC55KSAvIHYueTtcbiAgICAgIHZhciB4RnJvbVlEaXN0ID0gbFB0LnggKyB5RGlzdCAqIHYueDtcbiAgICAgIGlmIChwb2ludC54ID09PSB4RnJvbVlEaXN0KSByZXR1cm4gMDsgLy8gR2VuZXJhbCBjYXNlLlxuICAgICAgLy8gQ2hlY2sgdG8gc2VlIHdoZXJlIGEgcG9pbnQgb24gdGhlIGxpbmUgd2l0aCBtYXRjaGluZyBYIGNvb3JkaW5hdGUgaXMuXG5cbiAgICAgIHZhciB4RGlzdCA9IChwb2ludC54IC0gbFB0LngpIC8gdi54O1xuICAgICAgdmFyIHlGcm9tWERpc3QgPSBsUHQueSArIHhEaXN0ICogdi55O1xuICAgICAgaWYgKHBvaW50LnkgPT09IHlGcm9tWERpc3QpIHJldHVybiAwO1xuICAgICAgcmV0dXJuIHBvaW50LnkgPCB5RnJvbVhEaXN0ID8gLTEgOiAxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbm90aGVyIHNlZ21lbnQsIHJldHVybnMgdGhlIGZpcnN0IG5vbi10cml2aWFsIGludGVyc2VjdGlvblxuICAgICAqIGJldHdlZW4gdGhlIHR3byBzZWdtZW50cyAoaW4gdGVybXMgb2Ygc3dlZXAgbGluZSBvcmRlcmluZyksIGlmIGl0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEEgJ25vbi10cml2aWFsJyBpbnRlcnNlY3Rpb24gaXMgb25lIHRoYXQgd2lsbCBjYXVzZSBvbmUgb3IgYm90aCBvZiB0aGVcbiAgICAgKiBzZWdtZW50cyB0byBiZSBzcGxpdCgpLiBBcyBzdWNoLCAndHJpdmlhbCcgdnMuICdub24tdHJpdmlhbCcgaW50ZXJzZWN0aW9uOlxuICAgICAqXG4gICAgICogICAqIGVuZHBvaW50IG9mIHNlZ0Egd2l0aCBlbmRwb2ludCBvZiBzZWdCIC0tPiB0cml2aWFsXG4gICAgICogICAqIGVuZHBvaW50IG9mIHNlZ0Egd2l0aCBwb2ludCBhbG9uZyBzZWdCIC0tPiBub24tdHJpdmlhbFxuICAgICAqICAgKiBlbmRwb2ludCBvZiBzZWdCIHdpdGggcG9pbnQgYWxvbmcgc2VnQSAtLT4gbm9uLXRyaXZpYWxcbiAgICAgKiAgICogcG9pbnQgYWxvbmcgc2VnQSB3aXRoIHBvaW50IGFsb25nIHNlZ0IgLS0+IG5vbi10cml2aWFsXG4gICAgICpcbiAgICAgKiBJZiBubyBub24tdHJpdmlhbCBpbnRlcnNlY3Rpb24gZXhpc3RzLCByZXR1cm4gbnVsbFxuICAgICAqIEVsc2UsIHJldHVybiBudWxsLlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW50ZXJzZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbihvdGhlcikge1xuICAgICAgLy8gSWYgYmJveGVzIGRvbid0IG92ZXJsYXAsIHRoZXJlIGNhbid0IGJlIGFueSBpbnRlcnNlY3Rpb25zXG4gICAgICB2YXIgdEJib3ggPSB0aGlzLmJib3goKTtcbiAgICAgIHZhciBvQmJveCA9IG90aGVyLmJib3goKTtcbiAgICAgIHZhciBiYm94T3ZlcmxhcCA9IGdldEJib3hPdmVybGFwKHRCYm94LCBvQmJveCk7XG4gICAgICBpZiAoYmJveE92ZXJsYXAgPT09IG51bGwpIHJldHVybiBudWxsOyAvLyBXZSBmaXJzdCBjaGVjayB0byBzZWUgaWYgdGhlIGVuZHBvaW50cyBjYW4gYmUgY29uc2lkZXJlZCBpbnRlcnNlY3Rpb25zLlxuICAgICAgLy8gVGhpcyB3aWxsICdzbmFwJyBpbnRlcnNlY3Rpb25zIHRvIGVuZHBvaW50cyBpZiBwb3NzaWJsZSwgYW5kIHdpbGxcbiAgICAgIC8vIGhhbmRsZSBjYXNlcyBvZiBjb2xpbmVhcml0eS5cblxuICAgICAgdmFyIHRscCA9IHRoaXMubGVmdFNFLnBvaW50O1xuICAgICAgdmFyIHRycCA9IHRoaXMucmlnaHRTRS5wb2ludDtcbiAgICAgIHZhciBvbHAgPSBvdGhlci5sZWZ0U0UucG9pbnQ7XG4gICAgICB2YXIgb3JwID0gb3RoZXIucmlnaHRTRS5wb2ludDsgLy8gZG9lcyBlYWNoIGVuZHBvaW50IHRvdWNoIHRoZSBvdGhlciBzZWdtZW50P1xuICAgICAgLy8gbm90ZSB0aGF0IHdlIHJlc3RyaWN0IHRoZSAndG91Y2hpbmcnIGRlZmluaXRpb24gdG8gb25seSBhbGxvdyBzZWdtZW50c1xuICAgICAgLy8gdG8gdG91Y2ggZW5kcG9pbnRzIHRoYXQgbGllIGZvcndhcmQgZnJvbSB3aGVyZSB3ZSBhcmUgaW4gdGhlIHN3ZWVwIGxpbmUgcGFzc1xuXG4gICAgICB2YXIgdG91Y2hlc090aGVyTFNFID0gaXNJbkJib3godEJib3gsIG9scCkgJiYgdGhpcy5jb21wYXJlUG9pbnQob2xwKSA9PT0gMDtcbiAgICAgIHZhciB0b3VjaGVzVGhpc0xTRSA9IGlzSW5CYm94KG9CYm94LCB0bHApICYmIG90aGVyLmNvbXBhcmVQb2ludCh0bHApID09PSAwO1xuICAgICAgdmFyIHRvdWNoZXNPdGhlclJTRSA9IGlzSW5CYm94KHRCYm94LCBvcnApICYmIHRoaXMuY29tcGFyZVBvaW50KG9ycCkgPT09IDA7XG4gICAgICB2YXIgdG91Y2hlc1RoaXNSU0UgPSBpc0luQmJveChvQmJveCwgdHJwKSAmJiBvdGhlci5jb21wYXJlUG9pbnQodHJwKSA9PT0gMDsgLy8gZG8gbGVmdCBlbmRwb2ludHMgbWF0Y2g/XG5cbiAgICAgIGlmICh0b3VjaGVzVGhpc0xTRSAmJiB0b3VjaGVzT3RoZXJMU0UpIHtcbiAgICAgICAgLy8gdGhlc2UgdHdvIGNhc2VzIGFyZSBmb3IgY29saW5lYXIgc2VnbWVudHMgd2l0aCBtYXRjaGluZyBsZWZ0XG4gICAgICAgIC8vIGVuZHBvaW50cywgYW5kIG9uZSBzZWdtZW50IGJlaW5nIGxvbmdlciB0aGFuIHRoZSBvdGhlclxuICAgICAgICBpZiAodG91Y2hlc1RoaXNSU0UgJiYgIXRvdWNoZXNPdGhlclJTRSkgcmV0dXJuIHRycDtcbiAgICAgICAgaWYgKCF0b3VjaGVzVGhpc1JTRSAmJiB0b3VjaGVzT3RoZXJSU0UpIHJldHVybiBvcnA7IC8vIGVpdGhlciB0aGUgdHdvIHNlZ21lbnRzIG1hdGNoIGV4YWN0bHkgKHR3byB0cml2YWwgaW50ZXJzZWN0aW9ucylcbiAgICAgICAgLy8gb3IganVzdCBvbiB0aGVpciBsZWZ0IGVuZHBvaW50IChvbmUgdHJpdmlhbCBpbnRlcnNlY3Rpb25cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gLy8gZG9lcyB0aGlzIGxlZnQgZW5kcG9pbnQgbWF0Y2hlcyAob3RoZXIgZG9lc24ndClcblxuXG4gICAgICBpZiAodG91Y2hlc1RoaXNMU0UpIHtcbiAgICAgICAgLy8gY2hlY2sgZm9yIHNlZ21lbnRzIHRoYXQganVzdCBpbnRlcnNlY3Qgb24gb3Bwb3NpbmcgZW5kcG9pbnRzXG4gICAgICAgIGlmICh0b3VjaGVzT3RoZXJSU0UpIHtcbiAgICAgICAgICBpZiAodGxwLnggPT09IG9ycC54ICYmIHRscC55ID09PSBvcnAueSkgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gLy8gdC1pbnRlcnNlY3Rpb24gb24gbGVmdCBlbmRwb2ludFxuXG5cbiAgICAgICAgcmV0dXJuIHRscDtcbiAgICAgIH0gLy8gZG9lcyBvdGhlciBsZWZ0IGVuZHBvaW50IG1hdGNoZXMgKHRoaXMgZG9lc24ndClcblxuXG4gICAgICBpZiAodG91Y2hlc090aGVyTFNFKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciBzZWdtZW50cyB0aGF0IGp1c3QgaW50ZXJzZWN0IG9uIG9wcG9zaW5nIGVuZHBvaW50c1xuICAgICAgICBpZiAodG91Y2hlc1RoaXNSU0UpIHtcbiAgICAgICAgICBpZiAodHJwLnggPT09IG9scC54ICYmIHRycC55ID09PSBvbHAueSkgcmV0dXJuIG51bGw7XG4gICAgICAgIH0gLy8gdC1pbnRlcnNlY3Rpb24gb24gbGVmdCBlbmRwb2ludFxuXG5cbiAgICAgICAgcmV0dXJuIG9scDtcbiAgICAgIH0gLy8gdHJpdmlhbCBpbnRlcnNlY3Rpb24gb24gcmlnaHQgZW5kcG9pbnRzXG5cblxuICAgICAgaWYgKHRvdWNoZXNUaGlzUlNFICYmIHRvdWNoZXNPdGhlclJTRSkgcmV0dXJuIG51bGw7IC8vIHQtaW50ZXJzZWN0aW9ucyBvbiBqdXN0IG9uZSByaWdodCBlbmRwb2ludFxuXG4gICAgICBpZiAodG91Y2hlc1RoaXNSU0UpIHJldHVybiB0cnA7XG4gICAgICBpZiAodG91Y2hlc090aGVyUlNFKSByZXR1cm4gb3JwOyAvLyBOb25lIG9mIG91ciBlbmRwb2ludHMgaW50ZXJzZWN0LiBMb29rIGZvciBhIGdlbmVyYWwgaW50ZXJzZWN0aW9uIGJldHdlZW5cbiAgICAgIC8vIGluZmluaXRlIGxpbmVzIGxhaWQgb3ZlciB0aGUgc2VnbWVudHNcblxuICAgICAgdmFyIHB0ID0gaW50ZXJzZWN0aW9uKHRscCwgdGhpcy52ZWN0b3IoKSwgb2xwLCBvdGhlci52ZWN0b3IoKSk7IC8vIGFyZSB0aGUgc2VnbWVudHMgcGFycmFsbGVsPyBOb3RlIHRoYXQgaWYgdGhleSB3ZXJlIGNvbGluZWFyIHdpdGggb3ZlcmxhcCxcbiAgICAgIC8vIHRoZXkgd291bGQgaGF2ZSBhbiBlbmRwb2ludCBpbnRlcnNlY3Rpb24gYW5kIHRoYXQgY2FzZSB3YXMgYWxyZWFkeSBoYW5kbGVkIGFib3ZlXG5cbiAgICAgIGlmIChwdCA9PT0gbnVsbCkgcmV0dXJuIG51bGw7IC8vIGlzIHRoZSBpbnRlcnNlY3Rpb24gZm91bmQgYmV0d2VlbiB0aGUgbGluZXMgbm90IG9uIHRoZSBzZWdtZW50cz9cblxuICAgICAgaWYgKCFpc0luQmJveChiYm94T3ZlcmxhcCwgcHQpKSByZXR1cm4gbnVsbDsgLy8gcm91bmQgdGhlIHRoZSBjb21wdXRlZCBwb2ludCBpZiBuZWVkZWRcblxuICAgICAgcmV0dXJuIHJvdW5kZXIucm91bmQocHQueCwgcHQueSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNwbGl0IHRoZSBnaXZlbiBzZWdtZW50IGludG8gbXVsdGlwbGUgc2VnbWVudHMgb24gdGhlIGdpdmVuIHBvaW50cy5cbiAgICAgKiAgKiBFYWNoIGV4aXN0aW5nIHNlZ21lbnQgd2lsbCByZXRhaW4gaXRzIGxlZnRTRSBhbmQgYSBuZXcgcmlnaHRTRSB3aWxsIGJlXG4gICAgICogICAgZ2VuZXJhdGVkIGZvciBpdC5cbiAgICAgKiAgKiBBIG5ldyBzZWdtZW50IHdpbGwgYmUgZ2VuZXJhdGVkIHdoaWNoIHdpbGwgYWRvcHQgdGhlIG9yaWdpbmFsIHNlZ21lbnQnc1xuICAgICAqICAgIHJpZ2h0U0UsIGFuZCBhIG5ldyBsZWZ0U0Ugd2lsbCBiZSBnZW5lcmF0ZWQgZm9yIGl0LlxuICAgICAqICAqIElmIHRoZXJlIGFyZSBtb3JlIHRoYW4gdHdvIHBvaW50cyBnaXZlbiB0byBzcGxpdCBvbiwgbmV3IHNlZ21lbnRzXG4gICAgICogICAgaW4gdGhlIG1pZGRsZSB3aWxsIGJlIGdlbmVyYXRlZCB3aXRoIG5ldyBsZWZ0U0UgYW5kIHJpZ2h0U0Uncy5cbiAgICAgKiAgKiBBbiBhcnJheSBvZiB0aGUgbmV3bHkgZ2VuZXJhdGVkIFN3ZWVwRXZlbnRzIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiBpbnB1dCBhcnJheSBvZiBwb2ludHMgaXMgbW9kaWZpZWRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInNwbGl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0KHBvaW50KSB7XG4gICAgICB2YXIgbmV3RXZlbnRzID0gW107XG4gICAgICB2YXIgYWxyZWFkeUxpbmtlZCA9IHBvaW50LmV2ZW50cyAhPT0gdW5kZWZpbmVkO1xuICAgICAgdmFyIG5ld0xlZnRTRSA9IG5ldyBTd2VlcEV2ZW50KHBvaW50LCB0cnVlKTtcbiAgICAgIHZhciBuZXdSaWdodFNFID0gbmV3IFN3ZWVwRXZlbnQocG9pbnQsIGZhbHNlKTtcbiAgICAgIHZhciBvbGRSaWdodFNFID0gdGhpcy5yaWdodFNFO1xuICAgICAgdGhpcy5yZXBsYWNlUmlnaHRTRShuZXdSaWdodFNFKTtcbiAgICAgIG5ld0V2ZW50cy5wdXNoKG5ld1JpZ2h0U0UpO1xuICAgICAgbmV3RXZlbnRzLnB1c2gobmV3TGVmdFNFKTtcbiAgICAgIHZhciBuZXdTZWcgPSBuZXcgU2VnbWVudChuZXdMZWZ0U0UsIG9sZFJpZ2h0U0UsIHRoaXMucmluZ3Muc2xpY2UoKSwgdGhpcy53aW5kaW5ncy5zbGljZSgpKTsgLy8gd2hlbiBzcGxpdHRpbmcgYSBuZWFybHkgdmVydGljYWwgZG93bndhcmQtZmFjaW5nIHNlZ21lbnQsXG4gICAgICAvLyBzb21ldGltZXMgb25lIG9mIHRoZSByZXN1bHRpbmcgbmV3IHNlZ21lbnRzIGlzIHZlcnRpY2FsLCBpbiB3aGljaFxuICAgICAgLy8gY2FzZSBpdHMgbGVmdCBhbmQgcmlnaHQgZXZlbnRzIG1heSBuZWVkIHRvIGJlIHN3YXBwZWRcblxuICAgICAgaWYgKFN3ZWVwRXZlbnQuY29tcGFyZVBvaW50cyhuZXdTZWcubGVmdFNFLnBvaW50LCBuZXdTZWcucmlnaHRTRS5wb2ludCkgPiAwKSB7XG4gICAgICAgIG5ld1NlZy5zd2FwRXZlbnRzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChTd2VlcEV2ZW50LmNvbXBhcmVQb2ludHModGhpcy5sZWZ0U0UucG9pbnQsIHRoaXMucmlnaHRTRS5wb2ludCkgPiAwKSB7XG4gICAgICAgIHRoaXMuc3dhcEV2ZW50cygpO1xuICAgICAgfSAvLyBpbiB0aGUgcG9pbnQgd2UganVzdCB1c2VkIHRvIGNyZWF0ZSBuZXcgc3dlZXAgZXZlbnRzIHdpdGggd2FzIGFscmVhZHlcbiAgICAgIC8vIGxpbmtlZCB0byBvdGhlciBldmVudHMsIHdlIG5lZWQgdG8gY2hlY2sgaWYgZWl0aGVyIG9mIHRoZSBhZmZlY3RlZFxuICAgICAgLy8gc2VnbWVudHMgc2hvdWxkIGJlIGNvbnN1bWVkXG5cblxuICAgICAgaWYgKGFscmVhZHlMaW5rZWQpIHtcbiAgICAgICAgbmV3TGVmdFNFLmNoZWNrRm9yQ29uc3VtaW5nKCk7XG4gICAgICAgIG5ld1JpZ2h0U0UuY2hlY2tGb3JDb25zdW1pbmcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ld0V2ZW50cztcbiAgICB9XG4gICAgLyogU3dhcCB3aGljaCBldmVudCBpcyBsZWZ0IGFuZCByaWdodCAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwic3dhcEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzd2FwRXZlbnRzKCkge1xuICAgICAgdmFyIHRtcEV2dCA9IHRoaXMucmlnaHRTRTtcbiAgICAgIHRoaXMucmlnaHRTRSA9IHRoaXMubGVmdFNFO1xuICAgICAgdGhpcy5sZWZ0U0UgPSB0bXBFdnQ7XG4gICAgICB0aGlzLmxlZnRTRS5pc0xlZnQgPSB0cnVlO1xuICAgICAgdGhpcy5yaWdodFNFLmlzTGVmdCA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IHRoaXMud2luZGluZ3MubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgIHRoaXMud2luZGluZ3NbaV0gKj0gLTE7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIENvbnN1bWUgYW5vdGhlciBzZWdtZW50LiBXZSB0YWtlIHRoZWlyIHJpbmdzIHVuZGVyIG91ciB3aW5nXG4gICAgICogYW5kIG1hcmsgdGhlbSBhcyBjb25zdW1lZC4gVXNlIGZvciBwZXJmZWN0bHkgb3ZlcmxhcHBpbmcgc2VnbWVudHMgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShvdGhlcikge1xuICAgICAgdmFyIGNvbnN1bWVyID0gdGhpcztcbiAgICAgIHZhciBjb25zdW1lZSA9IG90aGVyO1xuXG4gICAgICB3aGlsZSAoY29uc3VtZXIuY29uc3VtZWRCeSkge1xuICAgICAgICBjb25zdW1lciA9IGNvbnN1bWVyLmNvbnN1bWVkQnk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjb25zdW1lZS5jb25zdW1lZEJ5KSB7XG4gICAgICAgIGNvbnN1bWVlID0gY29uc3VtZWUuY29uc3VtZWRCeTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNtcCA9IFNlZ21lbnQuY29tcGFyZShjb25zdW1lciwgY29uc3VtZWUpO1xuICAgICAgaWYgKGNtcCA9PT0gMCkgcmV0dXJuOyAvLyBhbHJlYWR5IGNvbnN1bWVkXG4gICAgICAvLyB0aGUgd2lubmVyIG9mIHRoZSBjb25zdW1wdGlvbiBpcyB0aGUgZWFybGllciBzZWdtZW50XG4gICAgICAvLyBhY2NvcmRpbmcgdG8gc3dlZXAgbGluZSBvcmRlcmluZ1xuXG4gICAgICBpZiAoY21wID4gMCkge1xuICAgICAgICB2YXIgdG1wID0gY29uc3VtZXI7XG4gICAgICAgIGNvbnN1bWVyID0gY29uc3VtZWU7XG4gICAgICAgIGNvbnN1bWVlID0gdG1wO1xuICAgICAgfSAvLyBtYWtlIHN1cmUgYSBzZWdtZW50IGRvZXNuJ3QgY29uc3VtZSBpdCdzIHByZXZcblxuXG4gICAgICBpZiAoY29uc3VtZXIucHJldiA9PT0gY29uc3VtZWUpIHtcbiAgICAgICAgdmFyIF90bXAgPSBjb25zdW1lcjtcbiAgICAgICAgY29uc3VtZXIgPSBjb25zdW1lZTtcbiAgICAgICAgY29uc3VtZWUgPSBfdG1wO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IGNvbnN1bWVlLnJpbmdzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IGNvbnN1bWVlLnJpbmdzW2ldO1xuICAgICAgICB2YXIgd2luZGluZyA9IGNvbnN1bWVlLndpbmRpbmdzW2ldO1xuICAgICAgICB2YXIgaW5kZXggPSBjb25zdW1lci5yaW5ncy5pbmRleE9mKHJpbmcpO1xuXG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICBjb25zdW1lci5yaW5ncy5wdXNoKHJpbmcpO1xuICAgICAgICAgIGNvbnN1bWVyLndpbmRpbmdzLnB1c2god2luZGluZyk7XG4gICAgICAgIH0gZWxzZSBjb25zdW1lci53aW5kaW5nc1tpbmRleF0gKz0gd2luZGluZztcbiAgICAgIH1cblxuICAgICAgY29uc3VtZWUucmluZ3MgPSBudWxsO1xuICAgICAgY29uc3VtZWUud2luZGluZ3MgPSBudWxsO1xuICAgICAgY29uc3VtZWUuY29uc3VtZWRCeSA9IGNvbnN1bWVyOyAvLyBtYXJrIHN3ZWVwIGV2ZW50cyBjb25zdW1lZCBhcyB0byBtYWludGFpbiBvcmRlcmluZyBpbiBzd2VlcCBldmVudCBxdWV1ZVxuXG4gICAgICBjb25zdW1lZS5sZWZ0U0UuY29uc3VtZWRCeSA9IGNvbnN1bWVyLmxlZnRTRTtcbiAgICAgIGNvbnN1bWVlLnJpZ2h0U0UuY29uc3VtZWRCeSA9IGNvbnN1bWVyLnJpZ2h0U0U7XG4gICAgfVxuICAgIC8qIFRoZSBmaXJzdCBzZWdtZW50IHByZXZpb3VzIHNlZ21lbnQgY2hhaW4gdGhhdCBpcyBpbiB0aGUgcmVzdWx0ICovXG5cbiAgfSwge1xuICAgIGtleTogXCJwcmV2SW5SZXN1bHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJldkluUmVzdWx0KCkge1xuICAgICAgaWYgKHRoaXMuX3ByZXZJblJlc3VsdCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5fcHJldkluUmVzdWx0O1xuICAgICAgaWYgKCF0aGlzLnByZXYpIHRoaXMuX3ByZXZJblJlc3VsdCA9IG51bGw7ZWxzZSBpZiAodGhpcy5wcmV2LmlzSW5SZXN1bHQoKSkgdGhpcy5fcHJldkluUmVzdWx0ID0gdGhpcy5wcmV2O2Vsc2UgdGhpcy5fcHJldkluUmVzdWx0ID0gdGhpcy5wcmV2LnByZXZJblJlc3VsdCgpO1xuICAgICAgcmV0dXJuIHRoaXMuX3ByZXZJblJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmVmb3JlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmVmb3JlU3RhdGUoKSB7XG4gICAgICBpZiAodGhpcy5fYmVmb3JlU3RhdGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX2JlZm9yZVN0YXRlO1xuICAgICAgaWYgKCF0aGlzLnByZXYpIHRoaXMuX2JlZm9yZVN0YXRlID0ge1xuICAgICAgICByaW5nczogW10sXG4gICAgICAgIHdpbmRpbmdzOiBbXSxcbiAgICAgICAgbXVsdGlQb2x5czogW11cbiAgICAgIH07ZWxzZSB7XG4gICAgICAgIHZhciBzZWcgPSB0aGlzLnByZXYuY29uc3VtZWRCeSB8fCB0aGlzLnByZXY7XG4gICAgICAgIHRoaXMuX2JlZm9yZVN0YXRlID0gc2VnLmFmdGVyU3RhdGUoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9iZWZvcmVTdGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWZ0ZXJTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZnRlclN0YXRlKCkge1xuICAgICAgaWYgKHRoaXMuX2FmdGVyU3RhdGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuX2FmdGVyU3RhdGU7XG4gICAgICB2YXIgYmVmb3JlU3RhdGUgPSB0aGlzLmJlZm9yZVN0YXRlKCk7XG4gICAgICB0aGlzLl9hZnRlclN0YXRlID0ge1xuICAgICAgICByaW5nczogYmVmb3JlU3RhdGUucmluZ3Muc2xpY2UoMCksXG4gICAgICAgIHdpbmRpbmdzOiBiZWZvcmVTdGF0ZS53aW5kaW5ncy5zbGljZSgwKSxcbiAgICAgICAgbXVsdGlQb2x5czogW11cbiAgICAgIH07XG4gICAgICB2YXIgcmluZ3NBZnRlciA9IHRoaXMuX2FmdGVyU3RhdGUucmluZ3M7XG4gICAgICB2YXIgd2luZGluZ3NBZnRlciA9IHRoaXMuX2FmdGVyU3RhdGUud2luZGluZ3M7XG4gICAgICB2YXIgbXBzQWZ0ZXIgPSB0aGlzLl9hZnRlclN0YXRlLm11bHRpUG9seXM7IC8vIGNhbGN1bGF0ZSByaW5nc0FmdGVyLCB3aW5kaW5nc0FmdGVyXG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpTWF4ID0gdGhpcy5yaW5ncy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSB0aGlzLnJpbmdzW2ldO1xuICAgICAgICB2YXIgd2luZGluZyA9IHRoaXMud2luZGluZ3NbaV07XG4gICAgICAgIHZhciBpbmRleCA9IHJpbmdzQWZ0ZXIuaW5kZXhPZihyaW5nKTtcblxuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgcmluZ3NBZnRlci5wdXNoKHJpbmcpO1xuICAgICAgICAgIHdpbmRpbmdzQWZ0ZXIucHVzaCh3aW5kaW5nKTtcbiAgICAgICAgfSBlbHNlIHdpbmRpbmdzQWZ0ZXJbaW5kZXhdICs9IHdpbmRpbmc7XG4gICAgICB9IC8vIGNhbGN1YWx0ZSBwb2x5c0FmdGVyXG5cblxuICAgICAgdmFyIHBvbHlzQWZ0ZXIgPSBbXTtcbiAgICAgIHZhciBwb2x5c0V4Y2x1ZGUgPSBbXTtcblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfaU1heCA9IHJpbmdzQWZ0ZXIubGVuZ3RoOyBfaSA8IF9pTWF4OyBfaSsrKSB7XG4gICAgICAgIGlmICh3aW5kaW5nc0FmdGVyW19pXSA9PT0gMCkgY29udGludWU7IC8vIG5vbi16ZXJvIHJ1bGVcblxuICAgICAgICB2YXIgX3JpbmcgPSByaW5nc0FmdGVyW19pXTtcbiAgICAgICAgdmFyIHBvbHkgPSBfcmluZy5wb2x5O1xuICAgICAgICBpZiAocG9seXNFeGNsdWRlLmluZGV4T2YocG9seSkgIT09IC0xKSBjb250aW51ZTtcbiAgICAgICAgaWYgKF9yaW5nLmlzRXh0ZXJpb3IpIHBvbHlzQWZ0ZXIucHVzaChwb2x5KTtlbHNlIHtcbiAgICAgICAgICBpZiAocG9seXNFeGNsdWRlLmluZGV4T2YocG9seSkgPT09IC0xKSBwb2x5c0V4Y2x1ZGUucHVzaChwb2x5KTtcblxuICAgICAgICAgIHZhciBfaW5kZXggPSBwb2x5c0FmdGVyLmluZGV4T2YoX3JpbmcucG9seSk7XG5cbiAgICAgICAgICBpZiAoX2luZGV4ICE9PSAtMSkgcG9seXNBZnRlci5zcGxpY2UoX2luZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBjYWxjdWxhdGUgbXVsdGlQb2x5c0FmdGVyXG5cblxuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2lNYXgyID0gcG9seXNBZnRlci5sZW5ndGg7IF9pMiA8IF9pTWF4MjsgX2kyKyspIHtcbiAgICAgICAgdmFyIG1wID0gcG9seXNBZnRlcltfaTJdLm11bHRpUG9seTtcbiAgICAgICAgaWYgKG1wc0FmdGVyLmluZGV4T2YobXApID09PSAtMSkgbXBzQWZ0ZXIucHVzaChtcCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9hZnRlclN0YXRlO1xuICAgIH1cbiAgICAvKiBJcyB0aGlzIHNlZ21lbnQgcGFydCBvZiB0aGUgZmluYWwgcmVzdWx0PyAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNJblJlc3VsdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0luUmVzdWx0KCkge1xuICAgICAgLy8gaWYgd2UndmUgYmVlbiBjb25zdW1lZCwgd2UncmUgbm90IGluIHRoZSByZXN1bHRcbiAgICAgIGlmICh0aGlzLmNvbnN1bWVkQnkpIHJldHVybiBmYWxzZTtcbiAgICAgIGlmICh0aGlzLl9pc0luUmVzdWx0ICE9PSB1bmRlZmluZWQpIHJldHVybiB0aGlzLl9pc0luUmVzdWx0O1xuICAgICAgdmFyIG1wc0JlZm9yZSA9IHRoaXMuYmVmb3JlU3RhdGUoKS5tdWx0aVBvbHlzO1xuICAgICAgdmFyIG1wc0FmdGVyID0gdGhpcy5hZnRlclN0YXRlKCkubXVsdGlQb2x5cztcblxuICAgICAgc3dpdGNoIChvcGVyYXRpb24udHlwZSkge1xuICAgICAgICBjYXNlICd1bmlvbic6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gVU5JT04gLSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgICAvLyAgKiBPbiBvbmUgc2lkZSBvZiB1cyB0aGVyZSBpcyAwIHBvbHkgaW50ZXJpb3JzIEFORFxuICAgICAgICAgICAgLy8gICogT24gdGhlIG90aGVyIHNpZGUgdGhlcmUgaXMgMSBvciBtb3JlLlxuICAgICAgICAgICAgdmFyIG5vQmVmb3JlcyA9IG1wc0JlZm9yZS5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB2YXIgbm9BZnRlcnMgPSBtcHNBZnRlci5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB0aGlzLl9pc0luUmVzdWx0ID0gbm9CZWZvcmVzICE9PSBub0FmdGVycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdpbnRlcnNlY3Rpb24nOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIElOVEVSU0VDVElPTiAtIGluY2x1ZGVkIGlmZjpcbiAgICAgICAgICAgIC8vICAqIG9uIG9uZSBzaWRlIG9mIHVzIGFsbCBtdWx0aXBvbHlzIGFyZSByZXAuIHdpdGggcG9seSBpbnRlcmlvcnMgQU5EXG4gICAgICAgICAgICAvLyAgKiBvbiB0aGUgb3RoZXIgc2lkZSBvZiB1cywgbm90IGFsbCBtdWx0aXBvbHlzIGFyZSByZXBzZW50ZWRcbiAgICAgICAgICAgIC8vICAgIHdpdGggcG9seSBpbnRlcmlvcnNcbiAgICAgICAgICAgIHZhciBsZWFzdDtcbiAgICAgICAgICAgIHZhciBtb3N0O1xuXG4gICAgICAgICAgICBpZiAobXBzQmVmb3JlLmxlbmd0aCA8IG1wc0FmdGVyLmxlbmd0aCkge1xuICAgICAgICAgICAgICBsZWFzdCA9IG1wc0JlZm9yZS5sZW5ndGg7XG4gICAgICAgICAgICAgIG1vc3QgPSBtcHNBZnRlci5sZW5ndGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsZWFzdCA9IG1wc0FmdGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgbW9zdCA9IG1wc0JlZm9yZS5sZW5ndGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2lzSW5SZXN1bHQgPSBtb3N0ID09PSBvcGVyYXRpb24ubnVtTXVsdGlQb2x5cyAmJiBsZWFzdCA8IG1vc3Q7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAneG9yJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBYT1IgLSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgICAvLyAgKiB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBudW1iZXIgb2YgbXVsdGlwb2x5cyByZXByZXNlbnRlZFxuICAgICAgICAgICAgLy8gICAgd2l0aCBwb2x5IGludGVyaW9ycyBvbiBvdXIgdHdvIHNpZGVzIGlzIGFuIG9kZCBudW1iZXJcbiAgICAgICAgICAgIHZhciBkaWZmID0gTWF0aC5hYnMobXBzQmVmb3JlLmxlbmd0aCAtIG1wc0FmdGVyLmxlbmd0aCk7XG4gICAgICAgICAgICB0aGlzLl9pc0luUmVzdWx0ID0gZGlmZiAlIDIgPT09IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnZGlmZmVyZW5jZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gRElGRkVSRU5DRSBpbmNsdWRlZCBpZmY6XG4gICAgICAgICAgICAvLyAgKiBvbiBleGFjdGx5IG9uZSBzaWRlLCB3ZSBoYXZlIGp1c3QgdGhlIHN1YmplY3RcbiAgICAgICAgICAgIHZhciBpc0p1c3RTdWJqZWN0ID0gZnVuY3Rpb24gaXNKdXN0U3ViamVjdChtcHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1wcy5sZW5ndGggPT09IDEgJiYgbXBzWzBdLmlzU3ViamVjdDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuX2lzSW5SZXN1bHQgPSBpc0p1c3RTdWJqZWN0KG1wc0JlZm9yZSkgIT09IGlzSnVzdFN1YmplY3QobXBzQWZ0ZXIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG9wZXJhdGlvbiB0eXBlIGZvdW5kIFwiLmNvbmNhdChvcGVyYXRpb24udHlwZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faXNJblJlc3VsdDtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tUmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUmluZyhwdDEsIHB0MiwgcmluZykge1xuICAgICAgdmFyIGxlZnRQdCwgcmlnaHRQdCwgd2luZGluZzsgLy8gb3JkZXJpbmcgdGhlIHR3byBwb2ludHMgYWNjb3JkaW5nIHRvIHN3ZWVwIGxpbmUgb3JkZXJpbmdcblxuICAgICAgdmFyIGNtcFB0cyA9IFN3ZWVwRXZlbnQuY29tcGFyZVBvaW50cyhwdDEsIHB0Mik7XG5cbiAgICAgIGlmIChjbXBQdHMgPCAwKSB7XG4gICAgICAgIGxlZnRQdCA9IHB0MTtcbiAgICAgICAgcmlnaHRQdCA9IHB0MjtcbiAgICAgICAgd2luZGluZyA9IDE7XG4gICAgICB9IGVsc2UgaWYgKGNtcFB0cyA+IDApIHtcbiAgICAgICAgbGVmdFB0ID0gcHQyO1xuICAgICAgICByaWdodFB0ID0gcHQxO1xuICAgICAgICB3aW5kaW5nID0gLTE7XG4gICAgICB9IGVsc2UgdGhyb3cgbmV3IEVycm9yKFwiVHJpZWQgdG8gY3JlYXRlIGRlZ2VuZXJhdGUgc2VnbWVudCBhdCBbXCIuY29uY2F0KHB0MS54LCBcIiwgXCIpLmNvbmNhdChwdDEueSwgXCJdXCIpKTtcblxuICAgICAgdmFyIGxlZnRTRSA9IG5ldyBTd2VlcEV2ZW50KGxlZnRQdCwgdHJ1ZSk7XG4gICAgICB2YXIgcmlnaHRTRSA9IG5ldyBTd2VlcEV2ZW50KHJpZ2h0UHQsIGZhbHNlKTtcbiAgICAgIHJldHVybiBuZXcgU2VnbWVudChsZWZ0U0UsIHJpZ2h0U0UsIFtyaW5nXSwgW3dpbmRpbmddKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2VnbWVudDtcbn0oKTtcblxudmFyIFJpbmdJbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJpbmdJbihnZW9tUmluZywgcG9seSwgaXNFeHRlcmlvcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSaW5nSW4pO1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGdlb21SaW5nKSB8fCBnZW9tUmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZ2VvbWV0cnkgaXMgbm90IGEgdmFsaWQgUG9seWdvbiBvciBNdWx0aVBvbHlnb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLnBvbHkgPSBwb2x5O1xuICAgIHRoaXMuaXNFeHRlcmlvciA9IGlzRXh0ZXJpb3I7XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuXG4gICAgaWYgKHR5cGVvZiBnZW9tUmluZ1swXVswXSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIGdlb21SaW5nWzBdWzFdICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvbicpO1xuICAgIH1cblxuICAgIHZhciBmaXJzdFBvaW50ID0gcm91bmRlci5yb3VuZChnZW9tUmluZ1swXVswXSwgZ2VvbVJpbmdbMF1bMV0pO1xuICAgIHRoaXMuYmJveCA9IHtcbiAgICAgIGxsOiB7XG4gICAgICAgIHg6IGZpcnN0UG9pbnQueCxcbiAgICAgICAgeTogZmlyc3RQb2ludC55XG4gICAgICB9LFxuICAgICAgdXI6IHtcbiAgICAgICAgeDogZmlyc3RQb2ludC54LFxuICAgICAgICB5OiBmaXJzdFBvaW50LnlcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwcmV2UG9pbnQgPSBmaXJzdFBvaW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGlNYXggPSBnZW9tUmluZy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGlmICh0eXBlb2YgZ2VvbVJpbmdbaV1bMF0gIT09ICdudW1iZXInIHx8IHR5cGVvZiBnZW9tUmluZ1tpXVsxXSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnQgPSByb3VuZGVyLnJvdW5kKGdlb21SaW5nW2ldWzBdLCBnZW9tUmluZ1tpXVsxXSk7IC8vIHNraXAgcmVwZWF0ZWQgcG9pbnRzXG5cbiAgICAgIGlmIChwb2ludC54ID09PSBwcmV2UG9pbnQueCAmJiBwb2ludC55ID09PSBwcmV2UG9pbnQueSkgY29udGludWU7XG4gICAgICB0aGlzLnNlZ21lbnRzLnB1c2goU2VnbWVudC5mcm9tUmluZyhwcmV2UG9pbnQsIHBvaW50LCB0aGlzKSk7XG4gICAgICBpZiAocG9pbnQueCA8IHRoaXMuYmJveC5sbC54KSB0aGlzLmJib3gubGwueCA9IHBvaW50Lng7XG4gICAgICBpZiAocG9pbnQueSA8IHRoaXMuYmJveC5sbC55KSB0aGlzLmJib3gubGwueSA9IHBvaW50Lnk7XG4gICAgICBpZiAocG9pbnQueCA+IHRoaXMuYmJveC51ci54KSB0aGlzLmJib3gudXIueCA9IHBvaW50Lng7XG4gICAgICBpZiAocG9pbnQueSA+IHRoaXMuYmJveC51ci55KSB0aGlzLmJib3gudXIueSA9IHBvaW50Lnk7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICB9IC8vIGFkZCBzZWdtZW50IGZyb20gbGFzdCB0byBmaXJzdCBpZiBsYXN0IGlzIG5vdCB0aGUgc2FtZSBhcyBmaXJzdFxuXG5cbiAgICBpZiAoZmlyc3RQb2ludC54ICE9PSBwcmV2UG9pbnQueCB8fCBmaXJzdFBvaW50LnkgIT09IHByZXZQb2ludC55KSB7XG4gICAgICB0aGlzLnNlZ21lbnRzLnB1c2goU2VnbWVudC5mcm9tUmluZyhwcmV2UG9pbnQsIGZpcnN0UG9pbnQsIHRoaXMpKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmluZ0luLCBbe1xuICAgIGtleTogXCJnZXRTd2VlcEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTd2VlcEV2ZW50cygpIHtcbiAgICAgIHZhciBzd2VlcEV2ZW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IHRoaXMuc2VnbWVudHMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgIHZhciBzZWdtZW50ID0gdGhpcy5zZWdtZW50c1tpXTtcbiAgICAgICAgc3dlZXBFdmVudHMucHVzaChzZWdtZW50LmxlZnRTRSk7XG4gICAgICAgIHN3ZWVwRXZlbnRzLnB1c2goc2VnbWVudC5yaWdodFNFKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN3ZWVwRXZlbnRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBSaW5nSW47XG59KCk7XG52YXIgUG9seUluID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seUluKGdlb21Qb2x5LCBtdWx0aVBvbHkpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9seUluKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShnZW9tUG9seSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5wdXQgZ2VvbWV0cnkgaXMgbm90IGEgdmFsaWQgUG9seWdvbiBvciBNdWx0aVBvbHlnb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLmV4dGVyaW9yUmluZyA9IG5ldyBSaW5nSW4oZ2VvbVBvbHlbMF0sIHRoaXMsIHRydWUpOyAvLyBjb3B5IGJ5IHZhbHVlXG5cbiAgICB0aGlzLmJib3ggPSB7XG4gICAgICBsbDoge1xuICAgICAgICB4OiB0aGlzLmV4dGVyaW9yUmluZy5iYm94LmxsLngsXG4gICAgICAgIHk6IHRoaXMuZXh0ZXJpb3JSaW5nLmJib3gubGwueVxuICAgICAgfSxcbiAgICAgIHVyOiB7XG4gICAgICAgIHg6IHRoaXMuZXh0ZXJpb3JSaW5nLmJib3gudXIueCxcbiAgICAgICAgeTogdGhpcy5leHRlcmlvclJpbmcuYmJveC51ci55XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmludGVyaW9yUmluZ3MgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAxLCBpTWF4ID0gZ2VvbVBvbHkubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICB2YXIgcmluZyA9IG5ldyBSaW5nSW4oZ2VvbVBvbHlbaV0sIHRoaXMsIGZhbHNlKTtcbiAgICAgIGlmIChyaW5nLmJib3gubGwueCA8IHRoaXMuYmJveC5sbC54KSB0aGlzLmJib3gubGwueCA9IHJpbmcuYmJveC5sbC54O1xuICAgICAgaWYgKHJpbmcuYmJveC5sbC55IDwgdGhpcy5iYm94LmxsLnkpIHRoaXMuYmJveC5sbC55ID0gcmluZy5iYm94LmxsLnk7XG4gICAgICBpZiAocmluZy5iYm94LnVyLnggPiB0aGlzLmJib3gudXIueCkgdGhpcy5iYm94LnVyLnggPSByaW5nLmJib3gudXIueDtcbiAgICAgIGlmIChyaW5nLmJib3gudXIueSA+IHRoaXMuYmJveC51ci55KSB0aGlzLmJib3gudXIueSA9IHJpbmcuYmJveC51ci55O1xuICAgICAgdGhpcy5pbnRlcmlvclJpbmdzLnB1c2gocmluZyk7XG4gICAgfVxuXG4gICAgdGhpcy5tdWx0aVBvbHkgPSBtdWx0aVBvbHk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9seUluLCBbe1xuICAgIGtleTogXCJnZXRTd2VlcEV2ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTd2VlcEV2ZW50cygpIHtcbiAgICAgIHZhciBzd2VlcEV2ZW50cyA9IHRoaXMuZXh0ZXJpb3JSaW5nLmdldFN3ZWVwRXZlbnRzKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpTWF4ID0gdGhpcy5pbnRlcmlvclJpbmdzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICB2YXIgcmluZ1N3ZWVwRXZlbnRzID0gdGhpcy5pbnRlcmlvclJpbmdzW2ldLmdldFN3ZWVwRXZlbnRzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpNYXggPSByaW5nU3dlZXBFdmVudHMubGVuZ3RoOyBqIDwgak1heDsgaisrKSB7XG4gICAgICAgICAgc3dlZXBFdmVudHMucHVzaChyaW5nU3dlZXBFdmVudHNbal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzd2VlcEV2ZW50cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9seUluO1xufSgpO1xudmFyIE11bHRpUG9seUluID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTXVsdGlQb2x5SW4oZ2VvbSwgaXNTdWJqZWN0KSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpUG9seUluKTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheShnZW9tKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBnZW9tZXRyeSBpcyBub3QgYSB2YWxpZCBQb2x5Z29uIG9yIE11bHRpUG9seWdvbicpO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZiB0aGUgaW5wdXQgbG9va3MgbGlrZSBhIHBvbHlnb24sIGNvbnZlcnQgaXQgdG8gYSBtdWx0aXBvbHlnb25cbiAgICAgIGlmICh0eXBlb2YgZ2VvbVswXVswXVswXSA9PT0gJ251bWJlcicpIGdlb20gPSBbZ2VvbV07XG4gICAgfSBjYXRjaCAoZXgpIHsvLyBUaGUgaW5wdXQgaXMgZWl0aGVyIG1hbGZvcm1lZCBvciBoYXMgZW1wdHkgYXJyYXlzLlxuICAgICAgLy8gSW4gZWl0aGVyIGNhc2UsIGl0IHdpbGwgYmUgaGFuZGxlZCBsYXRlciBvbi5cbiAgICB9XG5cbiAgICB0aGlzLnBvbHlzID0gW107XG4gICAgdGhpcy5iYm94ID0ge1xuICAgICAgbGw6IHtcbiAgICAgICAgeDogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICB5OiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFlcbiAgICAgIH0sXG4gICAgICB1cjoge1xuICAgICAgICB4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksXG4gICAgICAgIHk6IE51bWJlci5ORUdBVElWRV9JTkZJTklUWVxuICAgICAgfVxuICAgIH07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IGdlb20ubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICB2YXIgcG9seSA9IG5ldyBQb2x5SW4oZ2VvbVtpXSwgdGhpcyk7XG4gICAgICBpZiAocG9seS5iYm94LmxsLnggPCB0aGlzLmJib3gubGwueCkgdGhpcy5iYm94LmxsLnggPSBwb2x5LmJib3gubGwueDtcbiAgICAgIGlmIChwb2x5LmJib3gubGwueSA8IHRoaXMuYmJveC5sbC55KSB0aGlzLmJib3gubGwueSA9IHBvbHkuYmJveC5sbC55O1xuICAgICAgaWYgKHBvbHkuYmJveC51ci54ID4gdGhpcy5iYm94LnVyLngpIHRoaXMuYmJveC51ci54ID0gcG9seS5iYm94LnVyLng7XG4gICAgICBpZiAocG9seS5iYm94LnVyLnkgPiB0aGlzLmJib3gudXIueSkgdGhpcy5iYm94LnVyLnkgPSBwb2x5LmJib3gudXIueTtcbiAgICAgIHRoaXMucG9seXMucHVzaChwb2x5KTtcbiAgICB9XG5cbiAgICB0aGlzLmlzU3ViamVjdCA9IGlzU3ViamVjdDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNdWx0aVBvbHlJbiwgW3tcbiAgICBrZXk6IFwiZ2V0U3dlZXBFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3dlZXBFdmVudHMoKSB7XG4gICAgICB2YXIgc3dlZXBFdmVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlNYXggPSB0aGlzLnBvbHlzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICB2YXIgcG9seVN3ZWVwRXZlbnRzID0gdGhpcy5wb2x5c1tpXS5nZXRTd2VlcEV2ZW50cygpO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwLCBqTWF4ID0gcG9seVN3ZWVwRXZlbnRzLmxlbmd0aDsgaiA8IGpNYXg7IGorKykge1xuICAgICAgICAgIHN3ZWVwRXZlbnRzLnB1c2gocG9seVN3ZWVwRXZlbnRzW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3dlZXBFdmVudHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE11bHRpUG9seUluO1xufSgpO1xuXG52YXIgUmluZ091dCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhSaW5nT3V0LCBudWxsLCBbe1xuICAgIGtleTogXCJmYWN0b3J5XCIsXG5cbiAgICAvKiBHaXZlbiB0aGUgc2VnbWVudHMgZnJvbSB0aGUgc3dlZXAgbGluZSBwYXNzLCBjb21wdXRlICYgcmV0dXJuIGEgc2VyaWVzXG4gICAgICogb2YgY2xvc2VkIHJpbmdzIGZyb20gYWxsIHRoZSBzZWdtZW50cyBtYXJrZWQgdG8gYmUgcGFydCBvZiB0aGUgcmVzdWx0ICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZhY3RvcnkoYWxsU2VnbWVudHMpIHtcbiAgICAgIHZhciByaW5nc091dCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IGFsbFNlZ21lbnRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGFsbFNlZ21lbnRzW2ldO1xuICAgICAgICBpZiAoIXNlZ21lbnQuaXNJblJlc3VsdCgpIHx8IHNlZ21lbnQucmluZ091dCkgY29udGludWU7XG4gICAgICAgIHZhciBwcmV2RXZlbnQgPSBudWxsO1xuICAgICAgICB2YXIgZXZlbnQgPSBzZWdtZW50LmxlZnRTRTtcbiAgICAgICAgdmFyIG5leHRFdmVudCA9IHNlZ21lbnQucmlnaHRTRTtcbiAgICAgICAgdmFyIGV2ZW50cyA9IFtldmVudF07XG4gICAgICAgIHZhciBzdGFydGluZ1BvaW50ID0gZXZlbnQucG9pbnQ7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25MRXMgPSBbXTtcbiAgICAgICAgLyogV2FsayB0aGUgY2hhaW4gb2YgbGlua2VkIGV2ZW50cyB0byBmb3JtIGEgY2xvc2VkIHJpbmcgKi9cblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHByZXZFdmVudCA9IGV2ZW50O1xuICAgICAgICAgIGV2ZW50ID0gbmV4dEV2ZW50O1xuICAgICAgICAgIGV2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAvKiBJcyB0aGUgcmluZyBjb21wbGV0ZT8gKi9cblxuICAgICAgICAgIGlmIChldmVudC5wb2ludCA9PT0gc3RhcnRpbmdQb2ludCkgYnJlYWs7XG5cbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZUxFcyA9IGV2ZW50LmdldEF2YWlsYWJsZUxpbmtlZEV2ZW50cygpO1xuICAgICAgICAgICAgLyogRGlkIHdlIGhpdCBhIGRlYWQgZW5kPyBUaGlzIHNob3VsZG4ndCBoYXBwZW4uIEluZGljYXRlcyBzb21lIGVhcmxpZXJcbiAgICAgICAgICAgICAqIHBhcnQgb2YgdGhlIGFsZ29yaXRobSBtYWxmdW5jdGlvbmVkLi4uIHBsZWFzZSBmaWxlIGEgYnVnIHJlcG9ydC4gKi9cblxuICAgICAgICAgICAgaWYgKGF2YWlsYWJsZUxFcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0UHQgPSBldmVudHNbMF0ucG9pbnQ7XG4gICAgICAgICAgICAgIHZhciBsYXN0UHQgPSBldmVudHNbZXZlbnRzLmxlbmd0aCAtIDFdLnBvaW50O1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gY29tcGxldGUgb3V0cHV0IHJpbmcgc3RhcnRpbmcgYXQgW1wiLmNvbmNhdChmaXJzdFB0LngsIFwiLFwiKSArIFwiIFwiLmNvbmNhdChmaXJzdFB0LnksIFwiXS4gTGFzdCBtYXRjaGluZyBzZWdtZW50IGZvdW5kIGVuZHMgYXRcIikgKyBcIiBbXCIuY29uY2F0KGxhc3RQdC54LCBcIiwgXCIpLmNvbmNhdChsYXN0UHQueSwgXCJdLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBPbmx5IG9uZSB3YXkgdG8gZ28sIHNvIGNvdGludWUgb24gdGhlIHBhdGggKi9cblxuXG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlTEVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICBuZXh0RXZlbnQgPSBhdmFpbGFibGVMRXNbMF0ub3RoZXJTRTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBXZSBtdXN0IGhhdmUgYW4gaW50ZXJzZWN0aW9uLiBDaGVjayBmb3IgYSBjb21wbGV0ZWQgbG9vcCAqL1xuXG5cbiAgICAgICAgICAgIHZhciBpbmRleExFID0gbnVsbDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpNYXggPSBpbnRlcnNlY3Rpb25MRXMubGVuZ3RoOyBqIDwgak1heDsgaisrKSB7XG4gICAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb25MRXNbal0ucG9pbnQgPT09IGV2ZW50LnBvaW50KSB7XG4gICAgICAgICAgICAgICAgaW5kZXhMRSA9IGo7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIEZvdW5kIGEgY29tcGxldGVkIGxvb3AuIEN1dCB0aGF0IG9mZiBhbmQgbWFrZSBhIHJpbmcgKi9cblxuXG4gICAgICAgICAgICBpZiAoaW5kZXhMRSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uTEUgPSBpbnRlcnNlY3Rpb25MRXMuc3BsaWNlKGluZGV4TEUpWzBdO1xuICAgICAgICAgICAgICB2YXIgcmluZ0V2ZW50cyA9IGV2ZW50cy5zcGxpY2UoaW50ZXJzZWN0aW9uTEUuaW5kZXgpO1xuICAgICAgICAgICAgICByaW5nRXZlbnRzLnVuc2hpZnQocmluZ0V2ZW50c1swXS5vdGhlclNFKTtcbiAgICAgICAgICAgICAgcmluZ3NPdXQucHVzaChuZXcgUmluZ091dChyaW5nRXZlbnRzLnJldmVyc2UoKSkpO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHJlZ2lzdGVyIHRoZSBpbnRlcnNlY3Rpb24gKi9cblxuXG4gICAgICAgICAgICBpbnRlcnNlY3Rpb25MRXMucHVzaCh7XG4gICAgICAgICAgICAgIGluZGV4OiBldmVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICBwb2ludDogZXZlbnQucG9pbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyogQ2hvb3NlIHRoZSBsZWZ0LW1vc3Qgb3B0aW9uIHRvIGNvbnRpbnVlIHRoZSB3YWxrICovXG5cbiAgICAgICAgICAgIHZhciBjb21wYXJhdG9yID0gZXZlbnQuZ2V0TGVmdG1vc3RDb21wYXJhdG9yKHByZXZFdmVudCk7XG4gICAgICAgICAgICBuZXh0RXZlbnQgPSBhdmFpbGFibGVMRXMuc29ydChjb21wYXJhdG9yKVswXS5vdGhlclNFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmluZ3NPdXQucHVzaChuZXcgUmluZ091dChldmVudHMpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJpbmdzT3V0O1xuICAgIH1cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFJpbmdPdXQoZXZlbnRzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJpbmdPdXQpO1xuXG4gICAgdGhpcy5ldmVudHMgPSBldmVudHM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IGV2ZW50cy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgIGV2ZW50c1tpXS5zZWdtZW50LnJpbmdPdXQgPSB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMucG9seSA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmluZ091dCwgW3tcbiAgICBrZXk6IFwiZ2V0R2VvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHZW9tKCkge1xuICAgICAgLy8gUmVtb3ZlIHN1cGVyZmx1b3VzIHBvaW50cyAoaWUgZXh0cmEgcG9pbnRzIGFsb25nIGEgc3RyYWlnaHQgbGluZSksXG4gICAgICB2YXIgcHJldlB0ID0gdGhpcy5ldmVudHNbMF0ucG9pbnQ7XG4gICAgICB2YXIgcG9pbnRzID0gW3ByZXZQdF07XG5cbiAgICAgIGZvciAodmFyIGkgPSAxLCBpTWF4ID0gdGhpcy5ldmVudHMubGVuZ3RoIC0gMTsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICB2YXIgX3B0ID0gdGhpcy5ldmVudHNbaV0ucG9pbnQ7XG4gICAgICAgIHZhciBfbmV4dFB0ID0gdGhpcy5ldmVudHNbaSArIDFdLnBvaW50O1xuICAgICAgICBpZiAoY29tcGFyZVZlY3RvckFuZ2xlcyhfcHQsIHByZXZQdCwgX25leHRQdCkgPT09IDApIGNvbnRpbnVlO1xuICAgICAgICBwb2ludHMucHVzaChfcHQpO1xuICAgICAgICBwcmV2UHQgPSBfcHQ7XG4gICAgICB9IC8vIHJpbmcgd2FzIGFsbCAod2l0aGluIHJvdW5kaW5nIGVycm9yIG9mIGFuZ2xlIGNhbGMpIGNvbGluZWFyIHBvaW50c1xuXG5cbiAgICAgIGlmIChwb2ludHMubGVuZ3RoID09PSAxKSByZXR1cm4gbnVsbDsgLy8gY2hlY2sgaWYgdGhlIHN0YXJ0aW5nIHBvaW50IGlzIG5lY2Vzc2FyeVxuXG4gICAgICB2YXIgcHQgPSBwb2ludHNbMF07XG4gICAgICB2YXIgbmV4dFB0ID0gcG9pbnRzWzFdO1xuICAgICAgaWYgKGNvbXBhcmVWZWN0b3JBbmdsZXMocHQsIHByZXZQdCwgbmV4dFB0KSA9PT0gMCkgcG9pbnRzLnNoaWZ0KCk7XG4gICAgICBwb2ludHMucHVzaChwb2ludHNbMF0pO1xuICAgICAgdmFyIHN0ZXAgPSB0aGlzLmlzRXh0ZXJpb3JSaW5nKCkgPyAxIDogLTE7XG4gICAgICB2YXIgaVN0YXJ0ID0gdGhpcy5pc0V4dGVyaW9yUmluZygpID8gMCA6IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGlFbmQgPSB0aGlzLmlzRXh0ZXJpb3JSaW5nKCkgPyBwb2ludHMubGVuZ3RoIDogLTE7XG4gICAgICB2YXIgb3JkZXJlZFBvaW50cyA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBfaSA9IGlTdGFydDsgX2kgIT0gaUVuZDsgX2kgKz0gc3RlcCkge1xuICAgICAgICBvcmRlcmVkUG9pbnRzLnB1c2goW3BvaW50c1tfaV0ueCwgcG9pbnRzW19pXS55XSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvcmRlcmVkUG9pbnRzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0V4dGVyaW9yUmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0V4dGVyaW9yUmluZygpIHtcbiAgICAgIGlmICh0aGlzLl9pc0V4dGVyaW9yUmluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBlbmNsb3NpbmcgPSB0aGlzLmVuY2xvc2luZ1JpbmcoKTtcbiAgICAgICAgdGhpcy5faXNFeHRlcmlvclJpbmcgPSBlbmNsb3NpbmcgPyAhZW5jbG9zaW5nLmlzRXh0ZXJpb3JSaW5nKCkgOiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5faXNFeHRlcmlvclJpbmc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImVuY2xvc2luZ1JpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5jbG9zaW5nUmluZygpIHtcbiAgICAgIGlmICh0aGlzLl9lbmNsb3NpbmdSaW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fZW5jbG9zaW5nUmluZyA9IHRoaXMuX2NhbGNFbmNsb3NpbmdSaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9lbmNsb3NpbmdSaW5nO1xuICAgIH1cbiAgICAvKiBSZXR1cm5zIHRoZSByaW5nIHRoYXQgZW5jbG9zZXMgdGhpcyBvbmUsIGlmIGFueSAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2NhbGNFbmNsb3NpbmdSaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjRW5jbG9zaW5nUmluZygpIHtcbiAgICAgIC8vIHN0YXJ0IHdpdGggdGhlIGVhbGllciBzd2VlcCBsaW5lIGV2ZW50IHNvIHRoYXQgdGhlIHByZXZTZWdcbiAgICAgIC8vIGNoYWluIGRvZXNuJ3QgbGVhZCB1cyBpbnNpZGUgb2YgYSBsb29wIG9mIG91cnNcbiAgICAgIHZhciBsZWZ0TW9zdEV2dCA9IHRoaXMuZXZlbnRzWzBdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMSwgaU1heCA9IHRoaXMuZXZlbnRzLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICB2YXIgZXZ0ID0gdGhpcy5ldmVudHNbaV07XG4gICAgICAgIGlmIChTd2VlcEV2ZW50LmNvbXBhcmUobGVmdE1vc3RFdnQsIGV2dCkgPiAwKSBsZWZ0TW9zdEV2dCA9IGV2dDtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZTZWcgPSBsZWZ0TW9zdEV2dC5zZWdtZW50LnByZXZJblJlc3VsdCgpO1xuICAgICAgdmFyIHByZXZQcmV2U2VnID0gcHJldlNlZyA/IHByZXZTZWcucHJldkluUmVzdWx0KCkgOiBudWxsO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBubyBzZWdtZW50IGZvdW5kLCB0aHVzIG5vIHJpbmcgY2FuIGVuY2xvc2UgdXNcbiAgICAgICAgaWYgKCFwcmV2U2VnKSByZXR1cm4gbnVsbDsgLy8gbm8gc2VnbWVudHMgYmVsb3cgcHJldiBzZWdtZW50IGZvdW5kLCB0aHVzIHRoZSByaW5nIG9mIHRoZSBwcmV2XG4gICAgICAgIC8vIHNlZ21lbnQgbXVzdCBsb29wIGJhY2sgYXJvdW5kIGFuZCBlbmNsb3NlIHVzXG5cbiAgICAgICAgaWYgKCFwcmV2UHJldlNlZykgcmV0dXJuIHByZXZTZWcucmluZ091dDsgLy8gaWYgdGhlIHR3byBzZWdtZW50cyBhcmUgb2YgZGlmZmVyZW50IHJpbmdzLCB0aGUgcmluZyBvZiB0aGUgcHJldlxuICAgICAgICAvLyBzZWdtZW50IG11c3QgZWl0aGVyIGxvb3AgYXJvdW5kIHVzIG9yIHRoZSByaW5nIG9mIHRoZSBwcmV2IHByZXZcbiAgICAgICAgLy8gc2VnLCB3aGljaCB3b3VsZCBtYWtlIHVzIGFuZCB0aGUgcmluZyBvZiB0aGUgcHJldiBwZWVyc1xuXG4gICAgICAgIGlmIChwcmV2UHJldlNlZy5yaW5nT3V0ICE9PSBwcmV2U2VnLnJpbmdPdXQpIHtcbiAgICAgICAgICBpZiAocHJldlByZXZTZWcucmluZ091dC5lbmNsb3NpbmdSaW5nKCkgIT09IHByZXZTZWcucmluZ091dCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZTZWcucmluZ091dDtcbiAgICAgICAgICB9IGVsc2UgcmV0dXJuIHByZXZTZWcucmluZ091dC5lbmNsb3NpbmdSaW5nKCk7XG4gICAgICAgIH0gLy8gdHdvIHNlZ21lbnRzIGFyZSBmcm9tIHRoZSBzYW1lIHJpbmcsIHNvIHRoaXMgd2FzIGEgcGVuaXN1bGFcbiAgICAgICAgLy8gb2YgdGhhdCByaW5nLiBpdGVyYXRlIGRvd253YXJkLCBrZWVwIHNlYXJjaGluZ1xuXG5cbiAgICAgICAgcHJldlNlZyA9IHByZXZQcmV2U2VnLnByZXZJblJlc3VsdCgpO1xuICAgICAgICBwcmV2UHJldlNlZyA9IHByZXZTZWcgPyBwcmV2U2VnLnByZXZJblJlc3VsdCgpIDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmluZ091dDtcbn0oKTtcbnZhciBQb2x5T3V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUG9seU91dChleHRlcmlvclJpbmcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9seU91dCk7XG5cbiAgICB0aGlzLmV4dGVyaW9yUmluZyA9IGV4dGVyaW9yUmluZztcbiAgICBleHRlcmlvclJpbmcucG9seSA9IHRoaXM7XG4gICAgdGhpcy5pbnRlcmlvclJpbmdzID0gW107XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9seU91dCwgW3tcbiAgICBrZXk6IFwiYWRkSW50ZXJpb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW50ZXJpb3IocmluZykge1xuICAgICAgdGhpcy5pbnRlcmlvclJpbmdzLnB1c2gocmluZyk7XG4gICAgICByaW5nLnBvbHkgPSB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRHZW9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdlb20oKSB7XG4gICAgICB2YXIgZ2VvbSA9IFt0aGlzLmV4dGVyaW9yUmluZy5nZXRHZW9tKCldOyAvLyBleHRlcmlvciByaW5nIHdhcyBhbGwgKHdpdGhpbiByb3VuZGluZyBlcnJvciBvZiBhbmdsZSBjYWxjKSBjb2xpbmVhciBwb2ludHNcblxuICAgICAgaWYgKGdlb21bMF0gPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IHRoaXMuaW50ZXJpb3JSaW5ncy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmdHZW9tID0gdGhpcy5pbnRlcmlvclJpbmdzW2ldLmdldEdlb20oKTsgLy8gaW50ZXJpb3IgcmluZyB3YXMgYWxsICh3aXRoaW4gcm91bmRpbmcgZXJyb3Igb2YgYW5nbGUgY2FsYykgY29saW5lYXIgcG9pbnRzXG5cbiAgICAgICAgaWYgKHJpbmdHZW9tID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgZ2VvbS5wdXNoKHJpbmdHZW9tKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdlb207XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbHlPdXQ7XG59KCk7XG52YXIgTXVsdGlQb2x5T3V0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTXVsdGlQb2x5T3V0KHJpbmdzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE11bHRpUG9seU91dCk7XG5cbiAgICB0aGlzLnJpbmdzID0gcmluZ3M7XG4gICAgdGhpcy5wb2x5cyA9IHRoaXMuX2NvbXBvc2VQb2x5cyhyaW5ncyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTXVsdGlQb2x5T3V0LCBbe1xuICAgIGtleTogXCJnZXRHZW9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdlb20oKSB7XG4gICAgICB2YXIgZ2VvbSA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IHRoaXMucG9seXMubGVuZ3RoOyBpIDwgaU1heDsgaSsrKSB7XG4gICAgICAgIHZhciBwb2x5R2VvbSA9IHRoaXMucG9seXNbaV0uZ2V0R2VvbSgpOyAvLyBleHRlcmlvciByaW5nIHdhcyBhbGwgKHdpdGhpbiByb3VuZGluZyBlcnJvciBvZiBhbmdsZSBjYWxjKSBjb2xpbmVhciBwb2ludHNcblxuICAgICAgICBpZiAocG9seUdlb20gPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgICBnZW9tLnB1c2gocG9seUdlb20pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2VvbTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbXBvc2VQb2x5c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcG9zZVBvbHlzKHJpbmdzKSB7XG4gICAgICB2YXIgcG9seXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlNYXggPSByaW5ncy5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSByaW5nc1tpXTtcbiAgICAgICAgaWYgKHJpbmcucG9seSkgY29udGludWU7XG4gICAgICAgIGlmIChyaW5nLmlzRXh0ZXJpb3JSaW5nKCkpIHBvbHlzLnB1c2gobmV3IFBvbHlPdXQocmluZykpO2Vsc2Uge1xuICAgICAgICAgIHZhciBlbmNsb3NpbmdSaW5nID0gcmluZy5lbmNsb3NpbmdSaW5nKCk7XG4gICAgICAgICAgaWYgKCFlbmNsb3NpbmdSaW5nLnBvbHkpIHBvbHlzLnB1c2gobmV3IFBvbHlPdXQoZW5jbG9zaW5nUmluZykpO1xuICAgICAgICAgIGVuY2xvc2luZ1JpbmcucG9seS5hZGRJbnRlcmlvcihyaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcG9seXM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE11bHRpUG9seU91dDtcbn0oKTtcblxuLyoqXG4gKiBOT1RFOiAgV2UgbXVzdCBiZSBjYXJlZnVsIG5vdCB0byBjaGFuZ2UgYW55IHNlZ21lbnRzIHdoaWxlXG4gKiAgICAgICAgdGhleSBhcmUgaW4gdGhlIFNwbGF5VHJlZS4gQUZBSUssIHRoZXJlJ3Mgbm8gd2F5IHRvIHRlbGxcbiAqICAgICAgICB0aGUgdHJlZSB0byByZWJhbGFuY2UgaXRzZWxmIC0gdGh1cyBiZWZvcmUgc3BsaXR0aW5nXG4gKiAgICAgICAgYSBzZWdtZW50IHRoYXQncyBpbiB0aGUgdHJlZSwgd2UgcmVtb3ZlIGl0IGZyb20gdGhlIHRyZWUsXG4gKiAgICAgICAgZG8gdGhlIHNwbGl0LCB0aGVuIHJlLWluc2VydCBpdC4gKEV2ZW4gdGhvdWdoIHNwbGl0dGluZyBhXG4gKiAgICAgICAgc2VnbWVudCAqc2hvdWxkbid0KiBjaGFuZ2UgaXRzIGNvcnJlY3QgcG9zaXRpb24gaW4gdGhlXG4gKiAgICAgICAgc3dlZXAgbGluZSB0cmVlLCB0aGUgcmVhbGl0eSBpcyBiZWNhdXNlIG9mIHJvdW5kaW5nIGVycm9ycyxcbiAqICAgICAgICBpdCBzb21ldGltZXMgZG9lcy4pXG4gKi9cblxudmFyIFN3ZWVwTGluZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN3ZWVwTGluZShxdWV1ZSkge1xuICAgIHZhciBjb21wYXJhdG9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBTZWdtZW50LmNvbXBhcmU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3dlZXBMaW5lKTtcblxuICAgIHRoaXMucXVldWUgPSBxdWV1ZTtcbiAgICB0aGlzLnRyZWUgPSBuZXcgU3BsYXlUcmVlX19kZWZhdWx0WydkZWZhdWx0J10oY29tcGFyYXRvcik7XG4gICAgdGhpcy5zZWdtZW50cyA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN3ZWVwTGluZSwgW3tcbiAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKGV2ZW50KSB7XG4gICAgICB2YXIgc2VnbWVudCA9IGV2ZW50LnNlZ21lbnQ7XG4gICAgICB2YXIgbmV3RXZlbnRzID0gW107IC8vIGlmIHdlJ3ZlIGFscmVhZHkgYmVlbiBjb25zdW1lZCBieSBhbm90aGVyIHNlZ21lbnQsXG4gICAgICAvLyBjbGVhbiB1cCBvdXIgYm9keSBwYXJ0cyBhbmQgZ2V0IG91dFxuXG4gICAgICBpZiAoZXZlbnQuY29uc3VtZWRCeSkge1xuICAgICAgICBpZiAoZXZlbnQuaXNMZWZ0KSB0aGlzLnF1ZXVlLnJlbW92ZShldmVudC5vdGhlclNFKTtlbHNlIHRoaXMudHJlZS5yZW1vdmUoc2VnbWVudCk7XG4gICAgICAgIHJldHVybiBuZXdFdmVudHM7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gZXZlbnQuaXNMZWZ0ID8gdGhpcy50cmVlLmluc2VydChzZWdtZW50KSA6IHRoaXMudHJlZS5maW5kKHNlZ21lbnQpO1xuICAgICAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBzZWdtZW50ICNcIi5jb25jYXQoc2VnbWVudC5pZCwgXCIgXCIpICsgXCJbXCIuY29uY2F0KHNlZ21lbnQubGVmdFNFLnBvaW50LngsIFwiLCBcIikuY29uY2F0KHNlZ21lbnQubGVmdFNFLnBvaW50LnksIFwiXSAtPiBcIikgKyBcIltcIi5jb25jYXQoc2VnbWVudC5yaWdodFNFLnBvaW50LngsIFwiLCBcIikuY29uY2F0KHNlZ21lbnQucmlnaHRTRS5wb2ludC55LCBcIl0gXCIpICsgJ2luIFN3ZWVwTGluZSB0cmVlLiBQbGVhc2Ugc3VibWl0IGEgYnVnIHJlcG9ydC4nKTtcbiAgICAgIHZhciBwcmV2Tm9kZSA9IG5vZGU7XG4gICAgICB2YXIgbmV4dE5vZGUgPSBub2RlO1xuICAgICAgdmFyIHByZXZTZWcgPSB1bmRlZmluZWQ7XG4gICAgICB2YXIgbmV4dFNlZyA9IHVuZGVmaW5lZDsgLy8gc2tpcCBjb25zdW1lZCBzZWdtZW50cyBzdGlsbCBpbiB0cmVlXG5cbiAgICAgIHdoaWxlIChwcmV2U2VnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJldk5vZGUgPSB0aGlzLnRyZWUucHJldihwcmV2Tm9kZSk7XG4gICAgICAgIGlmIChwcmV2Tm9kZSA9PT0gbnVsbCkgcHJldlNlZyA9IG51bGw7ZWxzZSBpZiAocHJldk5vZGUua2V5LmNvbnN1bWVkQnkgPT09IHVuZGVmaW5lZCkgcHJldlNlZyA9IHByZXZOb2RlLmtleTtcbiAgICAgIH0gLy8gc2tpcCBjb25zdW1lZCBzZWdtZW50cyBzdGlsbCBpbiB0cmVlXG5cblxuICAgICAgd2hpbGUgKG5leHRTZWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXh0Tm9kZSA9IHRoaXMudHJlZS5uZXh0KG5leHROb2RlKTtcbiAgICAgICAgaWYgKG5leHROb2RlID09PSBudWxsKSBuZXh0U2VnID0gbnVsbDtlbHNlIGlmIChuZXh0Tm9kZS5rZXkuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSBuZXh0U2VnID0gbmV4dE5vZGUua2V5O1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZlbnQuaXNMZWZ0KSB7XG4gICAgICAgIC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb25zIGFnYWluc3QgdGhlIHByZXZpb3VzIHNlZ21lbnQgaW4gdGhlIHN3ZWVwIGxpbmVcbiAgICAgICAgdmFyIHByZXZNeVNwbGl0dGVyID0gbnVsbDtcblxuICAgICAgICBpZiAocHJldlNlZykge1xuICAgICAgICAgIHZhciBwcmV2SW50ZXIgPSBwcmV2U2VnLmdldEludGVyc2VjdGlvbihzZWdtZW50KTtcblxuICAgICAgICAgIGlmIChwcmV2SW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghc2VnbWVudC5pc0FuRW5kcG9pbnQocHJldkludGVyKSkgcHJldk15U3BsaXR0ZXIgPSBwcmV2SW50ZXI7XG5cbiAgICAgICAgICAgIGlmICghcHJldlNlZy5pc0FuRW5kcG9pbnQocHJldkludGVyKSkge1xuICAgICAgICAgICAgICB2YXIgbmV3RXZlbnRzRnJvbVNwbGl0ID0gdGhpcy5fc3BsaXRTYWZlbHkocHJldlNlZywgcHJldkludGVyKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaU1heCA9IG5ld0V2ZW50c0Zyb21TcGxpdC5sZW5ndGg7IGkgPCBpTWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChuZXdFdmVudHNGcm9tU3BsaXRbaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENoZWNrIGZvciBpbnRlcnNlY3Rpb25zIGFnYWluc3QgdGhlIG5leHQgc2VnbWVudCBpbiB0aGUgc3dlZXAgbGluZVxuXG5cbiAgICAgICAgdmFyIG5leHRNeVNwbGl0dGVyID0gbnVsbDtcblxuICAgICAgICBpZiAobmV4dFNlZykge1xuICAgICAgICAgIHZhciBuZXh0SW50ZXIgPSBuZXh0U2VnLmdldEludGVyc2VjdGlvbihzZWdtZW50KTtcblxuICAgICAgICAgIGlmIChuZXh0SW50ZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghc2VnbWVudC5pc0FuRW5kcG9pbnQobmV4dEludGVyKSkgbmV4dE15U3BsaXR0ZXIgPSBuZXh0SW50ZXI7XG5cbiAgICAgICAgICAgIGlmICghbmV4dFNlZy5pc0FuRW5kcG9pbnQobmV4dEludGVyKSkge1xuICAgICAgICAgICAgICB2YXIgX25ld0V2ZW50c0Zyb21TcGxpdCA9IHRoaXMuX3NwbGl0U2FmZWx5KG5leHRTZWcsIG5leHRJbnRlcik7XG5cbiAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfaU1heCA9IF9uZXdFdmVudHNGcm9tU3BsaXQubGVuZ3RoOyBfaSA8IF9pTWF4OyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgbmV3RXZlbnRzLnB1c2goX25ld0V2ZW50c0Zyb21TcGxpdFtfaV0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZvciBzaW1wbGljaXR5LCBldmVuIGlmIHdlIGZpbmQgbW9yZSB0aGFuIG9uZSBpbnRlcnNlY3Rpb24gd2Ugb25seVxuICAgICAgICAvLyBzcGlsdCBvbiB0aGUgJ2VhcmxpZXN0JyAoc3dlZXAtbGluZSBzdHlsZSkgb2YgdGhlIGludGVyc2VjdGlvbnMuXG4gICAgICAgIC8vIFRoZSBvdGhlciBpbnRlcnNlY3Rpb24gd2lsbCBiZSBoYW5kbGVkIGluIGEgZnV0dXJlIHByb2Nlc3MoKS5cblxuXG4gICAgICAgIGlmIChwcmV2TXlTcGxpdHRlciAhPT0gbnVsbCB8fCBuZXh0TXlTcGxpdHRlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBteVNwbGl0dGVyID0gbnVsbDtcbiAgICAgICAgICBpZiAocHJldk15U3BsaXR0ZXIgPT09IG51bGwpIG15U3BsaXR0ZXIgPSBuZXh0TXlTcGxpdHRlcjtlbHNlIGlmIChuZXh0TXlTcGxpdHRlciA9PT0gbnVsbCkgbXlTcGxpdHRlciA9IHByZXZNeVNwbGl0dGVyO2Vsc2Uge1xuICAgICAgICAgICAgdmFyIGNtcFNwbGl0dGVycyA9IFN3ZWVwRXZlbnQuY29tcGFyZVBvaW50cyhwcmV2TXlTcGxpdHRlciwgbmV4dE15U3BsaXR0ZXIpO1xuICAgICAgICAgICAgbXlTcGxpdHRlciA9IGNtcFNwbGl0dGVycyA8PSAwID8gcHJldk15U3BsaXR0ZXIgOiBuZXh0TXlTcGxpdHRlcjtcbiAgICAgICAgICB9IC8vIFJvdW5kaW5nIGVycm9ycyBjYW4gY2F1c2UgY2hhbmdlcyBpbiBvcmRlcmluZyxcbiAgICAgICAgICAvLyBzbyByZW1vdmUgYWZlY3RlZCBzZWdtZW50cyBhbmQgcmlnaHQgc3dlZXAgZXZlbnRzIGJlZm9yZSBzcGxpdHRpbmdcblxuICAgICAgICAgIHRoaXMucXVldWUucmVtb3ZlKHNlZ21lbnQucmlnaHRTRSk7XG4gICAgICAgICAgbmV3RXZlbnRzLnB1c2goc2VnbWVudC5yaWdodFNFKTtcblxuICAgICAgICAgIHZhciBfbmV3RXZlbnRzRnJvbVNwbGl0MiA9IHNlZ21lbnQuc3BsaXQobXlTcGxpdHRlcik7XG5cbiAgICAgICAgICBmb3IgKHZhciBfaTIgPSAwLCBfaU1heDIgPSBfbmV3RXZlbnRzRnJvbVNwbGl0Mi5sZW5ndGg7IF9pMiA8IF9pTWF4MjsgX2kyKyspIHtcbiAgICAgICAgICAgIG5ld0V2ZW50cy5wdXNoKF9uZXdFdmVudHNGcm9tU3BsaXQyW19pMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXdFdmVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIC8vIFdlIGZvdW5kIHNvbWUgaW50ZXJzZWN0aW9ucywgc28gcmUtZG8gdGhlIGN1cnJlbnQgZXZlbnQgdG9cbiAgICAgICAgICAvLyBtYWtlIHN1cmUgc3dlZXAgbGluZSBvcmRlcmluZyBpcyB0b3RhbGx5IGNvbnNpc3RlbnQgZm9yIGxhdGVyXG4gICAgICAgICAgLy8gdXNlIHdpdGggdGhlIHNlZ21lbnQgJ3ByZXYnIHBvaW50ZXJzXG4gICAgICAgICAgdGhpcy50cmVlLnJlbW92ZShzZWdtZW50KTtcbiAgICAgICAgICBuZXdFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gZG9uZSB3aXRoIGxlZnQgZXZlbnRcbiAgICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgc2VnbWVudC5wcmV2ID0gcHJldlNlZztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZXZlbnQuaXNSaWdodFxuICAgICAgICAvLyBzaW5jZSB3ZSdyZSBhYm91dCB0byBiZSByZW1vdmVkIGZyb20gdGhlIHN3ZWVwIGxpbmUsIGNoZWNrIGZvclxuICAgICAgICAvLyBpbnRlcnNlY3Rpb25zIGJldHdlZW4gb3VyIHByZXZpb3VzIGFuZCBuZXh0IHNlZ21lbnRzXG4gICAgICAgIGlmIChwcmV2U2VnICYmIG5leHRTZWcpIHtcbiAgICAgICAgICB2YXIgaW50ZXIgPSBwcmV2U2VnLmdldEludGVyc2VjdGlvbihuZXh0U2VnKTtcblxuICAgICAgICAgIGlmIChpbnRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCFwcmV2U2VnLmlzQW5FbmRwb2ludChpbnRlcikpIHtcbiAgICAgICAgICAgICAgdmFyIF9uZXdFdmVudHNGcm9tU3BsaXQzID0gdGhpcy5fc3BsaXRTYWZlbHkocHJldlNlZywgaW50ZXIpO1xuXG4gICAgICAgICAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9pTWF4MyA9IF9uZXdFdmVudHNGcm9tU3BsaXQzLmxlbmd0aDsgX2kzIDwgX2lNYXgzOyBfaTMrKykge1xuICAgICAgICAgICAgICAgIG5ld0V2ZW50cy5wdXNoKF9uZXdFdmVudHNGcm9tU3BsaXQzW19pM10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghbmV4dFNlZy5pc0FuRW5kcG9pbnQoaW50ZXIpKSB7XG4gICAgICAgICAgICAgIHZhciBfbmV3RXZlbnRzRnJvbVNwbGl0NCA9IHRoaXMuX3NwbGl0U2FmZWx5KG5leHRTZWcsIGludGVyKTtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfaU1heDQgPSBfbmV3RXZlbnRzRnJvbVNwbGl0NC5sZW5ndGg7IF9pNCA8IF9pTWF4NDsgX2k0KyspIHtcbiAgICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChfbmV3RXZlbnRzRnJvbVNwbGl0NFtfaTRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudHJlZS5yZW1vdmUoc2VnbWVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXdFdmVudHM7XG4gICAgfVxuICAgIC8qIFNhZmVseSBzcGxpdCBhIHNlZ21lbnQgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIGRhdGFzdHJ1Y3R1cmVzXG4gICAgICogSUUgLSBhIHNlZ21lbnQgb3RoZXIgdGhhbiB0aGUgb25lIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHByb2Nlc3NlZC4gKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zcGxpdFNhZmVseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc3BsaXRTYWZlbHkoc2VnLCBwdCkge1xuICAgICAgLy8gUm91bmRpbmcgZXJyb3JzIGNhbiBjYXVzZSBjaGFuZ2VzIGluIG9yZGVyaW5nLFxuICAgICAgLy8gc28gcmVtb3ZlIGFmZWN0ZWQgc2VnbWVudHMgYW5kIHJpZ2h0IHN3ZWVwIGV2ZW50cyBiZWZvcmUgc3BsaXR0aW5nXG4gICAgICAvLyByZW1vdmVOb2RlKCkgZG9lc24ndCB3b3JrLCBzbyBoYXZlIHJlLWZpbmQgdGhlIHNlZ1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3c4ci9zcGxheS10cmVlL3B1bGwvNVxuICAgICAgdGhpcy50cmVlLnJlbW92ZShzZWcpO1xuICAgICAgdmFyIHJpZ2h0U0UgPSBzZWcucmlnaHRTRTtcbiAgICAgIHRoaXMucXVldWUucmVtb3ZlKHJpZ2h0U0UpO1xuICAgICAgdmFyIG5ld0V2ZW50cyA9IHNlZy5zcGxpdChwdCk7XG4gICAgICBuZXdFdmVudHMucHVzaChyaWdodFNFKTsgLy8gc3BsaXR0aW5nIGNhbiB0cmlnZ2VyIGNvbnN1bXB0aW9uXG5cbiAgICAgIGlmIChzZWcuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSB0aGlzLnRyZWUuaW5zZXJ0KHNlZyk7XG4gICAgICByZXR1cm4gbmV3RXZlbnRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTd2VlcExpbmU7XG59KCk7XG5cbnZhciBQT0xZR09OX0NMSVBQSU5HX01BWF9RVUVVRV9TSVpFID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52LlBPTFlHT05fQ0xJUFBJTkdfTUFYX1FVRVVFX1NJWkUgfHwgMTAwMDAwMDtcbnZhciBQT0xZR09OX0NMSVBQSU5HX01BWF9TV0VFUExJTkVfU0VHTUVOVFMgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgcHJvY2Vzcy5lbnYuUE9MWUdPTl9DTElQUElOR19NQVhfU1dFRVBMSU5FX1NFR01FTlRTIHx8IDEwMDAwMDA7XG52YXIgT3BlcmF0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gT3BlcmF0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcGVyYXRpb24pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE9wZXJhdGlvbiwgW3tcbiAgICBrZXk6IFwicnVuXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJ1bih0eXBlLCBnZW9tLCBtb3JlR2VvbXMpIHtcbiAgICAgIG9wZXJhdGlvbi50eXBlID0gdHlwZTtcbiAgICAgIHJvdW5kZXIucmVzZXQoKTtcbiAgICAgIC8qIENvbnZlcnQgaW5wdXRzIHRvIE11bHRpUG9seSBvYmplY3RzICovXG5cbiAgICAgIHZhciBtdWx0aXBvbHlzID0gW25ldyBNdWx0aVBvbHlJbihnZW9tLCB0cnVlKV07XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpTWF4ID0gbW9yZUdlb21zLmxlbmd0aDsgaSA8IGlNYXg7IGkrKykge1xuICAgICAgICBtdWx0aXBvbHlzLnB1c2gobmV3IE11bHRpUG9seUluKG1vcmVHZW9tc1tpXSwgZmFsc2UpKTtcbiAgICAgIH1cblxuICAgICAgb3BlcmF0aW9uLm51bU11bHRpUG9seXMgPSBtdWx0aXBvbHlzLmxlbmd0aDtcbiAgICAgIC8qIEJCb3ggb3B0aW1pemF0aW9uIGZvciBkaWZmZXJlbmNlIG9wZXJhdGlvblxuICAgICAgICogSWYgdGhlIGJib3ggb2YgYSBtdWx0aXBvbHlnb24gdGhhdCdzIHBhcnQgb2YgdGhlIGNsaXBwaW5nIGRvZXNuJ3RcbiAgICAgICAqIGludGVyc2VjdCB0aGUgYmJveCBvZiB0aGUgc3ViamVjdCBhdCBhbGwsIHdlIGNhbiBqdXN0IGRyb3AgdGhhdFxuICAgICAgICogbXVsdGlwbG95Z29uLiAqL1xuXG4gICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdkaWZmZXJlbmNlJykge1xuICAgICAgICAvLyBpbiBwbGFjZSByZW1vdmFsXG4gICAgICAgIHZhciBzdWJqZWN0ID0gbXVsdGlwb2x5c1swXTtcbiAgICAgICAgdmFyIF9pID0gMTtcblxuICAgICAgICB3aGlsZSAoX2kgPCBtdWx0aXBvbHlzLmxlbmd0aCkge1xuICAgICAgICAgIGlmIChnZXRCYm94T3ZlcmxhcChtdWx0aXBvbHlzW19pXS5iYm94LCBzdWJqZWN0LmJib3gpICE9PSBudWxsKSBfaSsrO2Vsc2UgbXVsdGlwb2x5cy5zcGxpY2UoX2ksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBCQm94IG9wdGltaXphdGlvbiBmb3IgaW50ZXJzZWN0aW9uIG9wZXJhdGlvblxuICAgICAgICogSWYgd2UgY2FuIGZpbmQgYW55IHBhaXIgb2YgbXVsdGlwb2x5Z29ucyB3aG9zZSBiYm94IGRvZXMgbm90IG92ZXJsYXAsXG4gICAgICAgKiB0aGVuIHRoZSByZXN1bHQgd2lsbCBiZSBlbXB0eS4gKi9cblxuXG4gICAgICBpZiAob3BlcmF0aW9uLnR5cGUgPT09ICdpbnRlcnNlY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IHRoaXMgaXMgTyhuXjIpIGluIG51bWJlciBvZiBwb2x5Z29ucy4gQnkgc29ydGluZyB0aGUgYmJveGVzLFxuICAgICAgICAvLyAgICAgICBpdCBjb3VsZCBiZSBvcHRpbWl6ZWQgdG8gTyhuICogbG4obikpXG4gICAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9pTWF4ID0gbXVsdGlwb2x5cy5sZW5ndGg7IF9pMiA8IF9pTWF4OyBfaTIrKykge1xuICAgICAgICAgIHZhciBtcEEgPSBtdWx0aXBvbHlzW19pMl07XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gX2kyICsgMSwgak1heCA9IG11bHRpcG9seXMubGVuZ3RoOyBqIDwgak1heDsgaisrKSB7XG4gICAgICAgICAgICBpZiAoZ2V0QmJveE92ZXJsYXAobXBBLmJib3gsIG11bHRpcG9seXNbal0uYmJveCkgPT09IG51bGwpIHJldHVybiBbXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIFB1dCBzZWdtZW50IGVuZHBvaW50cyBpbiBhIHByaW9yaXR5IHF1ZXVlICovXG5cblxuICAgICAgdmFyIHF1ZXVlID0gbmV3IFNwbGF5VHJlZV9fZGVmYXVsdFsnZGVmYXVsdCddKFN3ZWVwRXZlbnQuY29tcGFyZSk7XG5cbiAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9pTWF4MiA9IG11bHRpcG9seXMubGVuZ3RoOyBfaTMgPCBfaU1heDI7IF9pMysrKSB7XG4gICAgICAgIHZhciBzd2VlcEV2ZW50cyA9IG11bHRpcG9seXNbX2kzXS5nZXRTd2VlcEV2ZW50cygpO1xuXG4gICAgICAgIGZvciAodmFyIF9qID0gMCwgX2pNYXggPSBzd2VlcEV2ZW50cy5sZW5ndGg7IF9qIDwgX2pNYXg7IF9qKyspIHtcbiAgICAgICAgICBxdWV1ZS5pbnNlcnQoc3dlZXBFdmVudHNbX2pdKTtcblxuICAgICAgICAgIGlmIChxdWV1ZS5zaXplID4gUE9MWUdPTl9DTElQUElOR19NQVhfUVVFVUVfU0laRSkge1xuICAgICAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCB3aGVuIHB1dHRpbmcgc2VnbWVudCBlbmRwb2ludHMgaW4gYSBwcmlvcml0eSBxdWV1ZSAnICsgJyhxdWV1ZSBzaXplIHRvbyBiaWcpLiBQbGVhc2UgZmlsZSBhIGJ1ZyByZXBvcnQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvKiBQYXNzIHRoZSBzd2VlcCBsaW5lIG92ZXIgdGhvc2UgZW5kcG9pbnRzICovXG5cblxuICAgICAgdmFyIHN3ZWVwTGluZSA9IG5ldyBTd2VlcExpbmUocXVldWUpO1xuICAgICAgdmFyIHByZXZRdWV1ZVNpemUgPSBxdWV1ZS5zaXplO1xuICAgICAgdmFyIG5vZGUgPSBxdWV1ZS5wb3AoKTtcblxuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgdmFyIGV2dCA9IG5vZGUua2V5O1xuXG4gICAgICAgIGlmIChxdWV1ZS5zaXplID09PSBwcmV2UXVldWVTaXplKSB7XG4gICAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgICB2YXIgc2VnID0gZXZ0LnNlZ21lbnQ7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHBvcCgpIFwiLmNvbmNhdChldnQuaXNMZWZ0ID8gJ2xlZnQnIDogJ3JpZ2h0JywgXCIgU3dlZXBFdmVudCBcIikgKyBcIltcIi5jb25jYXQoZXZ0LnBvaW50LngsIFwiLCBcIikuY29uY2F0KGV2dC5wb2ludC55LCBcIl0gZnJvbSBzZWdtZW50ICNcIikuY29uY2F0KHNlZy5pZCwgXCIgXCIpICsgXCJbXCIuY29uY2F0KHNlZy5sZWZ0U0UucG9pbnQueCwgXCIsIFwiKS5jb25jYXQoc2VnLmxlZnRTRS5wb2ludC55LCBcIl0gLT4gXCIpICsgXCJbXCIuY29uY2F0KHNlZy5yaWdodFNFLnBvaW50LngsIFwiLCBcIikuY29uY2F0KHNlZy5yaWdodFNFLnBvaW50LnksIFwiXSBmcm9tIHF1ZXVlLiBcIikgKyAnUGxlYXNlIGZpbGUgYSBidWcgcmVwb3J0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHF1ZXVlLnNpemUgPiBQT0xZR09OX0NMSVBQSU5HX01BWF9RVUVVRV9TSVpFKSB7XG4gICAgICAgICAgLy8gcHJldmVudHMgYW4gaW5maW5pdGUgbG9vcCwgYW4gb3RoZXJ3aXNlIGNvbW1vbiBtYW5pZmVzdGF0aW9uIG9mIGJ1Z3NcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3Agd2hlbiBwYXNzaW5nIHN3ZWVwIGxpbmUgb3ZlciBlbmRwb2ludHMgJyArICcocXVldWUgc2l6ZSB0b28gYmlnKS4gUGxlYXNlIGZpbGUgYSBidWcgcmVwb3J0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN3ZWVwTGluZS5zZWdtZW50cy5sZW5ndGggPiBQT0xZR09OX0NMSVBQSU5HX01BWF9TV0VFUExJTkVfU0VHTUVOVFMpIHtcbiAgICAgICAgICAvLyBwcmV2ZW50cyBhbiBpbmZpbml0ZSBsb29wLCBhbiBvdGhlcndpc2UgY29tbW9uIG1hbmlmZXN0YXRpb24gb2YgYnVnc1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgbG9vcCB3aGVuIHBhc3Npbmcgc3dlZXAgbGluZSBvdmVyIGVuZHBvaW50cyAnICsgJyh0b28gbWFueSBzd2VlcCBsaW5lIHNlZ21lbnRzKS4gUGxlYXNlIGZpbGUgYSBidWcgcmVwb3J0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld0V2ZW50cyA9IHN3ZWVwTGluZS5wcm9jZXNzKGV2dCk7XG5cbiAgICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX2lNYXgzID0gbmV3RXZlbnRzLmxlbmd0aDsgX2k0IDwgX2lNYXgzOyBfaTQrKykge1xuICAgICAgICAgIHZhciBfZXZ0ID0gbmV3RXZlbnRzW19pNF07XG4gICAgICAgICAgaWYgKF9ldnQuY29uc3VtZWRCeSA9PT0gdW5kZWZpbmVkKSBxdWV1ZS5pbnNlcnQoX2V2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2UXVldWVTaXplID0gcXVldWUuc2l6ZTtcbiAgICAgICAgbm9kZSA9IHF1ZXVlLnBvcCgpO1xuICAgICAgfSAvLyBmcmVlIHNvbWUgbWVtb3J5IHdlIGRvbid0IG5lZWQgYW55bW9yZVxuXG5cbiAgICAgIHJvdW5kZXIucmVzZXQoKTtcbiAgICAgIC8qIENvbGxlY3QgYW5kIGNvbXBpbGUgc2VnbWVudHMgd2UncmUga2VlcGluZyBpbnRvIGEgbXVsdGlwb2x5Z29uICovXG5cbiAgICAgIHZhciByaW5nc091dCA9IFJpbmdPdXQuZmFjdG9yeShzd2VlcExpbmUuc2VnbWVudHMpO1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBNdWx0aVBvbHlPdXQocmluZ3NPdXQpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5nZXRHZW9tKCk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE9wZXJhdGlvbjtcbn0oKTsgLy8gc2luZ2xldG9uIGF2YWlsYWJsZSBieSBpbXBvcnRcblxudmFyIG9wZXJhdGlvbiA9IG5ldyBPcGVyYXRpb24oKTtcblxudmFyIHVuaW9uID0gZnVuY3Rpb24gdW5pb24oZ2VvbSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgbW9yZUdlb21zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBtb3JlR2VvbXNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oJ3VuaW9uJywgZ2VvbSwgbW9yZUdlb21zKTtcbn07XG5cbnZhciBpbnRlcnNlY3Rpb24kMSA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbihnZW9tKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgbW9yZUdlb21zID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICBtb3JlR2VvbXNbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gIH1cblxuICByZXR1cm4gb3BlcmF0aW9uLnJ1bignaW50ZXJzZWN0aW9uJywgZ2VvbSwgbW9yZUdlb21zKTtcbn07XG5cbnZhciB4b3IgPSBmdW5jdGlvbiB4b3IoZ2VvbSkge1xuICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIG1vcmVHZW9tcyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgbW9yZUdlb21zW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICB9XG5cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oJ3hvcicsIGdlb20sIG1vcmVHZW9tcyk7XG59O1xuXG52YXIgZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIGRpZmZlcmVuY2Uoc3ViamVjdEdlb20pIHtcbiAgZm9yICh2YXIgX2xlbjQgPSBhcmd1bWVudHMubGVuZ3RoLCBjbGlwcGluZ0dlb21zID0gbmV3IEFycmF5KF9sZW40ID4gMSA/IF9sZW40IC0gMSA6IDApLCBfa2V5NCA9IDE7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICBjbGlwcGluZ0dlb21zW19rZXk0IC0gMV0gPSBhcmd1bWVudHNbX2tleTRdO1xuICB9XG5cbiAgcmV0dXJuIG9wZXJhdGlvbi5ydW4oJ2RpZmZlcmVuY2UnLCBzdWJqZWN0R2VvbSwgY2xpcHBpbmdHZW9tcyk7XG59O1xuXG52YXIgaW5kZXggPSB7XG4gIHVuaW9uOiB1bmlvbixcbiAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb24kMSxcbiAgeG9yOiB4b3IsXG4gIGRpZmZlcmVuY2U6IGRpZmZlcmVuY2Vcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaW5kZXg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/polygon-clipping@0.15.3/node_modules/polygon-clipping/dist/polygon-clipping.cjs.js\n");

/***/ })

};
;
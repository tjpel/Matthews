"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turf+isolines@6.5.0";
exports.ids = ["vendor-chunks/@turf+isolines@6.5.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@turf+isolines@6.5.0/node_modules/@turf/isolines/dist/es/index.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+isolines@6.5.0/node_modules/@turf/isolines/dist/es/index.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _turf_bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/bbox */ \"(ssr)/./node_modules/.pnpm/@turf+bbox@6.5.0/node_modules/@turf/bbox/dist/es/index.js\");\n/* harmony import */ var _turf_meta__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/meta */ \"(ssr)/./node_modules/.pnpm/@turf+meta@6.5.0/node_modules/@turf/meta/dist/es/index.js\");\n/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/invariant */ \"(ssr)/./node_modules/.pnpm/@turf+invariant@6.5.0/node_modules/@turf/invariant/dist/es/index.js\");\n/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @turf/helpers */ \"(ssr)/./node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js\");\n/* harmony import */ var object_assign__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! object-assign */ \"(ssr)/./node_modules/.pnpm/object-assign@4.1.1/node_modules/object-assign/index.js\");\n\n\n\n\n\n\n/**\n * @license GNU Affero General Public License.\n * Copyright (c) 2015, 2015 Ronny Lorenz <ronny@tbi.univie.ac.at>\n * v. 1.2.0\n * https://github.com/RaumZeit/MarchingSquares.js\n *\n * MarchingSquaresJS is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * MarchingSquaresJS is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * As additional permission under GNU Affero General Public License version 3\n * section 7, third-party projects (personal or commercial) may distribute,\n * include, or link against UNMODIFIED VERSIONS of MarchingSquaresJS without the\n * requirement that said third-party project for that reason alone becomes\n * subject to any requirement of the GNU Affero General Public License version 3.\n * Any modifications to MarchingSquaresJS, however, must be shared with the public\n * and made available.\n *\n * In summary this:\n * - allows you to use MarchingSquaresJS at no cost\n * - allows you to use MarchingSquaresJS for both personal and commercial purposes\n * - allows you to distribute UNMODIFIED VERSIONS of MarchingSquaresJS under any\n *   license as long as this license notice is included\n * - enables you to keep the source code of your program that uses MarchingSquaresJS\n *   undisclosed\n * - forces you to share any modifications you have made to MarchingSquaresJS,\n *   e.g. bug-fixes\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with MarchingSquaresJS.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n/**\n * Compute the isocontour(s) of a scalar 2D field given\n * a certain threshold by applying the Marching Squares\n * Algorithm. The function returns a list of path coordinates\n */\nvar defaultSettings = {\n  successCallback: null,\n  verbose: false,\n};\n\nvar settings = {};\n\nfunction isoContours(data, threshold, options) {\n  /* process options */\n  options = options ? options : {};\n\n  var optionKeys = Object.keys(defaultSettings);\n\n  for (var i = 0; i < optionKeys.length; i++) {\n    var key = optionKeys[i];\n    var val = options[key];\n    val =\n      typeof val !== \"undefined\" && val !== null ? val : defaultSettings[key];\n\n    settings[key] = val;\n  }\n\n  if (settings.verbose)\n    console.log(\n      \"MarchingSquaresJS-isoContours: computing isocontour for \" + threshold\n    );\n\n  var ret = contourGrid2Paths(computeContourGrid(data, threshold));\n\n  if (typeof settings.successCallback === \"function\")\n    settings.successCallback(ret);\n\n  return ret;\n}\n\n/*\n  Thats all for the public interface, below follows the actual\n  implementation\n*/\n\n/*\n################################\nIsocontour implementation below\n################################\n*/\n\n/* assume that x1 == 1 &&  x0 == 0 */\nfunction interpolateX(y, y0, y1) {\n  return (y - y0) / (y1 - y0);\n}\n\n/* compute the isocontour 4-bit grid */\nfunction computeContourGrid(data, threshold) {\n  var rows = data.length - 1;\n  var cols = data[0].length - 1;\n  var ContourGrid = { rows: rows, cols: cols, cells: [] };\n\n  for (var j = 0; j < rows; ++j) {\n    ContourGrid.cells[j] = [];\n    for (var i = 0; i < cols; ++i) {\n      /* compose the 4-bit corner representation */\n      var cval = 0;\n\n      var tl = data[j + 1][i];\n      var tr = data[j + 1][i + 1];\n      var br = data[j][i + 1];\n      var bl = data[j][i];\n\n      if (isNaN(tl) || isNaN(tr) || isNaN(br) || isNaN(bl)) {\n        continue;\n      }\n      cval |= tl >= threshold ? 8 : 0;\n      cval |= tr >= threshold ? 4 : 0;\n      cval |= br >= threshold ? 2 : 0;\n      cval |= bl >= threshold ? 1 : 0;\n\n      /* resolve ambiguity for cval == 5 || 10 via averaging */\n      var flipped = false;\n      if (cval === 5 || cval === 10) {\n        var average = (tl + tr + br + bl) / 4;\n        if (cval === 5 && average < threshold) {\n          cval = 10;\n          flipped = true;\n        } else if (cval === 10 && average < threshold) {\n          cval = 5;\n          flipped = true;\n        }\n      }\n\n      /* add cell to ContourGrid if it contains edges */\n      if (cval !== 0 && cval !== 15) {\n        var top, bottom, left, right;\n        top = bottom = left = right = 0.5;\n        /* interpolate edges of cell */\n        if (cval === 1) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          bottom = 1 - interpolateX(threshold, br, bl);\n        } else if (cval === 2) {\n          bottom = interpolateX(threshold, bl, br);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 3) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 4) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 5) {\n          top = interpolateX(threshold, tl, tr);\n          right = interpolateX(threshold, br, tr);\n          bottom = 1 - interpolateX(threshold, br, bl);\n          left = 1 - interpolateX(threshold, tl, bl);\n        } else if (cval === 6) {\n          bottom = interpolateX(threshold, bl, br);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 7) {\n          left = 1 - interpolateX(threshold, tl, bl);\n          top = interpolateX(threshold, tl, tr);\n        } else if (cval === 8) {\n          left = interpolateX(threshold, bl, tl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 9) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          top = 1 - interpolateX(threshold, tr, tl);\n        } else if (cval === 10) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n          bottom = interpolateX(threshold, bl, br);\n          left = interpolateX(threshold, bl, tl);\n        } else if (cval === 11) {\n          top = 1 - interpolateX(threshold, tr, tl);\n          right = 1 - interpolateX(threshold, tr, br);\n        } else if (cval === 12) {\n          left = interpolateX(threshold, bl, tl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 13) {\n          bottom = 1 - interpolateX(threshold, br, bl);\n          right = interpolateX(threshold, br, tr);\n        } else if (cval === 14) {\n          left = interpolateX(threshold, bl, tl);\n          bottom = interpolateX(threshold, bl, br);\n        } else {\n          console.log(\n            \"MarchingSquaresJS-isoContours: Illegal cval detected: \" + cval\n          );\n        }\n        ContourGrid.cells[j][i] = {\n          cval: cval,\n          flipped: flipped,\n          top: top,\n          right: right,\n          bottom: bottom,\n          left: left,\n        };\n      }\n    }\n  }\n\n  return ContourGrid;\n}\n\nfunction isSaddle(cell) {\n  return cell.cval === 5 || cell.cval === 10;\n}\n\nfunction isTrivial(cell) {\n  return cell.cval === 0 || cell.cval === 15;\n}\n\nfunction clearCell(cell) {\n  if (!isTrivial(cell) && cell.cval !== 5 && cell.cval !== 10) {\n    cell.cval = 15;\n  }\n}\n\nfunction getXY(cell, edge) {\n  if (edge === \"top\") {\n    return [cell.top, 1.0];\n  } else if (edge === \"bottom\") {\n    return [cell.bottom, 0.0];\n  } else if (edge === \"right\") {\n    return [1.0, cell.right];\n  } else if (edge === \"left\") {\n    return [0.0, cell.left];\n  }\n}\n\nfunction contourGrid2Paths(grid) {\n  var paths = [];\n  var path_idx = 0;\n  var epsilon = 1e-7;\n\n  grid.cells.forEach(function (g, j) {\n    g.forEach(function (gg, i) {\n      if (typeof gg !== \"undefined\" && !isSaddle(gg) && !isTrivial(gg)) {\n        var p = tracePath(grid.cells, j, i);\n        var merged = false;\n        /* we may try to merge paths at this point */\n        if (p.info === \"mergeable\") {\n          /*\n            search backwards through the path array to find an entry\n            that starts with where the current path ends...\n          */\n          var x = p.path[p.path.length - 1][0],\n            y = p.path[p.path.length - 1][1];\n\n          for (var k = path_idx - 1; k >= 0; k--) {\n            if (\n              Math.abs(paths[k][0][0] - x) <= epsilon &&\n              Math.abs(paths[k][0][1] - y) <= epsilon\n            ) {\n              for (var l = p.path.length - 2; l >= 0; --l) {\n                paths[k].unshift(p.path[l]);\n              }\n              merged = true;\n              break;\n            }\n          }\n        }\n        if (!merged) paths[path_idx++] = p.path;\n      }\n    });\n  });\n\n  return paths;\n}\n\n/*\n  construct consecutive line segments from starting cell by\n  walking arround the enclosed area clock-wise\n  */\nfunction tracePath(grid, j, i) {\n  var maxj = grid.length;\n  var p = [];\n  var dxContour = [0, 0, 1, 1, 0, 0, 0, 0, -1, 0, 1, 1, -1, 0, -1, 0];\n  var dyContour = [0, -1, 0, 0, 1, 1, 1, 1, 0, -1, 0, 0, 0, -1, 0, 0];\n  var dx, dy;\n  var startEdge = [\n    \"none\",\n    \"left\",\n    \"bottom\",\n    \"left\",\n    \"right\",\n    \"none\",\n    \"bottom\",\n    \"left\",\n    \"top\",\n    \"top\",\n    \"none\",\n    \"top\",\n    \"right\",\n    \"right\",\n    \"bottom\",\n    \"none\",\n  ];\n  var nextEdge = [\n    \"none\",\n    \"bottom\",\n    \"right\",\n    \"right\",\n    \"top\",\n    \"top\",\n    \"top\",\n    \"top\",\n    \"left\",\n    \"bottom\",\n    \"right\",\n    \"right\",\n    \"left\",\n    \"bottom\",\n    \"left\",\n    \"none\",\n  ];\n  var edge;\n\n  var currentCell = grid[j][i];\n\n  var cval = currentCell.cval;\n  var edge = startEdge[cval];\n\n  var pt = getXY(currentCell, edge);\n\n  /* push initial segment */\n  p.push([i + pt[0], j + pt[1]]);\n  edge = nextEdge[cval];\n  pt = getXY(currentCell, edge);\n  p.push([i + pt[0], j + pt[1]]);\n  clearCell(currentCell);\n\n  /* now walk arround the enclosed area in clockwise-direction */\n  var k = i + dxContour[cval];\n  var l = j + dyContour[cval];\n  var prev_cval = cval;\n\n  while (k >= 0 && l >= 0 && l < maxj && (k != i || l != j)) {\n    currentCell = grid[l][k];\n    if (typeof currentCell === \"undefined\") {\n      /* path ends here */\n      //console.log(k + \" \" + l + \" is undefined, stopping path!\");\n      break;\n    }\n    cval = currentCell.cval;\n    if (cval === 0 || cval === 15) {\n      return { path: p, info: \"mergeable\" };\n    }\n    edge = nextEdge[cval];\n    dx = dxContour[cval];\n    dy = dyContour[cval];\n    if (cval === 5 || cval === 10) {\n      /* select upper or lower band, depending on previous cells cval */\n      if (cval === 5) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 10 */\n          if (dyContour[prev_cval] === -1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          } else {\n            edge = \"right\";\n            dx = 1;\n            dy = 0;\n          }\n        } else {\n          /* real case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        }\n      } else if (cval === 10) {\n        if (currentCell.flipped) {\n          /* this is actually a flipped case 5 */\n          if (dxContour[prev_cval] === -1) {\n            edge = \"top\";\n            dx = 0;\n            dy = 1;\n          } else {\n            edge = \"bottom\";\n            dx = 0;\n            dy = -1;\n          }\n        } else {\n          /* real case 10 */\n          if (dyContour[prev_cval] === 1) {\n            edge = \"left\";\n            dx = -1;\n            dy = 0;\n          }\n        }\n      }\n    }\n    pt = getXY(currentCell, edge);\n    p.push([k + pt[0], l + pt[1]]);\n    clearCell(currentCell);\n    k += dx;\n    l += dy;\n    prev_cval = cval;\n  }\n\n  return { path: p, info: \"closed\" };\n}\n\n/**\n * Takes a {@link Point} grid and returns a correspondent matrix {Array<Array<number>>}\n * of the 'property' values\n *\n * @name gridToMatrix\n * @param {FeatureCollection<Point>} grid of points\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {boolean} [options.flip=false] returns the matrix upside-down\n * @param {boolean} [options.flags=false] flags, adding a `matrixPosition` array field ([row, column]) to its properties,\n * the grid points with coordinates on the matrix\n * @returns {Array<Array<number>>} matrix of property values\n * @example\n *   var extent = [-70.823364, -33.553984, -70.473175, -33.302986];\n *   var cellSize = 3;\n *   var grid = turf.pointGrid(extent, cellSize);\n *   // add a random property to each point between 0 and 60\n *   for (var i = 0; i < grid.features.length; i++) {\n *     grid.features[i].properties.elevation = (Math.random() * 60);\n *   }\n *   gridToMatrix(grid);\n *   //= [\n *     [ 1, 13, 10,  9, 10, 13, 18],\n *     [34,  8,  5,  4,  5,  8, 13],\n *     [10,  5,  2,  1,  2,  5,  4],\n *     [ 0,  4, 56, 19,  1,  4,  9],\n *     [10,  5,  2,  1,  2,  5, 10],\n *     [57,  8,  5,  4,  5,  0, 57],\n *     [ 3, 13, 10,  9,  5, 13, 18],\n *     [18, 13, 10,  9, 78, 13, 18]\n *   ]\n */\nfunction gridToMatrix(grid, options) {\n  // Optional parameters\n  options = options || {};\n  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_3__.isObject)(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var flip = options.flip;\n  var flags = options.flags;\n\n  // validation\n  (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.collectionOf)(grid, \"Point\", \"input must contain Points\");\n\n  var pointsMatrix = sortPointsByLatLng(grid, flip);\n\n  var matrix = [];\n  // create property matrix from sorted points\n  // looping order matters here\n  for (var r = 0; r < pointsMatrix.length; r++) {\n    var pointRow = pointsMatrix[r];\n    var row = [];\n    for (var c = 0; c < pointRow.length; c++) {\n      var point = pointRow[c];\n      // Check if zProperty exist\n      if (point.properties[zProperty]) row.push(point.properties[zProperty]);\n      else row.push(0);\n      // add flags\n      if (flags === true) point.properties.matrixPosition = [r, c];\n    }\n    matrix.push(row);\n  }\n\n  return matrix;\n}\n\n/**\n * Sorts points by latitude and longitude, creating a 2-dimensional array of points\n *\n * @private\n * @param {FeatureCollection<Point>} points GeoJSON Point features\n * @param {boolean} [flip=false] returns the matrix upside-down\n * @returns {Array<Array<Point>>} points ordered by latitude and longitude\n */\nfunction sortPointsByLatLng(points, flip) {\n  var pointsByLatitude = {};\n\n  // divide points by rows with the same latitude\n  (0,_turf_meta__WEBPACK_IMPORTED_MODULE_1__.featureEach)(points, function (point) {\n    var lat = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.getCoords)(point)[1];\n    if (!pointsByLatitude[lat]) pointsByLatitude[lat] = [];\n    pointsByLatitude[lat].push(point);\n  });\n\n  // sort points (with the same latitude) by longitude\n  var orderedRowsByLatitude = Object.keys(pointsByLatitude).map(function (lat) {\n    var row = pointsByLatitude[lat];\n    var rowOrderedByLongitude = row.sort(function (a, b) {\n      return (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.getCoords)(a)[0] - (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.getCoords)(b)[0];\n    });\n    return rowOrderedByLongitude;\n  });\n\n  // sort rows (of points with the same latitude) by latitude\n  var pointMatrix = orderedRowsByLatitude.sort(function (a, b) {\n    if (flip) return (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.getCoords)(a[0])[1] - (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.getCoords)(b[0])[1];\n    else return (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.getCoords)(b[0])[1] - (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.getCoords)(a[0])[1];\n  });\n\n  return pointMatrix;\n}\n\n/**\n * Takes a grid {@link FeatureCollection} of {@link Point} features with z-values and an array of\n * value breaks and generates [isolines](https://en.wikipedia.org/wiki/Contour_line).\n *\n * @name isolines\n * @param {FeatureCollection<Point>} pointGrid input points\n * @param {Array<number>} breaks values of `zProperty` where to draw isolines\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.zProperty='elevation'] the property name in `points` from which z-values will be pulled\n * @param {Object} [options.commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Array<Object>} [options.breaksProperties=[]] GeoJSON properties passed, in order, to the correspondent isoline;\n * the breaks array will define the order in which the isolines are created\n * @returns {FeatureCollection<MultiLineString>} a FeatureCollection of {@link MultiLineString} features representing isolines\n * @example\n * // create a grid of points with random z-values in their properties\n * var extent = [0, 30, 20, 50];\n * var cellWidth = 100;\n * var pointGrid = turf.pointGrid(extent, cellWidth, {units: 'miles'});\n *\n * for (var i = 0; i < pointGrid.features.length; i++) {\n *     pointGrid.features[i].properties.temperature = Math.random() * 10;\n * }\n * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n *\n * var lines = turf.isolines(pointGrid, breaks, {zProperty: 'temperature'});\n *\n * //addToMap\n * var addToMap = [lines];\n */\nfunction isolines(pointGrid, breaks, options) {\n  // Optional parameters\n  options = options || {};\n  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_3__.isObject)(options)) throw new Error(\"options is invalid\");\n  var zProperty = options.zProperty || \"elevation\";\n  var commonProperties = options.commonProperties || {};\n  var breaksProperties = options.breaksProperties || [];\n\n  // Input validation\n  (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_2__.collectionOf)(pointGrid, \"Point\", \"Input must contain Points\");\n  if (!breaks) throw new Error(\"breaks is required\");\n  if (!Array.isArray(breaks)) throw new Error(\"breaks must be an Array\");\n  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_3__.isObject)(commonProperties))\n    throw new Error(\"commonProperties must be an Object\");\n  if (!Array.isArray(breaksProperties))\n    throw new Error(\"breaksProperties must be an Array\");\n\n  // Isoline methods\n  var matrix = gridToMatrix(pointGrid, { zProperty: zProperty, flip: true });\n  var createdIsoLines = createIsoLines(\n    matrix,\n    breaks,\n    zProperty,\n    commonProperties,\n    breaksProperties\n  );\n  var scaledIsolines = rescaleIsolines(createdIsoLines, matrix, pointGrid);\n\n  return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_3__.featureCollection)(scaledIsolines);\n}\n\n/**\n * Creates the isolines lines (featuresCollection of MultiLineString features) from the 2D data grid\n *\n * Marchingsquares process the grid data as a 3D representation of a function on a 2D plane, therefore it\n * assumes the points (x-y coordinates) are one 'unit' distance. The result of the isolines function needs to be\n * rescaled, with turfjs, to the original area and proportions on the map\n *\n * @private\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Array<number>} breaks Breaks\n * @param {string} zProperty name of the z-values property\n * @param {Object} [commonProperties={}] GeoJSON properties passed to ALL isolines\n * @param {Object} [breaksProperties=[]] GeoJSON properties passed to the correspondent isoline\n * @returns {Array<MultiLineString>} isolines\n */\nfunction createIsoLines(\n  matrix,\n  breaks,\n  zProperty,\n  commonProperties,\n  breaksProperties\n) {\n  var results = [];\n  for (var i = 1; i < breaks.length; i++) {\n    var threshold = +breaks[i]; // make sure it's a number\n\n    var properties = object_assign__WEBPACK_IMPORTED_MODULE_4__({}, commonProperties, breaksProperties[i]);\n    properties[zProperty] = threshold;\n    var isoline = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_3__.multiLineString)(isoContours(matrix, threshold), properties);\n\n    results.push(isoline);\n  }\n  return results;\n}\n\n/**\n * Translates and scales isolines\n *\n * @private\n * @param {Array<MultiLineString>} createdIsoLines to be rescaled\n * @param {Array<Array<number>>} matrix Grid Data\n * @param {Object} points Points by Latitude\n * @returns {Array<MultiLineString>} isolines\n */\nfunction rescaleIsolines(createdIsoLines, matrix, points) {\n  // get dimensions (on the map) of the original grid\n  var gridBbox = (0,_turf_bbox__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(points); // [ minX, minY, maxX, maxY ]\n  var originalWidth = gridBbox[2] - gridBbox[0];\n  var originalHeigth = gridBbox[3] - gridBbox[1];\n\n  // get origin, which is the first point of the last row on the rectangular data on the map\n  var x0 = gridBbox[0];\n  var y0 = gridBbox[1];\n\n  // get number of cells per side\n  var matrixWidth = matrix[0].length - 1;\n  var matrixHeight = matrix.length - 1;\n\n  // calculate the scaling factor between matrix and rectangular grid on the map\n  var scaleX = originalWidth / matrixWidth;\n  var scaleY = originalHeigth / matrixHeight;\n\n  var resize = function (point) {\n    point[0] = point[0] * scaleX + x0;\n    point[1] = point[1] * scaleY + y0;\n  };\n\n  // resize and shift each point/line of the createdIsoLines\n  createdIsoLines.forEach(function (isoline) {\n    (0,_turf_meta__WEBPACK_IMPORTED_MODULE_1__.coordEach)(isoline, resize);\n  });\n  return createdIsoLines;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isolines);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYraXNvbGluZXNANi41LjAvbm9kZV9tb2R1bGVzL0B0dXJmL2lzb2xpbmVzL2Rpc3QvZXMvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQThCO0FBQ3NCO0FBQ007QUFDbUI7QUFDcEM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsdUJBQXVCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7O0FBRXRCLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUFDQSxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLGVBQWU7QUFDMUIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxvQkFBb0I7QUFDdkMsV0FBVyxRQUFRO0FBQ25CLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckMsZ0NBQWdDOztBQUVoQyxxQkFBcUIsMENBQVksR0FBRztBQUNwQztBQUNBLGtCQUFrQiw4REFBZTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdCQUF3QjtBQUNuQyxXQUFXLHNCQUFzQjtBQUNqQyxXQUFXLFFBQVE7QUFDbkIsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNEQUFJLFVBQVU7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSSxxREFBUztBQUNiLEdBQUc7QUFDSDtBQUNBOztBQUVBLGlFQUFlLFFBQVEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYraXNvbGluZXNANi41LjAvbm9kZV9tb2R1bGVzL0B0dXJmL2lzb2xpbmVzL2Rpc3QvZXMvaW5kZXguanM/YjQzMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmJveCBmcm9tICdAdHVyZi9iYm94JztcbmltcG9ydCB7IGZlYXR1cmVFYWNoLCBjb29yZEVhY2ggfSBmcm9tICdAdHVyZi9tZXRhJztcbmltcG9ydCB7IGNvbGxlY3Rpb25PZiwgZ2V0Q29vcmRzIH0gZnJvbSAnQHR1cmYvaW52YXJpYW50JztcbmltcG9ydCB7IGlzT2JqZWN0LCBmZWF0dXJlQ29sbGVjdGlvbiwgbXVsdGlMaW5lU3RyaW5nIH0gZnJvbSAnQHR1cmYvaGVscGVycyc7XG5pbXBvcnQgb2JqZWN0QXNzaWduIGZyb20gJ29iamVjdC1hc3NpZ24nO1xuXG4vKipcbiAqIEBsaWNlbnNlIEdOVSBBZmZlcm8gR2VuZXJhbCBQdWJsaWMgTGljZW5zZS5cbiAqIENvcHlyaWdodCAoYykgMjAxNSwgMjAxNSBSb25ueSBMb3JlbnogPHJvbm55QHRiaS51bml2aWUuYWMuYXQ+XG4gKiB2LiAxLjIuMFxuICogaHR0cHM6Ly9naXRodWIuY29tL1JhdW1aZWl0L01hcmNoaW5nU3F1YXJlcy5qc1xuICpcbiAqIE1hcmNoaW5nU3F1YXJlc0pTIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAqIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogTWFyY2hpbmdTcXVhcmVzSlMgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBBcyBhZGRpdGlvbmFsIHBlcm1pc3Npb24gdW5kZXIgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIHZlcnNpb24gM1xuICogc2VjdGlvbiA3LCB0aGlyZC1wYXJ0eSBwcm9qZWN0cyAocGVyc29uYWwgb3IgY29tbWVyY2lhbCkgbWF5IGRpc3RyaWJ1dGUsXG4gKiBpbmNsdWRlLCBvciBsaW5rIGFnYWluc3QgVU5NT0RJRklFRCBWRVJTSU9OUyBvZiBNYXJjaGluZ1NxdWFyZXNKUyB3aXRob3V0IHRoZVxuICogcmVxdWlyZW1lbnQgdGhhdCBzYWlkIHRoaXJkLXBhcnR5IHByb2plY3QgZm9yIHRoYXQgcmVhc29uIGFsb25lIGJlY29tZXNcbiAqIHN1YmplY3QgdG8gYW55IHJlcXVpcmVtZW50IG9mIHRoZSBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgdmVyc2lvbiAzLlxuICogQW55IG1vZGlmaWNhdGlvbnMgdG8gTWFyY2hpbmdTcXVhcmVzSlMsIGhvd2V2ZXIsIG11c3QgYmUgc2hhcmVkIHdpdGggdGhlIHB1YmxpY1xuICogYW5kIG1hZGUgYXZhaWxhYmxlLlxuICpcbiAqIEluIHN1bW1hcnkgdGhpczpcbiAqIC0gYWxsb3dzIHlvdSB0byB1c2UgTWFyY2hpbmdTcXVhcmVzSlMgYXQgbm8gY29zdFxuICogLSBhbGxvd3MgeW91IHRvIHVzZSBNYXJjaGluZ1NxdWFyZXNKUyBmb3IgYm90aCBwZXJzb25hbCBhbmQgY29tbWVyY2lhbCBwdXJwb3Nlc1xuICogLSBhbGxvd3MgeW91IHRvIGRpc3RyaWJ1dGUgVU5NT0RJRklFRCBWRVJTSU9OUyBvZiBNYXJjaGluZ1NxdWFyZXNKUyB1bmRlciBhbnlcbiAqICAgbGljZW5zZSBhcyBsb25nIGFzIHRoaXMgbGljZW5zZSBub3RpY2UgaXMgaW5jbHVkZWRcbiAqIC0gZW5hYmxlcyB5b3UgdG8ga2VlcCB0aGUgc291cmNlIGNvZGUgb2YgeW91ciBwcm9ncmFtIHRoYXQgdXNlcyBNYXJjaGluZ1NxdWFyZXNKU1xuICogICB1bmRpc2Nsb3NlZFxuICogLSBmb3JjZXMgeW91IHRvIHNoYXJlIGFueSBtb2RpZmljYXRpb25zIHlvdSBoYXZlIG1hZGUgdG8gTWFyY2hpbmdTcXVhcmVzSlMsXG4gKiAgIGUuZy4gYnVnLWZpeGVzXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIE1hcmNoaW5nU3F1YXJlc0pTLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuICovXG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaXNvY29udG91cihzKSBvZiBhIHNjYWxhciAyRCBmaWVsZCBnaXZlblxuICogYSBjZXJ0YWluIHRocmVzaG9sZCBieSBhcHBseWluZyB0aGUgTWFyY2hpbmcgU3F1YXJlc1xuICogQWxnb3JpdGhtLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhIGxpc3Qgb2YgcGF0aCBjb29yZGluYXRlc1xuICovXG52YXIgZGVmYXVsdFNldHRpbmdzID0ge1xuICBzdWNjZXNzQ2FsbGJhY2s6IG51bGwsXG4gIHZlcmJvc2U6IGZhbHNlLFxufTtcblxudmFyIHNldHRpbmdzID0ge307XG5cbmZ1bmN0aW9uIGlzb0NvbnRvdXJzKGRhdGEsIHRocmVzaG9sZCwgb3B0aW9ucykge1xuICAvKiBwcm9jZXNzIG9wdGlvbnMgKi9cbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBvcHRpb25zIDoge307XG5cbiAgdmFyIG9wdGlvbktleXMgPSBPYmplY3Qua2V5cyhkZWZhdWx0U2V0dGluZ3MpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9uS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBvcHRpb25LZXlzW2ldO1xuICAgIHZhciB2YWwgPSBvcHRpb25zW2tleV07XG4gICAgdmFsID1cbiAgICAgIHR5cGVvZiB2YWwgIT09IFwidW5kZWZpbmVkXCIgJiYgdmFsICE9PSBudWxsID8gdmFsIDogZGVmYXVsdFNldHRpbmdzW2tleV07XG5cbiAgICBzZXR0aW5nc1trZXldID0gdmFsO1xuICB9XG5cbiAgaWYgKHNldHRpbmdzLnZlcmJvc2UpXG4gICAgY29uc29sZS5sb2coXG4gICAgICBcIk1hcmNoaW5nU3F1YXJlc0pTLWlzb0NvbnRvdXJzOiBjb21wdXRpbmcgaXNvY29udG91ciBmb3IgXCIgKyB0aHJlc2hvbGRcbiAgICApO1xuXG4gIHZhciByZXQgPSBjb250b3VyR3JpZDJQYXRocyhjb21wdXRlQ29udG91ckdyaWQoZGF0YSwgdGhyZXNob2xkKSk7XG5cbiAgaWYgKHR5cGVvZiBzZXR0aW5ncy5zdWNjZXNzQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIilcbiAgICBzZXR0aW5ncy5zdWNjZXNzQ2FsbGJhY2socmV0KTtcblxuICByZXR1cm4gcmV0O1xufVxuXG4vKlxuICBUaGF0cyBhbGwgZm9yIHRoZSBwdWJsaWMgaW50ZXJmYWNlLCBiZWxvdyBmb2xsb3dzIHRoZSBhY3R1YWxcbiAgaW1wbGVtZW50YXRpb25cbiovXG5cbi8qXG4jIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjI1xuSXNvY29udG91ciBpbXBsZW1lbnRhdGlvbiBiZWxvd1xuIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyNcbiovXG5cbi8qIGFzc3VtZSB0aGF0IHgxID09IDEgJiYgIHgwID09IDAgKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlWCh5LCB5MCwgeTEpIHtcbiAgcmV0dXJuICh5IC0geTApIC8gKHkxIC0geTApO1xufVxuXG4vKiBjb21wdXRlIHRoZSBpc29jb250b3VyIDQtYml0IGdyaWQgKi9cbmZ1bmN0aW9uIGNvbXB1dGVDb250b3VyR3JpZChkYXRhLCB0aHJlc2hvbGQpIHtcbiAgdmFyIHJvd3MgPSBkYXRhLmxlbmd0aCAtIDE7XG4gIHZhciBjb2xzID0gZGF0YVswXS5sZW5ndGggLSAxO1xuICB2YXIgQ29udG91ckdyaWQgPSB7IHJvd3M6IHJvd3MsIGNvbHM6IGNvbHMsIGNlbGxzOiBbXSB9O1xuXG4gIGZvciAodmFyIGogPSAwOyBqIDwgcm93czsgKytqKSB7XG4gICAgQ29udG91ckdyaWQuY2VsbHNbal0gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7ICsraSkge1xuICAgICAgLyogY29tcG9zZSB0aGUgNC1iaXQgY29ybmVyIHJlcHJlc2VudGF0aW9uICovXG4gICAgICB2YXIgY3ZhbCA9IDA7XG5cbiAgICAgIHZhciB0bCA9IGRhdGFbaiArIDFdW2ldO1xuICAgICAgdmFyIHRyID0gZGF0YVtqICsgMV1baSArIDFdO1xuICAgICAgdmFyIGJyID0gZGF0YVtqXVtpICsgMV07XG4gICAgICB2YXIgYmwgPSBkYXRhW2pdW2ldO1xuXG4gICAgICBpZiAoaXNOYU4odGwpIHx8IGlzTmFOKHRyKSB8fCBpc05hTihicikgfHwgaXNOYU4oYmwpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY3ZhbCB8PSB0bCA+PSB0aHJlc2hvbGQgPyA4IDogMDtcbiAgICAgIGN2YWwgfD0gdHIgPj0gdGhyZXNob2xkID8gNCA6IDA7XG4gICAgICBjdmFsIHw9IGJyID49IHRocmVzaG9sZCA/IDIgOiAwO1xuICAgICAgY3ZhbCB8PSBibCA+PSB0aHJlc2hvbGQgPyAxIDogMDtcblxuICAgICAgLyogcmVzb2x2ZSBhbWJpZ3VpdHkgZm9yIGN2YWwgPT0gNSB8fCAxMCB2aWEgYXZlcmFnaW5nICovXG4gICAgICB2YXIgZmxpcHBlZCA9IGZhbHNlO1xuICAgICAgaWYgKGN2YWwgPT09IDUgfHwgY3ZhbCA9PT0gMTApIHtcbiAgICAgICAgdmFyIGF2ZXJhZ2UgPSAodGwgKyB0ciArIGJyICsgYmwpIC8gNDtcbiAgICAgICAgaWYgKGN2YWwgPT09IDUgJiYgYXZlcmFnZSA8IHRocmVzaG9sZCkge1xuICAgICAgICAgIGN2YWwgPSAxMDtcbiAgICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjdmFsID09PSAxMCAmJiBhdmVyYWdlIDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgY3ZhbCA9IDU7XG4gICAgICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyogYWRkIGNlbGwgdG8gQ29udG91ckdyaWQgaWYgaXQgY29udGFpbnMgZWRnZXMgKi9cbiAgICAgIGlmIChjdmFsICE9PSAwICYmIGN2YWwgIT09IDE1KSB7XG4gICAgICAgIHZhciB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQ7XG4gICAgICAgIHRvcCA9IGJvdHRvbSA9IGxlZnQgPSByaWdodCA9IDAuNTtcbiAgICAgICAgLyogaW50ZXJwb2xhdGUgZWRnZXMgb2YgY2VsbCAqL1xuICAgICAgICBpZiAoY3ZhbCA9PT0gMSkge1xuICAgICAgICAgIGxlZnQgPSAxIC0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgdGwsIGJsKTtcbiAgICAgICAgICBib3R0b20gPSAxIC0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgYnIsIGJsKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdmFsID09PSAyKSB7XG4gICAgICAgICAgYm90dG9tID0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgYmwsIGJyKTtcbiAgICAgICAgICByaWdodCA9IDEgLSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCB0ciwgYnIpO1xuICAgICAgICB9IGVsc2UgaWYgKGN2YWwgPT09IDMpIHtcbiAgICAgICAgICBsZWZ0ID0gMSAtIGludGVycG9sYXRlWCh0aHJlc2hvbGQsIHRsLCBibCk7XG4gICAgICAgICAgcmlnaHQgPSAxIC0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgdHIsIGJyKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdmFsID09PSA0KSB7XG4gICAgICAgICAgdG9wID0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgdGwsIHRyKTtcbiAgICAgICAgICByaWdodCA9IGludGVycG9sYXRlWCh0aHJlc2hvbGQsIGJyLCB0cik7XG4gICAgICAgIH0gZWxzZSBpZiAoY3ZhbCA9PT0gNSkge1xuICAgICAgICAgIHRvcCA9IGludGVycG9sYXRlWCh0aHJlc2hvbGQsIHRsLCB0cik7XG4gICAgICAgICAgcmlnaHQgPSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCBiciwgdHIpO1xuICAgICAgICAgIGJvdHRvbSA9IDEgLSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCBiciwgYmwpO1xuICAgICAgICAgIGxlZnQgPSAxIC0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgdGwsIGJsKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdmFsID09PSA2KSB7XG4gICAgICAgICAgYm90dG9tID0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgYmwsIGJyKTtcbiAgICAgICAgICB0b3AgPSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCB0bCwgdHIpO1xuICAgICAgICB9IGVsc2UgaWYgKGN2YWwgPT09IDcpIHtcbiAgICAgICAgICBsZWZ0ID0gMSAtIGludGVycG9sYXRlWCh0aHJlc2hvbGQsIHRsLCBibCk7XG4gICAgICAgICAgdG9wID0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgdGwsIHRyKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdmFsID09PSA4KSB7XG4gICAgICAgICAgbGVmdCA9IGludGVycG9sYXRlWCh0aHJlc2hvbGQsIGJsLCB0bCk7XG4gICAgICAgICAgdG9wID0gMSAtIGludGVycG9sYXRlWCh0aHJlc2hvbGQsIHRyLCB0bCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY3ZhbCA9PT0gOSkge1xuICAgICAgICAgIGJvdHRvbSA9IDEgLSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCBiciwgYmwpO1xuICAgICAgICAgIHRvcCA9IDEgLSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCB0ciwgdGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGN2YWwgPT09IDEwKSB7XG4gICAgICAgICAgdG9wID0gMSAtIGludGVycG9sYXRlWCh0aHJlc2hvbGQsIHRyLCB0bCk7XG4gICAgICAgICAgcmlnaHQgPSAxIC0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgdHIsIGJyKTtcbiAgICAgICAgICBib3R0b20gPSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCBibCwgYnIpO1xuICAgICAgICAgIGxlZnQgPSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCBibCwgdGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGN2YWwgPT09IDExKSB7XG4gICAgICAgICAgdG9wID0gMSAtIGludGVycG9sYXRlWCh0aHJlc2hvbGQsIHRyLCB0bCk7XG4gICAgICAgICAgcmlnaHQgPSAxIC0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgdHIsIGJyKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdmFsID09PSAxMikge1xuICAgICAgICAgIGxlZnQgPSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCBibCwgdGwpO1xuICAgICAgICAgIHJpZ2h0ID0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgYnIsIHRyKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdmFsID09PSAxMykge1xuICAgICAgICAgIGJvdHRvbSA9IDEgLSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCBiciwgYmwpO1xuICAgICAgICAgIHJpZ2h0ID0gaW50ZXJwb2xhdGVYKHRocmVzaG9sZCwgYnIsIHRyKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdmFsID09PSAxNCkge1xuICAgICAgICAgIGxlZnQgPSBpbnRlcnBvbGF0ZVgodGhyZXNob2xkLCBibCwgdGwpO1xuICAgICAgICAgIGJvdHRvbSA9IGludGVycG9sYXRlWCh0aHJlc2hvbGQsIGJsLCBicik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXG4gICAgICAgICAgICBcIk1hcmNoaW5nU3F1YXJlc0pTLWlzb0NvbnRvdXJzOiBJbGxlZ2FsIGN2YWwgZGV0ZWN0ZWQ6IFwiICsgY3ZhbFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgQ29udG91ckdyaWQuY2VsbHNbal1baV0gPSB7XG4gICAgICAgICAgY3ZhbDogY3ZhbCxcbiAgICAgICAgICBmbGlwcGVkOiBmbGlwcGVkLFxuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBDb250b3VyR3JpZDtcbn1cblxuZnVuY3Rpb24gaXNTYWRkbGUoY2VsbCkge1xuICByZXR1cm4gY2VsbC5jdmFsID09PSA1IHx8IGNlbGwuY3ZhbCA9PT0gMTA7XG59XG5cbmZ1bmN0aW9uIGlzVHJpdmlhbChjZWxsKSB7XG4gIHJldHVybiBjZWxsLmN2YWwgPT09IDAgfHwgY2VsbC5jdmFsID09PSAxNTtcbn1cblxuZnVuY3Rpb24gY2xlYXJDZWxsKGNlbGwpIHtcbiAgaWYgKCFpc1RyaXZpYWwoY2VsbCkgJiYgY2VsbC5jdmFsICE9PSA1ICYmIGNlbGwuY3ZhbCAhPT0gMTApIHtcbiAgICBjZWxsLmN2YWwgPSAxNTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRYWShjZWxsLCBlZGdlKSB7XG4gIGlmIChlZGdlID09PSBcInRvcFwiKSB7XG4gICAgcmV0dXJuIFtjZWxsLnRvcCwgMS4wXTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSBcImJvdHRvbVwiKSB7XG4gICAgcmV0dXJuIFtjZWxsLmJvdHRvbSwgMC4wXTtcbiAgfSBlbHNlIGlmIChlZGdlID09PSBcInJpZ2h0XCIpIHtcbiAgICByZXR1cm4gWzEuMCwgY2VsbC5yaWdodF07XG4gIH0gZWxzZSBpZiAoZWRnZSA9PT0gXCJsZWZ0XCIpIHtcbiAgICByZXR1cm4gWzAuMCwgY2VsbC5sZWZ0XTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb250b3VyR3JpZDJQYXRocyhncmlkKSB7XG4gIHZhciBwYXRocyA9IFtdO1xuICB2YXIgcGF0aF9pZHggPSAwO1xuICB2YXIgZXBzaWxvbiA9IDFlLTc7XG5cbiAgZ3JpZC5jZWxscy5mb3JFYWNoKGZ1bmN0aW9uIChnLCBqKSB7XG4gICAgZy5mb3JFYWNoKGZ1bmN0aW9uIChnZywgaSkge1xuICAgICAgaWYgKHR5cGVvZiBnZyAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhaXNTYWRkbGUoZ2cpICYmICFpc1RyaXZpYWwoZ2cpKSB7XG4gICAgICAgIHZhciBwID0gdHJhY2VQYXRoKGdyaWQuY2VsbHMsIGosIGkpO1xuICAgICAgICB2YXIgbWVyZ2VkID0gZmFsc2U7XG4gICAgICAgIC8qIHdlIG1heSB0cnkgdG8gbWVyZ2UgcGF0aHMgYXQgdGhpcyBwb2ludCAqL1xuICAgICAgICBpZiAocC5pbmZvID09PSBcIm1lcmdlYWJsZVwiKSB7XG4gICAgICAgICAgLypcbiAgICAgICAgICAgIHNlYXJjaCBiYWNrd2FyZHMgdGhyb3VnaCB0aGUgcGF0aCBhcnJheSB0byBmaW5kIGFuIGVudHJ5XG4gICAgICAgICAgICB0aGF0IHN0YXJ0cyB3aXRoIHdoZXJlIHRoZSBjdXJyZW50IHBhdGggZW5kcy4uLlxuICAgICAgICAgICovXG4gICAgICAgICAgdmFyIHggPSBwLnBhdGhbcC5wYXRoLmxlbmd0aCAtIDFdWzBdLFxuICAgICAgICAgICAgeSA9IHAucGF0aFtwLnBhdGgubGVuZ3RoIC0gMV1bMV07XG5cbiAgICAgICAgICBmb3IgKHZhciBrID0gcGF0aF9pZHggLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBNYXRoLmFicyhwYXRoc1trXVswXVswXSAtIHgpIDw9IGVwc2lsb24gJiZcbiAgICAgICAgICAgICAgTWF0aC5hYnMocGF0aHNba11bMF1bMV0gLSB5KSA8PSBlcHNpbG9uXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgZm9yICh2YXIgbCA9IHAucGF0aC5sZW5ndGggLSAyOyBsID49IDA7IC0tbCkge1xuICAgICAgICAgICAgICAgIHBhdGhzW2tdLnVuc2hpZnQocC5wYXRoW2xdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtZXJnZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFtZXJnZWQpIHBhdGhzW3BhdGhfaWR4KytdID0gcC5wYXRoO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcGF0aHM7XG59XG5cbi8qXG4gIGNvbnN0cnVjdCBjb25zZWN1dGl2ZSBsaW5lIHNlZ21lbnRzIGZyb20gc3RhcnRpbmcgY2VsbCBieVxuICB3YWxraW5nIGFycm91bmQgdGhlIGVuY2xvc2VkIGFyZWEgY2xvY2std2lzZVxuICAqL1xuZnVuY3Rpb24gdHJhY2VQYXRoKGdyaWQsIGosIGkpIHtcbiAgdmFyIG1heGogPSBncmlkLmxlbmd0aDtcbiAgdmFyIHAgPSBbXTtcbiAgdmFyIGR4Q29udG91ciA9IFswLCAwLCAxLCAxLCAwLCAwLCAwLCAwLCAtMSwgMCwgMSwgMSwgLTEsIDAsIC0xLCAwXTtcbiAgdmFyIGR5Q29udG91ciA9IFswLCAtMSwgMCwgMCwgMSwgMSwgMSwgMSwgMCwgLTEsIDAsIDAsIDAsIC0xLCAwLCAwXTtcbiAgdmFyIGR4LCBkeTtcbiAgdmFyIHN0YXJ0RWRnZSA9IFtcbiAgICBcIm5vbmVcIixcbiAgICBcImxlZnRcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcIm5vbmVcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwidG9wXCIsXG4gICAgXCJ0b3BcIixcbiAgICBcIm5vbmVcIixcbiAgICBcInRvcFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJib3R0b21cIixcbiAgICBcIm5vbmVcIixcbiAgXTtcbiAgdmFyIG5leHRFZGdlID0gW1xuICAgIFwibm9uZVwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcInRvcFwiLFxuICAgIFwidG9wXCIsXG4gICAgXCJ0b3BcIixcbiAgICBcInRvcFwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwicmlnaHRcIixcbiAgICBcImxlZnRcIixcbiAgICBcImJvdHRvbVwiLFxuICAgIFwibGVmdFwiLFxuICAgIFwibm9uZVwiLFxuICBdO1xuICB2YXIgZWRnZTtcblxuICB2YXIgY3VycmVudENlbGwgPSBncmlkW2pdW2ldO1xuXG4gIHZhciBjdmFsID0gY3VycmVudENlbGwuY3ZhbDtcbiAgdmFyIGVkZ2UgPSBzdGFydEVkZ2VbY3ZhbF07XG5cbiAgdmFyIHB0ID0gZ2V0WFkoY3VycmVudENlbGwsIGVkZ2UpO1xuXG4gIC8qIHB1c2ggaW5pdGlhbCBzZWdtZW50ICovXG4gIHAucHVzaChbaSArIHB0WzBdLCBqICsgcHRbMV1dKTtcbiAgZWRnZSA9IG5leHRFZGdlW2N2YWxdO1xuICBwdCA9IGdldFhZKGN1cnJlbnRDZWxsLCBlZGdlKTtcbiAgcC5wdXNoKFtpICsgcHRbMF0sIGogKyBwdFsxXV0pO1xuICBjbGVhckNlbGwoY3VycmVudENlbGwpO1xuXG4gIC8qIG5vdyB3YWxrIGFycm91bmQgdGhlIGVuY2xvc2VkIGFyZWEgaW4gY2xvY2t3aXNlLWRpcmVjdGlvbiAqL1xuICB2YXIgayA9IGkgKyBkeENvbnRvdXJbY3ZhbF07XG4gIHZhciBsID0gaiArIGR5Q29udG91cltjdmFsXTtcbiAgdmFyIHByZXZfY3ZhbCA9IGN2YWw7XG5cbiAgd2hpbGUgKGsgPj0gMCAmJiBsID49IDAgJiYgbCA8IG1heGogJiYgKGsgIT0gaSB8fCBsICE9IGopKSB7XG4gICAgY3VycmVudENlbGwgPSBncmlkW2xdW2tdO1xuICAgIGlmICh0eXBlb2YgY3VycmVudENlbGwgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIC8qIHBhdGggZW5kcyBoZXJlICovXG4gICAgICAvL2NvbnNvbGUubG9nKGsgKyBcIiBcIiArIGwgKyBcIiBpcyB1bmRlZmluZWQsIHN0b3BwaW5nIHBhdGghXCIpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN2YWwgPSBjdXJyZW50Q2VsbC5jdmFsO1xuICAgIGlmIChjdmFsID09PSAwIHx8IGN2YWwgPT09IDE1KSB7XG4gICAgICByZXR1cm4geyBwYXRoOiBwLCBpbmZvOiBcIm1lcmdlYWJsZVwiIH07XG4gICAgfVxuICAgIGVkZ2UgPSBuZXh0RWRnZVtjdmFsXTtcbiAgICBkeCA9IGR4Q29udG91cltjdmFsXTtcbiAgICBkeSA9IGR5Q29udG91cltjdmFsXTtcbiAgICBpZiAoY3ZhbCA9PT0gNSB8fCBjdmFsID09PSAxMCkge1xuICAgICAgLyogc2VsZWN0IHVwcGVyIG9yIGxvd2VyIGJhbmQsIGRlcGVuZGluZyBvbiBwcmV2aW91cyBjZWxscyBjdmFsICovXG4gICAgICBpZiAoY3ZhbCA9PT0gNSkge1xuICAgICAgICBpZiAoY3VycmVudENlbGwuZmxpcHBlZCkge1xuICAgICAgICAgIC8qIHRoaXMgaXMgYWN0dWFsbHkgYSBmbGlwcGVkIGNhc2UgMTAgKi9cbiAgICAgICAgICBpZiAoZHlDb250b3VyW3ByZXZfY3ZhbF0gPT09IC0xKSB7XG4gICAgICAgICAgICBlZGdlID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICBkeCA9IC0xO1xuICAgICAgICAgICAgZHkgPSAwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlZGdlID0gXCJyaWdodFwiO1xuICAgICAgICAgICAgZHggPSAxO1xuICAgICAgICAgICAgZHkgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiByZWFsIGNhc2UgNSAqL1xuICAgICAgICAgIGlmIChkeENvbnRvdXJbcHJldl9jdmFsXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBcImJvdHRvbVwiO1xuICAgICAgICAgICAgZHggPSAwO1xuICAgICAgICAgICAgZHkgPSAtMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY3ZhbCA9PT0gMTApIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDZWxsLmZsaXBwZWQpIHtcbiAgICAgICAgICAvKiB0aGlzIGlzIGFjdHVhbGx5IGEgZmxpcHBlZCBjYXNlIDUgKi9cbiAgICAgICAgICBpZiAoZHhDb250b3VyW3ByZXZfY3ZhbF0gPT09IC0xKSB7XG4gICAgICAgICAgICBlZGdlID0gXCJ0b3BcIjtcbiAgICAgICAgICAgIGR4ID0gMDtcbiAgICAgICAgICAgIGR5ID0gMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRnZSA9IFwiYm90dG9tXCI7XG4gICAgICAgICAgICBkeCA9IDA7XG4gICAgICAgICAgICBkeSA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvKiByZWFsIGNhc2UgMTAgKi9cbiAgICAgICAgICBpZiAoZHlDb250b3VyW3ByZXZfY3ZhbF0gPT09IDEpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBcImxlZnRcIjtcbiAgICAgICAgICAgIGR4ID0gLTE7XG4gICAgICAgICAgICBkeSA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHB0ID0gZ2V0WFkoY3VycmVudENlbGwsIGVkZ2UpO1xuICAgIHAucHVzaChbayArIHB0WzBdLCBsICsgcHRbMV1dKTtcbiAgICBjbGVhckNlbGwoY3VycmVudENlbGwpO1xuICAgIGsgKz0gZHg7XG4gICAgbCArPSBkeTtcbiAgICBwcmV2X2N2YWwgPSBjdmFsO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aDogcCwgaW5mbzogXCJjbG9zZWRcIiB9O1xufVxuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIFBvaW50fSBncmlkIGFuZCByZXR1cm5zIGEgY29ycmVzcG9uZGVudCBtYXRyaXgge0FycmF5PEFycmF5PG51bWJlcj4+fVxuICogb2YgdGhlICdwcm9wZXJ0eScgdmFsdWVzXG4gKlxuICogQG5hbWUgZ3JpZFRvTWF0cml4XG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gZ3JpZCBvZiBwb2ludHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnpQcm9wZXJ0eT0nZWxldmF0aW9uJ10gdGhlIHByb3BlcnR5IG5hbWUgaW4gYHBvaW50c2AgZnJvbSB3aGljaCB6LXZhbHVlcyB3aWxsIGJlIHB1bGxlZFxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mbGlwPWZhbHNlXSByZXR1cm5zIHRoZSBtYXRyaXggdXBzaWRlLWRvd25cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZmxhZ3M9ZmFsc2VdIGZsYWdzLCBhZGRpbmcgYSBgbWF0cml4UG9zaXRpb25gIGFycmF5IGZpZWxkIChbcm93LCBjb2x1bW5dKSB0byBpdHMgcHJvcGVydGllcyxcbiAqIHRoZSBncmlkIHBvaW50cyB3aXRoIGNvb3JkaW5hdGVzIG9uIHRoZSBtYXRyaXhcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0cml4IG9mIHByb3BlcnR5IHZhbHVlc1xuICogQGV4YW1wbGVcbiAqICAgdmFyIGV4dGVudCA9IFstNzAuODIzMzY0LCAtMzMuNTUzOTg0LCAtNzAuNDczMTc1LCAtMzMuMzAyOTg2XTtcbiAqICAgdmFyIGNlbGxTaXplID0gMztcbiAqICAgdmFyIGdyaWQgPSB0dXJmLnBvaW50R3JpZChleHRlbnQsIGNlbGxTaXplKTtcbiAqICAgLy8gYWRkIGEgcmFuZG9tIHByb3BlcnR5IHRvIGVhY2ggcG9pbnQgYmV0d2VlbiAwIGFuZCA2MFxuICogICBmb3IgKHZhciBpID0gMDsgaSA8IGdyaWQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAqICAgICBncmlkLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMuZWxldmF0aW9uID0gKE1hdGgucmFuZG9tKCkgKiA2MCk7XG4gKiAgIH1cbiAqICAgZ3JpZFRvTWF0cml4KGdyaWQpO1xuICogICAvLz0gW1xuICogICAgIFsgMSwgMTMsIDEwLCAgOSwgMTAsIDEzLCAxOF0sXG4gKiAgICAgWzM0LCAgOCwgIDUsICA0LCAgNSwgIDgsIDEzXSxcbiAqICAgICBbMTAsICA1LCAgMiwgIDEsICAyLCAgNSwgIDRdLFxuICogICAgIFsgMCwgIDQsIDU2LCAxOSwgIDEsICA0LCAgOV0sXG4gKiAgICAgWzEwLCAgNSwgIDIsICAxLCAgMiwgIDUsIDEwXSxcbiAqICAgICBbNTcsICA4LCAgNSwgIDQsICA1LCAgMCwgNTddLFxuICogICAgIFsgMywgMTMsIDEwLCAgOSwgIDUsIDEzLCAxOF0sXG4gKiAgICAgWzE4LCAxMywgMTAsICA5LCA3OCwgMTMsIDE4XVxuICogICBdXG4gKi9cbmZ1bmN0aW9uIGdyaWRUb01hdHJpeChncmlkLCBvcHRpb25zKSB7XG4gIC8vIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghaXNPYmplY3Qob3B0aW9ucykpIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMgaXMgaW52YWxpZFwiKTtcbiAgdmFyIHpQcm9wZXJ0eSA9IG9wdGlvbnMuelByb3BlcnR5IHx8IFwiZWxldmF0aW9uXCI7XG4gIHZhciBmbGlwID0gb3B0aW9ucy5mbGlwO1xuICB2YXIgZmxhZ3MgPSBvcHRpb25zLmZsYWdzO1xuXG4gIC8vIHZhbGlkYXRpb25cbiAgY29sbGVjdGlvbk9mKGdyaWQsIFwiUG9pbnRcIiwgXCJpbnB1dCBtdXN0IGNvbnRhaW4gUG9pbnRzXCIpO1xuXG4gIHZhciBwb2ludHNNYXRyaXggPSBzb3J0UG9pbnRzQnlMYXRMbmcoZ3JpZCwgZmxpcCk7XG5cbiAgdmFyIG1hdHJpeCA9IFtdO1xuICAvLyBjcmVhdGUgcHJvcGVydHkgbWF0cml4IGZyb20gc29ydGVkIHBvaW50c1xuICAvLyBsb29waW5nIG9yZGVyIG1hdHRlcnMgaGVyZVxuICBmb3IgKHZhciByID0gMDsgciA8IHBvaW50c01hdHJpeC5sZW5ndGg7IHIrKykge1xuICAgIHZhciBwb2ludFJvdyA9IHBvaW50c01hdHJpeFtyXTtcbiAgICB2YXIgcm93ID0gW107XG4gICAgZm9yICh2YXIgYyA9IDA7IGMgPCBwb2ludFJvdy5sZW5ndGg7IGMrKykge1xuICAgICAgdmFyIHBvaW50ID0gcG9pbnRSb3dbY107XG4gICAgICAvLyBDaGVjayBpZiB6UHJvcGVydHkgZXhpc3RcbiAgICAgIGlmIChwb2ludC5wcm9wZXJ0aWVzW3pQcm9wZXJ0eV0pIHJvdy5wdXNoKHBvaW50LnByb3BlcnRpZXNbelByb3BlcnR5XSk7XG4gICAgICBlbHNlIHJvdy5wdXNoKDApO1xuICAgICAgLy8gYWRkIGZsYWdzXG4gICAgICBpZiAoZmxhZ3MgPT09IHRydWUpIHBvaW50LnByb3BlcnRpZXMubWF0cml4UG9zaXRpb24gPSBbciwgY107XG4gICAgfVxuICAgIG1hdHJpeC5wdXNoKHJvdyk7XG4gIH1cblxuICByZXR1cm4gbWF0cml4O1xufVxuXG4vKipcbiAqIFNvcnRzIHBvaW50cyBieSBsYXRpdHVkZSBhbmQgbG9uZ2l0dWRlLCBjcmVhdGluZyBhIDItZGltZW5zaW9uYWwgYXJyYXkgb2YgcG9pbnRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgR2VvSlNPTiBQb2ludCBmZWF0dXJlc1xuICogQHBhcmFtIHtib29sZWFufSBbZmxpcD1mYWxzZV0gcmV0dXJucyB0aGUgbWF0cml4IHVwc2lkZS1kb3duXG4gKiBAcmV0dXJucyB7QXJyYXk8QXJyYXk8UG9pbnQ+Pn0gcG9pbnRzIG9yZGVyZWQgYnkgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZVxuICovXG5mdW5jdGlvbiBzb3J0UG9pbnRzQnlMYXRMbmcocG9pbnRzLCBmbGlwKSB7XG4gIHZhciBwb2ludHNCeUxhdGl0dWRlID0ge307XG5cbiAgLy8gZGl2aWRlIHBvaW50cyBieSByb3dzIHdpdGggdGhlIHNhbWUgbGF0aXR1ZGVcbiAgZmVhdHVyZUVhY2gocG9pbnRzLCBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgbGF0ID0gZ2V0Q29vcmRzKHBvaW50KVsxXTtcbiAgICBpZiAoIXBvaW50c0J5TGF0aXR1ZGVbbGF0XSkgcG9pbnRzQnlMYXRpdHVkZVtsYXRdID0gW107XG4gICAgcG9pbnRzQnlMYXRpdHVkZVtsYXRdLnB1c2gocG9pbnQpO1xuICB9KTtcblxuICAvLyBzb3J0IHBvaW50cyAod2l0aCB0aGUgc2FtZSBsYXRpdHVkZSkgYnkgbG9uZ2l0dWRlXG4gIHZhciBvcmRlcmVkUm93c0J5TGF0aXR1ZGUgPSBPYmplY3Qua2V5cyhwb2ludHNCeUxhdGl0dWRlKS5tYXAoZnVuY3Rpb24gKGxhdCkge1xuICAgIHZhciByb3cgPSBwb2ludHNCeUxhdGl0dWRlW2xhdF07XG4gICAgdmFyIHJvd09yZGVyZWRCeUxvbmdpdHVkZSA9IHJvdy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZ2V0Q29vcmRzKGEpWzBdIC0gZ2V0Q29vcmRzKGIpWzBdO1xuICAgIH0pO1xuICAgIHJldHVybiByb3dPcmRlcmVkQnlMb25naXR1ZGU7XG4gIH0pO1xuXG4gIC8vIHNvcnQgcm93cyAob2YgcG9pbnRzIHdpdGggdGhlIHNhbWUgbGF0aXR1ZGUpIGJ5IGxhdGl0dWRlXG4gIHZhciBwb2ludE1hdHJpeCA9IG9yZGVyZWRSb3dzQnlMYXRpdHVkZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGZsaXApIHJldHVybiBnZXRDb29yZHMoYVswXSlbMV0gLSBnZXRDb29yZHMoYlswXSlbMV07XG4gICAgZWxzZSByZXR1cm4gZ2V0Q29vcmRzKGJbMF0pWzFdIC0gZ2V0Q29vcmRzKGFbMF0pWzFdO1xuICB9KTtcblxuICByZXR1cm4gcG9pbnRNYXRyaXg7XG59XG5cbi8qKlxuICogVGFrZXMgYSBncmlkIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gb2Yge0BsaW5rIFBvaW50fSBmZWF0dXJlcyB3aXRoIHotdmFsdWVzIGFuZCBhbiBhcnJheSBvZlxuICogdmFsdWUgYnJlYWtzIGFuZCBnZW5lcmF0ZXMgW2lzb2xpbmVzXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db250b3VyX2xpbmUpLlxuICpcbiAqIEBuYW1lIGlzb2xpbmVzXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gcG9pbnRHcmlkIGlucHV0IHBvaW50c1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBicmVha3MgdmFsdWVzIG9mIGB6UHJvcGVydHlgIHdoZXJlIHRvIGRyYXcgaXNvbGluZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnpQcm9wZXJ0eT0nZWxldmF0aW9uJ10gdGhlIHByb3BlcnR5IG5hbWUgaW4gYHBvaW50c2AgZnJvbSB3aGljaCB6LXZhbHVlcyB3aWxsIGJlIHB1bGxlZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmNvbW1vblByb3BlcnRpZXM9e31dIEdlb0pTT04gcHJvcGVydGllcyBwYXNzZWQgdG8gQUxMIGlzb2xpbmVzXG4gKiBAcGFyYW0ge0FycmF5PE9iamVjdD59IFtvcHRpb25zLmJyZWFrc1Byb3BlcnRpZXM9W11dIEdlb0pTT04gcHJvcGVydGllcyBwYXNzZWQsIGluIG9yZGVyLCB0byB0aGUgY29ycmVzcG9uZGVudCBpc29saW5lO1xuICogdGhlIGJyZWFrcyBhcnJheSB3aWxsIGRlZmluZSB0aGUgb3JkZXIgaW4gd2hpY2ggdGhlIGlzb2xpbmVzIGFyZSBjcmVhdGVkXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248TXVsdGlMaW5lU3RyaW5nPn0gYSBGZWF0dXJlQ29sbGVjdGlvbiBvZiB7QGxpbmsgTXVsdGlMaW5lU3RyaW5nfSBmZWF0dXJlcyByZXByZXNlbnRpbmcgaXNvbGluZXNcbiAqIEBleGFtcGxlXG4gKiAvLyBjcmVhdGUgYSBncmlkIG9mIHBvaW50cyB3aXRoIHJhbmRvbSB6LXZhbHVlcyBpbiB0aGVpciBwcm9wZXJ0aWVzXG4gKiB2YXIgZXh0ZW50ID0gWzAsIDMwLCAyMCwgNTBdO1xuICogdmFyIGNlbGxXaWR0aCA9IDEwMDtcbiAqIHZhciBwb2ludEdyaWQgPSB0dXJmLnBvaW50R3JpZChleHRlbnQsIGNlbGxXaWR0aCwge3VuaXRzOiAnbWlsZXMnfSk7XG4gKlxuICogZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludEdyaWQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAqICAgICBwb2ludEdyaWQuZmVhdHVyZXNbaV0ucHJvcGVydGllcy50ZW1wZXJhdHVyZSA9IE1hdGgucmFuZG9tKCkgKiAxMDtcbiAqIH1cbiAqIHZhciBicmVha3MgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdO1xuICpcbiAqIHZhciBsaW5lcyA9IHR1cmYuaXNvbGluZXMocG9pbnRHcmlkLCBicmVha3MsIHt6UHJvcGVydHk6ICd0ZW1wZXJhdHVyZSd9KTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbbGluZXNdO1xuICovXG5mdW5jdGlvbiBpc29saW5lcyhwb2ludEdyaWQsIGJyZWFrcywgb3B0aW9ucykge1xuICAvLyBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zIGlzIGludmFsaWRcIik7XG4gIHZhciB6UHJvcGVydHkgPSBvcHRpb25zLnpQcm9wZXJ0eSB8fCBcImVsZXZhdGlvblwiO1xuICB2YXIgY29tbW9uUHJvcGVydGllcyA9IG9wdGlvbnMuY29tbW9uUHJvcGVydGllcyB8fCB7fTtcbiAgdmFyIGJyZWFrc1Byb3BlcnRpZXMgPSBvcHRpb25zLmJyZWFrc1Byb3BlcnRpZXMgfHwgW107XG5cbiAgLy8gSW5wdXQgdmFsaWRhdGlvblxuICBjb2xsZWN0aW9uT2YocG9pbnRHcmlkLCBcIlBvaW50XCIsIFwiSW5wdXQgbXVzdCBjb250YWluIFBvaW50c1wiKTtcbiAgaWYgKCFicmVha3MpIHRocm93IG5ldyBFcnJvcihcImJyZWFrcyBpcyByZXF1aXJlZFwiKTtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGJyZWFrcykpIHRocm93IG5ldyBFcnJvcihcImJyZWFrcyBtdXN0IGJlIGFuIEFycmF5XCIpO1xuICBpZiAoIWlzT2JqZWN0KGNvbW1vblByb3BlcnRpZXMpKVxuICAgIHRocm93IG5ldyBFcnJvcihcImNvbW1vblByb3BlcnRpZXMgbXVzdCBiZSBhbiBPYmplY3RcIik7XG4gIGlmICghQXJyYXkuaXNBcnJheShicmVha3NQcm9wZXJ0aWVzKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJicmVha3NQcm9wZXJ0aWVzIG11c3QgYmUgYW4gQXJyYXlcIik7XG5cbiAgLy8gSXNvbGluZSBtZXRob2RzXG4gIHZhciBtYXRyaXggPSBncmlkVG9NYXRyaXgocG9pbnRHcmlkLCB7IHpQcm9wZXJ0eTogelByb3BlcnR5LCBmbGlwOiB0cnVlIH0pO1xuICB2YXIgY3JlYXRlZElzb0xpbmVzID0gY3JlYXRlSXNvTGluZXMoXG4gICAgbWF0cml4LFxuICAgIGJyZWFrcyxcbiAgICB6UHJvcGVydHksXG4gICAgY29tbW9uUHJvcGVydGllcyxcbiAgICBicmVha3NQcm9wZXJ0aWVzXG4gICk7XG4gIHZhciBzY2FsZWRJc29saW5lcyA9IHJlc2NhbGVJc29saW5lcyhjcmVhdGVkSXNvTGluZXMsIG1hdHJpeCwgcG9pbnRHcmlkKTtcblxuICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oc2NhbGVkSXNvbGluZXMpO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgdGhlIGlzb2xpbmVzIGxpbmVzIChmZWF0dXJlc0NvbGxlY3Rpb24gb2YgTXVsdGlMaW5lU3RyaW5nIGZlYXR1cmVzKSBmcm9tIHRoZSAyRCBkYXRhIGdyaWRcbiAqXG4gKiBNYXJjaGluZ3NxdWFyZXMgcHJvY2VzcyB0aGUgZ3JpZCBkYXRhIGFzIGEgM0QgcmVwcmVzZW50YXRpb24gb2YgYSBmdW5jdGlvbiBvbiBhIDJEIHBsYW5lLCB0aGVyZWZvcmUgaXRcbiAqIGFzc3VtZXMgdGhlIHBvaW50cyAoeC15IGNvb3JkaW5hdGVzKSBhcmUgb25lICd1bml0JyBkaXN0YW5jZS4gVGhlIHJlc3VsdCBvZiB0aGUgaXNvbGluZXMgZnVuY3Rpb24gbmVlZHMgdG8gYmVcbiAqIHJlc2NhbGVkLCB3aXRoIHR1cmZqcywgdG8gdGhlIG9yaWdpbmFsIGFyZWEgYW5kIHByb3BvcnRpb25zIG9uIHRoZSBtYXBcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gbWF0cml4IEdyaWQgRGF0YVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBicmVha3MgQnJlYWtzXG4gKiBAcGFyYW0ge3N0cmluZ30gelByb3BlcnR5IG5hbWUgb2YgdGhlIHotdmFsdWVzIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbW1vblByb3BlcnRpZXM9e31dIEdlb0pTT04gcHJvcGVydGllcyBwYXNzZWQgdG8gQUxMIGlzb2xpbmVzXG4gKiBAcGFyYW0ge09iamVjdH0gW2JyZWFrc1Byb3BlcnRpZXM9W11dIEdlb0pTT04gcHJvcGVydGllcyBwYXNzZWQgdG8gdGhlIGNvcnJlc3BvbmRlbnQgaXNvbGluZVxuICogQHJldHVybnMge0FycmF5PE11bHRpTGluZVN0cmluZz59IGlzb2xpbmVzXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlzb0xpbmVzKFxuICBtYXRyaXgsXG4gIGJyZWFrcyxcbiAgelByb3BlcnR5LFxuICBjb21tb25Qcm9wZXJ0aWVzLFxuICBicmVha3NQcm9wZXJ0aWVzXG4pIHtcbiAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBicmVha3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGhyZXNob2xkID0gK2JyZWFrc1tpXTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBudW1iZXJcblxuICAgIHZhciBwcm9wZXJ0aWVzID0gb2JqZWN0QXNzaWduKHt9LCBjb21tb25Qcm9wZXJ0aWVzLCBicmVha3NQcm9wZXJ0aWVzW2ldKTtcbiAgICBwcm9wZXJ0aWVzW3pQcm9wZXJ0eV0gPSB0aHJlc2hvbGQ7XG4gICAgdmFyIGlzb2xpbmUgPSBtdWx0aUxpbmVTdHJpbmcoaXNvQ29udG91cnMobWF0cml4LCB0aHJlc2hvbGQpLCBwcm9wZXJ0aWVzKTtcblxuICAgIHJlc3VsdHMucHVzaChpc29saW5lKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGVzIGFuZCBzY2FsZXMgaXNvbGluZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxNdWx0aUxpbmVTdHJpbmc+fSBjcmVhdGVkSXNvTGluZXMgdG8gYmUgcmVzY2FsZWRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IG1hdHJpeCBHcmlkIERhdGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBwb2ludHMgUG9pbnRzIGJ5IExhdGl0dWRlXG4gKiBAcmV0dXJucyB7QXJyYXk8TXVsdGlMaW5lU3RyaW5nPn0gaXNvbGluZXNcbiAqL1xuZnVuY3Rpb24gcmVzY2FsZUlzb2xpbmVzKGNyZWF0ZWRJc29MaW5lcywgbWF0cml4LCBwb2ludHMpIHtcbiAgLy8gZ2V0IGRpbWVuc2lvbnMgKG9uIHRoZSBtYXApIG9mIHRoZSBvcmlnaW5hbCBncmlkXG4gIHZhciBncmlkQmJveCA9IGJib3gocG9pbnRzKTsgLy8gWyBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIF1cbiAgdmFyIG9yaWdpbmFsV2lkdGggPSBncmlkQmJveFsyXSAtIGdyaWRCYm94WzBdO1xuICB2YXIgb3JpZ2luYWxIZWlndGggPSBncmlkQmJveFszXSAtIGdyaWRCYm94WzFdO1xuXG4gIC8vIGdldCBvcmlnaW4sIHdoaWNoIGlzIHRoZSBmaXJzdCBwb2ludCBvZiB0aGUgbGFzdCByb3cgb24gdGhlIHJlY3Rhbmd1bGFyIGRhdGEgb24gdGhlIG1hcFxuICB2YXIgeDAgPSBncmlkQmJveFswXTtcbiAgdmFyIHkwID0gZ3JpZEJib3hbMV07XG5cbiAgLy8gZ2V0IG51bWJlciBvZiBjZWxscyBwZXIgc2lkZVxuICB2YXIgbWF0cml4V2lkdGggPSBtYXRyaXhbMF0ubGVuZ3RoIC0gMTtcbiAgdmFyIG1hdHJpeEhlaWdodCA9IG1hdHJpeC5sZW5ndGggLSAxO1xuXG4gIC8vIGNhbGN1bGF0ZSB0aGUgc2NhbGluZyBmYWN0b3IgYmV0d2VlbiBtYXRyaXggYW5kIHJlY3Rhbmd1bGFyIGdyaWQgb24gdGhlIG1hcFxuICB2YXIgc2NhbGVYID0gb3JpZ2luYWxXaWR0aCAvIG1hdHJpeFdpZHRoO1xuICB2YXIgc2NhbGVZID0gb3JpZ2luYWxIZWlndGggLyBtYXRyaXhIZWlnaHQ7XG5cbiAgdmFyIHJlc2l6ZSA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgIHBvaW50WzBdID0gcG9pbnRbMF0gKiBzY2FsZVggKyB4MDtcbiAgICBwb2ludFsxXSA9IHBvaW50WzFdICogc2NhbGVZICsgeTA7XG4gIH07XG5cbiAgLy8gcmVzaXplIGFuZCBzaGlmdCBlYWNoIHBvaW50L2xpbmUgb2YgdGhlIGNyZWF0ZWRJc29MaW5lc1xuICBjcmVhdGVkSXNvTGluZXMuZm9yRWFjaChmdW5jdGlvbiAoaXNvbGluZSkge1xuICAgIGNvb3JkRWFjaChpc29saW5lLCByZXNpemUpO1xuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZWRJc29MaW5lcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNvbGluZXM7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+isolines@6.5.0/node_modules/@turf/isolines/dist/es/index.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turf+polygonize@6.5.0";
exports.ids = ["vendor-chunks/@turf+polygonize@6.5.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/index.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/index.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ polygonize)\n/* harmony export */ });\n/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ \"(ssr)/./node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js\");\n/* harmony import */ var _lib_Graph_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/Graph.js */ \"(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Graph.js\");\n/* harmony import */ var _lib_EdgeRing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/EdgeRing.js */ \"(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js\");\n\n\n\n/**\n * Polygonizes {@link LineString|(Multi)LineString(s)} into {@link Polygons}.\n *\n * Implementation of GEOSPolygonize function (`geos::operation::polygonize::Polygonizer`).\n *\n * Polygonizes a set of lines that represents edges in a planar graph. Edges must be correctly\n * noded, i.e., they must only meet at their endpoints.\n *\n * The implementation correctly handles:\n *\n * - Dangles: edges which have one or both ends which are not incident on another edge endpoint.\n * - Cut Edges (bridges): edges that are connected at both ends but which do not form part of a polygon.\n *\n * @name polygonize\n * @param {FeatureCollection|Geometry|Feature<LineString|MultiLineString>} geoJson Lines in order to polygonize\n * @returns {FeatureCollection<Polygon>} Polygons created\n * @throws {Error} if geoJson is invalid.\n */\nfunction polygonize(geoJson) {\n    var graph = _lib_Graph_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fromGeoJson(geoJson);\n    // 1. Remove dangle node\n    graph.deleteDangles();\n    // 2. Remove cut-edges (bridge edges)\n    graph.deleteCutEdges();\n    // 3. Get all holes and shells\n    var holes = [], shells = [];\n    graph\n        .getEdgeRings()\n        .filter(function (edgeRing) { return edgeRing.isValid(); })\n        .forEach(function (edgeRing) {\n        if (edgeRing.isHole())\n            holes.push(edgeRing);\n        else\n            shells.push(edgeRing);\n    });\n    // 4. Assign Holes to Shells\n    holes.forEach(function (hole) {\n        if (_lib_EdgeRing_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"].findEdgeRingContaining(hole, shells))\n            shells.push(hole);\n    });\n    // 5. EdgeRings to Polygons\n    return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.featureCollection)(shells.map(function (shell) { return shell.toPolygon(); }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcG9seWdvbml6ZUA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbml6ZS9kaXN0L2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0Q7QUFDZjtBQUNNO0FBQ3pDO0FBQ0EsZ0JBQWdCLHVDQUF1QyxNQUFNLGVBQWU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnRUFBZ0U7QUFDM0UsYUFBYSw0QkFBNEI7QUFDekMsWUFBWSxPQUFPO0FBQ25CO0FBQ2U7QUFDZixnQkFBZ0IscURBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw0QkFBNEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSx3REFBUTtBQUNwQjtBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVcsZ0VBQWlCLCtCQUErQiwyQkFBMkI7QUFDdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZnZhbHVlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0dXJmK3BvbHlnb25pemVANi41LjAvbm9kZV9tb2R1bGVzL0B0dXJmL3BvbHlnb25pemUvZGlzdC9lcy9pbmRleC5qcz9lMDRhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZlYXR1cmVDb2xsZWN0aW9uIH0gZnJvbSBcIkB0dXJmL2hlbHBlcnNcIjtcbmltcG9ydCBHcmFwaCBmcm9tIFwiLi9saWIvR3JhcGguanNcIjtcbmltcG9ydCBFZGdlUmluZyBmcm9tIFwiLi9saWIvRWRnZVJpbmcuanNcIjtcbi8qKlxuICogUG9seWdvbml6ZXMge0BsaW5rIExpbmVTdHJpbmd8KE11bHRpKUxpbmVTdHJpbmcocyl9IGludG8ge0BsaW5rIFBvbHlnb25zfS5cbiAqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBHRU9TUG9seWdvbml6ZSBmdW5jdGlvbiAoYGdlb3M6Om9wZXJhdGlvbjo6cG9seWdvbml6ZTo6UG9seWdvbml6ZXJgKS5cbiAqXG4gKiBQb2x5Z29uaXplcyBhIHNldCBvZiBsaW5lcyB0aGF0IHJlcHJlc2VudHMgZWRnZXMgaW4gYSBwbGFuYXIgZ3JhcGguIEVkZ2VzIG11c3QgYmUgY29ycmVjdGx5XG4gKiBub2RlZCwgaS5lLiwgdGhleSBtdXN0IG9ubHkgbWVldCBhdCB0aGVpciBlbmRwb2ludHMuXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIGNvcnJlY3RseSBoYW5kbGVzOlxuICpcbiAqIC0gRGFuZ2xlczogZWRnZXMgd2hpY2ggaGF2ZSBvbmUgb3IgYm90aCBlbmRzIHdoaWNoIGFyZSBub3QgaW5jaWRlbnQgb24gYW5vdGhlciBlZGdlIGVuZHBvaW50LlxuICogLSBDdXQgRWRnZXMgKGJyaWRnZXMpOiBlZGdlcyB0aGF0IGFyZSBjb25uZWN0ZWQgYXQgYm90aCBlbmRzIGJ1dCB3aGljaCBkbyBub3QgZm9ybSBwYXJ0IG9mIGEgcG9seWdvbi5cbiAqXG4gKiBAbmFtZSBwb2x5Z29uaXplXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEdlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xNdWx0aUxpbmVTdHJpbmc+fSBnZW9Kc29uIExpbmVzIGluIG9yZGVyIHRvIHBvbHlnb25pemVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gUG9seWdvbnMgY3JlYXRlZFxuICogQHRocm93cyB7RXJyb3J9IGlmIGdlb0pzb24gaXMgaW52YWxpZC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcG9seWdvbml6ZShnZW9Kc29uKSB7XG4gICAgdmFyIGdyYXBoID0gR3JhcGguZnJvbUdlb0pzb24oZ2VvSnNvbik7XG4gICAgLy8gMS4gUmVtb3ZlIGRhbmdsZSBub2RlXG4gICAgZ3JhcGguZGVsZXRlRGFuZ2xlcygpO1xuICAgIC8vIDIuIFJlbW92ZSBjdXQtZWRnZXMgKGJyaWRnZSBlZGdlcylcbiAgICBncmFwaC5kZWxldGVDdXRFZGdlcygpO1xuICAgIC8vIDMuIEdldCBhbGwgaG9sZXMgYW5kIHNoZWxsc1xuICAgIHZhciBob2xlcyA9IFtdLCBzaGVsbHMgPSBbXTtcbiAgICBncmFwaFxuICAgICAgICAuZ2V0RWRnZVJpbmdzKClcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWRnZVJpbmcpIHsgcmV0dXJuIGVkZ2VSaW5nLmlzVmFsaWQoKTsgfSlcbiAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGVkZ2VSaW5nKSB7XG4gICAgICAgIGlmIChlZGdlUmluZy5pc0hvbGUoKSlcbiAgICAgICAgICAgIGhvbGVzLnB1c2goZWRnZVJpbmcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzaGVsbHMucHVzaChlZGdlUmluZyk7XG4gICAgfSk7XG4gICAgLy8gNC4gQXNzaWduIEhvbGVzIHRvIFNoZWxsc1xuICAgIGhvbGVzLmZvckVhY2goZnVuY3Rpb24gKGhvbGUpIHtcbiAgICAgICAgaWYgKEVkZ2VSaW5nLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoaG9sZSwgc2hlbGxzKSlcbiAgICAgICAgICAgIHNoZWxscy5wdXNoKGhvbGUpO1xuICAgIH0pO1xuICAgIC8vIDUuIEVkZ2VSaW5ncyB0byBQb2x5Z29uc1xuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihzaGVsbHMubWFwKGZ1bmN0aW9uIChzaGVsbCkgeyByZXR1cm4gc2hlbGwudG9Qb2x5Z29uKCk7IH0pKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Edge.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Edge.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ \"(ssr)/./node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/util.js\");\n\n\n/**\n * This class is inspired by GEOS's geos::operation::polygonize::PolygonizeDirectedEdge\n */\nvar Edge = /** @class */ (function () {\n    /**\n     * @param {Node} from - start node of the Edge\n     * @param {Node} to - end node of the edge\n     */\n    function Edge(from, to) {\n        this.from = from; //< start\n        this.to = to; //< End\n        this.next = undefined; //< The edge to be computed after\n        this.label = undefined; //< Used in order to detect Cut Edges (Bridges)\n        this.symetric = undefined; //< The symetric edge of this\n        this.ring = undefined; //< EdgeRing in which the Edge is\n        this.from.addOuterEdge(this);\n        this.to.addInnerEdge(this);\n    }\n    /**\n     * Creates or get the symetric Edge.\n     *\n     * @returns {Edge} - Symetric Edge.\n     */\n    Edge.prototype.getSymetric = function () {\n        if (!this.symetric) {\n            this.symetric = new Edge(this.to, this.from);\n            this.symetric.symetric = this;\n        }\n        return this.symetric;\n    };\n    /**\n     * Removes edge from from and to nodes.\n     */\n    Edge.prototype.deleteEdge = function () {\n        this.from.removeOuterEdge(this);\n        this.to.removeInnerEdge(this);\n    };\n    /**\n     * Compares Edge equallity.\n     *\n     * An edge is equal to another, if the from and to nodes are the same.\n     *\n     * @param {Edge} edge - Another Edge\n     * @returns {boolean} - True if Edges are equal, False otherwise\n     */\n    Edge.prototype.isEqual = function (edge) {\n        return this.from.id === edge.from.id && this.to.id === edge.to.id;\n    };\n    Edge.prototype.toString = function () {\n        return \"Edge { \" + this.from.id + \" -> \" + this.to.id + \" }\";\n    };\n    /**\n     * Returns a LineString representation of the Edge\n     *\n     * @returns {Feature<LineString>} - LineString representation of the Edge\n     */\n    Edge.prototype.toLineString = function () {\n        return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)([this.from.coordinates, this.to.coordinates]);\n    };\n    /**\n     * Comparator of two edges.\n     *\n     * Implementation of geos::planargraph::DirectedEdge::compareTo.\n     *\n     * @param {Edge} edge - Another edge to compare with this one\n     * @returns {number} -1 if this Edge has a greater angle with the positive x-axis than b,\n     *          0 if the Edges are colinear,\n     *          1 otherwise\n     */\n    Edge.prototype.compareTo = function (edge) {\n        return (0,_util_js__WEBPACK_IMPORTED_MODULE_1__.orientationIndex)(edge.from.coordinates, edge.to.coordinates, this.to.coordinates);\n    };\n    return Edge;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Edge);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcG9seWdvbml6ZUA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbml6ZS9kaXN0L2VzL2xpYi9FZGdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyQztBQUNFO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsc0JBQXNCO0FBQ3RCLCtCQUErQjtBQUMvQixnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNENBQTRDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHFCQUFxQjtBQUN0QztBQUNBO0FBQ0EsZUFBZSx5REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFnQjtBQUMvQjtBQUNBO0FBQ0EsQ0FBQztBQUNELGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcG9seWdvbml6ZUA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbml6ZS9kaXN0L2VzL2xpYi9FZGdlLmpzP2JhZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbGluZVN0cmluZyB9IGZyb20gXCJAdHVyZi9oZWxwZXJzXCI7XG5pbXBvcnQgeyBvcmllbnRhdGlvbkluZGV4IH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuLyoqXG4gKiBUaGlzIGNsYXNzIGlzIGluc3BpcmVkIGJ5IEdFT1MncyBnZW9zOjpvcGVyYXRpb246OnBvbHlnb25pemU6OlBvbHlnb25pemVEaXJlY3RlZEVkZ2VcbiAqL1xudmFyIEVkZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBmcm9tIC0gc3RhcnQgbm9kZSBvZiB0aGUgRWRnZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdG8gLSBlbmQgbm9kZSBvZiB0aGUgZWRnZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEVkZ2UoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTsgLy88IHN0YXJ0XG4gICAgICAgIHRoaXMudG8gPSB0bzsgLy88IEVuZFxuICAgICAgICB0aGlzLm5leHQgPSB1bmRlZmluZWQ7IC8vPCBUaGUgZWRnZSB0byBiZSBjb21wdXRlZCBhZnRlclxuICAgICAgICB0aGlzLmxhYmVsID0gdW5kZWZpbmVkOyAvLzwgVXNlZCBpbiBvcmRlciB0byBkZXRlY3QgQ3V0IEVkZ2VzIChCcmlkZ2VzKVxuICAgICAgICB0aGlzLnN5bWV0cmljID0gdW5kZWZpbmVkOyAvLzwgVGhlIHN5bWV0cmljIGVkZ2Ugb2YgdGhpc1xuICAgICAgICB0aGlzLnJpbmcgPSB1bmRlZmluZWQ7IC8vPCBFZGdlUmluZyBpbiB3aGljaCB0aGUgRWRnZSBpc1xuICAgICAgICB0aGlzLmZyb20uYWRkT3V0ZXJFZGdlKHRoaXMpO1xuICAgICAgICB0aGlzLnRvLmFkZElubmVyRWRnZSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciBnZXQgdGhlIHN5bWV0cmljIEVkZ2UuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RWRnZX0gLSBTeW1ldHJpYyBFZGdlLlxuICAgICAqL1xuICAgIEVkZ2UucHJvdG90eXBlLmdldFN5bWV0cmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3ltZXRyaWMpIHtcbiAgICAgICAgICAgIHRoaXMuc3ltZXRyaWMgPSBuZXcgRWRnZSh0aGlzLnRvLCB0aGlzLmZyb20pO1xuICAgICAgICAgICAgdGhpcy5zeW1ldHJpYy5zeW1ldHJpYyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltZXRyaWM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGVkZ2UgZnJvbSBmcm9tIGFuZCB0byBub2Rlcy5cbiAgICAgKi9cbiAgICBFZGdlLnByb3RvdHlwZS5kZWxldGVFZGdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmZyb20ucmVtb3ZlT3V0ZXJFZGdlKHRoaXMpO1xuICAgICAgICB0aGlzLnRvLnJlbW92ZUlubmVyRWRnZSh0aGlzKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIEVkZ2UgZXF1YWxsaXR5LlxuICAgICAqXG4gICAgICogQW4gZWRnZSBpcyBlcXVhbCB0byBhbm90aGVyLCBpZiB0aGUgZnJvbSBhbmQgdG8gbm9kZXMgYXJlIHRoZSBzYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFZGdlfSBlZGdlIC0gQW5vdGhlciBFZGdlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBFZGdlcyBhcmUgZXF1YWwsIEZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIEVkZ2UucHJvdG90eXBlLmlzRXF1YWwgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tLmlkID09PSBlZGdlLmZyb20uaWQgJiYgdGhpcy50by5pZCA9PT0gZWRnZS50by5pZDtcbiAgICB9O1xuICAgIEVkZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gXCJFZGdlIHsgXCIgKyB0aGlzLmZyb20uaWQgKyBcIiAtPiBcIiArIHRoaXMudG8uaWQgKyBcIiB9XCI7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgTGluZVN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRWRnZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IC0gTGluZVN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgRWRnZVxuICAgICAqL1xuICAgIEVkZ2UucHJvdG90eXBlLnRvTGluZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoW3RoaXMuZnJvbS5jb29yZGluYXRlcywgdGhpcy50by5jb29yZGluYXRlc10pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ29tcGFyYXRvciBvZiB0d28gZWRnZXMuXG4gICAgICpcbiAgICAgKiBJbXBsZW1lbnRhdGlvbiBvZiBnZW9zOjpwbGFuYXJncmFwaDo6RGlyZWN0ZWRFZGdlOjpjb21wYXJlVG8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2UgLSBBbm90aGVyIGVkZ2UgdG8gY29tcGFyZSB3aXRoIHRoaXMgb25lXG4gICAgICogQHJldHVybnMge251bWJlcn0gLTEgaWYgdGhpcyBFZGdlIGhhcyBhIGdyZWF0ZXIgYW5nbGUgd2l0aCB0aGUgcG9zaXRpdmUgeC1heGlzIHRoYW4gYixcbiAgICAgKiAgICAgICAgICAwIGlmIHRoZSBFZGdlcyBhcmUgY29saW5lYXIsXG4gICAgICogICAgICAgICAgMSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBFZGdlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gb3JpZW50YXRpb25JbmRleChlZGdlLmZyb20uY29vcmRpbmF0ZXMsIGVkZ2UudG8uY29vcmRpbmF0ZXMsIHRoaXMudG8uY29vcmRpbmF0ZXMpO1xuICAgIH07XG4gICAgcmV0dXJuIEVkZ2U7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgRWRnZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Edge.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/util.js\");\n/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/helpers */ \"(ssr)/./node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js\");\n/* harmony import */ var _turf_envelope__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/envelope */ \"(ssr)/./node_modules/.pnpm/@turf+envelope@6.5.0/node_modules/@turf/envelope/dist/es/index.js\");\n/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @turf/boolean-point-in-polygon */ \"(ssr)/./node_modules/.pnpm/@turf+boolean-point-in-polygon@6.5.0/node_modules/@turf/boolean-point-in-polygon/dist/es/index.js\");\n\n\n\n\n/**\n * Ring of edges which form a polygon.\n *\n * The ring may be either an outer shell or a hole.\n *\n * This class is inspired in GEOS's geos::operation::polygonize::EdgeRing\n */\nvar EdgeRing = /** @class */ (function () {\n    function EdgeRing() {\n        this.edges = [];\n        this.polygon = undefined; //< Caches Polygon representation\n        this.envelope = undefined; //< Caches Envelope representation\n    }\n    /**\n     * Add an edge to the ring, inserting it in the last position.\n     *\n     * @memberof EdgeRing\n     * @param {Edge} edge - Edge to be inserted\n     */\n    EdgeRing.prototype.push = function (edge) {\n        this.edges.push(edge);\n        this.polygon = this.envelope = undefined;\n    };\n    /**\n     * Get Edge.\n     *\n     * @memberof EdgeRing\n     * @param {number} i - Index\n     * @returns {Edge} - Edge in the i position\n     */\n    EdgeRing.prototype.get = function (i) {\n        return this.edges[i];\n    };\n    Object.defineProperty(EdgeRing.prototype, \"length\", {\n        /**\n         * Getter of length property.\n         *\n         * @memberof EdgeRing\n         * @returns {number} - Length of the edge ring.\n         */\n        get: function () {\n            return this.edges.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Similar to Array.prototype.forEach for the list of Edges in the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @param {Function} f - The same function to be passed to Array.prototype.forEach\n     */\n    EdgeRing.prototype.forEach = function (f) {\n        this.edges.forEach(f);\n    };\n    /**\n     * Similar to Array.prototype.map for the list of Edges in the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @param {Function} f - The same function to be passed to Array.prototype.map\n     * @returns {Array} - The mapped values in the function\n     */\n    EdgeRing.prototype.map = function (f) {\n        return this.edges.map(f);\n    };\n    /**\n     * Similar to Array.prototype.some for the list of Edges in the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @param {Function} f - The same function to be passed to Array.prototype.some\n     * @returns {boolean} - True if an Edge check the condition\n     */\n    EdgeRing.prototype.some = function (f) {\n        return this.edges.some(f);\n    };\n    /**\n     * Check if the ring is valid in geomtry terms.\n     *\n     * A ring must have either 0 or 4 or more points. The first and the last must be\n     * equal (in 2D)\n     * geos::geom::LinearRing::validateConstruction\n     *\n     * @memberof EdgeRing\n     * @returns {boolean} - Validity of the EdgeRing\n     */\n    EdgeRing.prototype.isValid = function () {\n        // TODO: stub\n        return true;\n    };\n    /**\n     * Tests whether this ring is a hole.\n     *\n     * A ring is a hole if it is oriented counter-clockwise.\n     * Similar implementation of geos::algorithm::CGAlgorithms::isCCW\n     *\n     * @memberof EdgeRing\n     * @returns {boolean} - true: if it is a hole\n     */\n    EdgeRing.prototype.isHole = function () {\n        var _this = this;\n        // XXX: Assuming Ring is valid\n        // Find highest point\n        var hiIndex = this.edges.reduce(function (high, edge, i) {\n            if (edge.from.coordinates[1] > _this.edges[high].from.coordinates[1])\n                high = i;\n            return high;\n        }, 0), iPrev = (hiIndex === 0 ? this.length : hiIndex) - 1, iNext = (hiIndex + 1) % this.length, disc = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.orientationIndex)(this.edges[iPrev].from.coordinates, this.edges[hiIndex].from.coordinates, this.edges[iNext].from.coordinates);\n        if (disc === 0)\n            return (this.edges[iPrev].from.coordinates[0] >\n                this.edges[iNext].from.coordinates[0]);\n        return disc > 0;\n    };\n    /**\n     * Creates a MultiPoint representing the EdgeRing (discarts edges directions).\n     *\n     * @memberof EdgeRing\n     * @returns {Feature<MultiPoint>} - Multipoint representation of the EdgeRing\n     */\n    EdgeRing.prototype.toMultiPoint = function () {\n        return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.multiPoint)(this.edges.map(function (edge) { return edge.from.coordinates; }));\n    };\n    /**\n     * Creates a Polygon representing the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @returns {Feature<Polygon>} - Polygon representation of the Edge Ring\n     */\n    EdgeRing.prototype.toPolygon = function () {\n        if (this.polygon)\n            return this.polygon;\n        var coordinates = this.edges.map(function (edge) { return edge.from.coordinates; });\n        coordinates.push(this.edges[0].from.coordinates);\n        return (this.polygon = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.polygon)([coordinates]));\n    };\n    /**\n     * Calculates the envelope of the EdgeRing.\n     *\n     * @memberof EdgeRing\n     * @returns {Feature<Polygon>} - envelope\n     */\n    EdgeRing.prototype.getEnvelope = function () {\n        if (this.envelope)\n            return this.envelope;\n        return (this.envelope = (0,_turf_envelope__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this.toPolygon()));\n    };\n    /**\n     * `geos::operation::polygonize::EdgeRing::findEdgeRingContaining`\n     *\n     * @param {EdgeRing} testEdgeRing - EdgeRing to look in the list\n     * @param {EdgeRing[]} shellList - List of EdgeRing in which to search\n     *\n     * @returns {EdgeRing} - EdgeRing which contains the testEdgeRing\n     */\n    EdgeRing.findEdgeRingContaining = function (testEdgeRing, shellList) {\n        var testEnvelope = testEdgeRing.getEnvelope();\n        var minEnvelope, minShell;\n        shellList.forEach(function (shell) {\n            var tryEnvelope = shell.getEnvelope();\n            if (minShell)\n                minEnvelope = minShell.getEnvelope();\n            // the hole envelope cannot equal the shell envelope\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.envelopeIsEqual)(tryEnvelope, testEnvelope))\n                return;\n            if ((0,_util_js__WEBPACK_IMPORTED_MODULE_0__.envelopeContains)(tryEnvelope, testEnvelope)) {\n                var testEdgeRingCoordinates = testEdgeRing.map(function (edge) { return edge.from.coordinates; });\n                var testPoint = void 0;\n                var _loop_1 = function (pt) {\n                    if (!shell.some(function (edge) { return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.coordinatesEqual)(pt, edge.from.coordinates); })) {\n                        testPoint = pt;\n                    }\n                };\n                for (var _i = 0, testEdgeRingCoordinates_1 = testEdgeRingCoordinates; _i < testEdgeRingCoordinates_1.length; _i++) {\n                    var pt = testEdgeRingCoordinates_1[_i];\n                    _loop_1(pt);\n                }\n                if (testPoint && shell.inside((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.point)(testPoint))) {\n                    if (!minShell || (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.envelopeContains)(minEnvelope, tryEnvelope))\n                        minShell = shell;\n                }\n            }\n        });\n        return minShell;\n    };\n    /**\n     * Checks if the point is inside the edgeRing\n     *\n     * @param {Feature<Point>} pt - Point to check if it is inside the edgeRing\n     * @returns {boolean} - True if it is inside, False otherwise\n     */\n    EdgeRing.prototype.inside = function (pt) {\n        return (0,_turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(pt, this.toPolygon());\n    };\n    return EdgeRing;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EdgeRing);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcG9seWdvbml6ZUA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbml6ZS9kaXN0L2VzL2xpYi9FZGdlUmluZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRztBQUN2QztBQUN0QjtBQUM2QjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQyxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdUdBQXVHLDBEQUFnQjtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQSxlQUFlLHlEQUFVLGtDQUFrQywrQkFBK0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsK0JBQStCO0FBQzFGO0FBQ0EsK0JBQStCLHNEQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBEQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsWUFBWTtBQUMzQjtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5REFBZTtBQUMvQjtBQUNBLGdCQUFnQiwwREFBZ0I7QUFDaEMsaUZBQWlGLCtCQUErQjtBQUNoSDtBQUNBO0FBQ0Esc0RBQXNELE9BQU8sMERBQWdCLDhCQUE4QjtBQUMzRztBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsdUNBQXVDO0FBQzdIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxvREFBSztBQUNuRCxxQ0FBcUMsMERBQWdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0IsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLGVBQWUsMEVBQXFCO0FBQ3BDO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUVBQWUsUUFBUSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWZ2YWx1ZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHVyZitwb2x5Z29uaXplQDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi9wb2x5Z29uaXplL2Rpc3QvZXMvbGliL0VkZ2VSaW5nLmpzPzEyNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb3JpZW50YXRpb25JbmRleCwgZW52ZWxvcGVJc0VxdWFsLCBlbnZlbG9wZUNvbnRhaW5zLCBjb29yZGluYXRlc0VxdWFsLCB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCB7IG11bHRpUG9pbnQsIHBvbHlnb24sIHBvaW50LCB9IGZyb20gXCJAdHVyZi9oZWxwZXJzXCI7XG5pbXBvcnQgZW52ZWxvcGUgZnJvbSBcIkB0dXJmL2VudmVsb3BlXCI7XG5pbXBvcnQgYm9vbGVhblBvaW50SW5Qb2x5Z29uIGZyb20gXCJAdHVyZi9ib29sZWFuLXBvaW50LWluLXBvbHlnb25cIjtcbi8qKlxuICogUmluZyBvZiBlZGdlcyB3aGljaCBmb3JtIGEgcG9seWdvbi5cbiAqXG4gKiBUaGUgcmluZyBtYXkgYmUgZWl0aGVyIGFuIG91dGVyIHNoZWxsIG9yIGEgaG9sZS5cbiAqXG4gKiBUaGlzIGNsYXNzIGlzIGluc3BpcmVkIGluIEdFT1MncyBnZW9zOjpvcGVyYXRpb246OnBvbHlnb25pemU6OkVkZ2VSaW5nXG4gKi9cbnZhciBFZGdlUmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFZGdlUmluZygpIHtcbiAgICAgICAgdGhpcy5lZGdlcyA9IFtdO1xuICAgICAgICB0aGlzLnBvbHlnb24gPSB1bmRlZmluZWQ7IC8vPCBDYWNoZXMgUG9seWdvbiByZXByZXNlbnRhdGlvblxuICAgICAgICB0aGlzLmVudmVsb3BlID0gdW5kZWZpbmVkOyAvLzwgQ2FjaGVzIEVudmVsb3BlIHJlcHJlc2VudGF0aW9uXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBlZGdlIHRvIHRoZSByaW5nLCBpbnNlcnRpbmcgaXQgaW4gdGhlIGxhc3QgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgRWRnZVJpbmdcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2UgLSBFZGdlIHRvIGJlIGluc2VydGVkXG4gICAgICovXG4gICAgRWRnZVJpbmcucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB0aGlzLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIHRoaXMucG9seWdvbiA9IHRoaXMuZW52ZWxvcGUgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgRWRnZS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBFZGdlUmluZ1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpIC0gSW5kZXhcbiAgICAgKiBAcmV0dXJucyB7RWRnZX0gLSBFZGdlIGluIHRoZSBpIHBvc2l0aW9uXG4gICAgICovXG4gICAgRWRnZVJpbmcucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2VzW2ldO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVkZ2VSaW5nLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogR2V0dGVyIG9mIGxlbmd0aCBwcm9wZXJ0eS5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlcm9mIEVkZ2VSaW5nXG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gTGVuZ3RoIG9mIHRoZSBlZGdlIHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVkZ2VzLmxlbmd0aDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCBmb3IgdGhlIGxpc3Qgb2YgRWRnZXMgaW4gdGhlIEVkZ2VSaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEVkZ2VSaW5nXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiAtIFRoZSBzYW1lIGZ1bmN0aW9uIHRvIGJlIHBhc3NlZCB0byBBcnJheS5wcm90b3R5cGUuZm9yRWFjaFxuICAgICAqL1xuICAgIEVkZ2VSaW5nLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdGhpcy5lZGdlcy5mb3JFYWNoKGYpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2ltaWxhciB0byBBcnJheS5wcm90b3R5cGUubWFwIGZvciB0aGUgbGlzdCBvZiBFZGdlcyBpbiB0aGUgRWRnZVJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgRWRnZVJpbmdcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmIC0gVGhlIHNhbWUgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIHRvIEFycmF5LnByb3RvdHlwZS5tYXBcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IC0gVGhlIG1hcHBlZCB2YWx1ZXMgaW4gdGhlIGZ1bmN0aW9uXG4gICAgICovXG4gICAgRWRnZVJpbmcucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2VzLm1hcChmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gQXJyYXkucHJvdG90eXBlLnNvbWUgZm9yIHRoZSBsaXN0IG9mIEVkZ2VzIGluIHRoZSBFZGdlUmluZy5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBFZGdlUmluZ1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGYgLSBUaGUgc2FtZSBmdW5jdGlvbiB0byBiZSBwYXNzZWQgdG8gQXJyYXkucHJvdG90eXBlLnNvbWVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBUcnVlIGlmIGFuIEVkZ2UgY2hlY2sgdGhlIGNvbmRpdGlvblxuICAgICAqL1xuICAgIEVkZ2VSaW5nLnByb3RvdHlwZS5zb21lID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRnZXMuc29tZShmKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSByaW5nIGlzIHZhbGlkIGluIGdlb210cnkgdGVybXMuXG4gICAgICpcbiAgICAgKiBBIHJpbmcgbXVzdCBoYXZlIGVpdGhlciAwIG9yIDQgb3IgbW9yZSBwb2ludHMuIFRoZSBmaXJzdCBhbmQgdGhlIGxhc3QgbXVzdCBiZVxuICAgICAqIGVxdWFsIChpbiAyRClcbiAgICAgKiBnZW9zOjpnZW9tOjpMaW5lYXJSaW5nOjp2YWxpZGF0ZUNvbnN0cnVjdGlvblxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEVkZ2VSaW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVmFsaWRpdHkgb2YgdGhlIEVkZ2VSaW5nXG4gICAgICovXG4gICAgRWRnZVJpbmcucHJvdG90eXBlLmlzVmFsaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE86IHN0dWJcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBUZXN0cyB3aGV0aGVyIHRoaXMgcmluZyBpcyBhIGhvbGUuXG4gICAgICpcbiAgICAgKiBBIHJpbmcgaXMgYSBob2xlIGlmIGl0IGlzIG9yaWVudGVkIGNvdW50ZXItY2xvY2t3aXNlLlxuICAgICAqIFNpbWlsYXIgaW1wbGVtZW50YXRpb24gb2YgZ2Vvczo6YWxnb3JpdGhtOjpDR0FsZ29yaXRobXM6OmlzQ0NXXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgRWRnZVJpbmdcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSB0cnVlOiBpZiBpdCBpcyBhIGhvbGVcbiAgICAgKi9cbiAgICBFZGdlUmluZy5wcm90b3R5cGUuaXNIb2xlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBYWFg6IEFzc3VtaW5nIFJpbmcgaXMgdmFsaWRcbiAgICAgICAgLy8gRmluZCBoaWdoZXN0IHBvaW50XG4gICAgICAgIHZhciBoaUluZGV4ID0gdGhpcy5lZGdlcy5yZWR1Y2UoZnVuY3Rpb24gKGhpZ2gsIGVkZ2UsIGkpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmZyb20uY29vcmRpbmF0ZXNbMV0gPiBfdGhpcy5lZGdlc1toaWdoXS5mcm9tLmNvb3JkaW5hdGVzWzFdKVxuICAgICAgICAgICAgICAgIGhpZ2ggPSBpO1xuICAgICAgICAgICAgcmV0dXJuIGhpZ2g7XG4gICAgICAgIH0sIDApLCBpUHJldiA9IChoaUluZGV4ID09PSAwID8gdGhpcy5sZW5ndGggOiBoaUluZGV4KSAtIDEsIGlOZXh0ID0gKGhpSW5kZXggKyAxKSAlIHRoaXMubGVuZ3RoLCBkaXNjID0gb3JpZW50YXRpb25JbmRleCh0aGlzLmVkZ2VzW2lQcmV2XS5mcm9tLmNvb3JkaW5hdGVzLCB0aGlzLmVkZ2VzW2hpSW5kZXhdLmZyb20uY29vcmRpbmF0ZXMsIHRoaXMuZWRnZXNbaU5leHRdLmZyb20uY29vcmRpbmF0ZXMpO1xuICAgICAgICBpZiAoZGlzYyA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5lZGdlc1tpUHJldl0uZnJvbS5jb29yZGluYXRlc1swXSA+XG4gICAgICAgICAgICAgICAgdGhpcy5lZGdlc1tpTmV4dF0uZnJvbS5jb29yZGluYXRlc1swXSk7XG4gICAgICAgIHJldHVybiBkaXNjID4gMDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBNdWx0aVBvaW50IHJlcHJlc2VudGluZyB0aGUgRWRnZVJpbmcgKGRpc2NhcnRzIGVkZ2VzIGRpcmVjdGlvbnMpLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEVkZ2VSaW5nXG4gICAgICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlQb2ludD59IC0gTXVsdGlwb2ludCByZXByZXNlbnRhdGlvbiBvZiB0aGUgRWRnZVJpbmdcbiAgICAgKi9cbiAgICBFZGdlUmluZy5wcm90b3R5cGUudG9NdWx0aVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbXVsdGlQb2ludCh0aGlzLmVkZ2VzLm1hcChmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gZWRnZS5mcm9tLmNvb3JkaW5hdGVzOyB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUG9seWdvbiByZXByZXNlbnRpbmcgdGhlIEVkZ2VSaW5nLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIEVkZ2VSaW5nXG4gICAgICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IC0gUG9seWdvbiByZXByZXNlbnRhdGlvbiBvZiB0aGUgRWRnZSBSaW5nXG4gICAgICovXG4gICAgRWRnZVJpbmcucHJvdG90eXBlLnRvUG9seWdvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucG9seWdvbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvbHlnb247XG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IHRoaXMuZWRnZXMubWFwKGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLmZyb20uY29vcmRpbmF0ZXM7IH0pO1xuICAgICAgICBjb29yZGluYXRlcy5wdXNoKHRoaXMuZWRnZXNbMF0uZnJvbS5jb29yZGluYXRlcyk7XG4gICAgICAgIHJldHVybiAodGhpcy5wb2x5Z29uID0gcG9seWdvbihbY29vcmRpbmF0ZXNdKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSBlbnZlbG9wZSBvZiB0aGUgRWRnZVJpbmcuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgRWRnZVJpbmdcbiAgICAgKiBAcmV0dXJucyB7RmVhdHVyZTxQb2x5Z29uPn0gLSBlbnZlbG9wZVxuICAgICAqL1xuICAgIEVkZ2VSaW5nLnByb3RvdHlwZS5nZXRFbnZlbG9wZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZW52ZWxvcGUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbnZlbG9wZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLmVudmVsb3BlID0gZW52ZWxvcGUodGhpcy50b1BvbHlnb24oKSkpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogYGdlb3M6Om9wZXJhdGlvbjo6cG9seWdvbml6ZTo6RWRnZVJpbmc6OmZpbmRFZGdlUmluZ0NvbnRhaW5pbmdgXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2VSaW5nfSB0ZXN0RWRnZVJpbmcgLSBFZGdlUmluZyB0byBsb29rIGluIHRoZSBsaXN0XG4gICAgICogQHBhcmFtIHtFZGdlUmluZ1tdfSBzaGVsbExpc3QgLSBMaXN0IG9mIEVkZ2VSaW5nIGluIHdoaWNoIHRvIHNlYXJjaFxuICAgICAqXG4gICAgICogQHJldHVybnMge0VkZ2VSaW5nfSAtIEVkZ2VSaW5nIHdoaWNoIGNvbnRhaW5zIHRoZSB0ZXN0RWRnZVJpbmdcbiAgICAgKi9cbiAgICBFZGdlUmluZy5maW5kRWRnZVJpbmdDb250YWluaW5nID0gZnVuY3Rpb24gKHRlc3RFZGdlUmluZywgc2hlbGxMaXN0KSB7XG4gICAgICAgIHZhciB0ZXN0RW52ZWxvcGUgPSB0ZXN0RWRnZVJpbmcuZ2V0RW52ZWxvcGUoKTtcbiAgICAgICAgdmFyIG1pbkVudmVsb3BlLCBtaW5TaGVsbDtcbiAgICAgICAgc2hlbGxMaXN0LmZvckVhY2goZnVuY3Rpb24gKHNoZWxsKSB7XG4gICAgICAgICAgICB2YXIgdHJ5RW52ZWxvcGUgPSBzaGVsbC5nZXRFbnZlbG9wZSgpO1xuICAgICAgICAgICAgaWYgKG1pblNoZWxsKVxuICAgICAgICAgICAgICAgIG1pbkVudmVsb3BlID0gbWluU2hlbGwuZ2V0RW52ZWxvcGUoKTtcbiAgICAgICAgICAgIC8vIHRoZSBob2xlIGVudmVsb3BlIGNhbm5vdCBlcXVhbCB0aGUgc2hlbGwgZW52ZWxvcGVcbiAgICAgICAgICAgIGlmIChlbnZlbG9wZUlzRXF1YWwodHJ5RW52ZWxvcGUsIHRlc3RFbnZlbG9wZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGVudmVsb3BlQ29udGFpbnModHJ5RW52ZWxvcGUsIHRlc3RFbnZlbG9wZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGVzdEVkZ2VSaW5nQ29vcmRpbmF0ZXMgPSB0ZXN0RWRnZVJpbmcubWFwKGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBlZGdlLmZyb20uY29vcmRpbmF0ZXM7IH0pO1xuICAgICAgICAgICAgICAgIHZhciB0ZXN0UG9pbnQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaGVsbC5zb21lKGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBjb29yZGluYXRlc0VxdWFsKHB0LCBlZGdlLmZyb20uY29vcmRpbmF0ZXMpOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGVzdFBvaW50ID0gcHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgdGVzdEVkZ2VSaW5nQ29vcmRpbmF0ZXNfMSA9IHRlc3RFZGdlUmluZ0Nvb3JkaW5hdGVzOyBfaSA8IHRlc3RFZGdlUmluZ0Nvb3JkaW5hdGVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwdCA9IHRlc3RFZGdlUmluZ0Nvb3JkaW5hdGVzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICBfbG9vcF8xKHB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRlc3RQb2ludCAmJiBzaGVsbC5pbnNpZGUocG9pbnQodGVzdFBvaW50KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtaW5TaGVsbCB8fCBlbnZlbG9wZUNvbnRhaW5zKG1pbkVudmVsb3BlLCB0cnlFbnZlbG9wZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5TaGVsbCA9IHNoZWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtaW5TaGVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBlZGdlUmluZ1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcHQgLSBQb2ludCB0byBjaGVjayBpZiBpdCBpcyBpbnNpZGUgdGhlIGVkZ2VSaW5nXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBpdCBpcyBpbnNpZGUsIEZhbHNlIG90aGVyd2lzZVxuICAgICAqL1xuICAgIEVkZ2VSaW5nLnByb3RvdHlwZS5pbnNpZGUgPSBmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgcmV0dXJuIGJvb2xlYW5Qb2ludEluUG9seWdvbihwdCwgdGhpcy50b1BvbHlnb24oKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRWRnZVJpbmc7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgRWRnZVJpbmc7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Graph.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Graph.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _Node_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Node.js */ \"(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Node.js\");\n/* harmony import */ var _Edge_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Edge.js */ \"(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Edge.js\");\n/* harmony import */ var _EdgeRing_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EdgeRing.js */ \"(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/EdgeRing.js\");\n/* harmony import */ var _turf_meta__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @turf/meta */ \"(ssr)/./node_modules/.pnpm/@turf+meta@6.5.0/node_modules/@turf/meta/dist/es/index.js\");\n/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @turf/invariant */ \"(ssr)/./node_modules/.pnpm/@turf+invariant@6.5.0/node_modules/@turf/invariant/dist/es/index.js\");\n\n\n\n\n\n/**\n * Validates the geoJson.\n *\n * @param {GeoJSON} geoJson - input geoJson.\n * @throws {Error} if geoJson is invalid.\n */\nfunction validateGeoJson(geoJson) {\n    if (!geoJson)\n        throw new Error(\"No geojson passed\");\n    if (geoJson.type !== \"FeatureCollection\" &&\n        geoJson.type !== \"GeometryCollection\" &&\n        geoJson.type !== \"MultiLineString\" &&\n        geoJson.type !== \"LineString\" &&\n        geoJson.type !== \"Feature\")\n        throw new Error(\"Invalid input type '\" + geoJson.type + \"'. Geojson must be FeatureCollection, GeometryCollection, LineString, MultiLineString or Feature\");\n}\n/**\n * Represents a planar graph of edges and nodes that can be used to compute a polygonization.\n *\n * Although, this class is inspired by GEOS's `geos::operation::polygonize::PolygonizeGraph`,\n * it isn't a rewrite. As regards algorithm, this class implements the same logic, but it\n * isn't a javascript transcription of the C++ source.\n *\n * This graph is directed (both directions are created)\n */\nvar Graph = /** @class */ (function () {\n    function Graph() {\n        this.edges = []; //< {Edge[]} dirEdges\n        // The key is the `id` of the Node (ie: coordinates.join(','))\n        this.nodes = {};\n    }\n    /**\n     * Creates a graph from a GeoJSON.\n     *\n     * @param {FeatureCollection<LineString>} geoJson - it must comply with the restrictions detailed in the index\n     * @returns {Graph} - The newly created graph\n     * @throws {Error} if geoJson is invalid.\n     */\n    Graph.fromGeoJson = function (geoJson) {\n        validateGeoJson(geoJson);\n        var graph = new Graph();\n        (0,_turf_meta__WEBPACK_IMPORTED_MODULE_3__.flattenEach)(geoJson, function (feature) {\n            (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_4__.featureOf)(feature, \"LineString\", \"Graph::fromGeoJson\");\n            // When a LineString if formed by many segments, split them\n            (0,_turf_meta__WEBPACK_IMPORTED_MODULE_3__.coordReduce)(feature, function (prev, cur) {\n                if (prev) {\n                    var start = graph.getNode(prev), end = graph.getNode(cur);\n                    graph.addEdge(start, end);\n                }\n                return cur;\n            });\n        });\n        return graph;\n    };\n    /**\n     * Creates or get a Node.\n     *\n     * @param {number[]} coordinates - Coordinates of the node\n     * @returns {Node} - The created or stored node\n     */\n    Graph.prototype.getNode = function (coordinates) {\n        var id = _Node_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].buildId(coordinates);\n        var node = this.nodes[id];\n        if (!node)\n            node = this.nodes[id] = new _Node_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"](coordinates);\n        return node;\n    };\n    /**\n     * Adds an Edge and its symetricall.\n     *\n     * Edges are added symetrically, i.e.: we also add its symetric\n     *\n     * @param {Node} from - Node which starts the Edge\n     * @param {Node} to - Node which ends the Edge\n     */\n    Graph.prototype.addEdge = function (from, to) {\n        var edge = new _Edge_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](from, to), symetricEdge = edge.getSymetric();\n        this.edges.push(edge);\n        this.edges.push(symetricEdge);\n    };\n    /**\n     * Removes Dangle Nodes (nodes with grade 1).\n     */\n    Graph.prototype.deleteDangles = function () {\n        var _this = this;\n        Object.keys(this.nodes)\n            .map(function (id) { return _this.nodes[id]; })\n            .forEach(function (node) { return _this._removeIfDangle(node); });\n    };\n    /**\n     * Check if node is dangle, if so, remove it.\n     *\n     * It calls itself recursively, removing a dangling node might cause another dangling node\n     *\n     * @param {Node} node - Node to check if it's a dangle\n     */\n    Graph.prototype._removeIfDangle = function (node) {\n        var _this = this;\n        // As edges are directed and symetrical, we count only innerEdges\n        if (node.innerEdges.length <= 1) {\n            var outerNodes = node.getOuterEdges().map(function (e) { return e.to; });\n            this.removeNode(node);\n            outerNodes.forEach(function (n) { return _this._removeIfDangle(n); });\n        }\n    };\n    /**\n     * Delete cut-edges (bridge edges).\n     *\n     * The graph will be traversed, all the edges will be labeled according the ring\n     * in which they are. (The label is a number incremented by 1). Edges with the same\n     * label are cut-edges.\n     */\n    Graph.prototype.deleteCutEdges = function () {\n        var _this = this;\n        this._computeNextCWEdges();\n        this._findLabeledEdgeRings();\n        // Cut-edges (bridges) are edges where both edges have the same label\n        this.edges.forEach(function (edge) {\n            if (edge.label === edge.symetric.label) {\n                _this.removeEdge(edge.symetric);\n                _this.removeEdge(edge);\n            }\n        });\n    };\n    /**\n     * Set the `next` property of each Edge.\n     *\n     * The graph will be transversed in a CW form, so, we set the next of the symetrical edge as the previous one.\n     * OuterEdges are sorted CCW.\n     *\n     * @param {Node} [node] - If no node is passed, the function calls itself for every node in the Graph\n     */\n    Graph.prototype._computeNextCWEdges = function (node) {\n        var _this = this;\n        if (typeof node === \"undefined\") {\n            Object.keys(this.nodes).forEach(function (id) {\n                return _this._computeNextCWEdges(_this.nodes[id]);\n            });\n        }\n        else {\n            node.getOuterEdges().forEach(function (edge, i) {\n                node.getOuterEdge((i === 0 ? node.getOuterEdges().length : i) - 1).symetric.next = edge;\n            });\n        }\n    };\n    /**\n     * Computes the next edge pointers going CCW around the given node, for the given edgering label.\n     *\n     * This algorithm has the effect of converting maximal edgerings into minimal edgerings\n     *\n     * XXX: method literally transcribed from `geos::operation::polygonize::PolygonizeGraph::computeNextCCWEdges`,\n     * could be written in a more javascript way.\n     *\n     * @param {Node} node - Node\n     * @param {number} label - Ring's label\n     */\n    Graph.prototype._computeNextCCWEdges = function (node, label) {\n        var edges = node.getOuterEdges();\n        var firstOutDE, prevInDE;\n        for (var i = edges.length - 1; i >= 0; --i) {\n            var de = edges[i], sym = de.symetric, outDE = void 0, inDE = void 0;\n            if (de.label === label)\n                outDE = de;\n            if (sym.label === label)\n                inDE = sym;\n            if (!outDE || !inDE)\n                // This edge is not in edgering\n                continue;\n            if (inDE)\n                prevInDE = inDE;\n            if (outDE) {\n                if (prevInDE) {\n                    prevInDE.next = outDE;\n                    prevInDE = undefined;\n                }\n                if (!firstOutDE)\n                    firstOutDE = outDE;\n            }\n        }\n        if (prevInDE)\n            prevInDE.next = firstOutDE;\n    };\n    /**\n     * Finds rings and labels edges according to which rings are.\n     *\n     * The label is a number which is increased for each ring.\n     *\n     * @returns {Edge[]} edges that start rings\n     */\n    Graph.prototype._findLabeledEdgeRings = function () {\n        var edgeRingStarts = [];\n        var label = 0;\n        this.edges.forEach(function (edge) {\n            if (edge.label >= 0)\n                return;\n            edgeRingStarts.push(edge);\n            var e = edge;\n            do {\n                e.label = label;\n                e = e.next;\n            } while (!edge.isEqual(e));\n            label++;\n        });\n        return edgeRingStarts;\n    };\n    /**\n     * Computes the EdgeRings formed by the edges in this graph.\n     *\n     * @returns {EdgeRing[]} - A list of all the EdgeRings in the graph.\n     */\n    Graph.prototype.getEdgeRings = function () {\n        var _this = this;\n        this._computeNextCWEdges();\n        // Clear labels\n        this.edges.forEach(function (edge) {\n            edge.label = undefined;\n        });\n        this._findLabeledEdgeRings().forEach(function (edge) {\n            // convertMaximalToMinimalEdgeRings\n            _this._findIntersectionNodes(edge).forEach(function (node) {\n                _this._computeNextCCWEdges(node, edge.label);\n            });\n        });\n        var edgeRingList = [];\n        // find all edgerings\n        this.edges.forEach(function (edge) {\n            if (edge.ring)\n                return;\n            edgeRingList.push(_this._findEdgeRing(edge));\n        });\n        return edgeRingList;\n    };\n    /**\n     * Find all nodes in a Maxima EdgeRing which are self-intersection nodes.\n     *\n     * @param {Node} startEdge - Start Edge of the Ring\n     * @returns {Node[]} - intersection nodes\n     */\n    Graph.prototype._findIntersectionNodes = function (startEdge) {\n        var intersectionNodes = [];\n        var edge = startEdge;\n        var _loop_1 = function () {\n            // getDegree\n            var degree = 0;\n            edge.from.getOuterEdges().forEach(function (e) {\n                if (e.label === startEdge.label)\n                    ++degree;\n            });\n            if (degree > 1)\n                intersectionNodes.push(edge.from);\n            edge = edge.next;\n        };\n        do {\n            _loop_1();\n        } while (!startEdge.isEqual(edge));\n        return intersectionNodes;\n    };\n    /**\n     * Get the edge-ring which starts from the provided Edge.\n     *\n     * @param {Edge} startEdge - starting edge of the edge ring\n     * @returns {EdgeRing} - EdgeRing which start Edge is the provided one.\n     */\n    Graph.prototype._findEdgeRing = function (startEdge) {\n        var edge = startEdge;\n        var edgeRing = new _EdgeRing_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]();\n        do {\n            edgeRing.push(edge);\n            edge.ring = edgeRing;\n            edge = edge.next;\n        } while (!startEdge.isEqual(edge));\n        return edgeRing;\n    };\n    /**\n     * Removes a node from the Graph.\n     *\n     * It also removes edges asociated to that node\n     * @param {Node} node - Node to be removed\n     */\n    Graph.prototype.removeNode = function (node) {\n        var _this = this;\n        node.getOuterEdges().forEach(function (edge) { return _this.removeEdge(edge); });\n        node.innerEdges.forEach(function (edge) { return _this.removeEdge(edge); });\n        delete this.nodes[node.id];\n    };\n    /**\n     * Remove edge from the graph and deletes the edge.\n     *\n     * @param {Edge} edge - Edge to be removed\n     */\n    Graph.prototype.removeEdge = function (edge) {\n        this.edges = this.edges.filter(function (e) { return !e.isEqual(edge); });\n        edge.deleteEdge();\n    };\n    return Graph;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Graph);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcG9seWdvbml6ZUA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbml6ZS9kaXN0L2VzL2xpYi9HcmFwaC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBNkI7QUFDQTtBQUNRO0FBQ2lCO0FBQ1Y7QUFDNUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixLQUFLLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsaUJBQWlCLE9BQU87QUFDeEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CLFlBQVksMERBQVM7QUFDckI7QUFDQSxZQUFZLHVEQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBLGlCQUFpQixnREFBSTtBQUNyQjtBQUNBO0FBQ0Esd0NBQXdDLGdEQUFJO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0EsdUJBQXVCLGdEQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQsdUNBQXVDLHFDQUFxQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxjQUFjO0FBQ25GO0FBQ0EsOENBQThDLGtDQUFrQztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsZ0NBQWdDO0FBQ3ZGLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0Esc0RBQXNELDBCQUEwQjtBQUNoRjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsaUVBQWUsS0FBSyxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWZ2YWx1ZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AdHVyZitwb2x5Z29uaXplQDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi9wb2x5Z29uaXplL2Rpc3QvZXMvbGliL0dyYXBoLmpzPzEyY2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE5vZGUgZnJvbSBcIi4vTm9kZS5qc1wiO1xuaW1wb3J0IEVkZ2UgZnJvbSBcIi4vRWRnZS5qc1wiO1xuaW1wb3J0IEVkZ2VSaW5nIGZyb20gXCIuL0VkZ2VSaW5nLmpzXCI7XG5pbXBvcnQgeyBmbGF0dGVuRWFjaCwgY29vcmRSZWR1Y2UgfSBmcm9tIFwiQHR1cmYvbWV0YVwiO1xuaW1wb3J0IHsgZmVhdHVyZU9mIH0gZnJvbSBcIkB0dXJmL2ludmFyaWFudFwiO1xuLyoqXG4gKiBWYWxpZGF0ZXMgdGhlIGdlb0pzb24uXG4gKlxuICogQHBhcmFtIHtHZW9KU09OfSBnZW9Kc29uIC0gaW5wdXQgZ2VvSnNvbi5cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBnZW9Kc29uIGlzIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlR2VvSnNvbihnZW9Kc29uKSB7XG4gICAgaWYgKCFnZW9Kc29uKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBnZW9qc29uIHBhc3NlZFwiKTtcbiAgICBpZiAoZ2VvSnNvbi50eXBlICE9PSBcIkZlYXR1cmVDb2xsZWN0aW9uXCIgJiZcbiAgICAgICAgZ2VvSnNvbi50eXBlICE9PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiICYmXG4gICAgICAgIGdlb0pzb24udHlwZSAhPT0gXCJNdWx0aUxpbmVTdHJpbmdcIiAmJlxuICAgICAgICBnZW9Kc29uLnR5cGUgIT09IFwiTGluZVN0cmluZ1wiICYmXG4gICAgICAgIGdlb0pzb24udHlwZSAhPT0gXCJGZWF0dXJlXCIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdHlwZSAnXCIgKyBnZW9Kc29uLnR5cGUgKyBcIicuIEdlb2pzb24gbXVzdCBiZSBGZWF0dXJlQ29sbGVjdGlvbiwgR2VvbWV0cnlDb2xsZWN0aW9uLCBMaW5lU3RyaW5nLCBNdWx0aUxpbmVTdHJpbmcgb3IgRmVhdHVyZVwiKTtcbn1cbi8qKlxuICogUmVwcmVzZW50cyBhIHBsYW5hciBncmFwaCBvZiBlZGdlcyBhbmQgbm9kZXMgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21wdXRlIGEgcG9seWdvbml6YXRpb24uXG4gKlxuICogQWx0aG91Z2gsIHRoaXMgY2xhc3MgaXMgaW5zcGlyZWQgYnkgR0VPUydzIGBnZW9zOjpvcGVyYXRpb246OnBvbHlnb25pemU6OlBvbHlnb25pemVHcmFwaGAsXG4gKiBpdCBpc24ndCBhIHJld3JpdGUuIEFzIHJlZ2FyZHMgYWxnb3JpdGhtLCB0aGlzIGNsYXNzIGltcGxlbWVudHMgdGhlIHNhbWUgbG9naWMsIGJ1dCBpdFxuICogaXNuJ3QgYSBqYXZhc2NyaXB0IHRyYW5zY3JpcHRpb24gb2YgdGhlIEMrKyBzb3VyY2UuXG4gKlxuICogVGhpcyBncmFwaCBpcyBkaXJlY3RlZCAoYm90aCBkaXJlY3Rpb25zIGFyZSBjcmVhdGVkKVxuICovXG52YXIgR3JhcGggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGgoKSB7XG4gICAgICAgIHRoaXMuZWRnZXMgPSBbXTsgLy88IHtFZGdlW119IGRpckVkZ2VzXG4gICAgICAgIC8vIFRoZSBrZXkgaXMgdGhlIGBpZGAgb2YgdGhlIE5vZGUgKGllOiBjb29yZGluYXRlcy5qb2luKCcsJykpXG4gICAgICAgIHRoaXMubm9kZXMgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGdyYXBoIGZyb20gYSBHZW9KU09OLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gZ2VvSnNvbiAtIGl0IG11c3QgY29tcGx5IHdpdGggdGhlIHJlc3RyaWN0aW9ucyBkZXRhaWxlZCBpbiB0aGUgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7R3JhcGh9IC0gVGhlIG5ld2x5IGNyZWF0ZWQgZ3JhcGhcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gaWYgZ2VvSnNvbiBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIEdyYXBoLmZyb21HZW9Kc29uID0gZnVuY3Rpb24gKGdlb0pzb24pIHtcbiAgICAgICAgdmFsaWRhdGVHZW9Kc29uKGdlb0pzb24pO1xuICAgICAgICB2YXIgZ3JhcGggPSBuZXcgR3JhcGgoKTtcbiAgICAgICAgZmxhdHRlbkVhY2goZ2VvSnNvbiwgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGZlYXR1cmVPZihmZWF0dXJlLCBcIkxpbmVTdHJpbmdcIiwgXCJHcmFwaDo6ZnJvbUdlb0pzb25cIik7XG4gICAgICAgICAgICAvLyBXaGVuIGEgTGluZVN0cmluZyBpZiBmb3JtZWQgYnkgbWFueSBzZWdtZW50cywgc3BsaXQgdGhlbVxuICAgICAgICAgICAgY29vcmRSZWR1Y2UoZmVhdHVyZSwgZnVuY3Rpb24gKHByZXYsIGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdGFydCA9IGdyYXBoLmdldE5vZGUocHJldiksIGVuZCA9IGdyYXBoLmdldE5vZGUoY3VyKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYWRkRWRnZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGdyYXBoO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBvciBnZXQgYSBOb2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gY29vcmRpbmF0ZXMgLSBDb29yZGluYXRlcyBvZiB0aGUgbm9kZVxuICAgICAqIEByZXR1cm5zIHtOb2RlfSAtIFRoZSBjcmVhdGVkIG9yIHN0b3JlZCBub2RlXG4gICAgICovXG4gICAgR3JhcGgucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdmFyIGlkID0gTm9kZS5idWlsZElkKGNvb3JkaW5hdGVzKTtcbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLm5vZGVzW2lkXTtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgbm9kZSA9IHRoaXMubm9kZXNbaWRdID0gbmV3IE5vZGUoY29vcmRpbmF0ZXMpO1xuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gRWRnZSBhbmQgaXRzIHN5bWV0cmljYWxsLlxuICAgICAqXG4gICAgICogRWRnZXMgYXJlIGFkZGVkIHN5bWV0cmljYWxseSwgaS5lLjogd2UgYWxzbyBhZGQgaXRzIHN5bWV0cmljXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IGZyb20gLSBOb2RlIHdoaWNoIHN0YXJ0cyB0aGUgRWRnZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gdG8gLSBOb2RlIHdoaWNoIGVuZHMgdGhlIEVkZ2VcbiAgICAgKi9cbiAgICBHcmFwaC5wcm90b3R5cGUuYWRkRWRnZSA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgICAgICB2YXIgZWRnZSA9IG5ldyBFZGdlKGZyb20sIHRvKSwgc3ltZXRyaWNFZGdlID0gZWRnZS5nZXRTeW1ldHJpYygpO1xuICAgICAgICB0aGlzLmVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIHRoaXMuZWRnZXMucHVzaChzeW1ldHJpY0VkZ2UpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBEYW5nbGUgTm9kZXMgKG5vZGVzIHdpdGggZ3JhZGUgMSkuXG4gICAgICovXG4gICAgR3JhcGgucHJvdG90eXBlLmRlbGV0ZURhbmdsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMubm9kZXMpXG4gICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpZCkgeyByZXR1cm4gX3RoaXMubm9kZXNbaWRdOyB9KVxuICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLl9yZW1vdmVJZkRhbmdsZShub2RlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBub2RlIGlzIGRhbmdsZSwgaWYgc28sIHJlbW92ZSBpdC5cbiAgICAgKlxuICAgICAqIEl0IGNhbGxzIGl0c2VsZiByZWN1cnNpdmVseSwgcmVtb3ZpbmcgYSBkYW5nbGluZyBub2RlIG1pZ2h0IGNhdXNlIGFub3RoZXIgZGFuZ2xpbmcgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIC0gTm9kZSB0byBjaGVjayBpZiBpdCdzIGEgZGFuZ2xlXG4gICAgICovXG4gICAgR3JhcGgucHJvdG90eXBlLl9yZW1vdmVJZkRhbmdsZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8vIEFzIGVkZ2VzIGFyZSBkaXJlY3RlZCBhbmQgc3ltZXRyaWNhbCwgd2UgY291bnQgb25seSBpbm5lckVkZ2VzXG4gICAgICAgIGlmIChub2RlLmlubmVyRWRnZXMubGVuZ3RoIDw9IDEpIHtcbiAgICAgICAgICAgIHZhciBvdXRlck5vZGVzID0gbm9kZS5nZXRPdXRlckVkZ2VzKCkubWFwKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRvOyB9KTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgICAgIG91dGVyTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobikgeyByZXR1cm4gX3RoaXMuX3JlbW92ZUlmRGFuZ2xlKG4pOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGN1dC1lZGdlcyAoYnJpZGdlIGVkZ2VzKS5cbiAgICAgKlxuICAgICAqIFRoZSBncmFwaCB3aWxsIGJlIHRyYXZlcnNlZCwgYWxsIHRoZSBlZGdlcyB3aWxsIGJlIGxhYmVsZWQgYWNjb3JkaW5nIHRoZSByaW5nXG4gICAgICogaW4gd2hpY2ggdGhleSBhcmUuIChUaGUgbGFiZWwgaXMgYSBudW1iZXIgaW5jcmVtZW50ZWQgYnkgMSkuIEVkZ2VzIHdpdGggdGhlIHNhbWVcbiAgICAgKiBsYWJlbCBhcmUgY3V0LWVkZ2VzLlxuICAgICAqL1xuICAgIEdyYXBoLnByb3RvdHlwZS5kZWxldGVDdXRFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY29tcHV0ZU5leHRDV0VkZ2VzKCk7XG4gICAgICAgIHRoaXMuX2ZpbmRMYWJlbGVkRWRnZVJpbmdzKCk7XG4gICAgICAgIC8vIEN1dC1lZGdlcyAoYnJpZGdlcykgYXJlIGVkZ2VzIHdoZXJlIGJvdGggZWRnZXMgaGF2ZSB0aGUgc2FtZSBsYWJlbFxuICAgICAgICB0aGlzLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChlZGdlLmxhYmVsID09PSBlZGdlLnN5bWV0cmljLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVtb3ZlRWRnZShlZGdlLnN5bWV0cmljKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVFZGdlKGVkZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFNldCB0aGUgYG5leHRgIHByb3BlcnR5IG9mIGVhY2ggRWRnZS5cbiAgICAgKlxuICAgICAqIFRoZSBncmFwaCB3aWxsIGJlIHRyYW5zdmVyc2VkIGluIGEgQ1cgZm9ybSwgc28sIHdlIHNldCB0aGUgbmV4dCBvZiB0aGUgc3ltZXRyaWNhbCBlZGdlIGFzIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICogT3V0ZXJFZGdlcyBhcmUgc29ydGVkIENDVy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gW25vZGVdIC0gSWYgbm8gbm9kZSBpcyBwYXNzZWQsIHRoZSBmdW5jdGlvbiBjYWxscyBpdHNlbGYgZm9yIGV2ZXJ5IG5vZGUgaW4gdGhlIEdyYXBoXG4gICAgICovXG4gICAgR3JhcGgucHJvdG90eXBlLl9jb21wdXRlTmV4dENXRWRnZXMgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMubm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9jb21wdXRlTmV4dENXRWRnZXMoX3RoaXMubm9kZXNbaWRdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5nZXRPdXRlckVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSwgaSkge1xuICAgICAgICAgICAgICAgIG5vZGUuZ2V0T3V0ZXJFZGdlKChpID09PSAwID8gbm9kZS5nZXRPdXRlckVkZ2VzKCkubGVuZ3RoIDogaSkgLSAxKS5zeW1ldHJpYy5uZXh0ID0gZWRnZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbmV4dCBlZGdlIHBvaW50ZXJzIGdvaW5nIENDVyBhcm91bmQgdGhlIGdpdmVuIG5vZGUsIGZvciB0aGUgZ2l2ZW4gZWRnZXJpbmcgbGFiZWwuXG4gICAgICpcbiAgICAgKiBUaGlzIGFsZ29yaXRobSBoYXMgdGhlIGVmZmVjdCBvZiBjb252ZXJ0aW5nIG1heGltYWwgZWRnZXJpbmdzIGludG8gbWluaW1hbCBlZGdlcmluZ3NcbiAgICAgKlxuICAgICAqIFhYWDogbWV0aG9kIGxpdGVyYWxseSB0cmFuc2NyaWJlZCBmcm9tIGBnZW9zOjpvcGVyYXRpb246OnBvbHlnb25pemU6OlBvbHlnb25pemVHcmFwaDo6Y29tcHV0ZU5leHRDQ1dFZGdlc2AsXG4gICAgICogY291bGQgYmUgd3JpdHRlbiBpbiBhIG1vcmUgamF2YXNjcmlwdCB3YXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgLSBOb2RlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxhYmVsIC0gUmluZydzIGxhYmVsXG4gICAgICovXG4gICAgR3JhcGgucHJvdG90eXBlLl9jb21wdXRlTmV4dENDV0VkZ2VzID0gZnVuY3Rpb24gKG5vZGUsIGxhYmVsKSB7XG4gICAgICAgIHZhciBlZGdlcyA9IG5vZGUuZ2V0T3V0ZXJFZGdlcygpO1xuICAgICAgICB2YXIgZmlyc3RPdXRERSwgcHJldkluREU7XG4gICAgICAgIGZvciAodmFyIGkgPSBlZGdlcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICAgICAgdmFyIGRlID0gZWRnZXNbaV0sIHN5bSA9IGRlLnN5bWV0cmljLCBvdXRERSA9IHZvaWQgMCwgaW5ERSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChkZS5sYWJlbCA9PT0gbGFiZWwpXG4gICAgICAgICAgICAgICAgb3V0REUgPSBkZTtcbiAgICAgICAgICAgIGlmIChzeW0ubGFiZWwgPT09IGxhYmVsKVxuICAgICAgICAgICAgICAgIGluREUgPSBzeW07XG4gICAgICAgICAgICBpZiAoIW91dERFIHx8ICFpbkRFKVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgZWRnZSBpcyBub3QgaW4gZWRnZXJpbmdcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChpbkRFKVxuICAgICAgICAgICAgICAgIHByZXZJbkRFID0gaW5ERTtcbiAgICAgICAgICAgIGlmIChvdXRERSkge1xuICAgICAgICAgICAgICAgIGlmIChwcmV2SW5ERSkge1xuICAgICAgICAgICAgICAgICAgICBwcmV2SW5ERS5uZXh0ID0gb3V0REU7XG4gICAgICAgICAgICAgICAgICAgIHByZXZJbkRFID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWZpcnN0T3V0REUpXG4gICAgICAgICAgICAgICAgICAgIGZpcnN0T3V0REUgPSBvdXRERTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkluREUpXG4gICAgICAgICAgICBwcmV2SW5ERS5uZXh0ID0gZmlyc3RPdXRERTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmRzIHJpbmdzIGFuZCBsYWJlbHMgZWRnZXMgYWNjb3JkaW5nIHRvIHdoaWNoIHJpbmdzIGFyZS5cbiAgICAgKlxuICAgICAqIFRoZSBsYWJlbCBpcyBhIG51bWJlciB3aGljaCBpcyBpbmNyZWFzZWQgZm9yIGVhY2ggcmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtFZGdlW119IGVkZ2VzIHRoYXQgc3RhcnQgcmluZ3NcbiAgICAgKi9cbiAgICBHcmFwaC5wcm90b3R5cGUuX2ZpbmRMYWJlbGVkRWRnZVJpbmdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWRnZVJpbmdTdGFydHMgPSBbXTtcbiAgICAgICAgdmFyIGxhYmVsID0gMDtcbiAgICAgICAgdGhpcy5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5sYWJlbCA+PSAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVkZ2VSaW5nU3RhcnRzLnB1c2goZWRnZSk7XG4gICAgICAgICAgICB2YXIgZSA9IGVkZ2U7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZS5sYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgICAgIGUgPSBlLm5leHQ7XG4gICAgICAgICAgICB9IHdoaWxlICghZWRnZS5pc0VxdWFsKGUpKTtcbiAgICAgICAgICAgIGxhYmVsKys7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZWRnZVJpbmdTdGFydHM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgRWRnZVJpbmdzIGZvcm1lZCBieSB0aGUgZWRnZXMgaW4gdGhpcyBncmFwaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtFZGdlUmluZ1tdfSAtIEEgbGlzdCBvZiBhbGwgdGhlIEVkZ2VSaW5ncyBpbiB0aGUgZ3JhcGguXG4gICAgICovXG4gICAgR3JhcGgucHJvdG90eXBlLmdldEVkZ2VSaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fY29tcHV0ZU5leHRDV0VkZ2VzKCk7XG4gICAgICAgIC8vIENsZWFyIGxhYmVsc1xuICAgICAgICB0aGlzLmVkZ2VzLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIGVkZ2UubGFiZWwgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9maW5kTGFiZWxlZEVkZ2VSaW5ncygpLmZvckVhY2goZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICAgIC8vIGNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzXG4gICAgICAgICAgICBfdGhpcy5fZmluZEludGVyc2VjdGlvbk5vZGVzKGVkZ2UpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5fY29tcHV0ZU5leHRDQ1dFZGdlcyhub2RlLCBlZGdlLmxhYmVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGVkZ2VSaW5nTGlzdCA9IFtdO1xuICAgICAgICAvLyBmaW5kIGFsbCBlZGdlcmluZ3NcbiAgICAgICAgdGhpcy5lZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5yaW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVkZ2VSaW5nTGlzdC5wdXNoKF90aGlzLl9maW5kRWRnZVJpbmcoZWRnZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVkZ2VSaW5nTGlzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZpbmQgYWxsIG5vZGVzIGluIGEgTWF4aW1hIEVkZ2VSaW5nIHdoaWNoIGFyZSBzZWxmLWludGVyc2VjdGlvbiBub2Rlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gc3RhcnRFZGdlIC0gU3RhcnQgRWRnZSBvZiB0aGUgUmluZ1xuICAgICAqIEByZXR1cm5zIHtOb2RlW119IC0gaW50ZXJzZWN0aW9uIG5vZGVzXG4gICAgICovXG4gICAgR3JhcGgucHJvdG90eXBlLl9maW5kSW50ZXJzZWN0aW9uTm9kZXMgPSBmdW5jdGlvbiAoc3RhcnRFZGdlKSB7XG4gICAgICAgIHZhciBpbnRlcnNlY3Rpb25Ob2RlcyA9IFtdO1xuICAgICAgICB2YXIgZWRnZSA9IHN0YXJ0RWRnZTtcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBnZXREZWdyZWVcbiAgICAgICAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgICAgICAgZWRnZS5mcm9tLmdldE91dGVyRWRnZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUubGFiZWwgPT09IHN0YXJ0RWRnZS5sYWJlbClcbiAgICAgICAgICAgICAgICAgICAgKytkZWdyZWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChkZWdyZWUgPiAxKVxuICAgICAgICAgICAgICAgIGludGVyc2VjdGlvbk5vZGVzLnB1c2goZWRnZS5mcm9tKTtcbiAgICAgICAgICAgIGVkZ2UgPSBlZGdlLm5leHQ7XG4gICAgICAgIH07XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIF9sb29wXzEoKTtcbiAgICAgICAgfSB3aGlsZSAoIXN0YXJ0RWRnZS5pc0VxdWFsKGVkZ2UpKTtcbiAgICAgICAgcmV0dXJuIGludGVyc2VjdGlvbk5vZGVzO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlZGdlLXJpbmcgd2hpY2ggc3RhcnRzIGZyb20gdGhlIHByb3ZpZGVkIEVkZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IHN0YXJ0RWRnZSAtIHN0YXJ0aW5nIGVkZ2Ugb2YgdGhlIGVkZ2UgcmluZ1xuICAgICAqIEByZXR1cm5zIHtFZGdlUmluZ30gLSBFZGdlUmluZyB3aGljaCBzdGFydCBFZGdlIGlzIHRoZSBwcm92aWRlZCBvbmUuXG4gICAgICovXG4gICAgR3JhcGgucHJvdG90eXBlLl9maW5kRWRnZVJpbmcgPSBmdW5jdGlvbiAoc3RhcnRFZGdlKSB7XG4gICAgICAgIHZhciBlZGdlID0gc3RhcnRFZGdlO1xuICAgICAgICB2YXIgZWRnZVJpbmcgPSBuZXcgRWRnZVJpbmcoKTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgZWRnZVJpbmcucHVzaChlZGdlKTtcbiAgICAgICAgICAgIGVkZ2UucmluZyA9IGVkZ2VSaW5nO1xuICAgICAgICAgICAgZWRnZSA9IGVkZ2UubmV4dDtcbiAgICAgICAgfSB3aGlsZSAoIXN0YXJ0RWRnZS5pc0VxdWFsKGVkZ2UpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VSaW5nO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIG5vZGUgZnJvbSB0aGUgR3JhcGguXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIHJlbW92ZXMgZWRnZXMgYXNvY2lhdGVkIHRvIHRoYXQgbm9kZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAtIE5vZGUgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIEdyYXBoLnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbm9kZS5nZXRPdXRlckVkZ2VzKCkuZm9yRWFjaChmdW5jdGlvbiAoZWRnZSkgeyByZXR1cm4gX3RoaXMucmVtb3ZlRWRnZShlZGdlKTsgfSk7XG4gICAgICAgIG5vZGUuaW5uZXJFZGdlcy5mb3JFYWNoKGZ1bmN0aW9uIChlZGdlKSB7IHJldHVybiBfdGhpcy5yZW1vdmVFZGdlKGVkZ2UpOyB9KTtcbiAgICAgICAgZGVsZXRlIHRoaXMubm9kZXNbbm9kZS5pZF07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZWRnZSBmcm9tIHRoZSBncmFwaCBhbmQgZGVsZXRlcyB0aGUgZWRnZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWRnZX0gZWRnZSAtIEVkZ2UgdG8gYmUgcmVtb3ZlZFxuICAgICAqL1xuICAgIEdyYXBoLnByb3RvdHlwZS5yZW1vdmVFZGdlID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgdGhpcy5lZGdlcyA9IHRoaXMuZWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiAhZS5pc0VxdWFsKGVkZ2UpOyB9KTtcbiAgICAgICAgZWRnZS5kZWxldGVFZGdlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gR3JhcGg7XG59KCkpO1xuZXhwb3J0IGRlZmF1bHQgR3JhcGg7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Graph.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Node.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Node.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/util.js\");\n\n/**\n * Node\n */\nvar Node = /** @class */ (function () {\n    function Node(coordinates) {\n        this.id = Node.buildId(coordinates);\n        this.coordinates = coordinates; //< {Number[]}\n        this.innerEdges = []; //< {Edge[]}\n        // We wil store to (out) edges in an CCW order as geos::planargraph::DirectedEdgeStar does\n        this.outerEdges = []; //< {Edge[]}\n        this.outerEdgesSorted = false; //< {Boolean} flag that stores if the outer Edges had been sorted\n    }\n    Node.buildId = function (coordinates) {\n        return coordinates.join(\",\");\n    };\n    Node.prototype.removeInnerEdge = function (edge) {\n        this.innerEdges = this.innerEdges.filter(function (e) { return e.from.id !== edge.from.id; });\n    };\n    Node.prototype.removeOuterEdge = function (edge) {\n        this.outerEdges = this.outerEdges.filter(function (e) { return e.to.id !== edge.to.id; });\n    };\n    /**\n     * Outer edges are stored CCW order.\n     *\n     * @memberof Node\n     * @param {Edge} edge - Edge to add as an outerEdge.\n     */\n    Node.prototype.addOuterEdge = function (edge) {\n        this.outerEdges.push(edge);\n        this.outerEdgesSorted = false;\n    };\n    /**\n     * Sorts outer edges in CCW way.\n     *\n     * @memberof Node\n     * @private\n     */\n    Node.prototype.sortOuterEdges = function () {\n        var _this = this;\n        if (!this.outerEdgesSorted) {\n            //this.outerEdges.sort((a, b) => a.compareTo(b));\n            // Using this comparator in order to be deterministic\n            this.outerEdges.sort(function (a, b) {\n                var aNode = a.to, bNode = b.to;\n                if (aNode.coordinates[0] - _this.coordinates[0] >= 0 &&\n                    bNode.coordinates[0] - _this.coordinates[0] < 0)\n                    return 1;\n                if (aNode.coordinates[0] - _this.coordinates[0] < 0 &&\n                    bNode.coordinates[0] - _this.coordinates[0] >= 0)\n                    return -1;\n                if (aNode.coordinates[0] - _this.coordinates[0] === 0 &&\n                    bNode.coordinates[0] - _this.coordinates[0] === 0) {\n                    if (aNode.coordinates[1] - _this.coordinates[1] >= 0 ||\n                        bNode.coordinates[1] - _this.coordinates[1] >= 0)\n                        return aNode.coordinates[1] - bNode.coordinates[1];\n                    return bNode.coordinates[1] - aNode.coordinates[1];\n                }\n                var det = (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.orientationIndex)(_this.coordinates, aNode.coordinates, bNode.coordinates);\n                if (det < 0)\n                    return 1;\n                if (det > 0)\n                    return -1;\n                var d1 = Math.pow(aNode.coordinates[0] - _this.coordinates[0], 2) +\n                    Math.pow(aNode.coordinates[1] - _this.coordinates[1], 2), d2 = Math.pow(bNode.coordinates[0] - _this.coordinates[0], 2) +\n                    Math.pow(bNode.coordinates[1] - _this.coordinates[1], 2);\n                return d1 - d2;\n            });\n            this.outerEdgesSorted = true;\n        }\n    };\n    /**\n     * Retrieves outer edges.\n     *\n     * They are sorted if they aren't in the CCW order.\n     *\n     * @memberof Node\n     * @returns {Edge[]} - List of outer edges sorted in a CCW order.\n     */\n    Node.prototype.getOuterEdges = function () {\n        this.sortOuterEdges();\n        return this.outerEdges;\n    };\n    Node.prototype.getOuterEdge = function (i) {\n        this.sortOuterEdges();\n        return this.outerEdges[i];\n    };\n    Node.prototype.addInnerEdge = function (edge) {\n        this.innerEdges.push(edge);\n    };\n    return Node;\n}());\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Node);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcG9seWdvbml6ZUA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbml6ZS9kaXN0L2VzL2xpYi9Ob2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLO0FBQzdDLDhCQUE4QixLQUFLO0FBQ25DO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkMsdUNBQXVDLEtBQUssU0FBUztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLG9DQUFvQztBQUNwRztBQUNBO0FBQ0EsZ0VBQWdFLGdDQUFnQztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBEQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcG9seWdvbml6ZUA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbml6ZS9kaXN0L2VzL2xpYi9Ob2RlLmpzPzJmY2UiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb3JpZW50YXRpb25JbmRleCB9IGZyb20gXCIuL3V0aWwuanNcIjtcbi8qKlxuICogTm9kZVxuICovXG52YXIgTm9kZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRoaXMuaWQgPSBOb2RlLmJ1aWxkSWQoY29vcmRpbmF0ZXMpO1xuICAgICAgICB0aGlzLmNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXM7IC8vPCB7TnVtYmVyW119XG4gICAgICAgIHRoaXMuaW5uZXJFZGdlcyA9IFtdOyAvLzwge0VkZ2VbXX1cbiAgICAgICAgLy8gV2Ugd2lsIHN0b3JlIHRvIChvdXQpIGVkZ2VzIGluIGFuIENDVyBvcmRlciBhcyBnZW9zOjpwbGFuYXJncmFwaDo6RGlyZWN0ZWRFZGdlU3RhciBkb2VzXG4gICAgICAgIHRoaXMub3V0ZXJFZGdlcyA9IFtdOyAvLzwge0VkZ2VbXX1cbiAgICAgICAgdGhpcy5vdXRlckVkZ2VzU29ydGVkID0gZmFsc2U7IC8vPCB7Qm9vbGVhbn0gZmxhZyB0aGF0IHN0b3JlcyBpZiB0aGUgb3V0ZXIgRWRnZXMgaGFkIGJlZW4gc29ydGVkXG4gICAgfVxuICAgIE5vZGUuYnVpbGRJZCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICByZXR1cm4gY29vcmRpbmF0ZXMuam9pbihcIixcIik7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5yZW1vdmVJbm5lckVkZ2UgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB0aGlzLmlubmVyRWRnZXMgPSB0aGlzLmlubmVyRWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLmZyb20uaWQgIT09IGVkZ2UuZnJvbS5pZDsgfSk7XG4gICAgfTtcbiAgICBOb2RlLnByb3RvdHlwZS5yZW1vdmVPdXRlckVkZ2UgPSBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICB0aGlzLm91dGVyRWRnZXMgPSB0aGlzLm91dGVyRWRnZXMuZmlsdGVyKGZ1bmN0aW9uIChlKSB7IHJldHVybiBlLnRvLmlkICE9PSBlZGdlLnRvLmlkOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIE91dGVyIGVkZ2VzIGFyZSBzdG9yZWQgQ0NXIG9yZGVyLlxuICAgICAqXG4gICAgICogQG1lbWJlcm9mIE5vZGVcbiAgICAgKiBAcGFyYW0ge0VkZ2V9IGVkZ2UgLSBFZGdlIHRvIGFkZCBhcyBhbiBvdXRlckVkZ2UuXG4gICAgICovXG4gICAgTm9kZS5wcm90b3R5cGUuYWRkT3V0ZXJFZGdlID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgdGhpcy5vdXRlckVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIHRoaXMub3V0ZXJFZGdlc1NvcnRlZCA9IGZhbHNlO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU29ydHMgb3V0ZXIgZWRnZXMgaW4gQ0NXIHdheS5cbiAgICAgKlxuICAgICAqIEBtZW1iZXJvZiBOb2RlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBOb2RlLnByb3RvdHlwZS5zb3J0T3V0ZXJFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLm91dGVyRWRnZXNTb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vdGhpcy5vdXRlckVkZ2VzLnNvcnQoKGEsIGIpID0+IGEuY29tcGFyZVRvKGIpKTtcbiAgICAgICAgICAgIC8vIFVzaW5nIHRoaXMgY29tcGFyYXRvciBpbiBvcmRlciB0byBiZSBkZXRlcm1pbmlzdGljXG4gICAgICAgICAgICB0aGlzLm91dGVyRWRnZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBhTm9kZSA9IGEudG8sIGJOb2RlID0gYi50bztcbiAgICAgICAgICAgICAgICBpZiAoYU5vZGUuY29vcmRpbmF0ZXNbMF0gLSBfdGhpcy5jb29yZGluYXRlc1swXSA+PSAwICYmXG4gICAgICAgICAgICAgICAgICAgIGJOb2RlLmNvb3JkaW5hdGVzWzBdIC0gX3RoaXMuY29vcmRpbmF0ZXNbMF0gPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoYU5vZGUuY29vcmRpbmF0ZXNbMF0gLSBfdGhpcy5jb29yZGluYXRlc1swXSA8IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgYk5vZGUuY29vcmRpbmF0ZXNbMF0gLSBfdGhpcy5jb29yZGluYXRlc1swXSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGFOb2RlLmNvb3JkaW5hdGVzWzBdIC0gX3RoaXMuY29vcmRpbmF0ZXNbMF0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgYk5vZGUuY29vcmRpbmF0ZXNbMF0gLSBfdGhpcy5jb29yZGluYXRlc1swXSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYU5vZGUuY29vcmRpbmF0ZXNbMV0gLSBfdGhpcy5jb29yZGluYXRlc1sxXSA+PSAwIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBiTm9kZS5jb29yZGluYXRlc1sxXSAtIF90aGlzLmNvb3JkaW5hdGVzWzFdID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYU5vZGUuY29vcmRpbmF0ZXNbMV0gLSBiTm9kZS5jb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJOb2RlLmNvb3JkaW5hdGVzWzFdIC0gYU5vZGUuY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkZXQgPSBvcmllbnRhdGlvbkluZGV4KF90aGlzLmNvb3JkaW5hdGVzLCBhTm9kZS5jb29yZGluYXRlcywgYk5vZGUuY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgICAgIGlmIChkZXQgPCAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgICAgICBpZiAoZGV0ID4gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIHZhciBkMSA9IE1hdGgucG93KGFOb2RlLmNvb3JkaW5hdGVzWzBdIC0gX3RoaXMuY29vcmRpbmF0ZXNbMF0sIDIpICtcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5wb3coYU5vZGUuY29vcmRpbmF0ZXNbMV0gLSBfdGhpcy5jb29yZGluYXRlc1sxXSwgMiksIGQyID0gTWF0aC5wb3coYk5vZGUuY29vcmRpbmF0ZXNbMF0gLSBfdGhpcy5jb29yZGluYXRlc1swXSwgMikgK1xuICAgICAgICAgICAgICAgICAgICBNYXRoLnBvdyhiTm9kZS5jb29yZGluYXRlc1sxXSAtIF90aGlzLmNvb3JkaW5hdGVzWzFdLCAyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZDEgLSBkMjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5vdXRlckVkZ2VzU29ydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIG91dGVyIGVkZ2VzLlxuICAgICAqXG4gICAgICogVGhleSBhcmUgc29ydGVkIGlmIHRoZXkgYXJlbid0IGluIHRoZSBDQ1cgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAbWVtYmVyb2YgTm9kZVxuICAgICAqIEByZXR1cm5zIHtFZGdlW119IC0gTGlzdCBvZiBvdXRlciBlZGdlcyBzb3J0ZWQgaW4gYSBDQ1cgb3JkZXIuXG4gICAgICovXG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0T3V0ZXJFZGdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zb3J0T3V0ZXJFZGdlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRlckVkZ2VzO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuZ2V0T3V0ZXJFZGdlID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgdGhpcy5zb3J0T3V0ZXJFZGdlcygpO1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRlckVkZ2VzW2ldO1xuICAgIH07XG4gICAgTm9kZS5wcm90b3R5cGUuYWRkSW5uZXJFZGdlID0gZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgdGhpcy5pbm5lckVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9kZTtcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBOb2RlO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/Node.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/util.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/util.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   coordinatesEqual: () => (/* binding */ coordinatesEqual),\n/* harmony export */   envelopeContains: () => (/* binding */ envelopeContains),\n/* harmony export */   envelopeIsEqual: () => (/* binding */ envelopeIsEqual),\n/* harmony export */   orientationIndex: () => (/* binding */ orientationIndex)\n/* harmony export */ });\n/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/boolean-point-in-polygon */ \"(ssr)/./node_modules/.pnpm/@turf+boolean-point-in-polygon@6.5.0/node_modules/@turf/boolean-point-in-polygon/dist/es/index.js\");\n/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/helpers */ \"(ssr)/./node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js\");\n\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign#Polyfill\nfunction mathSign(x) {\n    return ((x > 0) - (x < 0) || +x);\n}\n/**\n * Returns the direction of the point q relative to the vector p1 -> p2.\n *\n * Implementation of geos::algorithm::CGAlgorithm::orientationIndex()\n * (same as geos::algorithm::CGAlgorithm::computeOrientation())\n *\n * @param {number[]} p1 - the origin point of the vector\n * @param {number[]} p2 - the final point of the vector\n * @param {number[]} q - the point to compute the direction to\n *\n * @returns {number} - 1 if q is ccw (left) from p1->p2,\n *    -1 if q is cw (right) from p1->p2,\n *     0 if q is colinear with p1->p2\n */\nfunction orientationIndex(p1, p2, q) {\n    var dx1 = p2[0] - p1[0], dy1 = p2[1] - p1[1], dx2 = q[0] - p2[0], dy2 = q[1] - p2[1];\n    return mathSign(dx1 * dy2 - dx2 * dy1);\n}\n/**\n * Checks if two envelopes are equal.\n *\n * The function assumes that the arguments are envelopes, i.e.: Rectangular polygon\n *\n * @param {Feature<Polygon>} env1 - Envelope\n * @param {Feature<Polygon>} env2 - Envelope\n * @returns {boolean} - True if the envelopes are equal\n */\nfunction envelopeIsEqual(env1, env2) {\n    var envX1 = env1.geometry.coordinates[0].map(function (c) { return c[0]; }), envY1 = env1.geometry.coordinates[0].map(function (c) { return c[1]; }), envX2 = env2.geometry.coordinates[0].map(function (c) { return c[0]; }), envY2 = env2.geometry.coordinates[0].map(function (c) { return c[1]; });\n    return (Math.max.apply(null, envX1) === Math.max.apply(null, envX2) &&\n        Math.max.apply(null, envY1) === Math.max.apply(null, envY2) &&\n        Math.min.apply(null, envX1) === Math.min.apply(null, envX2) &&\n        Math.min.apply(null, envY1) === Math.min.apply(null, envY2));\n}\n/**\n * Check if a envelope is contained in other one.\n *\n * The function assumes that the arguments are envelopes, i.e.: Convex polygon\n * XXX: Envelopes are rectangular, checking if a point is inside a rectangule is something easy,\n * this could be further improved.\n *\n * @param {Feature<Polygon>} self - Envelope\n * @param {Feature<Polygon>} env - Envelope\n * @returns {boolean} - True if env is contained in self\n */\nfunction envelopeContains(self, env) {\n    return env.geometry.coordinates[0].every(function (c) {\n        return (0,_turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_1__.point)(c), self);\n    });\n}\n/**\n * Checks if two coordinates are equal.\n *\n * @param {number[]} coord1 - First coordinate\n * @param {number[]} coord2 - Second coordinate\n * @returns {boolean} - True if coordinates are equal\n */\nfunction coordinatesEqual(coord1, coord2) {\n    return coord1[0] === coord2[0] && coord1[1] === coord2[1];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcG9seWdvbml6ZUA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvcG9seWdvbml6ZS9kaXN0L2VzL2xpYi91dGlsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFtRTtBQUM3QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFdBQVcsa0JBQWtCO0FBQzdCLGFBQWEsU0FBUztBQUN0QjtBQUNPO0FBQ1AsZ0VBQWdFLGNBQWMsMkRBQTJELGNBQWMsMkRBQTJELGNBQWMsMkRBQTJELGNBQWM7QUFDelM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxrQkFBa0I7QUFDN0IsYUFBYSxTQUFTO0FBQ3RCO0FBQ087QUFDUDtBQUNBLGVBQWUsMEVBQXFCLENBQUMsb0RBQUs7QUFDMUMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDTztBQUNQO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZnZhbHVlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0dXJmK3BvbHlnb25pemVANi41LjAvbm9kZV9tb2R1bGVzL0B0dXJmL3BvbHlnb25pemUvZGlzdC9lcy9saWIvdXRpbC5qcz81ZTlkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBib29sZWFuUG9pbnRJblBvbHlnb24gZnJvbSBcIkB0dXJmL2Jvb2xlYW4tcG9pbnQtaW4tcG9seWdvblwiO1xuaW1wb3J0IHsgcG9pbnQgfSBmcm9tIFwiQHR1cmYvaGVscGVyc1wiO1xuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9zaWduI1BvbHlmaWxsXG5mdW5jdGlvbiBtYXRoU2lnbih4KSB7XG4gICAgcmV0dXJuICgoeCA+IDApIC0gKHggPCAwKSB8fCAreCk7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgcG9pbnQgcSByZWxhdGl2ZSB0byB0aGUgdmVjdG9yIHAxIC0+IHAyLlxuICpcbiAqIEltcGxlbWVudGF0aW9uIG9mIGdlb3M6OmFsZ29yaXRobTo6Q0dBbGdvcml0aG06Om9yaWVudGF0aW9uSW5kZXgoKVxuICogKHNhbWUgYXMgZ2Vvczo6YWxnb3JpdGhtOjpDR0FsZ29yaXRobTo6Y29tcHV0ZU9yaWVudGF0aW9uKCkpXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gcDEgLSB0aGUgb3JpZ2luIHBvaW50IG9mIHRoZSB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyW119IHAyIC0gdGhlIGZpbmFsIHBvaW50IG9mIHRoZSB2ZWN0b3JcbiAqIEBwYXJhbSB7bnVtYmVyW119IHEgLSB0aGUgcG9pbnQgdG8gY29tcHV0ZSB0aGUgZGlyZWN0aW9uIHRvXG4gKlxuICogQHJldHVybnMge251bWJlcn0gLSAxIGlmIHEgaXMgY2N3IChsZWZ0KSBmcm9tIHAxLT5wMixcbiAqICAgIC0xIGlmIHEgaXMgY3cgKHJpZ2h0KSBmcm9tIHAxLT5wMixcbiAqICAgICAwIGlmIHEgaXMgY29saW5lYXIgd2l0aCBwMS0+cDJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG9yaWVudGF0aW9uSW5kZXgocDEsIHAyLCBxKSB7XG4gICAgdmFyIGR4MSA9IHAyWzBdIC0gcDFbMF0sIGR5MSA9IHAyWzFdIC0gcDFbMV0sIGR4MiA9IHFbMF0gLSBwMlswXSwgZHkyID0gcVsxXSAtIHAyWzFdO1xuICAgIHJldHVybiBtYXRoU2lnbihkeDEgKiBkeTIgLSBkeDIgKiBkeTEpO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdHdvIGVudmVsb3BlcyBhcmUgZXF1YWwuXG4gKlxuICogVGhlIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSBlbnZlbG9wZXMsIGkuZS46IFJlY3Rhbmd1bGFyIHBvbHlnb25cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IGVudjEgLSBFbnZlbG9wZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBlbnYyIC0gRW52ZWxvcGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGVudmVsb3BlcyBhcmUgZXF1YWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudmVsb3BlSXNFcXVhbChlbnYxLCBlbnYyKSB7XG4gICAgdmFyIGVudlgxID0gZW52MS5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGNbMF07IH0pLCBlbnZZMSA9IGVudjEuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjWzFdOyB9KSwgZW52WDIgPSBlbnYyLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gY1swXTsgfSksIGVudlkyID0gZW52Mi5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5tYXAoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGNbMV07IH0pO1xuICAgIHJldHVybiAoTWF0aC5tYXguYXBwbHkobnVsbCwgZW52WDEpID09PSBNYXRoLm1heC5hcHBseShudWxsLCBlbnZYMikgJiZcbiAgICAgICAgTWF0aC5tYXguYXBwbHkobnVsbCwgZW52WTEpID09PSBNYXRoLm1heC5hcHBseShudWxsLCBlbnZZMikgJiZcbiAgICAgICAgTWF0aC5taW4uYXBwbHkobnVsbCwgZW52WDEpID09PSBNYXRoLm1pbi5hcHBseShudWxsLCBlbnZYMikgJiZcbiAgICAgICAgTWF0aC5taW4uYXBwbHkobnVsbCwgZW52WTEpID09PSBNYXRoLm1pbi5hcHBseShudWxsLCBlbnZZMikpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGVudmVsb3BlIGlzIGNvbnRhaW5lZCBpbiBvdGhlciBvbmUuXG4gKlxuICogVGhlIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCB0aGUgYXJndW1lbnRzIGFyZSBlbnZlbG9wZXMsIGkuZS46IENvbnZleCBwb2x5Z29uXG4gKiBYWFg6IEVudmVsb3BlcyBhcmUgcmVjdGFuZ3VsYXIsIGNoZWNraW5nIGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgcmVjdGFuZ3VsZSBpcyBzb21ldGhpbmcgZWFzeSxcbiAqIHRoaXMgY291bGQgYmUgZnVydGhlciBpbXByb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHNlbGYgLSBFbnZlbG9wZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBlbnYgLSBFbnZlbG9wZVxuICogQHJldHVybnMge2Jvb2xlYW59IC0gVHJ1ZSBpZiBlbnYgaXMgY29udGFpbmVkIGluIHNlbGZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVudmVsb3BlQ29udGFpbnMoc2VsZiwgZW52KSB7XG4gICAgcmV0dXJuIGVudi5nZW9tZXRyeS5jb29yZGluYXRlc1swXS5ldmVyeShmdW5jdGlvbiAoYykge1xuICAgICAgICByZXR1cm4gYm9vbGVhblBvaW50SW5Qb2x5Z29uKHBvaW50KGMpLCBzZWxmKTtcbiAgICB9KTtcbn1cbi8qKlxuICogQ2hlY2tzIGlmIHR3byBjb29yZGluYXRlcyBhcmUgZXF1YWwuXG4gKlxuICogQHBhcmFtIHtudW1iZXJbXX0gY29vcmQxIC0gRmlyc3QgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtudW1iZXJbXX0gY29vcmQyIC0gU2Vjb25kIGNvb3JkaW5hdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIFRydWUgaWYgY29vcmRpbmF0ZXMgYXJlIGVxdWFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb29yZGluYXRlc0VxdWFsKGNvb3JkMSwgY29vcmQyKSB7XG4gICAgcmV0dXJuIGNvb3JkMVswXSA9PT0gY29vcmQyWzBdICYmIGNvb3JkMVsxXSA9PT0gY29vcmQyWzFdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+polygonize@6.5.0/node_modules/@turf/polygonize/dist/es/lib/util.js\n");

/***/ })

};
;
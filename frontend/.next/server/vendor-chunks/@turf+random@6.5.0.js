"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turf+random@6.5.0";
exports.ids = ["vendor-chunks/@turf+random@6.5.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@turf+random@6.5.0/node_modules/@turf/random/dist/es/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+random@6.5.0/node_modules/@turf/random/dist/es/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   randomLineString: () => (/* binding */ randomLineString),\n/* harmony export */   randomPoint: () => (/* binding */ randomPoint),\n/* harmony export */   randomPolygon: () => (/* binding */ randomPolygon),\n/* harmony export */   randomPosition: () => (/* binding */ randomPosition)\n/* harmony export */ });\n/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/helpers */ \"(ssr)/./node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js\");\nvar __spreadArrays = (undefined && undefined.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\n\n/**\n * Returns a random position within a {@link bounding box}.\n *\n * @name randomPosition\n * @param {Array<number>} [bbox=[-180, -90, 180, 90]] a bounding box inside of which positions are placed.\n * @returns {Array<number>} Position [longitude, latitude]\n * @example\n * var position = turf.randomPosition([-180, -90, 180, 90])\n * // => position\n */\nfunction randomPosition(bbox) {\n    if (Array.isArray(bbox)) {\n        return coordInBBox(bbox);\n    }\n    if (bbox && bbox.bbox) {\n        return coordInBBox(bbox.bbox);\n    }\n    return [lon(), lat()];\n}\n/**\n * Returns a random {@link point}.\n *\n * @name randomPoint\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @returns {FeatureCollection<Point>} GeoJSON FeatureCollection of points\n * @example\n * var points = turf.randomPoint(25, {bbox: [-180, -90, 180, 90]})\n * // => points\n */\nfunction randomPoint(count, options) {\n    if (options === void 0) { options = {}; }\n    if (count === undefined || count === null) {\n        count = 1;\n    }\n    var features = [];\n    for (var i = 0; i < count; i++) {\n        features.push((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.point)(randomPosition(options.bbox)));\n    }\n    return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.featureCollection)(features);\n}\n/**\n * Returns a random {@link polygon}.\n *\n * @name randomPolygon\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_radial_length=10] is the maximum number of decimal degrees latitude or longitude that a\n * vertex can reach out of the center of the Polygon.\n * @returns {FeatureCollection<Polygon>} GeoJSON FeatureCollection of polygons\n * @example\n * var polygons = turf.randomPolygon(25, {bbox: [-180, -90, 180, 90]})\n * // => polygons\n */\nfunction randomPolygon(count, options) {\n    if (options === void 0) { options = {}; }\n    // Default param\n    if (count === undefined || count === null) {\n        count = 1;\n    }\n    if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(options.num_vertices) || options.num_vertices === undefined) {\n        options.num_vertices = 10;\n    }\n    if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(options.max_radial_length) ||\n        options.max_radial_length === undefined) {\n        options.max_radial_length = 10;\n    }\n    var features = [];\n    var _loop_1 = function (i) {\n        var vertices = [];\n        var circleOffsets = __spreadArrays(Array(options.num_vertices + 1)).map(Math.random);\n        // Sum Offsets\n        circleOffsets.forEach(function (cur, index, arr) {\n            arr[index] = index > 0 ? cur + arr[index - 1] : cur;\n        });\n        // scaleOffsets\n        circleOffsets.forEach(function (cur) {\n            cur = (cur * 2 * Math.PI) / circleOffsets[circleOffsets.length - 1];\n            var radialScaler = Math.random();\n            vertices.push([\n                radialScaler * (options.max_radial_length || 10) * Math.sin(cur),\n                radialScaler * (options.max_radial_length || 10) * Math.cos(cur),\n            ]);\n        });\n        vertices[vertices.length - 1] = vertices[0]; // close the ring\n        // center the polygon around something\n        vertices = vertices.map(vertexToCoordinate(randomPosition(options.bbox)));\n        features.push((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.polygon)([vertices]));\n    };\n    for (var i = 0; i < count; i++) {\n        _loop_1(i);\n    }\n    return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.featureCollection)(features);\n}\n/**\n * Returns a random {@link linestring}.\n *\n * @name randomLineString\n * @param {number} [count=1] how many geometries will be generated\n * @param {Object} [options={}] Optional parameters\n * @param {Array<number>} [options.bbox=[-180, -90, 180, 90]] a bounding box inside of which geometries are placed.\n * @param {number} [options.num_vertices=10] is how many coordinates each LineString will contain.\n * @param {number} [options.max_length=0.0001] is the maximum number of decimal degrees that a\n * vertex can be from its predecessor\n * @param {number} [options.max_rotation=Math.PI / 8] is the maximum number of radians that a\n * line segment can turn from the previous segment.\n * @returns {FeatureCollection<LineString>} GeoJSON FeatureCollection of linestrings\n * @example\n * var lineStrings = turf.randomLineString(25, {bbox: [-180, -90, 180, 90]})\n * // => lineStrings\n */\nfunction randomLineString(count, options) {\n    if (options === void 0) { options = {}; }\n    // Optional parameters\n    options = options || {};\n    if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isObject)(options)) {\n        throw new Error(\"options is invalid\");\n    }\n    var bbox = options.bbox;\n    var num_vertices = options.num_vertices;\n    var max_length = options.max_length;\n    var max_rotation = options.max_rotation;\n    if (count === undefined || count === null) {\n        count = 1;\n    }\n    // Default parameters\n    if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(num_vertices) ||\n        num_vertices === undefined ||\n        num_vertices < 2) {\n        num_vertices = 10;\n    }\n    if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(max_length) || max_length === undefined) {\n        max_length = 0.0001;\n    }\n    if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.isNumber)(max_rotation) || max_rotation === undefined) {\n        max_rotation = Math.PI / 8;\n    }\n    var features = [];\n    for (var i = 0; i < count; i++) {\n        var startingPoint = randomPosition(bbox);\n        var vertices = [startingPoint];\n        for (var j = 0; j < num_vertices - 1; j++) {\n            var priorAngle = j === 0\n                ? Math.random() * 2 * Math.PI\n                : Math.tan((vertices[j][1] - vertices[j - 1][1]) /\n                    (vertices[j][0] - vertices[j - 1][0]));\n            var angle = priorAngle + (Math.random() - 0.5) * max_rotation * 2;\n            var distance = Math.random() * max_length;\n            vertices.push([\n                vertices[j][0] + distance * Math.cos(angle),\n                vertices[j][1] + distance * Math.sin(angle),\n            ]);\n        }\n        features.push((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.lineString)(vertices));\n    }\n    return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_0__.featureCollection)(features);\n}\nfunction vertexToCoordinate(hub) {\n    return function (cur) {\n        return [cur[0] + hub[0], cur[1] + hub[1]];\n    };\n}\nfunction rnd() {\n    return Math.random() - 0.5;\n}\nfunction lon() {\n    return rnd() * 360;\n}\nfunction lat() {\n    return rnd() * 180;\n}\nfunction coordInBBox(bbox) {\n    return [\n        Math.random() * (bbox[2] - bbox[0]) + bbox[0],\n        Math.random() * (bbox[3] - bbox[1]) + bbox[1],\n    ];\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcmFuZG9tQDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi9yYW5kb20vZGlzdC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBLHNCQUFzQixTQUFJLElBQUksU0FBSTtBQUNsQyxrREFBa0QsUUFBUTtBQUMxRCx5Q0FBeUMsUUFBUTtBQUNqRCx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDbUc7QUFDbkc7QUFDQSx1Q0FBdUMsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsWUFBWTtBQUNqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUSxXQUFXO0FBQzlCLFdBQVcsZUFBZTtBQUMxQixhQUFhLDBCQUEwQjtBQUN2QztBQUNBLHNDQUFzQywyQkFBMkI7QUFDakU7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0Isc0JBQXNCLG9EQUFLO0FBQzNCO0FBQ0EsV0FBVyxnRUFBaUI7QUFDNUI7QUFDQTtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLFdBQVc7QUFDOUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLDRCQUE0QjtBQUN6QztBQUNBLDBDQUEwQywyQkFBMkI7QUFDckU7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBUTtBQUNqQjtBQUNBO0FBQ0EsU0FBUyx1REFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFPO0FBQzdCO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBLFdBQVcsZ0VBQWlCO0FBQzVCO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRLFdBQVc7QUFDOUIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBLGdEQUFnRCwyQkFBMkI7QUFDM0U7QUFDQTtBQUNPO0FBQ1AsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxTQUFTLHVEQUFRO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBUTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsdURBQVE7QUFDakI7QUFDQTtBQUNBLFNBQVMsdURBQVE7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBLHdCQUF3QixzQkFBc0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBVTtBQUNoQztBQUNBLFdBQVcsZ0VBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrcmFuZG9tQDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi9yYW5kb20vZGlzdC9lcy9pbmRleC5qcz81YTVlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX3NwcmVhZEFycmF5cyA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheXMpIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxuICAgICAgICAgICAgcltrXSA9IGFbal07XG4gICAgcmV0dXJuIHI7XG59O1xuaW1wb3J0IHsgZmVhdHVyZUNvbGxlY3Rpb24sIGlzTnVtYmVyLCBpc09iamVjdCwgbGluZVN0cmluZywgcG9pbnQsIHBvbHlnb24sIH0gZnJvbSBcIkB0dXJmL2hlbHBlcnNcIjtcbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSBwb3NpdGlvbiB3aXRoaW4gYSB7QGxpbmsgYm91bmRpbmcgYm94fS5cbiAqXG4gKiBAbmFtZSByYW5kb21Qb3NpdGlvblxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbYmJveD1bLTE4MCwgLTkwLCAxODAsIDkwXV0gYSBib3VuZGluZyBib3ggaW5zaWRlIG9mIHdoaWNoIHBvc2l0aW9ucyBhcmUgcGxhY2VkLlxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFBvc2l0aW9uIFtsb25naXR1ZGUsIGxhdGl0dWRlXVxuICogQGV4YW1wbGVcbiAqIHZhciBwb3NpdGlvbiA9IHR1cmYucmFuZG9tUG9zaXRpb24oWy0xODAsIC05MCwgMTgwLCA5MF0pXG4gKiAvLyA9PiBwb3NpdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tUG9zaXRpb24oYmJveCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJib3gpKSB7XG4gICAgICAgIHJldHVybiBjb29yZEluQkJveChiYm94KTtcbiAgICB9XG4gICAgaWYgKGJib3ggJiYgYmJveC5iYm94KSB7XG4gICAgICAgIHJldHVybiBjb29yZEluQkJveChiYm94LmJib3gpO1xuICAgIH1cbiAgICByZXR1cm4gW2xvbigpLCBsYXQoKV07XG59XG4vKipcbiAqIFJldHVybnMgYSByYW5kb20ge0BsaW5rIHBvaW50fS5cbiAqXG4gKiBAbmFtZSByYW5kb21Qb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudD0xXSBob3cgbWFueSBnZW9tZXRyaWVzIHdpbGwgYmUgZ2VuZXJhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveD1bLTE4MCwgLTkwLCAxODAsIDkwXV0gYSBib3VuZGluZyBib3ggaW5zaWRlIG9mIHdoaWNoIGdlb21ldHJpZXMgYXJlIHBsYWNlZC5cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IEdlb0pTT04gRmVhdHVyZUNvbGxlY3Rpb24gb2YgcG9pbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHR1cmYucmFuZG9tUG9pbnQoMjUsIHtiYm94OiBbLTE4MCwgLTkwLCAxODAsIDkwXX0pXG4gKiAvLyA9PiBwb2ludHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVBvaW50KGNvdW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCB8fCBjb3VudCA9PT0gbnVsbCkge1xuICAgICAgICBjb3VudCA9IDE7XG4gICAgfVxuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBmZWF0dXJlcy5wdXNoKHBvaW50KHJhbmRvbVBvc2l0aW9uKG9wdGlvbnMuYmJveCkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSB7QGxpbmsgcG9seWdvbn0uXG4gKlxuICogQG5hbWUgcmFuZG9tUG9seWdvblxuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudD0xXSBob3cgbWFueSBnZW9tZXRyaWVzIHdpbGwgYmUgZ2VuZXJhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveD1bLTE4MCwgLTkwLCAxODAsIDkwXV0gYSBib3VuZGluZyBib3ggaW5zaWRlIG9mIHdoaWNoIGdlb21ldHJpZXMgYXJlIHBsYWNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5udW1fdmVydGljZXM9MTBdIGlzIGhvdyBtYW55IGNvb3JkaW5hdGVzIGVhY2ggTGluZVN0cmluZyB3aWxsIGNvbnRhaW4uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4X3JhZGlhbF9sZW5ndGg9MTBdIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRlZ3JlZXMgbGF0aXR1ZGUgb3IgbG9uZ2l0dWRlIHRoYXQgYVxuICogdmVydGV4IGNhbiByZWFjaCBvdXQgb2YgdGhlIGNlbnRlciBvZiB0aGUgUG9seWdvbi5cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gR2VvSlNPTiBGZWF0dXJlQ29sbGVjdGlvbiBvZiBwb2x5Z29uc1xuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29ucyA9IHR1cmYucmFuZG9tUG9seWdvbigyNSwge2Jib3g6IFstMTgwLCAtOTAsIDE4MCwgOTBdfSlcbiAqIC8vID0+IHBvbHlnb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21Qb2x5Z29uKGNvdW50LCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAvLyBEZWZhdWx0IHBhcmFtXG4gICAgaWYgKGNvdW50ID09PSB1bmRlZmluZWQgfHwgY291bnQgPT09IG51bGwpIHtcbiAgICAgICAgY291bnQgPSAxO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKG9wdGlvbnMubnVtX3ZlcnRpY2VzKSB8fCBvcHRpb25zLm51bV92ZXJ0aWNlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMubnVtX3ZlcnRpY2VzID0gMTA7XG4gICAgfVxuICAgIGlmICghaXNOdW1iZXIob3B0aW9ucy5tYXhfcmFkaWFsX2xlbmd0aCkgfHxcbiAgICAgICAgb3B0aW9ucy5tYXhfcmFkaWFsX2xlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMubWF4X3JhZGlhbF9sZW5ndGggPSAxMDtcbiAgICB9XG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICAgICAgdmFyIGNpcmNsZU9mZnNldHMgPSBfX3NwcmVhZEFycmF5cyhBcnJheShvcHRpb25zLm51bV92ZXJ0aWNlcyArIDEpKS5tYXAoTWF0aC5yYW5kb20pO1xuICAgICAgICAvLyBTdW0gT2Zmc2V0c1xuICAgICAgICBjaXJjbGVPZmZzZXRzLmZvckVhY2goZnVuY3Rpb24gKGN1ciwgaW5kZXgsIGFycikge1xuICAgICAgICAgICAgYXJyW2luZGV4XSA9IGluZGV4ID4gMCA/IGN1ciArIGFycltpbmRleCAtIDFdIDogY3VyO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gc2NhbGVPZmZzZXRzXG4gICAgICAgIGNpcmNsZU9mZnNldHMuZm9yRWFjaChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICAgICAgICBjdXIgPSAoY3VyICogMiAqIE1hdGguUEkpIC8gY2lyY2xlT2Zmc2V0c1tjaXJjbGVPZmZzZXRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIHJhZGlhbFNjYWxlciA9IE1hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgICAgICByYWRpYWxTY2FsZXIgKiAob3B0aW9ucy5tYXhfcmFkaWFsX2xlbmd0aCB8fCAxMCkgKiBNYXRoLnNpbihjdXIpLFxuICAgICAgICAgICAgICAgIHJhZGlhbFNjYWxlciAqIChvcHRpb25zLm1heF9yYWRpYWxfbGVuZ3RoIHx8IDEwKSAqIE1hdGguY29zKGN1ciksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZlcnRpY2VzW3ZlcnRpY2VzLmxlbmd0aCAtIDFdID0gdmVydGljZXNbMF07IC8vIGNsb3NlIHRoZSByaW5nXG4gICAgICAgIC8vIGNlbnRlciB0aGUgcG9seWdvbiBhcm91bmQgc29tZXRoaW5nXG4gICAgICAgIHZlcnRpY2VzID0gdmVydGljZXMubWFwKHZlcnRleFRvQ29vcmRpbmF0ZShyYW5kb21Qb3NpdGlvbihvcHRpb25zLmJib3gpKSk7XG4gICAgICAgIGZlYXR1cmVzLnB1c2gocG9seWdvbihbdmVydGljZXNdKSk7XG4gICAgfTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbn1cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbSB7QGxpbmsgbGluZXN0cmluZ30uXG4gKlxuICogQG5hbWUgcmFuZG9tTGluZVN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IFtjb3VudD0xXSBob3cgbWFueSBnZW9tZXRyaWVzIHdpbGwgYmUgZ2VuZXJhdGVkXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveD1bLTE4MCwgLTkwLCAxODAsIDkwXV0gYSBib3VuZGluZyBib3ggaW5zaWRlIG9mIHdoaWNoIGdlb21ldHJpZXMgYXJlIHBsYWNlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5udW1fdmVydGljZXM9MTBdIGlzIGhvdyBtYW55IGNvb3JkaW5hdGVzIGVhY2ggTGluZVN0cmluZyB3aWxsIGNvbnRhaW4uXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4X2xlbmd0aD0wLjAwMDFdIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIGRlZ3JlZXMgdGhhdCBhXG4gKiB2ZXJ0ZXggY2FuIGJlIGZyb20gaXRzIHByZWRlY2Vzc29yXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4X3JvdGF0aW9uPU1hdGguUEkgLyA4XSBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmFkaWFucyB0aGF0IGFcbiAqIGxpbmUgc2VnbWVudCBjYW4gdHVybiBmcm9tIHRoZSBwcmV2aW91cyBzZWdtZW50LlxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPExpbmVTdHJpbmc+fSBHZW9KU09OIEZlYXR1cmVDb2xsZWN0aW9uIG9mIGxpbmVzdHJpbmdzXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmVTdHJpbmdzID0gdHVyZi5yYW5kb21MaW5lU3RyaW5nKDI1LCB7YmJveDogWy0xODAsIC05MCwgMTgwLCA5MF19KVxuICogLy8gPT4gbGluZVN0cmluZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUxpbmVTdHJpbmcoY291bnQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIC8vIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMgaXMgaW52YWxpZFwiKTtcbiAgICB9XG4gICAgdmFyIGJib3ggPSBvcHRpb25zLmJib3g7XG4gICAgdmFyIG51bV92ZXJ0aWNlcyA9IG9wdGlvbnMubnVtX3ZlcnRpY2VzO1xuICAgIHZhciBtYXhfbGVuZ3RoID0gb3B0aW9ucy5tYXhfbGVuZ3RoO1xuICAgIHZhciBtYXhfcm90YXRpb24gPSBvcHRpb25zLm1heF9yb3RhdGlvbjtcbiAgICBpZiAoY291bnQgPT09IHVuZGVmaW5lZCB8fCBjb3VudCA9PT0gbnVsbCkge1xuICAgICAgICBjb3VudCA9IDE7XG4gICAgfVxuICAgIC8vIERlZmF1bHQgcGFyYW1ldGVyc1xuICAgIGlmICghaXNOdW1iZXIobnVtX3ZlcnRpY2VzKSB8fFxuICAgICAgICBudW1fdmVydGljZXMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBudW1fdmVydGljZXMgPCAyKSB7XG4gICAgICAgIG51bV92ZXJ0aWNlcyA9IDEwO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKG1heF9sZW5ndGgpIHx8IG1heF9sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtYXhfbGVuZ3RoID0gMC4wMDAxO1xuICAgIH1cbiAgICBpZiAoIWlzTnVtYmVyKG1heF9yb3RhdGlvbikgfHwgbWF4X3JvdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbWF4X3JvdGF0aW9uID0gTWF0aC5QSSAvIDg7XG4gICAgfVxuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnRpbmdQb2ludCA9IHJhbmRvbVBvc2l0aW9uKGJib3gpO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBbc3RhcnRpbmdQb2ludF07XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtX3ZlcnRpY2VzIC0gMTsgaisrKSB7XG4gICAgICAgICAgICB2YXIgcHJpb3JBbmdsZSA9IGogPT09IDBcbiAgICAgICAgICAgICAgICA/IE1hdGgucmFuZG9tKCkgKiAyICogTWF0aC5QSVxuICAgICAgICAgICAgICAgIDogTWF0aC50YW4oKHZlcnRpY2VzW2pdWzFdIC0gdmVydGljZXNbaiAtIDFdWzFdKSAvXG4gICAgICAgICAgICAgICAgICAgICh2ZXJ0aWNlc1tqXVswXSAtIHZlcnRpY2VzW2ogLSAxXVswXSkpO1xuICAgICAgICAgICAgdmFyIGFuZ2xlID0gcHJpb3JBbmdsZSArIChNYXRoLnJhbmRvbSgpIC0gMC41KSAqIG1heF9yb3RhdGlvbiAqIDI7XG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnJhbmRvbSgpICogbWF4X2xlbmd0aDtcbiAgICAgICAgICAgIHZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgICAgIHZlcnRpY2VzW2pdWzBdICsgZGlzdGFuY2UgKiBNYXRoLmNvcyhhbmdsZSksXG4gICAgICAgICAgICAgICAgdmVydGljZXNbal1bMV0gKyBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICAgIGZlYXR1cmVzLnB1c2gobGluZVN0cmluZyh2ZXJ0aWNlcykpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpO1xufVxuZnVuY3Rpb24gdmVydGV4VG9Db29yZGluYXRlKGh1Yikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY3VyKSB7XG4gICAgICAgIHJldHVybiBbY3VyWzBdICsgaHViWzBdLCBjdXJbMV0gKyBodWJbMV1dO1xuICAgIH07XG59XG5mdW5jdGlvbiBybmQoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgLSAwLjU7XG59XG5mdW5jdGlvbiBsb24oKSB7XG4gICAgcmV0dXJuIHJuZCgpICogMzYwO1xufVxuZnVuY3Rpb24gbGF0KCkge1xuICAgIHJldHVybiBybmQoKSAqIDE4MDtcbn1cbmZ1bmN0aW9uIGNvb3JkSW5CQm94KGJib3gpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBNYXRoLnJhbmRvbSgpICogKGJib3hbMl0gLSBiYm94WzBdKSArIGJib3hbMF0sXG4gICAgICAgIE1hdGgucmFuZG9tKCkgKiAoYmJveFszXSAtIGJib3hbMV0pICsgYmJveFsxXSxcbiAgICBdO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+random@6.5.0/node_modules/@turf/random/dist/es/index.js\n");

/***/ })

};
;
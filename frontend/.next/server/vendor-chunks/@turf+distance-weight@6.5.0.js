"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turf+distance-weight@6.5.0";
exports.ids = ["vendor-chunks/@turf+distance-weight@6.5.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@turf+distance-weight@6.5.0/node_modules/@turf/distance-weight/dist/es/index.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+distance-weight@6.5.0/node_modules/@turf/distance-weight/dist/es/index.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ distanceWeight),\n/* harmony export */   pNormDistance: () => (/* binding */ pNormDistance)\n/* harmony export */ });\n/* harmony import */ var _turf_centroid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/centroid */ \"(ssr)/./node_modules/.pnpm/@turf+centroid@6.5.0/node_modules/@turf/centroid/dist/es/index.js\");\n/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/invariant */ \"(ssr)/./node_modules/.pnpm/@turf+invariant@6.5.0/node_modules/@turf/invariant/dist/es/index.js\");\n/* harmony import */ var _turf_meta__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/meta */ \"(ssr)/./node_modules/.pnpm/@turf+meta@6.5.0/node_modules/@turf/meta/dist/es/index.js\");\n\n\n\n/**\n * calcualte the Minkowski p-norm distance between two features.\n * @param feature1 point feature\n * @param feature2 point feature\n * @param p p-norm 1=<p<=infinity 1: Manhattan distance 2: Euclidean distance\n */\nfunction pNormDistance(feature1, feature2, p) {\n    if (p === void 0) { p = 2; }\n    var coordinate1 = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_1__.getCoord)(feature1);\n    var coordinate2 = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_1__.getCoord)(feature2);\n    var xDiff = coordinate1[0] - coordinate2[0];\n    var yDiff = coordinate1[1] - coordinate2[1];\n    if (p === 1) {\n        return Math.abs(xDiff) + Math.abs(yDiff);\n    }\n    return Math.pow(Math.pow(xDiff, p) + Math.pow(yDiff, p), 1 / p);\n}\n/**\n *\n *\n * @name distanceWeight\n * @param {FeatureCollection<any>} fc FeatureCollection.\n * @param {Object} [options] option object.\n * @param {number} [options.threshold=10000] If the distance between neighbor and\n * target features is greater than threshold, the weight of that neighbor is 0.\n * @param {number} [options.p=2] Minkowski p-norm distance parameter.\n * 1: Manhattan distance. 2: Euclidean distance. 1=<p<=infinity.\n * @param {boolean} [options.binary=false] If true, weight=1 if d <= threshold otherwise weight=0.\n *  If false, weight=Math.pow(d, alpha).\n * @param {number} [options.alpha=-1] distance decay parameter.\n * A big value means the weight decay quickly as distance increases.\n * @param {boolean} [options.standardization=false] row standardization.\n * @returns {Array<Array<number>>} distance weight matrix.\n * @example\n *\n * var bbox = [-65, 40, -63, 42];\n * var dataset = turf.randomPoint(100, { bbox: bbox });\n * var result = turf.distanceWeight(dataset);\n */\nfunction distanceWeight(fc, options) {\n    options = options || {};\n    var threshold = options.threshold || 10000;\n    var p = options.p || 2;\n    var binary = options.binary || false;\n    var alpha = options.alpha || -1;\n    var rowTransform = options.standardization || false;\n    var features = [];\n    (0,_turf_meta__WEBPACK_IMPORTED_MODULE_2__.featureEach)(fc, function (feature) {\n        features.push((0,_turf_centroid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(feature));\n    });\n    // computing the distance between the features\n    var weights = [];\n    for (var i = 0; i < features.length; i++) {\n        weights[i] = [];\n    }\n    for (var i = 0; i < features.length; i++) {\n        for (var j = i; j < features.length; j++) {\n            if (i === j) {\n                weights[i][j] = 0;\n            }\n            var dis = pNormDistance(features[i], features[j], p);\n            weights[i][j] = dis;\n            weights[j][i] = dis;\n        }\n    }\n    // binary or distance decay\n    for (var i = 0; i < features.length; i++) {\n        for (var j = 0; j < features.length; j++) {\n            var dis = weights[i][j];\n            if (dis === 0) {\n                continue;\n            }\n            if (binary) {\n                if (dis <= threshold) {\n                    weights[i][j] = 1.0;\n                }\n                else {\n                    weights[i][j] = 0.0;\n                }\n            }\n            else {\n                if (dis <= threshold) {\n                    weights[i][j] = Math.pow(dis, alpha);\n                }\n                else {\n                    weights[i][j] = 0.0;\n                }\n            }\n        }\n    }\n    if (rowTransform) {\n        for (var i = 0; i < features.length; i++) {\n            var rowSum = weights[i].reduce(function (sum, currentVal) {\n                return sum + currentVal;\n            }, 0);\n            for (var j = 0; j < features.length; j++) {\n                weights[i][j] = weights[i][j] / rowSum;\n            }\n        }\n    }\n    return weights;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrZGlzdGFuY2Utd2VpZ2h0QDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi9kaXN0YW5jZS13ZWlnaHQvZGlzdC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFzQztBQUNLO0FBQ0Y7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCx3QkFBd0I7QUFDeEIsc0JBQXNCLHlEQUFRO0FBQzlCLHNCQUFzQix5REFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx3QkFBd0I7QUFDbkMsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLHNCQUFzQjtBQUNuQztBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksdURBQVc7QUFDZixzQkFBc0IsMERBQVE7QUFDOUIsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6Qyx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZnZhbHVlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0B0dXJmK2Rpc3RhbmNlLXdlaWdodEA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvZGlzdGFuY2Utd2VpZ2h0L2Rpc3QvZXMvaW5kZXguanM/MmZlZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY2VudHJvaWQgZnJvbSBcIkB0dXJmL2NlbnRyb2lkXCI7XG5pbXBvcnQgeyBnZXRDb29yZCB9IGZyb20gXCJAdHVyZi9pbnZhcmlhbnRcIjtcbmltcG9ydCB7IGZlYXR1cmVFYWNoIH0gZnJvbSBcIkB0dXJmL21ldGFcIjtcbi8qKlxuICogY2FsY3VhbHRlIHRoZSBNaW5rb3dza2kgcC1ub3JtIGRpc3RhbmNlIGJldHdlZW4gdHdvIGZlYXR1cmVzLlxuICogQHBhcmFtIGZlYXR1cmUxIHBvaW50IGZlYXR1cmVcbiAqIEBwYXJhbSBmZWF0dXJlMiBwb2ludCBmZWF0dXJlXG4gKiBAcGFyYW0gcCBwLW5vcm0gMT08cDw9aW5maW5pdHkgMTogTWFuaGF0dGFuIGRpc3RhbmNlIDI6IEV1Y2xpZGVhbiBkaXN0YW5jZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcE5vcm1EaXN0YW5jZShmZWF0dXJlMSwgZmVhdHVyZTIsIHApIHtcbiAgICBpZiAocCA9PT0gdm9pZCAwKSB7IHAgPSAyOyB9XG4gICAgdmFyIGNvb3JkaW5hdGUxID0gZ2V0Q29vcmQoZmVhdHVyZTEpO1xuICAgIHZhciBjb29yZGluYXRlMiA9IGdldENvb3JkKGZlYXR1cmUyKTtcbiAgICB2YXIgeERpZmYgPSBjb29yZGluYXRlMVswXSAtIGNvb3JkaW5hdGUyWzBdO1xuICAgIHZhciB5RGlmZiA9IGNvb3JkaW5hdGUxWzFdIC0gY29vcmRpbmF0ZTJbMV07XG4gICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHhEaWZmKSArIE1hdGguYWJzKHlEaWZmKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgucG93KE1hdGgucG93KHhEaWZmLCBwKSArIE1hdGgucG93KHlEaWZmLCBwKSwgMSAvIHApO1xufVxuLyoqXG4gKlxuICpcbiAqIEBuYW1lIGRpc3RhbmNlV2VpZ2h0XG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPGFueT59IGZjIEZlYXR1cmVDb2xsZWN0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBvcHRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDAwMF0gSWYgdGhlIGRpc3RhbmNlIGJldHdlZW4gbmVpZ2hib3IgYW5kXG4gKiB0YXJnZXQgZmVhdHVyZXMgaXMgZ3JlYXRlciB0aGFuIHRocmVzaG9sZCwgdGhlIHdlaWdodCBvZiB0aGF0IG5laWdoYm9yIGlzIDAuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucD0yXSBNaW5rb3dza2kgcC1ub3JtIGRpc3RhbmNlIHBhcmFtZXRlci5cbiAqIDE6IE1hbmhhdHRhbiBkaXN0YW5jZS4gMjogRXVjbGlkZWFuIGRpc3RhbmNlLiAxPTxwPD1pbmZpbml0eS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBJZiB0cnVlLCB3ZWlnaHQ9MSBpZiBkIDw9IHRocmVzaG9sZCBvdGhlcndpc2Ugd2VpZ2h0PTAuXG4gKiAgSWYgZmFsc2UsIHdlaWdodD1NYXRoLnBvdyhkLCBhbHBoYSkuXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuYWxwaGE9LTFdIGRpc3RhbmNlIGRlY2F5IHBhcmFtZXRlci5cbiAqIEEgYmlnIHZhbHVlIG1lYW5zIHRoZSB3ZWlnaHQgZGVjYXkgcXVpY2tseSBhcyBkaXN0YW5jZSBpbmNyZWFzZXMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnN0YW5kYXJkaXphdGlvbj1mYWxzZV0gcm93IHN0YW5kYXJkaXphdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gZGlzdGFuY2Ugd2VpZ2h0IG1hdHJpeC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIGJib3ggPSBbLTY1LCA0MCwgLTYzLCA0Ml07XG4gKiB2YXIgZGF0YXNldCA9IHR1cmYucmFuZG9tUG9pbnQoMTAwLCB7IGJib3g6IGJib3ggfSk7XG4gKiB2YXIgcmVzdWx0ID0gdHVyZi5kaXN0YW5jZVdlaWdodChkYXRhc2V0KTtcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGlzdGFuY2VXZWlnaHQoZmMsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgdGhyZXNob2xkID0gb3B0aW9ucy50aHJlc2hvbGQgfHwgMTAwMDA7XG4gICAgdmFyIHAgPSBvcHRpb25zLnAgfHwgMjtcbiAgICB2YXIgYmluYXJ5ID0gb3B0aW9ucy5iaW5hcnkgfHwgZmFsc2U7XG4gICAgdmFyIGFscGhhID0gb3B0aW9ucy5hbHBoYSB8fCAtMTtcbiAgICB2YXIgcm93VHJhbnNmb3JtID0gb3B0aW9ucy5zdGFuZGFyZGl6YXRpb24gfHwgZmFsc2U7XG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgZmVhdHVyZUVhY2goZmMsIGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goY2VudHJvaWQoZmVhdHVyZSkpO1xuICAgIH0pO1xuICAgIC8vIGNvbXB1dGluZyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgZmVhdHVyZXNcbiAgICB2YXIgd2VpZ2h0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgd2VpZ2h0c1tpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpOyBqIDwgZmVhdHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0c1tpXVtqXSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGlzID0gcE5vcm1EaXN0YW5jZShmZWF0dXJlc1tpXSwgZmVhdHVyZXNbal0sIHApO1xuICAgICAgICAgICAgd2VpZ2h0c1tpXVtqXSA9IGRpcztcbiAgICAgICAgICAgIHdlaWdodHNbal1baV0gPSBkaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYmluYXJ5IG9yIGRpc3RhbmNlIGRlY2F5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGZlYXR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZGlzID0gd2VpZ2h0c1tpXVtqXTtcbiAgICAgICAgICAgIGlmIChkaXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChiaW5hcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzW2ldW2pdID0gMS4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c1tpXVtqXSA9IDAuMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZGlzIDw9IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzW2ldW2pdID0gTWF0aC5wb3coZGlzLCBhbHBoYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3ZWlnaHRzW2ldW2pdID0gMC4wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocm93VHJhbnNmb3JtKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciByb3dTdW0gPSB3ZWlnaHRzW2ldLnJlZHVjZShmdW5jdGlvbiAoc3VtLCBjdXJyZW50VmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1bSArIGN1cnJlbnRWYWw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZmVhdHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHRzW2ldW2pdID0gd2VpZ2h0c1tpXVtqXSAvIHJvd1N1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+distance-weight@6.5.0/node_modules/@turf/distance-weight/dist/es/index.js\n");

/***/ })

};
;
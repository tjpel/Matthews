"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/turf-jsts@1.2.3";
exports.ids = ["vendor-chunks/turf-jsts@1.2.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/turf-jsts@1.2.3/node_modules/turf-jsts/jsts.js":
/*!***************************************************************************!*\
  !*** ./node_modules/.pnpm/turf-jsts@1.2.3/node_modules/turf-jsts/jsts.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n\n/* Polyfill service v3.13.0\n * For detailed credits and licence information see http://github.com/financial-times/polyfill-service\n *\n * - Array.prototype.fill, License: CC0 */\n\nif (!('fill' in Array.prototype)) {\n  Object.defineProperty(Array.prototype, 'fill', {\n    configurable: true,\n    value: function fill (value) {\n      if (this === undefined || this === null) {\n        throw new TypeError(this + ' is not an object')\n      }\n\n      var arrayLike = Object(this);\n\n      var length = Math.max(Math.min(arrayLike.length, 9007199254740991), 0) || 0;\n\n      var relativeStart = 1 in arguments ? parseInt(Number(arguments[1]), 10) || 0 : 0;\n\n      relativeStart = relativeStart < 0 ? Math.max(length + relativeStart, 0) : Math.min(relativeStart, length);\n\n      var relativeEnd = 2 in arguments && arguments[2] !== undefined ? parseInt(Number(arguments[2]), 10) || 0 : length;\n\n      relativeEnd = relativeEnd < 0 ? Math.max(length + arguments[2], 0) : Math.min(relativeEnd, length);\n\n      while (relativeStart < relativeEnd) {\n        arrayLike[relativeStart] = value;\n\n        ++relativeStart;\n      }\n\n      return arrayLike\n    },\n    writable: true\n  });\n}\n\n/**\n * Polyfill for IE support\n */\nNumber.isFinite = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value)\n};\n\nNumber.isInteger = Number.isInteger || function (val) {\n  return typeof val === 'number' &&\n  isFinite(val) &&\n  Math.floor(val) === val\n};\n\nNumber.parseFloat = Number.parseFloat || parseFloat;\n\nNumber.isNaN = Number.isNaN || function (value) {\n  return value !== value // eslint-disable-line\n};\n\n/**\n * Polyfill for IE support\n */\nMath.trunc = Math.trunc || function (x) {\n  return x < 0 ? Math.ceil(x) : Math.floor(x)\n};\n\nvar NumberUtil = function NumberUtil () {};\n\nNumberUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNumberUtil.prototype.getClass = function getClass () {\n  return NumberUtil\n};\nNumberUtil.prototype.equalsWithTolerance = function equalsWithTolerance (x1, x2, tolerance) {\n  return Math.abs(x1 - x2) <= tolerance\n};\n\nvar IllegalArgumentException = (function (Error) {\n\tfunction IllegalArgumentException (message) {\n\t\tError.call(this, message);\n\t\tthis.name = 'IllegalArgumentException';\n\t\tthis.message = message;\n\t\tthis.stack = (new Error()).stack;\n\t}\n\n\tif ( Error ) IllegalArgumentException.__proto__ = Error;\n\tIllegalArgumentException.prototype = Object.create( Error && Error.prototype );\n\tIllegalArgumentException.prototype.constructor = IllegalArgumentException;\n\n\treturn IllegalArgumentException;\n}(Error));\n\nvar Double = function Double () {};\n\nvar staticAccessors$1 = { MAX_VALUE: { configurable: true } };\n\nDouble.isNaN = function isNaN (n) { return Number.isNaN(n) };\nDouble.doubleToLongBits = function doubleToLongBits (n) { return n };\nDouble.longBitsToDouble = function longBitsToDouble (n) { return n };\nDouble.isInfinite = function isInfinite (n) { return !Number.isFinite(n) };\nstaticAccessors$1.MAX_VALUE.get = function () { return Number.MAX_VALUE };\n\nObject.defineProperties( Double, staticAccessors$1 );\n\nvar Comparable = function Comparable () {};\n\nvar Clonable = function Clonable () {};\n\nvar Comparator = function Comparator () {};\n\nfunction Serializable () {}\n\n// import Assert from '../util/Assert'\n\nvar Coordinate = function Coordinate () {\n  this.x = null;\n  this.y = null;\n  this.z = null;\n  if (arguments.length === 0) {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.z = Coordinate.NULL_ORDINATE;\n  } else if (arguments.length === 1) {\n    var c = arguments[0];\n    this.x = c.x;\n    this.y = c.y;\n    this.z = c.z;\n  } else if (arguments.length === 2) {\n    this.x = arguments[0];\n    this.y = arguments[1];\n    this.z = Coordinate.NULL_ORDINATE;\n  } else if (arguments.length === 3) {\n    this.x = arguments[0];\n    this.y = arguments[1];\n    this.z = arguments[2];\n  }\n};\n\nvar staticAccessors = { DimensionalComparator: { configurable: true },serialVersionUID: { configurable: true },NULL_ORDINATE: { configurable: true },X: { configurable: true },Y: { configurable: true },Z: { configurable: true } };\nCoordinate.prototype.setOrdinate = function setOrdinate (ordinateIndex, value) {\n  switch (ordinateIndex) {\n    case Coordinate.X:\n      this.x = value;\n      break\n    case Coordinate.Y:\n      this.y = value;\n      break\n    case Coordinate.Z:\n      this.z = value;\n      break\n    default:\n      throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n  }\n};\nCoordinate.prototype.equals2D = function equals2D () {\n  if (arguments.length === 1) {\n    var other = arguments[0];\n    if (this.x !== other.x) {\n      return false\n    }\n    if (this.y !== other.y) {\n      return false\n    }\n    return true\n  } else if (arguments.length === 2) {\n    var c = arguments[0];\n    var tolerance = arguments[1];\n    if (!NumberUtil.equalsWithTolerance(this.x, c.x, tolerance)) {\n      return false\n    }\n    if (!NumberUtil.equalsWithTolerance(this.y, c.y, tolerance)) {\n      return false\n    }\n    return true\n  }\n};\nCoordinate.prototype.getOrdinate = function getOrdinate (ordinateIndex) {\n  switch (ordinateIndex) {\n    case Coordinate.X:\n      return this.x\n    case Coordinate.Y:\n      return this.y\n    case Coordinate.Z:\n      return this.z\n    default:\n  }\n  throw new IllegalArgumentException('Invalid ordinate index: ' + ordinateIndex)\n};\nCoordinate.prototype.equals3D = function equals3D (other) {\n  return this.x === other.x &&\n         this.y === other.y &&\n         ((this.z === other.z || Double.isNaN(this.z)) &&\n         Double.isNaN(other.z))\n};\nCoordinate.prototype.equals = function equals (other) {\n  if (!(other instanceof Coordinate)) {\n    return false\n  }\n  return this.equals2D(other)\n};\nCoordinate.prototype.equalInZ = function equalInZ (c, tolerance) {\n  return NumberUtil.equalsWithTolerance(this.z, c.z, tolerance)\n};\nCoordinate.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  if (this.x < other.x) { return -1 }\n  if (this.x > other.x) { return 1 }\n  if (this.y < other.y) { return -1 }\n  if (this.y > other.y) { return 1 }\n  return 0\n};\nCoordinate.prototype.clone = function clone () {\n  // try {\n  // var coord = null\n  // return coord\n  // } catch (e) {\n  // if (e instanceof CloneNotSupportedException) {\n  //   Assert.shouldNeverReachHere(\"this shouldn't happen because this class is Cloneable\")\n  //   return null\n  // } else throw e\n  // } finally {}\n};\nCoordinate.prototype.copy = function copy () {\n  return new Coordinate(this)\n};\nCoordinate.prototype.toString = function toString () {\n  return '(' + this.x + ', ' + this.y + ', ' + this.z + ')'\n};\nCoordinate.prototype.distance3D = function distance3D (c) {\n  var dx = this.x - c.x;\n  var dy = this.y - c.y;\n  var dz = this.z - c.z;\n  return Math.sqrt(dx * dx + dy * dy + dz * dz)\n};\nCoordinate.prototype.distance = function distance (c) {\n  var dx = this.x - c.x;\n  var dy = this.y - c.y;\n  return Math.sqrt(dx * dx + dy * dy)\n};\nCoordinate.prototype.hashCode = function hashCode () {\n  var result = 17;\n  result = 37 * result + Coordinate.hashCode(this.x);\n  result = 37 * result + Coordinate.hashCode(this.y);\n  return result\n};\nCoordinate.prototype.setCoordinate = function setCoordinate (other) {\n  this.x = other.x;\n  this.y = other.y;\n  this.z = other.z;\n};\nCoordinate.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Clonable, Serializable]\n};\nCoordinate.prototype.getClass = function getClass () {\n  return Coordinate\n};\nCoordinate.hashCode = function hashCode () {\n  if (arguments.length === 1) {\n    var x = arguments[0];\n    var f = Double.doubleToLongBits(x);\n    return Math.trunc((f ^ f) >>> 32)\n  }\n};\nstaticAccessors.DimensionalComparator.get = function () { return DimensionalComparator };\nstaticAccessors.serialVersionUID.get = function () { return 6683108902428366910 };\nstaticAccessors.NULL_ORDINATE.get = function () { return Double.NaN };\nstaticAccessors.X.get = function () { return 0 };\nstaticAccessors.Y.get = function () { return 1 };\nstaticAccessors.Z.get = function () { return 2 };\n\nObject.defineProperties( Coordinate, staticAccessors );\n\nvar DimensionalComparator = function DimensionalComparator (dimensionsToTest) {\n  this._dimensionsToTest = 2;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var dimensionsToTest$1 = arguments[0];\n    if (dimensionsToTest$1 !== 2 && dimensionsToTest$1 !== 3) { throw new IllegalArgumentException('only 2 or 3 dimensions may be specified') }\n    this._dimensionsToTest = dimensionsToTest$1;\n  }\n};\nDimensionalComparator.prototype.compare = function compare (o1, o2) {\n  var c1 = o1;\n  var c2 = o2;\n  var compX = DimensionalComparator.compare(c1.x, c2.x);\n  if (compX !== 0) { return compX }\n  var compY = DimensionalComparator.compare(c1.y, c2.y);\n  if (compY !== 0) { return compY }\n  if (this._dimensionsToTest <= 2) { return 0 }\n  var compZ = DimensionalComparator.compare(c1.z, c2.z);\n  return compZ\n};\nDimensionalComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nDimensionalComparator.prototype.getClass = function getClass () {\n  return DimensionalComparator\n};\nDimensionalComparator.compare = function compare (a, b) {\n  if (a < b) { return -1 }\n  if (a > b) { return 1 }\n  if (Double.isNaN(a)) {\n    if (Double.isNaN(b)) { return 0 }\n    return -1\n  }\n  if (Double.isNaN(b)) { return 1 }\n  return 0\n};\n\n// import hasInterface from '../../../../hasInterface'\n// import CoordinateSequence from './CoordinateSequence'\n\nvar CoordinateSequenceFactory = function CoordinateSequenceFactory () {};\n\nCoordinateSequenceFactory.prototype.create = function create () {\n  // if (arguments.length === 1) {\n  // if (arguments[0] instanceof Array) {\n  //   let coordinates = arguments[0]\n  // } else if (hasInterface(arguments[0], CoordinateSequence)) {\n  //   let coordSeq = arguments[0]\n  // }\n  // } else if (arguments.length === 2) {\n  // let size = arguments[0]\n  // let dimension = arguments[1]\n  // }\n};\nCoordinateSequenceFactory.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequenceFactory.prototype.getClass = function getClass () {\n  return CoordinateSequenceFactory\n};\n\nvar Location = function Location () {};\n\nvar staticAccessors$4 = { INTERIOR: { configurable: true },BOUNDARY: { configurable: true },EXTERIOR: { configurable: true },NONE: { configurable: true } };\n\nLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLocation.prototype.getClass = function getClass () {\n  return Location\n};\nLocation.toLocationSymbol = function toLocationSymbol (locationValue) {\n  switch (locationValue) {\n    case Location.EXTERIOR:\n      return 'e'\n    case Location.BOUNDARY:\n      return 'b'\n    case Location.INTERIOR:\n      return 'i'\n    case Location.NONE:\n      return '-'\n    default:\n  }\n  throw new IllegalArgumentException('Unknown location value: ' + locationValue)\n};\nstaticAccessors$4.INTERIOR.get = function () { return 0 };\nstaticAccessors$4.BOUNDARY.get = function () { return 1 };\nstaticAccessors$4.EXTERIOR.get = function () { return 2 };\nstaticAccessors$4.NONE.get = function () { return -1 };\n\nObject.defineProperties( Location, staticAccessors$4 );\n\nvar hasInterface = function (o, i) {\n  return o.interfaces_ && o.interfaces_().indexOf(i) > -1\n};\n\nvar MathUtil = function MathUtil () {};\n\nvar staticAccessors$5 = { LOG_10: { configurable: true } };\n\nMathUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMathUtil.prototype.getClass = function getClass () {\n  return MathUtil\n};\nMathUtil.log10 = function log10 (x) {\n  var ln = Math.log(x);\n  if (Double.isInfinite(ln)) { return ln }\n  if (Double.isNaN(ln)) { return ln }\n  return ln / MathUtil.LOG_10\n};\nMathUtil.min = function min (v1, v2, v3, v4) {\n  var min = v1;\n  if (v2 < min) { min = v2; }\n  if (v3 < min) { min = v3; }\n  if (v4 < min) { min = v4; }\n  return min\n};\nMathUtil.clamp = function clamp () {\n  if (typeof arguments[2] === 'number' && (typeof arguments[0] === 'number' && typeof arguments[1] === 'number')) {\n    var x = arguments[0];\n    var min = arguments[1];\n    var max = arguments[2];\n    if (x < min) { return min }\n    if (x > max) { return max }\n    return x\n  } else if (Number.isInteger(arguments[2]) && (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1]))) {\n    var x$1 = arguments[0];\n    var min$1 = arguments[1];\n    var max$1 = arguments[2];\n    if (x$1 < min$1) { return min$1 }\n    if (x$1 > max$1) { return max$1 }\n    return x$1\n  }\n};\nMathUtil.wrap = function wrap (index, max) {\n  if (index < 0) {\n    return max - -index % max\n  }\n  return index % max\n};\nMathUtil.max = function max () {\n  if (arguments.length === 3) {\n    var v1 = arguments[0];\n    var v2 = arguments[1];\n    var v3 = arguments[2];\n    var max = v1;\n    if (v2 > max) { max = v2; }\n    if (v3 > max) { max = v3; }\n    return max\n  } else if (arguments.length === 4) {\n    var v1$1 = arguments[0];\n    var v2$1 = arguments[1];\n    var v3$1 = arguments[2];\n    var v4 = arguments[3];\n    var max$1 = v1$1;\n    if (v2$1 > max$1) { max$1 = v2$1; }\n    if (v3$1 > max$1) { max$1 = v3$1; }\n    if (v4 > max$1) { max$1 = v4; }\n    return max$1\n  }\n};\nMathUtil.average = function average (x1, x2) {\n  return (x1 + x2) / 2.0\n};\nstaticAccessors$5.LOG_10.get = function () { return Math.log(10) };\n\nObject.defineProperties( MathUtil, staticAccessors$5 );\n\nvar StringBuffer = function StringBuffer (str) {\n  this.str = str;\n};\nStringBuffer.prototype.append = function append (e) {\n  this.str += e;\n};\n\nStringBuffer.prototype.setCharAt = function setCharAt (i, c) {\n  this.str = this.str.substr(0, i) + c + this.str.substr(i + 1);\n};\n\nStringBuffer.prototype.toString = function toString (e) {\n  return this.str\n};\n\nvar Integer = function Integer (value) {\n  this.value = value;\n};\nInteger.prototype.intValue = function intValue () {\n  return this.value\n};\nInteger.prototype.compareTo = function compareTo (o) {\n  if (this.value < o) { return -1 }\n  if (this.value > o) { return 1 }\n  return 0\n};\nInteger.isNaN = function isNaN (n) { return Number.isNaN(n) };\n\nvar Character = function Character () {};\n\nCharacter.isWhitespace = function isWhitespace (c) { return ((c <= 32 && c >= 0) || c === 127) };\nCharacter.toUpperCase = function toUpperCase (c) { return c.toUpperCase() };\n\nvar DD = function DD () {\n  this._hi = 0.0;\n  this._lo = 0.0;\n  if (arguments.length === 0) {\n    this.init(0.0);\n  } else if (arguments.length === 1) {\n    if (typeof arguments[0] === 'number') {\n      var x = arguments[0];\n      this.init(x);\n    } else if (arguments[0] instanceof DD) {\n      var dd = arguments[0];\n      this.init(dd);\n    } else if (typeof arguments[0] === 'string') {\n      var str = arguments[0];\n      DD.call(this, DD.parse(str));\n    }\n  } else if (arguments.length === 2) {\n    var hi = arguments[0];\n    var lo = arguments[1];\n    this.init(hi, lo);\n  }\n};\n\nvar staticAccessors$7 = { PI: { configurable: true },TWO_PI: { configurable: true },PI_2: { configurable: true },E: { configurable: true },NaN: { configurable: true },EPS: { configurable: true },SPLIT: { configurable: true },MAX_PRINT_DIGITS: { configurable: true },TEN: { configurable: true },ONE: { configurable: true },SCI_NOT_EXPONENT_CHAR: { configurable: true },SCI_NOT_ZERO: { configurable: true } };\nDD.prototype.le = function le (y) {\n  return (this._hi < y._hi || this._hi === y._hi) && this._lo <= y._lo\n};\nDD.prototype.extractSignificantDigits = function extractSignificantDigits (insertDecimalPoint, magnitude) {\n  var y = this.abs();\n  var mag = DD.magnitude(y._hi);\n  var scale = DD.TEN.pow(mag);\n  y = y.divide(scale);\n  if (y.gt(DD.TEN)) {\n    y = y.divide(DD.TEN);\n    mag += 1;\n  } else if (y.lt(DD.ONE)) {\n    y = y.multiply(DD.TEN);\n    mag -= 1;\n  }\n  var decimalPointPos = mag + 1;\n  var buf = new StringBuffer();\n  var numDigits = DD.MAX_PRINT_DIGITS - 1;\n  for (var i = 0; i <= numDigits; i++) {\n    if (insertDecimalPoint && i === decimalPointPos) {\n      buf.append('.');\n    }\n    var digit = Math.trunc(y._hi);\n    if (digit < 0) {\n      break\n    }\n    var rebiasBy10 = false;\n    var digitChar = 0;\n    if (digit > 9) {\n      rebiasBy10 = true;\n      digitChar = '9';\n    } else {\n      digitChar = '0' + digit;\n    }\n    buf.append(digitChar);\n    y = y.subtract(DD.valueOf(digit)).multiply(DD.TEN);\n    if (rebiasBy10) { y.selfAdd(DD.TEN); }\n    var continueExtractingDigits = true;\n    var remMag = DD.magnitude(y._hi);\n    if (remMag < 0 && Math.abs(remMag) >= numDigits - i) { continueExtractingDigits = false; }\n    if (!continueExtractingDigits) { break }\n  }\n  magnitude[0] = mag;\n  return buf.toString()\n};\nDD.prototype.sqr = function sqr () {\n  return this.multiply(this)\n};\nDD.prototype.doubleValue = function doubleValue () {\n  return this._hi + this._lo\n};\nDD.prototype.subtract = function subtract () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    return this.add(y.negate())\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    return this.add(-y$1)\n  }\n};\nDD.prototype.equals = function equals () {\n  if (arguments.length === 1) {\n    var y = arguments[0];\n    return this._hi === y._hi && this._lo === y._lo\n  }\n};\nDD.prototype.isZero = function isZero () {\n  return this._hi === 0.0 && this._lo === 0.0\n};\nDD.prototype.selfSubtract = function selfSubtract () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    if (this.isNaN()) { return this }\n    return this.selfAdd(-y._hi, -y._lo)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (this.isNaN()) { return this }\n    return this.selfAdd(-y$1, 0.0)\n  }\n};\nDD.prototype.getSpecialNumberString = function getSpecialNumberString () {\n  if (this.isZero()) { return '0.0' }\n  if (this.isNaN()) { return 'NaN ' }\n  return null\n};\nDD.prototype.min = function min (x) {\n  if (this.le(x)) {\n    return this\n  } else {\n    return x\n  }\n};\nDD.prototype.selfDivide = function selfDivide () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfDivide(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      return this.selfDivide(y$1, 0.0)\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var hc = null;\n    var tc = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    var U = null;\n    var u = null;\n    C = this._hi / yhi;\n    c = DD.SPLIT * C;\n    hc = c - C;\n    u = DD.SPLIT * yhi;\n    hc = c - hc;\n    tc = C - hc;\n    hy = u - yhi;\n    U = C * yhi;\n    hy = u - hy;\n    ty = yhi - hy;\n    u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n    c = (this._hi - U - u + this._lo - C * ylo) / yhi;\n    u = C + c;\n    this._hi = u;\n    this._lo = C - u + c;\n    return this\n  }\n};\nDD.prototype.dump = function dump () {\n  return 'DD<' + this._hi + ', ' + this._lo + '>'\n};\nDD.prototype.divide = function divide () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    var hc = null;\n    var tc = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    var U = null;\n    var u = null;\n    C = this._hi / y._hi;\n    c = DD.SPLIT * C;\n    hc = c - C;\n    u = DD.SPLIT * y._hi;\n    hc = c - hc;\n    tc = C - hc;\n    hy = u - y._hi;\n    U = C * y._hi;\n    hy = u - hy;\n    ty = y._hi - hy;\n    u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n    c = (this._hi - U - u + this._lo - C * y._lo) / y._hi;\n    u = C + c;\n    var zhi = u;\n    var zlo = C - u + c;\n    return new DD(zhi, zlo)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (Double.isNaN(y$1)) { return DD.createNaN() }\n    return DD.copy(this).selfDivide(y$1, 0.0)\n  }\n};\nDD.prototype.ge = function ge (y) {\n  return (this._hi > y._hi || this._hi === y._hi) && this._lo >= y._lo\n};\nDD.prototype.pow = function pow (exp) {\n  if (exp === 0.0) { return DD.valueOf(1.0) }\n  var r = new DD(this);\n  var s = DD.valueOf(1.0);\n  var n = Math.abs(exp);\n  if (n > 1) {\n    while (n > 0) {\n      if (n % 2 === 1) {\n        s.selfMultiply(r);\n      }\n      n /= 2;\n      if (n > 0) { r = r.sqr(); }\n    }\n  } else {\n    s = r;\n  }\n  if (exp < 0) { return s.reciprocal() }\n  return s\n};\nDD.prototype.ceil = function ceil () {\n  if (this.isNaN()) { return DD.NaN }\n  var fhi = Math.ceil(this._hi);\n  var flo = 0.0;\n  if (fhi === this._hi) {\n    flo = Math.ceil(this._lo);\n  }\n  return new DD(fhi, flo)\n};\nDD.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  if (this._hi < other._hi) { return -1 }\n  if (this._hi > other._hi) { return 1 }\n  if (this._lo < other._lo) { return -1 }\n  if (this._lo > other._lo) { return 1 }\n  return 0\n};\nDD.prototype.rint = function rint () {\n  if (this.isNaN()) { return this }\n  var plus5 = this.add(0.5);\n  return plus5.floor()\n};\nDD.prototype.setValue = function setValue () {\n  if (arguments[0] instanceof DD) {\n    var value = arguments[0];\n    this.init(value);\n    return this\n  } else if (typeof arguments[0] === 'number') {\n    var value$1 = arguments[0];\n    this.init(value$1);\n    return this\n  }\n};\nDD.prototype.max = function max (x) {\n  if (this.ge(x)) {\n    return this\n  } else {\n    return x\n  }\n};\nDD.prototype.sqrt = function sqrt () {\n  if (this.isZero()) { return DD.valueOf(0.0) }\n  if (this.isNegative()) {\n    return DD.NaN\n  }\n  var x = 1.0 / Math.sqrt(this._hi);\n  var ax = this._hi * x;\n  var axdd = DD.valueOf(ax);\n  var diffSq = this.subtract(axdd.sqr());\n  var d2 = diffSq._hi * (x * 0.5);\n  return axdd.add(d2)\n};\nDD.prototype.selfAdd = function selfAdd () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfAdd(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      var H = null;\n      var h = null;\n      var S = null;\n      var s = null;\n      var e = null;\n      var f = null;\n      S = this._hi + y$1;\n      e = S - this._hi;\n      s = S - e;\n      s = y$1 - e + (this._hi - s);\n      f = s + this._lo;\n      H = S + f;\n      h = f + (S - H);\n      this._hi = H + h;\n      this._lo = h + (H - this._hi);\n      return this\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var H$1 = null;\n    var h$1 = null;\n    var T = null;\n    var t = null;\n    var S$1 = null;\n    var s$1 = null;\n    var e$1 = null;\n    var f$1 = null;\n    S$1 = this._hi + yhi;\n    T = this._lo + ylo;\n    e$1 = S$1 - this._hi;\n    f$1 = T - this._lo;\n    s$1 = S$1 - e$1;\n    t = T - f$1;\n    s$1 = yhi - e$1 + (this._hi - s$1);\n    t = ylo - f$1 + (this._lo - t);\n    e$1 = s$1 + T;\n    H$1 = S$1 + e$1;\n    h$1 = e$1 + (S$1 - H$1);\n    e$1 = t + h$1;\n    var zhi = H$1 + e$1;\n    var zlo = e$1 + (H$1 - zhi);\n    this._hi = zhi;\n    this._lo = zlo;\n    return this\n  }\n};\nDD.prototype.selfMultiply = function selfMultiply () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof DD) {\n      var y = arguments[0];\n      return this.selfMultiply(y._hi, y._lo)\n    } else if (typeof arguments[0] === 'number') {\n      var y$1 = arguments[0];\n      return this.selfMultiply(y$1, 0.0)\n    }\n  } else if (arguments.length === 2) {\n    var yhi = arguments[0];\n    var ylo = arguments[1];\n    var hx = null;\n    var tx = null;\n    var hy = null;\n    var ty = null;\n    var C = null;\n    var c = null;\n    C = DD.SPLIT * this._hi;\n    hx = C - this._hi;\n    c = DD.SPLIT * yhi;\n    hx = C - hx;\n    tx = this._hi - hx;\n    hy = c - yhi;\n    C = this._hi * yhi;\n    hy = c - hy;\n    ty = yhi - hy;\n    c = hx * hy - C + hx * ty + tx * hy + tx * ty + (this._hi * ylo + this._lo * yhi);\n    var zhi = C + c;\n    hx = C - zhi;\n    var zlo = c + hx;\n    this._hi = zhi;\n    this._lo = zlo;\n    return this\n  }\n};\nDD.prototype.selfSqr = function selfSqr () {\n  return this.selfMultiply(this)\n};\nDD.prototype.floor = function floor () {\n  if (this.isNaN()) { return DD.NaN }\n  var fhi = Math.floor(this._hi);\n  var flo = 0.0;\n  if (fhi === this._hi) {\n    flo = Math.floor(this._lo);\n  }\n  return new DD(fhi, flo)\n};\nDD.prototype.negate = function negate () {\n  if (this.isNaN()) { return this }\n  return new DD(-this._hi, -this._lo)\n};\nDD.prototype.clone = function clone () {\n  // try {\n  // return null\n  // } catch (ex) {\n  // if (ex instanceof CloneNotSupportedException) {\n  //   return null\n  // } else throw ex\n  // } finally {}\n};\nDD.prototype.multiply = function multiply () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    if (y.isNaN()) { return DD.createNaN() }\n    return DD.copy(this).selfMultiply(y)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    if (Double.isNaN(y$1)) { return DD.createNaN() }\n    return DD.copy(this).selfMultiply(y$1, 0.0)\n  }\n};\nDD.prototype.isNaN = function isNaN () {\n  return Double.isNaN(this._hi)\n};\nDD.prototype.intValue = function intValue () {\n  return Math.trunc(this._hi)\n};\nDD.prototype.toString = function toString () {\n  var mag = DD.magnitude(this._hi);\n  if (mag >= -3 && mag <= 20) { return this.toStandardNotation() }\n  return this.toSciNotation()\n};\nDD.prototype.toStandardNotation = function toStandardNotation () {\n  var specialStr = this.getSpecialNumberString();\n  if (specialStr !== null) { return specialStr }\n  var magnitude = new Array(1).fill(null);\n  var sigDigits = this.extractSignificantDigits(true, magnitude);\n  var decimalPointPos = magnitude[0] + 1;\n  var num = sigDigits;\n  if (sigDigits.charAt(0) === '.') {\n    num = '0' + sigDigits;\n  } else if (decimalPointPos < 0) {\n    num = '0.' + DD.stringOfChar('0', -decimalPointPos) + sigDigits;\n  } else if (sigDigits.indexOf('.') === -1) {\n    var numZeroes = decimalPointPos - sigDigits.length;\n    var zeroes = DD.stringOfChar('0', numZeroes);\n    num = sigDigits + zeroes + '.0';\n  }\n  if (this.isNegative()) { return '-' + num }\n  return num\n};\nDD.prototype.reciprocal = function reciprocal () {\n  var hc = null;\n  var tc = null;\n  var hy = null;\n  var ty = null;\n  var C = null;\n  var c = null;\n  var U = null;\n  var u = null;\n  C = 1.0 / this._hi;\n  c = DD.SPLIT * C;\n  hc = c - C;\n  u = DD.SPLIT * this._hi;\n  hc = c - hc;\n  tc = C - hc;\n  hy = u - this._hi;\n  U = C * this._hi;\n  hy = u - hy;\n  ty = this._hi - hy;\n  u = hc * hy - U + hc * ty + tc * hy + tc * ty;\n  c = (1.0 - U - u - C * this._lo) / this._hi;\n  var zhi = C + c;\n  var zlo = C - zhi + c;\n  return new DD(zhi, zlo)\n};\nDD.prototype.toSciNotation = function toSciNotation () {\n  if (this.isZero()) { return DD.SCI_NOT_ZERO }\n  var specialStr = this.getSpecialNumberString();\n  if (specialStr !== null) { return specialStr }\n  var magnitude = new Array(1).fill(null);\n  var digits = this.extractSignificantDigits(false, magnitude);\n  var expStr = DD.SCI_NOT_EXPONENT_CHAR + magnitude[0];\n  if (digits.charAt(0) === '0') {\n    throw new Error('Found leading zero: ' + digits)\n  }\n  var trailingDigits = '';\n  if (digits.length > 1) { trailingDigits = digits.substring(1); }\n  var digitsWithDecimal = digits.charAt(0) + '.' + trailingDigits;\n  if (this.isNegative()) { return '-' + digitsWithDecimal + expStr }\n  return digitsWithDecimal + expStr\n};\nDD.prototype.abs = function abs () {\n  if (this.isNaN()) { return DD.NaN }\n  if (this.isNegative()) { return this.negate() }\n  return new DD(this)\n};\nDD.prototype.isPositive = function isPositive () {\n  return (this._hi > 0.0 || this._hi === 0.0) && this._lo > 0.0\n};\nDD.prototype.lt = function lt (y) {\n  return (this._hi < y._hi || this._hi === y._hi) && this._lo < y._lo\n};\nDD.prototype.add = function add () {\n  if (arguments[0] instanceof DD) {\n    var y = arguments[0];\n    return DD.copy(this).selfAdd(y)\n  } else if (typeof arguments[0] === 'number') {\n    var y$1 = arguments[0];\n    return DD.copy(this).selfAdd(y$1)\n  }\n};\nDD.prototype.init = function init () {\n  if (arguments.length === 1) {\n    if (typeof arguments[0] === 'number') {\n      var x = arguments[0];\n      this._hi = x;\n      this._lo = 0.0;\n    } else if (arguments[0] instanceof DD) {\n      var dd = arguments[0];\n      this._hi = dd._hi;\n      this._lo = dd._lo;\n    }\n  } else if (arguments.length === 2) {\n    var hi = arguments[0];\n    var lo = arguments[1];\n    this._hi = hi;\n    this._lo = lo;\n  }\n};\nDD.prototype.gt = function gt (y) {\n  return (this._hi > y._hi || this._hi === y._hi) && this._lo > y._lo\n};\nDD.prototype.isNegative = function isNegative () {\n  return (this._hi < 0.0 || this._hi === 0.0) && this._lo < 0.0\n};\nDD.prototype.trunc = function trunc () {\n  if (this.isNaN()) { return DD.NaN }\n  if (this.isPositive()) { return this.floor(); } else { return this.ceil() }\n};\nDD.prototype.signum = function signum () {\n  if (this._hi > 0) { return 1 }\n  if (this._hi < 0) { return -1 }\n  if (this._lo > 0) { return 1 }\n  if (this._lo < 0) { return -1 }\n  return 0\n};\nDD.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable, Comparable, Clonable]\n};\nDD.prototype.getClass = function getClass () {\n  return DD\n};\nDD.sqr = function sqr (x) {\n  return DD.valueOf(x).selfMultiply(x)\n};\nDD.valueOf = function valueOf () {\n  if (typeof arguments[0] === 'string') {\n    var str = arguments[0];\n    return DD.parse(str)\n  } else if (typeof arguments[0] === 'number') {\n    var x = arguments[0];\n    return new DD(x)\n  }\n};\nDD.sqrt = function sqrt (x) {\n  return DD.valueOf(x).sqrt()\n};\nDD.parse = function parse (str) {\n  var i = 0;\n  var strlen = str.length;\n  while (Character.isWhitespace(str.charAt(i))) { i++; }\n  var isNegative = false;\n  if (i < strlen) {\n    var signCh = str.charAt(i);\n    if (signCh === '-' || signCh === '+') {\n      i++;\n      if (signCh === '-') { isNegative = true; }\n    }\n  }\n  var val = new DD();\n  var numDigits = 0;\n  var numBeforeDec = 0;\n  var exp = 0;\n  while (true) {\n    if (i >= strlen) { break }\n    var ch = str.charAt(i);\n    i++;\n    if (Character.isDigit(ch)) {\n      var d = ch - '0';\n      val.selfMultiply(DD.TEN);\n      val.selfAdd(d);\n      numDigits++;\n      continue\n    }\n    if (ch === '.') {\n      numBeforeDec = numDigits;\n      continue\n    }\n    if (ch === 'e' || ch === 'E') {\n      var expStr = str.substring(i);\n      try {\n        exp = Integer.parseInt(expStr);\n      } catch (ex) {\n        if (ex instanceof Error) {\n          throw new Error('Invalid exponent ' + expStr + ' in string ' + str)\n        } else { throw ex }\n      } finally {}\n      break\n    }\n    throw new Error(\"Unexpected character '\" + ch + \"' at position \" + i + ' in string ' + str)\n  }\n  var val2 = val;\n  var numDecPlaces = numDigits - numBeforeDec - exp;\n  if (numDecPlaces === 0) {\n    val2 = val;\n  } else if (numDecPlaces > 0) {\n    var scale = DD.TEN.pow(numDecPlaces);\n    val2 = val.divide(scale);\n  } else if (numDecPlaces < 0) {\n    var scale$1 = DD.TEN.pow(-numDecPlaces);\n    val2 = val.multiply(scale$1);\n  }\n  if (isNegative) {\n    return val2.negate()\n  }\n  return val2\n};\nDD.createNaN = function createNaN () {\n  return new DD(Double.NaN, Double.NaN)\n};\nDD.copy = function copy (dd) {\n  return new DD(dd)\n};\nDD.magnitude = function magnitude (x) {\n  var xAbs = Math.abs(x);\n  var xLog10 = Math.log(xAbs) / Math.log(10);\n  var xMag = Math.trunc(Math.floor(xLog10));\n  var xApprox = Math.pow(10, xMag);\n  if (xApprox * 10 <= xAbs) { xMag += 1; }\n  return xMag\n};\nDD.stringOfChar = function stringOfChar (ch, len) {\n  var buf = new StringBuffer();\n  for (var i = 0; i < len; i++) {\n    buf.append(ch);\n  }\n  return buf.toString()\n};\nstaticAccessors$7.PI.get = function () { return new DD(3.141592653589793116e+00, 1.224646799147353207e-16) };\nstaticAccessors$7.TWO_PI.get = function () { return new DD(6.283185307179586232e+00, 2.449293598294706414e-16) };\nstaticAccessors$7.PI_2.get = function () { return new DD(1.570796326794896558e+00, 6.123233995736766036e-17) };\nstaticAccessors$7.E.get = function () { return new DD(2.718281828459045091e+00, 1.445646891729250158e-16) };\nstaticAccessors$7.NaN.get = function () { return new DD(Double.NaN, Double.NaN) };\nstaticAccessors$7.EPS.get = function () { return 1.23259516440783e-32 };\nstaticAccessors$7.SPLIT.get = function () { return 134217729.0 };\nstaticAccessors$7.MAX_PRINT_DIGITS.get = function () { return 32 };\nstaticAccessors$7.TEN.get = function () { return DD.valueOf(10.0) };\nstaticAccessors$7.ONE.get = function () { return DD.valueOf(1.0) };\nstaticAccessors$7.SCI_NOT_EXPONENT_CHAR.get = function () { return 'E' };\nstaticAccessors$7.SCI_NOT_ZERO.get = function () { return '0.0E0' };\n\nObject.defineProperties( DD, staticAccessors$7 );\n\nvar CGAlgorithmsDD = function CGAlgorithmsDD () {};\n\nvar staticAccessors$6 = { DP_SAFE_EPSILON: { configurable: true } };\n\nCGAlgorithmsDD.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCGAlgorithmsDD.prototype.getClass = function getClass () {\n  return CGAlgorithmsDD\n};\nCGAlgorithmsDD.orientationIndex = function orientationIndex (p1, p2, q) {\n  var index = CGAlgorithmsDD.orientationIndexFilter(p1, p2, q);\n  if (index <= 1) { return index }\n  var dx1 = DD.valueOf(p2.x).selfAdd(-p1.x);\n  var dy1 = DD.valueOf(p2.y).selfAdd(-p1.y);\n  var dx2 = DD.valueOf(q.x).selfAdd(-p2.x);\n  var dy2 = DD.valueOf(q.y).selfAdd(-p2.y);\n  return dx1.selfMultiply(dy2).selfSubtract(dy1.selfMultiply(dx2)).signum()\n};\nCGAlgorithmsDD.signOfDet2x2 = function signOfDet2x2 (x1, y1, x2, y2) {\n  var det = x1.multiply(y2).selfSubtract(y1.multiply(x2));\n  return det.signum()\n};\nCGAlgorithmsDD.intersection = function intersection (p1, p2, q1, q2) {\n  var denom1 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p2.x).selfSubtract(p1.x));\n  var denom2 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p2.y).selfSubtract(p1.y));\n  var denom = denom1.subtract(denom2);\n  var numx1 = DD.valueOf(q2.x).selfSubtract(q1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  var numx2 = DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  var numx = numx1.subtract(numx2);\n  var fracP = numx.selfDivide(denom).doubleValue();\n  var x = DD.valueOf(p1.x).selfAdd(DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(fracP)).doubleValue();\n  var numy1 = DD.valueOf(p2.x).selfSubtract(p1.x).selfMultiply(DD.valueOf(p1.y).selfSubtract(q1.y));\n  var numy2 = DD.valueOf(p2.y).selfSubtract(p1.y).selfMultiply(DD.valueOf(p1.x).selfSubtract(q1.x));\n  var numy = numy1.subtract(numy2);\n  var fracQ = numy.selfDivide(denom).doubleValue();\n  var y = DD.valueOf(q1.y).selfAdd(DD.valueOf(q2.y).selfSubtract(q1.y).selfMultiply(fracQ)).doubleValue();\n  return new Coordinate(x, y)\n};\nCGAlgorithmsDD.orientationIndexFilter = function orientationIndexFilter (pa, pb, pc) {\n  var detsum = null;\n  var detleft = (pa.x - pc.x) * (pb.y - pc.y);\n  var detright = (pa.y - pc.y) * (pb.x - pc.x);\n  var det = detleft - detright;\n  if (detleft > 0.0) {\n    if (detright <= 0.0) {\n      return CGAlgorithmsDD.signum(det)\n    } else {\n      detsum = detleft + detright;\n    }\n  } else if (detleft < 0.0) {\n    if (detright >= 0.0) {\n      return CGAlgorithmsDD.signum(det)\n    } else {\n      detsum = -detleft - detright;\n    }\n  } else {\n    return CGAlgorithmsDD.signum(det)\n  }\n  var errbound = CGAlgorithmsDD.DP_SAFE_EPSILON * detsum;\n  if (det >= errbound || -det >= errbound) {\n    return CGAlgorithmsDD.signum(det)\n  }\n  return 2\n};\nCGAlgorithmsDD.signum = function signum (x) {\n  if (x > 0) { return 1 }\n  if (x < 0) { return -1 }\n  return 0\n};\nstaticAccessors$6.DP_SAFE_EPSILON.get = function () { return 1e-15 };\n\nObject.defineProperties( CGAlgorithmsDD, staticAccessors$6 );\n\nvar CoordinateSequence = function CoordinateSequence () {};\n\nvar staticAccessors$8 = { X: { configurable: true },Y: { configurable: true },Z: { configurable: true },M: { configurable: true } };\n\nstaticAccessors$8.X.get = function () { return 0 };\nstaticAccessors$8.Y.get = function () { return 1 };\nstaticAccessors$8.Z.get = function () { return 2 };\nstaticAccessors$8.M.get = function () { return 3 };\nCoordinateSequence.prototype.setOrdinate = function setOrdinate (index, ordinateIndex, value) {};\nCoordinateSequence.prototype.size = function size () {};\nCoordinateSequence.prototype.getOrdinate = function getOrdinate (index, ordinateIndex) {};\nCoordinateSequence.prototype.getCoordinate = function getCoordinate () {};\nCoordinateSequence.prototype.getCoordinateCopy = function getCoordinateCopy (i) {};\nCoordinateSequence.prototype.getDimension = function getDimension () {};\nCoordinateSequence.prototype.getX = function getX (index) {};\nCoordinateSequence.prototype.clone = function clone () {};\nCoordinateSequence.prototype.expandEnvelope = function expandEnvelope (env) {};\nCoordinateSequence.prototype.copy = function copy () {};\nCoordinateSequence.prototype.getY = function getY (index) {};\nCoordinateSequence.prototype.toCoordinateArray = function toCoordinateArray () {};\nCoordinateSequence.prototype.interfaces_ = function interfaces_ () {\n  return [Clonable]\n};\nCoordinateSequence.prototype.getClass = function getClass () {\n  return CoordinateSequence\n};\n\nObject.defineProperties( CoordinateSequence, staticAccessors$8 );\n\nvar Exception = function Exception () {};\n\nvar NotRepresentableException = (function (Exception$$1) {\n  function NotRepresentableException () {\n    Exception$$1.call(this, 'Projective point not representable on the Cartesian plane.');\n  }\n\n  if ( Exception$$1 ) NotRepresentableException.__proto__ = Exception$$1;\n  NotRepresentableException.prototype = Object.create( Exception$$1 && Exception$$1.prototype );\n  NotRepresentableException.prototype.constructor = NotRepresentableException;\n  NotRepresentableException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  NotRepresentableException.prototype.getClass = function getClass () {\n    return NotRepresentableException\n  };\n\n  return NotRepresentableException;\n}(Exception));\n\nvar System = function System () {};\n\nSystem.arraycopy = function arraycopy (src, srcPos, dest, destPos, len) {\n  var c = 0;\n  for (var i = srcPos; i < srcPos + len; i++) {\n    dest[destPos + c] = src[i];\n    c++;\n  }\n};\n\nSystem.getProperty = function getProperty (name) {\n  return {\n    'line.separator': '\\n'\n  }[name]\n};\n\nvar HCoordinate = function HCoordinate () {\n  this.x = null;\n  this.y = null;\n  this.w = null;\n  if (arguments.length === 0) {\n    this.x = 0.0;\n    this.y = 0.0;\n    this.w = 1.0;\n  } else if (arguments.length === 1) {\n    var p = arguments[0];\n    this.x = p.x;\n    this.y = p.y;\n    this.w = 1.0;\n  } else if (arguments.length === 2) {\n    if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n      var _x = arguments[0];\n      var _y = arguments[1];\n      this.x = _x;\n      this.y = _y;\n      this.w = 1.0;\n    } else if (arguments[0] instanceof HCoordinate && arguments[1] instanceof HCoordinate) {\n      var p1 = arguments[0];\n      var p2 = arguments[1];\n      this.x = p1.y * p2.w - p2.y * p1.w;\n      this.y = p2.x * p1.w - p1.x * p2.w;\n      this.w = p1.x * p2.y - p2.x * p1.y;\n    } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n      var p1$1 = arguments[0];\n      var p2$1 = arguments[1];\n      this.x = p1$1.y - p2$1.y;\n      this.y = p2$1.x - p1$1.x;\n      this.w = p1$1.x * p2$1.y - p2$1.x * p1$1.y;\n    }\n  } else if (arguments.length === 3) {\n    var _x$1 = arguments[0];\n    var _y$1 = arguments[1];\n    var _w = arguments[2];\n    this.x = _x$1;\n    this.y = _y$1;\n    this.w = _w;\n  } else if (arguments.length === 4) {\n    var p1$2 = arguments[0];\n    var p2$2 = arguments[1];\n    var q1 = arguments[2];\n    var q2 = arguments[3];\n    var px = p1$2.y - p2$2.y;\n    var py = p2$2.x - p1$2.x;\n    var pw = p1$2.x * p2$2.y - p2$2.x * p1$2.y;\n    var qx = q1.y - q2.y;\n    var qy = q2.x - q1.x;\n    var qw = q1.x * q2.y - q2.x * q1.y;\n    this.x = py * qw - qy * pw;\n    this.y = qx * pw - px * qw;\n    this.w = px * qy - qx * py;\n  }\n};\nHCoordinate.prototype.getY = function getY () {\n  var a = this.y / this.w;\n  if (Double.isNaN(a) || Double.isInfinite(a)) {\n    throw new NotRepresentableException()\n  }\n  return a\n};\nHCoordinate.prototype.getX = function getX () {\n  var a = this.x / this.w;\n  if (Double.isNaN(a) || Double.isInfinite(a)) {\n    throw new NotRepresentableException()\n  }\n  return a\n};\nHCoordinate.prototype.getCoordinate = function getCoordinate () {\n  var p = new Coordinate();\n  p.x = this.getX();\n  p.y = this.getY();\n  return p\n};\nHCoordinate.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nHCoordinate.prototype.getClass = function getClass () {\n  return HCoordinate\n};\nHCoordinate.intersection = function intersection (p1, p2, q1, q2) {\n  var px = p1.y - p2.y;\n  var py = p2.x - p1.x;\n  var pw = p1.x * p2.y - p2.x * p1.y;\n  var qx = q1.y - q2.y;\n  var qy = q2.x - q1.x;\n  var qw = q1.x * q2.y - q2.x * q1.y;\n  var x = py * qw - qy * pw;\n  var y = qx * pw - px * qw;\n  var w = px * qy - qx * py;\n  var xInt = x / w;\n  var yInt = y / w;\n  if (Double.isNaN(xInt) || (Double.isInfinite(xInt) || Double.isNaN(yInt)) || Double.isInfinite(yInt)) {\n    throw new NotRepresentableException()\n  }\n  return new Coordinate(xInt, yInt)\n};\n\nvar Envelope = function Envelope () {\n  this._minx = null;\n  this._maxx = null;\n  this._miny = null;\n  this._maxy = null;\n  if (arguments.length === 0) {\n    this.init();\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.init(p.x, p.x, p.y, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var env = arguments[0];\n      this.init(env);\n    }\n  } else if (arguments.length === 2) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    this.init(p1.x, p2.x, p1.y, p2.y);\n  } else if (arguments.length === 4) {\n    var x1 = arguments[0];\n    var x2 = arguments[1];\n    var y1 = arguments[2];\n    var y2 = arguments[3];\n    this.init(x1, x2, y1, y2);\n  }\n};\n\nvar staticAccessors$9 = { serialVersionUID: { configurable: true } };\nEnvelope.prototype.getArea = function getArea () {\n  return this.getWidth() * this.getHeight()\n};\nEnvelope.prototype.equals = function equals (other) {\n  if (!(other instanceof Envelope)) {\n    return false\n  }\n  var otherEnvelope = other;\n  if (this.isNull()) {\n    return otherEnvelope.isNull()\n  }\n  return this._maxx === otherEnvelope.getMaxX() && this._maxy === otherEnvelope.getMaxY() && this._minx === otherEnvelope.getMinX() && this._miny === otherEnvelope.getMinY()\n};\nEnvelope.prototype.intersection = function intersection (env) {\n  if (this.isNull() || env.isNull() || !this.intersects(env)) { return new Envelope() }\n  var intMinX = this._minx > env._minx ? this._minx : env._minx;\n  var intMinY = this._miny > env._miny ? this._miny : env._miny;\n  var intMaxX = this._maxx < env._maxx ? this._maxx : env._maxx;\n  var intMaxY = this._maxy < env._maxy ? this._maxy : env._maxy;\n  return new Envelope(intMinX, intMaxX, intMinY, intMaxY)\n};\nEnvelope.prototype.isNull = function isNull () {\n  return this._maxx < this._minx\n};\nEnvelope.prototype.getMaxX = function getMaxX () {\n  return this._maxx\n};\nEnvelope.prototype.covers = function covers () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.covers(p.x, p.y)\n    } else if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (this.isNull() || other.isNull()) {\n        return false\n      }\n      return other.getMinX() >= this._minx && other.getMaxX() <= this._maxx && other.getMinY() >= this._miny && other.getMaxY() <= this._maxy\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) { return false }\n    return x >= this._minx && x <= this._maxx && y >= this._miny && y <= this._maxy\n  }\n};\nEnvelope.prototype.intersects = function intersects () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (this.isNull() || other.isNull()) {\n        return false\n      }\n      return !(other._minx > this._maxx || other._maxx < this._minx || other._miny > this._maxy || other._maxy < this._miny)\n    } else if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.intersects(p.x, p.y)\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) { return false }\n    return !(x > this._maxx || x < this._minx || y > this._maxy || y < this._miny)\n  }\n};\nEnvelope.prototype.getMinY = function getMinY () {\n  return this._miny\n};\nEnvelope.prototype.getMinX = function getMinX () {\n  return this._minx\n};\nEnvelope.prototype.expandToInclude = function expandToInclude () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.expandToInclude(p.x, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      if (other.isNull()) {\n        return null\n      }\n      if (this.isNull()) {\n        this._minx = other.getMinX();\n        this._maxx = other.getMaxX();\n        this._miny = other.getMinY();\n        this._maxy = other.getMaxY();\n      } else {\n        if (other._minx < this._minx) {\n          this._minx = other._minx;\n        }\n        if (other._maxx > this._maxx) {\n          this._maxx = other._maxx;\n        }\n        if (other._miny < this._miny) {\n          this._miny = other._miny;\n        }\n        if (other._maxy > this._maxy) {\n          this._maxy = other._maxy;\n        }\n      }\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    if (this.isNull()) {\n      this._minx = x;\n      this._maxx = x;\n      this._miny = y;\n      this._maxy = y;\n    } else {\n      if (x < this._minx) {\n        this._minx = x;\n      }\n      if (x > this._maxx) {\n        this._maxx = x;\n      }\n      if (y < this._miny) {\n        this._miny = y;\n      }\n      if (y > this._maxy) {\n        this._maxy = y;\n      }\n    }\n  }\n};\nEnvelope.prototype.minExtent = function minExtent () {\n  if (this.isNull()) { return 0.0 }\n  var w = this.getWidth();\n  var h = this.getHeight();\n  if (w < h) { return w }\n  return h\n};\nEnvelope.prototype.getWidth = function getWidth () {\n  if (this.isNull()) {\n    return 0\n  }\n  return this._maxx - this._minx\n};\nEnvelope.prototype.compareTo = function compareTo (o) {\n  var env = o;\n  if (this.isNull()) {\n    if (env.isNull()) { return 0 }\n    return -1\n  } else {\n    if (env.isNull()) { return 1 }\n  }\n  if (this._minx < env._minx) { return -1 }\n  if (this._minx > env._minx) { return 1 }\n  if (this._miny < env._miny) { return -1 }\n  if (this._miny > env._miny) { return 1 }\n  if (this._maxx < env._maxx) { return -1 }\n  if (this._maxx > env._maxx) { return 1 }\n  if (this._maxy < env._maxy) { return -1 }\n  if (this._maxy > env._maxy) { return 1 }\n  return 0\n};\nEnvelope.prototype.translate = function translate (transX, transY) {\n  if (this.isNull()) {\n    return null\n  }\n  this.init(this.getMinX() + transX, this.getMaxX() + transX, this.getMinY() + transY, this.getMaxY() + transY);\n};\nEnvelope.prototype.toString = function toString () {\n  return 'Env[' + this._minx + ' : ' + this._maxx + ', ' + this._miny + ' : ' + this._maxy + ']'\n};\nEnvelope.prototype.setToNull = function setToNull () {\n  this._minx = 0;\n  this._maxx = -1;\n  this._miny = 0;\n  this._maxy = -1;\n};\nEnvelope.prototype.getHeight = function getHeight () {\n  if (this.isNull()) {\n    return 0\n  }\n  return this._maxy - this._miny\n};\nEnvelope.prototype.maxExtent = function maxExtent () {\n  if (this.isNull()) { return 0.0 }\n  var w = this.getWidth();\n  var h = this.getHeight();\n  if (w > h) { return w }\n  return h\n};\nEnvelope.prototype.expandBy = function expandBy () {\n  if (arguments.length === 1) {\n    var distance = arguments[0];\n    this.expandBy(distance, distance);\n  } else if (arguments.length === 2) {\n    var deltaX = arguments[0];\n    var deltaY = arguments[1];\n    if (this.isNull()) { return null }\n    this._minx -= deltaX;\n    this._maxx += deltaX;\n    this._miny -= deltaY;\n    this._maxy += deltaY;\n    if (this._minx > this._maxx || this._miny > this._maxy) { this.setToNull(); }\n  }\n};\nEnvelope.prototype.contains = function contains () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Envelope) {\n      var other = arguments[0];\n      return this.covers(other)\n    } else if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      return this.covers(p)\n    }\n  } else if (arguments.length === 2) {\n    var x = arguments[0];\n    var y = arguments[1];\n    return this.covers(x, y)\n  }\n};\nEnvelope.prototype.centre = function centre () {\n  if (this.isNull()) { return null }\n  return new Coordinate((this.getMinX() + this.getMaxX()) / 2.0, (this.getMinY() + this.getMaxY()) / 2.0)\n};\nEnvelope.prototype.init = function init () {\n  if (arguments.length === 0) {\n    this.setToNull();\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var p = arguments[0];\n      this.init(p.x, p.x, p.y, p.y);\n    } else if (arguments[0] instanceof Envelope) {\n      var env = arguments[0];\n      this._minx = env._minx;\n      this._maxx = env._maxx;\n      this._miny = env._miny;\n      this._maxy = env._maxy;\n    }\n  } else if (arguments.length === 2) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    this.init(p1.x, p2.x, p1.y, p2.y);\n  } else if (arguments.length === 4) {\n    var x1 = arguments[0];\n    var x2 = arguments[1];\n    var y1 = arguments[2];\n    var y2 = arguments[3];\n    if (x1 < x2) {\n      this._minx = x1;\n      this._maxx = x2;\n    } else {\n      this._minx = x2;\n      this._maxx = x1;\n    }\n    if (y1 < y2) {\n      this._miny = y1;\n      this._maxy = y2;\n    } else {\n      this._miny = y2;\n      this._maxy = y1;\n    }\n  }\n};\nEnvelope.prototype.getMaxY = function getMaxY () {\n  return this._maxy\n};\nEnvelope.prototype.distance = function distance (env) {\n  if (this.intersects(env)) { return 0 }\n  var dx = 0.0;\n  if (this._maxx < env._minx) { dx = env._minx - this._maxx; } else if (this._minx > env._maxx) { dx = this._minx - env._maxx; }\n  var dy = 0.0;\n  if (this._maxy < env._miny) { dy = env._miny - this._maxy; } else if (this._miny > env._maxy) { dy = this._miny - env._maxy; }\n  if (dx === 0.0) { return dy }\n  if (dy === 0.0) { return dx }\n  return Math.sqrt(dx * dx + dy * dy)\n};\nEnvelope.prototype.hashCode = function hashCode () {\n  var result = 17;\n  result = 37 * result + Coordinate.hashCode(this._minx);\n  result = 37 * result + Coordinate.hashCode(this._maxx);\n  result = 37 * result + Coordinate.hashCode(this._miny);\n  result = 37 * result + Coordinate.hashCode(this._maxy);\n  return result\n};\nEnvelope.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Serializable]\n};\nEnvelope.prototype.getClass = function getClass () {\n  return Envelope\n};\nEnvelope.intersects = function intersects () {\n  if (arguments.length === 3) {\n    var p1 = arguments[0];\n    var p2 = arguments[1];\n    var q = arguments[2];\n    if (q.x >= (p1.x < p2.x ? p1.x : p2.x) && q.x <= (p1.x > p2.x ? p1.x : p2.x) && (q.y >= (p1.y < p2.y ? p1.y : p2.y) && q.y <= (p1.y > p2.y ? p1.y : p2.y))) {\n      return true\n    }\n    return false\n  } else if (arguments.length === 4) {\n    var p1$1 = arguments[0];\n    var p2$1 = arguments[1];\n    var q1 = arguments[2];\n    var q2 = arguments[3];\n    var minq = Math.min(q1.x, q2.x);\n    var maxq = Math.max(q1.x, q2.x);\n    var minp = Math.min(p1$1.x, p2$1.x);\n    var maxp = Math.max(p1$1.x, p2$1.x);\n    if (minp > maxq) { return false }\n    if (maxp < minq) { return false }\n    minq = Math.min(q1.y, q2.y);\n    maxq = Math.max(q1.y, q2.y);\n    minp = Math.min(p1$1.y, p2$1.y);\n    maxp = Math.max(p1$1.y, p2$1.y);\n    if (minp > maxq) { return false }\n    if (maxp < minq) { return false }\n    return true\n  }\n};\nstaticAccessors$9.serialVersionUID.get = function () { return 5873921885273102420 };\n\nObject.defineProperties( Envelope, staticAccessors$9 );\n\nvar regExes = {\n  'typeStr': /^\\s*(\\w+)\\s*\\(\\s*(.*)\\s*\\)\\s*$/,\n  'emptyTypeStr': /^\\s*(\\w+)\\s*EMPTY\\s*$/,\n  'spaces': /\\s+/,\n  'parenComma': /\\)\\s*,\\s*\\(/,\n  'doubleParenComma': /\\)\\s*\\)\\s*,\\s*\\(\\s*\\(/, // can't use {2} here\n  'trimParens': /^\\s*\\(?(.*?)\\)?\\s*$/\n};\n\n/**\n * Class for reading and writing Well-Known Text.\n *\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/** Create a new parser for WKT\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of WKTParser.\n * @constructor\n * @private\n */\nvar WKTParser = function WKTParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n};\n/**\n * Deserialize a WKT string and return a geometry. Supports WKT for POINT,\n * MULTIPOINT, LINESTRING, LINEARRING, MULTILINESTRING, POLYGON, MULTIPOLYGON,\n * and GEOMETRYCOLLECTION.\n *\n * @param {String} wkt A WKT string.\n * @return {Geometry} A geometry instance.\n * @private\n */\nWKTParser.prototype.read = function read (wkt) {\n  var geometry, type, str;\n  wkt = wkt.replace(/[\\n\\r]/g, ' ');\n  var matches = regExes.typeStr.exec(wkt);\n  if (wkt.search('EMPTY') !== -1) {\n    matches = regExes.emptyTypeStr.exec(wkt);\n    matches[2] = undefined;\n  }\n  if (matches) {\n    type = matches[1].toLowerCase();\n    str = matches[2];\n    if (parse$1[type]) {\n      geometry = parse$1[type].apply(this, [str]);\n    }\n  }\n\n  if (geometry === undefined) { throw new Error('Could not parse WKT ' + wkt) }\n\n  return geometry\n};\n\n/**\n * Serialize a geometry into a WKT string.\n *\n * @param {Geometry} geometry A feature or array of features.\n * @return {String} The WKT string representation of the input geometries.\n * @private\n */\nWKTParser.prototype.write = function write (geometry) {\n  return this.extractGeometry(geometry)\n};\n\n/**\n * Entry point to construct the WKT for a single Geometry object.\n *\n * @param {Geometry} geometry\n * @return {String} A WKT string of representing the geometry.\n * @private\n */\nWKTParser.prototype.extractGeometry = function extractGeometry (geometry) {\n  var type = geometry.getGeometryType().toLowerCase();\n  if (!extract$1[type]) {\n    return null\n  }\n  var wktType = type.toUpperCase();\n  var data;\n  if (geometry.isEmpty()) {\n    data = wktType + ' EMPTY';\n  } else {\n    data = wktType + '(' + extract$1[type].apply(this, [geometry]) + ')';\n  }\n  return data\n};\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual data extraction.\n * @private\n */\nvar extract$1 = {\n  coordinate: function coordinate (coordinate$1) {\n    return coordinate$1.x + ' ' + coordinate$1.y\n  },\n\n  /**\n   * Return a space delimited string of point coordinates.\n   *\n   * @param {Point}\n   *          point\n   * @return {String} A string of coordinates representing the point.\n   */\n  point: function point (point$1) {\n    return extract$1.coordinate.call(this, point$1._coordinates._coordinates[0])\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a multipoint.\n   *\n   * @param {MultiPoint}\n   *          multipoint\n   * @return {String} A string of point coordinate strings representing the\n   *         multipoint.\n   */\n  multipoint: function multipoint (multipoint$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multipoint$1._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.point.apply(this$1, [multipoint$1._geometries[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of point coordinates from a line.\n   *\n   * @param {LineString} linestring\n   * @return {String} A string of point coordinate strings representing the linestring.\n   */\n  linestring: function linestring (linestring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = linestring$1._points._coordinates.length; i < len; ++i) {\n      array.push(extract$1.coordinate.apply(this$1, [linestring$1._points._coordinates[i]]));\n    }\n    return array.join(',')\n  },\n\n  linearring: function linearring (linearring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = linearring$1._points._coordinates.length; i < len; ++i) {\n      array.push(extract$1.coordinate.apply(this$1, [linearring$1._points._coordinates[i]]));\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linestring strings from a\n   * multilinestring.\n   *\n   * @param {MultiLineString} multilinestring\n   * @return {String} A string of of linestring strings representing the multilinestring.\n   */\n  multilinestring: function multilinestring (multilinestring$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multilinestring$1._geometries.length; i < len; ++i) {\n      array.push('(' +\n        extract$1.linestring.apply(this$1, [multilinestring$1._geometries[i]]) +\n        ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return a comma delimited string of linear ring arrays from a polygon.\n   *\n   * @param {Polygon} polygon\n   * @return {String} An array of linear ring arrays representing the polygon.\n   */\n  polygon: function polygon (polygon$1) {\n    var this$1 = this;\n\n    var array = [];\n    array.push('(' + extract$1.linestring.apply(this, [polygon$1._shell]) + ')');\n    for (var i = 0, len = polygon$1._holes.length; i < len; ++i) {\n      array.push('(' + extract$1.linestring.apply(this$1, [polygon$1._holes[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return an array of polygon arrays from a multipolygon.\n   *\n   * @param {MultiPolygon} multipolygon\n   * @return {String} An array of polygon arrays representing the multipolygon.\n   */\n  multipolygon: function multipolygon (multipolygon$1) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = multipolygon$1._geometries.length; i < len; ++i) {\n      array.push('(' + extract$1.polygon.apply(this$1, [multipolygon$1._geometries[i]]) + ')');\n    }\n    return array.join(',')\n  },\n\n  /**\n   * Return the WKT portion between 'GEOMETRYCOLLECTION(' and ')' for an\n   * geometrycollection.\n   *\n   * @param {GeometryCollection} collection\n   * @return {String} internal WKT representation of the collection.\n   */\n  geometrycollection: function geometrycollection (collection) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0, len = collection._geometries.length; i < len; ++i) {\n      array.push(this$1.extractGeometry(collection._geometries[i]));\n    }\n    return array.join(',')\n  }\n};\n\n/**\n * Object with properties corresponding to the geometry types. Property values\n * are functions that do the actual parsing.\n * @private\n */\nvar parse$1 = {\n  /**\n   * Return point geometry given a point WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the point.\n   * @return {Point} A point geometry.\n   * @private\n   */\n  point: function point (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createPoint()\n    }\n\n    var coords = str.trim().split(regExes.spaces);\n    return this.geometryFactory.createPoint(new Coordinate(Number.parseFloat(coords[0]),\n      Number.parseFloat(coords[1])))\n  },\n\n  /**\n   * Return a multipoint geometry given a multipoint WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipoint.\n   * @return {Point} A multipoint feature.\n   * @private\n   */\n  multipoint: function multipoint (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPoint()\n    }\n\n    var point;\n    var points = str.trim().split(',');\n    var components = [];\n    for (var i = 0, len = points.length; i < len; ++i) {\n      point = points[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.point.apply(this$1, [point]));\n    }\n    return this.geometryFactory.createMultiPoint(components)\n  },\n\n  /**\n   * Return a linestring geometry given a linestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linestring.\n   * @return {LineString} A linestring geometry.\n   * @private\n   */\n  linestring: function linestring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLineString()\n    }\n\n    var points = str.trim().split(',');\n    var components = [];\n    var coords;\n    for (var i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces);\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    }\n    return this.geometryFactory.createLineString(components)\n  },\n\n  /**\n   * Return a linearring geometry given a linearring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the linearring.\n   * @return {LinearRing} A linearring geometry.\n   * @private\n   */\n  linearring: function linearring (str) {\n    if (str === undefined) {\n      return this.geometryFactory.createLinearRing()\n    }\n\n    var points = str.trim().split(',');\n    var components = [];\n    var coords;\n    for (var i = 0, len = points.length; i < len; ++i) {\n      coords = points[i].trim().split(regExes.spaces);\n      components.push(new Coordinate(Number.parseFloat(coords[0]), Number.parseFloat(coords[1])));\n    }\n    return this.geometryFactory.createLinearRing(components)\n  },\n\n  /**\n   * Return a multilinestring geometry given a multilinestring WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multilinestring.\n   * @return {MultiLineString} A multilinestring geometry.\n   * @private\n   */\n  multilinestring: function multilinestring (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiLineString()\n    }\n\n    var line;\n    var lines = str.trim().split(regExes.parenComma);\n    var components = [];\n    for (var i = 0, len = lines.length; i < len; ++i) {\n      line = lines[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.linestring.apply(this$1, [line]));\n    }\n    return this.geometryFactory.createMultiLineString(components)\n  },\n\n  /**\n   * Return a polygon geometry given a polygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the polygon.\n   * @return {Polygon} A polygon geometry.\n   * @private\n   */\n  polygon: function polygon (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createPolygon()\n    }\n\n    var ring, linestring, linearring;\n    var rings = str.trim().split(regExes.parenComma);\n    var shell;\n    var holes = [];\n    for (var i = 0, len = rings.length; i < len; ++i) {\n      ring = rings[i].replace(regExes.trimParens, '$1');\n      linestring = parse$1.linestring.apply(this$1, [ring]);\n      linearring = this$1.geometryFactory.createLinearRing(linestring._points);\n      if (i === 0) {\n        shell = linearring;\n      } else {\n        holes.push(linearring);\n      }\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Return a multipolygon geometry given a multipolygon WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the multipolygon.\n   * @return {MultiPolygon} A multipolygon geometry.\n   * @private\n   */\n  multipolygon: function multipolygon (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createMultiPolygon()\n    }\n\n    var polygon;\n    var polygons = str.trim().split(regExes.doubleParenComma);\n    var components = [];\n    for (var i = 0, len = polygons.length; i < len; ++i) {\n      polygon = polygons[i].replace(regExes.trimParens, '$1');\n      components.push(parse$1.polygon.apply(this$1, [polygon]));\n    }\n    return this.geometryFactory.createMultiPolygon(components)\n  },\n\n  /**\n   * Return a geometrycollection given a geometrycollection WKT fragment.\n   *\n   * @param {String} str A WKT fragment representing the geometrycollection.\n   * @return {GeometryCollection}\n   * @private\n   */\n  geometrycollection: function geometrycollection (str) {\n    var this$1 = this;\n\n    if (str === undefined) {\n      return this.geometryFactory.createGeometryCollection()\n    }\n\n    // separate components of the collection with |\n    str = str.replace(/,\\s*([A-Za-z])/g, '|$1');\n    var wktArray = str.trim().split('|');\n    var components = [];\n    for (var i = 0, len = wktArray.length; i < len; ++i) {\n      components.push(this$1.read(wktArray[i]));\n    }\n    return this.geometryFactory.createGeometryCollection(components)\n  }\n};\n\n/**\n * Writes the Well-Known Text representation of a {@link Geometry}. The\n * Well-Known Text format is defined in the <A\n * HREF=\"http://www.opengis.org/techno/specs.htm\"> OGC Simple Features\n * Specification for SQL</A>.\n * <p>\n * The <code>WKTWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n * <p>\n * The SFS WKT spec does not define a special tag for {@link LinearRing}s.\n * Under the spec, rings are output as <code>LINESTRING</code>s.\n */\n\n/**\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar WKTWriter = function WKTWriter (geometryFactory) {\n  this.parser = new WKTParser(geometryFactory);\n};\n\n/**\n * Converts a <code>Geometry</code> to its Well-known Text representation.\n *\n * @param {Geometry} geometry a <code>Geometry</code> to process.\n * @return {string} a <Geometry Tagged Text> string (see the OpenGIS Simple\n *       Features Specification).\n * @memberof WKTWriter\n */\nWKTWriter.prototype.write = function write (geometry) {\n  return this.parser.write(geometry)\n};\n/**\n * Generates the WKT for a <tt>LINESTRING</tt> specified by two\n * {@link Coordinate}s.\n *\n * @param p0 the first coordinate.\n * @param p1 the second coordinate.\n *\n * @return the WKT.\n * @private\n */\nWKTWriter.toLineString = function toLineString (p0, p1) {\n  if (arguments.length !== 2) {\n    throw new Error('Not implemented')\n  }\n  return 'LINESTRING ( ' + p0.x + ' ' + p0.y + ', ' + p1.x + ' ' + p1.y + ' )'\n};\n\nvar RuntimeException = (function (Error) {\n  function RuntimeException (message) {\n    Error.call(this, message);\n    this.name = 'RuntimeException';\n    this.message = message;\n    this.stack = (new Error()).stack;\n  }\n\n  if ( Error ) RuntimeException.__proto__ = Error;\n  RuntimeException.prototype = Object.create( Error && Error.prototype );\n  RuntimeException.prototype.constructor = RuntimeException;\n\n  return RuntimeException;\n}(Error));\n\nvar AssertionFailedException = (function (RuntimeException$$1) {\n  function AssertionFailedException () {\n    RuntimeException$$1.call(this);\n    if (arguments.length === 0) {\n      RuntimeException$$1.call(this);\n    } else if (arguments.length === 1) {\n      var message = arguments[0];\n      RuntimeException$$1.call(this, message);\n    }\n  }\n\n  if ( RuntimeException$$1 ) AssertionFailedException.__proto__ = RuntimeException$$1;\n  AssertionFailedException.prototype = Object.create( RuntimeException$$1 && RuntimeException$$1.prototype );\n  AssertionFailedException.prototype.constructor = AssertionFailedException;\n  AssertionFailedException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  AssertionFailedException.prototype.getClass = function getClass () {\n    return AssertionFailedException\n  };\n\n  return AssertionFailedException;\n}(RuntimeException));\n\nvar Assert = function Assert () {};\n\nAssert.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nAssert.prototype.getClass = function getClass () {\n  return Assert\n};\nAssert.shouldNeverReachHere = function shouldNeverReachHere () {\n  if (arguments.length === 0) {\n    Assert.shouldNeverReachHere(null);\n  } else if (arguments.length === 1) {\n    var message = arguments[0];\n    throw new AssertionFailedException('Should never reach here' + (message !== null ? ': ' + message : ''))\n  }\n};\nAssert.isTrue = function isTrue () {\n  var assertion;\n  var message;\n  if (arguments.length === 1) {\n    assertion = arguments[0];\n    Assert.isTrue(assertion, null);\n  } else if (arguments.length === 2) {\n    assertion = arguments[0];\n    message = arguments[1];\n    if (!assertion) {\n      if (message === null) {\n        throw new AssertionFailedException()\n      } else {\n        throw new AssertionFailedException(message)\n      }\n    }\n  }\n};\nAssert.equals = function equals () {\n  var expectedValue;\n  var actualValue;\n  var message;\n  if (arguments.length === 2) {\n    expectedValue = arguments[0];\n    actualValue = arguments[1];\n    Assert.equals(expectedValue, actualValue, null);\n  } else if (arguments.length === 3) {\n    expectedValue = arguments[0];\n    actualValue = arguments[1];\n    message = arguments[2];\n    if (!actualValue.equals(expectedValue)) {\n      throw new AssertionFailedException('Expected ' + expectedValue + ' but encountered ' + actualValue + (message !== null ? ': ' + message : ''))\n    }\n  }\n};\n\nvar LineIntersector = function LineIntersector () {\n  this._result = null;\n  this._inputLines = Array(2).fill().map(function () { return Array(2); });\n  this._intPt = new Array(2).fill(null);\n  this._intLineIndex = null;\n  this._isProper = null;\n  this._pa = null;\n  this._pb = null;\n  this._precisionModel = null;\n  this._intPt[0] = new Coordinate();\n  this._intPt[1] = new Coordinate();\n  this._pa = this._intPt[0];\n  this._pb = this._intPt[1];\n  this._result = 0;\n};\n\nvar staticAccessors$10 = { DONT_INTERSECT: { configurable: true },DO_INTERSECT: { configurable: true },COLLINEAR: { configurable: true },NO_INTERSECTION: { configurable: true },POINT_INTERSECTION: { configurable: true },COLLINEAR_INTERSECTION: { configurable: true } };\nLineIntersector.prototype.getIndexAlongSegment = function getIndexAlongSegment (segmentIndex, intIndex) {\n  this.computeIntLineIndex();\n  return this._intLineIndex[segmentIndex][intIndex]\n};\nLineIntersector.prototype.getTopologySummary = function getTopologySummary () {\n  var catBuf = new StringBuffer();\n  if (this.isEndPoint()) { catBuf.append(' endpoint'); }\n  if (this._isProper) { catBuf.append(' proper'); }\n  if (this.isCollinear()) { catBuf.append(' collinear'); }\n  return catBuf.toString()\n};\nLineIntersector.prototype.computeIntersection = function computeIntersection (p1, p2, p3, p4) {\n  this._inputLines[0][0] = p1;\n  this._inputLines[0][1] = p2;\n  this._inputLines[1][0] = p3;\n  this._inputLines[1][1] = p4;\n  this._result = this.computeIntersect(p1, p2, p3, p4);\n};\nLineIntersector.prototype.getIntersectionNum = function getIntersectionNum () {\n  return this._result\n};\nLineIntersector.prototype.computeIntLineIndex = function computeIntLineIndex () {\n  if (arguments.length === 0) {\n    if (this._intLineIndex === null) {\n      this._intLineIndex = Array(2).fill().map(function () { return Array(2); });\n      this.computeIntLineIndex(0);\n      this.computeIntLineIndex(1);\n    }\n  } else if (arguments.length === 1) {\n    var segmentIndex = arguments[0];\n    var dist0 = this.getEdgeDistance(segmentIndex, 0);\n    var dist1 = this.getEdgeDistance(segmentIndex, 1);\n    if (dist0 > dist1) {\n      this._intLineIndex[segmentIndex][0] = 0;\n      this._intLineIndex[segmentIndex][1] = 1;\n    } else {\n      this._intLineIndex[segmentIndex][0] = 1;\n      this._intLineIndex[segmentIndex][1] = 0;\n    }\n  }\n};\nLineIntersector.prototype.isProper = function isProper () {\n  return this.hasIntersection() && this._isProper\n};\nLineIntersector.prototype.setPrecisionModel = function setPrecisionModel (precisionModel) {\n  this._precisionModel = precisionModel;\n};\nLineIntersector.prototype.isInteriorIntersection = function isInteriorIntersection () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isInteriorIntersection(0)) { return true }\n    if (this.isInteriorIntersection(1)) { return true }\n    return false\n  } else if (arguments.length === 1) {\n    var inputLineIndex = arguments[0];\n    for (var i = 0; i < this._result; i++) {\n      if (!(this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][0]) || this$1._intPt[i].equals2D(this$1._inputLines[inputLineIndex][1]))) {\n        return true\n      }\n    }\n    return false\n  }\n};\nLineIntersector.prototype.getIntersection = function getIntersection (intIndex) {\n  return this._intPt[intIndex]\n};\nLineIntersector.prototype.isEndPoint = function isEndPoint () {\n  return this.hasIntersection() && !this._isProper\n};\nLineIntersector.prototype.hasIntersection = function hasIntersection () {\n  return this._result !== LineIntersector.NO_INTERSECTION\n};\nLineIntersector.prototype.getEdgeDistance = function getEdgeDistance (segmentIndex, intIndex) {\n  var dist = LineIntersector.computeEdgeDistance(this._intPt[intIndex], this._inputLines[segmentIndex][0], this._inputLines[segmentIndex][1]);\n  return dist\n};\nLineIntersector.prototype.isCollinear = function isCollinear () {\n  return this._result === LineIntersector.COLLINEAR_INTERSECTION\n};\nLineIntersector.prototype.toString = function toString () {\n  return WKTWriter.toLineString(this._inputLines[0][0], this._inputLines[0][1]) + ' - ' + WKTWriter.toLineString(this._inputLines[1][0], this._inputLines[1][1]) + this.getTopologySummary()\n};\nLineIntersector.prototype.getEndpoint = function getEndpoint (segmentIndex, ptIndex) {\n  return this._inputLines[segmentIndex][ptIndex]\n};\nLineIntersector.prototype.isIntersection = function isIntersection (pt) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._result; i++) {\n    if (this$1._intPt[i].equals2D(pt)) {\n      return true\n    }\n  }\n  return false\n};\nLineIntersector.prototype.getIntersectionAlongSegment = function getIntersectionAlongSegment (segmentIndex, intIndex) {\n  this.computeIntLineIndex();\n  return this._intPt[this._intLineIndex[segmentIndex][intIndex]]\n};\nLineIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineIntersector.prototype.getClass = function getClass () {\n  return LineIntersector\n};\nLineIntersector.computeEdgeDistance = function computeEdgeDistance (p, p0, p1) {\n  var dx = Math.abs(p1.x - p0.x);\n  var dy = Math.abs(p1.y - p0.y);\n  var dist = -1.0;\n  if (p.equals(p0)) {\n    dist = 0.0;\n  } else if (p.equals(p1)) {\n    if (dx > dy) { dist = dx; } else { dist = dy; }\n  } else {\n    var pdx = Math.abs(p.x - p0.x);\n    var pdy = Math.abs(p.y - p0.y);\n    if (dx > dy) { dist = pdx; } else { dist = pdy; }\n    if (dist === 0.0 && !p.equals(p0)) {\n      dist = Math.max(pdx, pdy);\n    }\n  }\n  Assert.isTrue(!(dist === 0.0 && !p.equals(p0)), 'Bad distance calculation');\n  return dist\n};\nLineIntersector.nonRobustComputeEdgeDistance = function nonRobustComputeEdgeDistance (p, p1, p2) {\n  var dx = p.x - p1.x;\n  var dy = p.y - p1.y;\n  var dist = Math.sqrt(dx * dx + dy * dy);\n  Assert.isTrue(!(dist === 0.0 && !p.equals(p1)), 'Invalid distance calculation');\n  return dist\n};\nstaticAccessors$10.DONT_INTERSECT.get = function () { return 0 };\nstaticAccessors$10.DO_INTERSECT.get = function () { return 1 };\nstaticAccessors$10.COLLINEAR.get = function () { return 2 };\nstaticAccessors$10.NO_INTERSECTION.get = function () { return 0 };\nstaticAccessors$10.POINT_INTERSECTION.get = function () { return 1 };\nstaticAccessors$10.COLLINEAR_INTERSECTION.get = function () { return 2 };\n\nObject.defineProperties( LineIntersector, staticAccessors$10 );\n\nvar RobustLineIntersector = (function (LineIntersector$$1) {\n  function RobustLineIntersector () {\n    LineIntersector$$1.apply(this, arguments);\n  }\n\n  if ( LineIntersector$$1 ) RobustLineIntersector.__proto__ = LineIntersector$$1;\n  RobustLineIntersector.prototype = Object.create( LineIntersector$$1 && LineIntersector$$1.prototype );\n  RobustLineIntersector.prototype.constructor = RobustLineIntersector;\n\n  RobustLineIntersector.prototype.isInSegmentEnvelopes = function isInSegmentEnvelopes (intPt) {\n    var env0 = new Envelope(this._inputLines[0][0], this._inputLines[0][1]);\n    var env1 = new Envelope(this._inputLines[1][0], this._inputLines[1][1]);\n    return env0.contains(intPt) && env1.contains(intPt)\n  };\n  RobustLineIntersector.prototype.computeIntersection = function computeIntersection () {\n    if (arguments.length === 3) {\n      var p = arguments[0];\n      var p1 = arguments[1];\n      var p2 = arguments[2];\n      this._isProper = false;\n      if (Envelope.intersects(p1, p2, p)) {\n        if (CGAlgorithms.orientationIndex(p1, p2, p) === 0 && CGAlgorithms.orientationIndex(p2, p1, p) === 0) {\n          this._isProper = true;\n          if (p.equals(p1) || p.equals(p2)) {\n            this._isProper = false;\n          }\n          this._result = LineIntersector$$1.POINT_INTERSECTION;\n          return null\n        }\n      }\n      this._result = LineIntersector$$1.NO_INTERSECTION;\n    } else { return LineIntersector$$1.prototype.computeIntersection.apply(this, arguments) }\n  };\n  RobustLineIntersector.prototype.normalizeToMinimum = function normalizeToMinimum (n1, n2, n3, n4, normPt) {\n    normPt.x = this.smallestInAbsValue(n1.x, n2.x, n3.x, n4.x);\n    normPt.y = this.smallestInAbsValue(n1.y, n2.y, n3.y, n4.y);\n    n1.x -= normPt.x;\n    n1.y -= normPt.y;\n    n2.x -= normPt.x;\n    n2.y -= normPt.y;\n    n3.x -= normPt.x;\n    n3.y -= normPt.y;\n    n4.x -= normPt.x;\n    n4.y -= normPt.y;\n  };\n  RobustLineIntersector.prototype.safeHCoordinateIntersection = function safeHCoordinateIntersection (p1, p2, q1, q2) {\n    var intPt = null;\n    try {\n      intPt = HCoordinate.intersection(p1, p2, q1, q2);\n    } catch (e) {\n      if (e instanceof NotRepresentableException) {\n        intPt = RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2);\n      } else { throw e }\n    } finally {}\n    return intPt\n  };\n  RobustLineIntersector.prototype.intersection = function intersection (p1, p2, q1, q2) {\n    var intPt = this.intersectionWithNormalization(p1, p2, q1, q2);\n    if (!this.isInSegmentEnvelopes(intPt)) {\n      intPt = new Coordinate(RobustLineIntersector.nearestEndpoint(p1, p2, q1, q2));\n    }\n    if (this._precisionModel !== null) {\n      this._precisionModel.makePrecise(intPt);\n    }\n    return intPt\n  };\n  RobustLineIntersector.prototype.smallestInAbsValue = function smallestInAbsValue (x1, x2, x3, x4) {\n    var x = x1;\n    var xabs = Math.abs(x);\n    if (Math.abs(x2) < xabs) {\n      x = x2;\n      xabs = Math.abs(x2);\n    }\n    if (Math.abs(x3) < xabs) {\n      x = x3;\n      xabs = Math.abs(x3);\n    }\n    if (Math.abs(x4) < xabs) {\n      x = x4;\n    }\n    return x\n  };\n  RobustLineIntersector.prototype.checkDD = function checkDD (p1, p2, q1, q2, intPt) {\n    var intPtDD = CGAlgorithmsDD.intersection(p1, p2, q1, q2);\n    var isIn = this.isInSegmentEnvelopes(intPtDD);\n    System.out.println('DD in env = ' + isIn + '  --------------------- ' + intPtDD);\n    if (intPt.distance(intPtDD) > 0.0001) {\n      System.out.println('Distance = ' + intPt.distance(intPtDD));\n    }\n  };\n  RobustLineIntersector.prototype.intersectionWithNormalization = function intersectionWithNormalization (p1, p2, q1, q2) {\n    var n1 = new Coordinate(p1);\n    var n2 = new Coordinate(p2);\n    var n3 = new Coordinate(q1);\n    var n4 = new Coordinate(q2);\n    var normPt = new Coordinate();\n    this.normalizeToEnvCentre(n1, n2, n3, n4, normPt);\n    var intPt = this.safeHCoordinateIntersection(n1, n2, n3, n4);\n    intPt.x += normPt.x;\n    intPt.y += normPt.y;\n    return intPt\n  };\n  RobustLineIntersector.prototype.computeCollinearIntersection = function computeCollinearIntersection (p1, p2, q1, q2) {\n    var p1q1p2 = Envelope.intersects(p1, p2, q1);\n    var p1q2p2 = Envelope.intersects(p1, p2, q2);\n    var q1p1q2 = Envelope.intersects(q1, q2, p1);\n    var q1p2q2 = Envelope.intersects(q1, q2, p2);\n    if (p1q1p2 && p1q2p2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = q2;\n      return LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (q1p1q2 && q1p2q2) {\n      this._intPt[0] = p1;\n      this._intPt[1] = p2;\n      return LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p1q2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = p1;\n      return q1.equals(p1) && !p1q2p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q1p2 && q1p2q2) {\n      this._intPt[0] = q1;\n      this._intPt[1] = p2;\n      return q1.equals(p2) && !p1q2p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p1q2) {\n      this._intPt[0] = q2;\n      this._intPt[1] = p1;\n      return q2.equals(p1) && !p1q1p2 && !q1p2q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    if (p1q2p2 && q1p2q2) {\n      this._intPt[0] = q2;\n      this._intPt[1] = p2;\n      return q2.equals(p2) && !p1q1p2 && !q1p1q2 ? LineIntersector$$1.POINT_INTERSECTION : LineIntersector$$1.COLLINEAR_INTERSECTION\n    }\n    return LineIntersector$$1.NO_INTERSECTION\n  };\n  RobustLineIntersector.prototype.normalizeToEnvCentre = function normalizeToEnvCentre (n00, n01, n10, n11, normPt) {\n    var minX0 = n00.x < n01.x ? n00.x : n01.x;\n    var minY0 = n00.y < n01.y ? n00.y : n01.y;\n    var maxX0 = n00.x > n01.x ? n00.x : n01.x;\n    var maxY0 = n00.y > n01.y ? n00.y : n01.y;\n    var minX1 = n10.x < n11.x ? n10.x : n11.x;\n    var minY1 = n10.y < n11.y ? n10.y : n11.y;\n    var maxX1 = n10.x > n11.x ? n10.x : n11.x;\n    var maxY1 = n10.y > n11.y ? n10.y : n11.y;\n    var intMinX = minX0 > minX1 ? minX0 : minX1;\n    var intMaxX = maxX0 < maxX1 ? maxX0 : maxX1;\n    var intMinY = minY0 > minY1 ? minY0 : minY1;\n    var intMaxY = maxY0 < maxY1 ? maxY0 : maxY1;\n    var intMidX = (intMinX + intMaxX) / 2.0;\n    var intMidY = (intMinY + intMaxY) / 2.0;\n    normPt.x = intMidX;\n    normPt.y = intMidY;\n    n00.x -= normPt.x;\n    n00.y -= normPt.y;\n    n01.x -= normPt.x;\n    n01.y -= normPt.y;\n    n10.x -= normPt.x;\n    n10.y -= normPt.y;\n    n11.x -= normPt.x;\n    n11.y -= normPt.y;\n  };\n  RobustLineIntersector.prototype.computeIntersect = function computeIntersect (p1, p2, q1, q2) {\n    this._isProper = false;\n    if (!Envelope.intersects(p1, p2, q1, q2)) { return LineIntersector$$1.NO_INTERSECTION }\n    var Pq1 = CGAlgorithms.orientationIndex(p1, p2, q1);\n    var Pq2 = CGAlgorithms.orientationIndex(p1, p2, q2);\n    if ((Pq1 > 0 && Pq2 > 0) || (Pq1 < 0 && Pq2 < 0)) {\n      return LineIntersector$$1.NO_INTERSECTION\n    }\n    var Qp1 = CGAlgorithms.orientationIndex(q1, q2, p1);\n    var Qp2 = CGAlgorithms.orientationIndex(q1, q2, p2);\n    if ((Qp1 > 0 && Qp2 > 0) || (Qp1 < 0 && Qp2 < 0)) {\n      return LineIntersector$$1.NO_INTERSECTION\n    }\n    var collinear = Pq1 === 0 && Pq2 === 0 && Qp1 === 0 && Qp2 === 0;\n    if (collinear) {\n      return this.computeCollinearIntersection(p1, p2, q1, q2)\n    }\n    if (Pq1 === 0 || Pq2 === 0 || Qp1 === 0 || Qp2 === 0) {\n      this._isProper = false;\n      if (p1.equals2D(q1) || p1.equals2D(q2)) {\n        this._intPt[0] = p1;\n      } else if (p2.equals2D(q1) || p2.equals2D(q2)) {\n        this._intPt[0] = p2;\n      } else if (Pq1 === 0) {\n        this._intPt[0] = new Coordinate(q1);\n      } else if (Pq2 === 0) {\n        this._intPt[0] = new Coordinate(q2);\n      } else if (Qp1 === 0) {\n        this._intPt[0] = new Coordinate(p1);\n      } else if (Qp2 === 0) {\n        this._intPt[0] = new Coordinate(p2);\n      }\n    } else {\n      this._isProper = true;\n      this._intPt[0] = this.intersection(p1, p2, q1, q2);\n    }\n    return LineIntersector$$1.POINT_INTERSECTION\n  };\n  RobustLineIntersector.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  RobustLineIntersector.prototype.getClass = function getClass () {\n    return RobustLineIntersector\n  };\n  RobustLineIntersector.nearestEndpoint = function nearestEndpoint (p1, p2, q1, q2) {\n    var nearestPt = p1;\n    var minDist = CGAlgorithms.distancePointLine(p1, q1, q2);\n    var dist = CGAlgorithms.distancePointLine(p2, q1, q2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = p2;\n    }\n    dist = CGAlgorithms.distancePointLine(q1, p1, p2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = q1;\n    }\n    dist = CGAlgorithms.distancePointLine(q2, p1, p2);\n    if (dist < minDist) {\n      minDist = dist;\n      nearestPt = q2;\n    }\n    return nearestPt\n  };\n\n  return RobustLineIntersector;\n}(LineIntersector));\n\nvar RobustDeterminant = function RobustDeterminant () {};\n\nRobustDeterminant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRobustDeterminant.prototype.getClass = function getClass () {\n  return RobustDeterminant\n};\nRobustDeterminant.orientationIndex = function orientationIndex (p1, p2, q) {\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dx2 = q.x - p2.x;\n  var dy2 = q.y - p2.y;\n  return RobustDeterminant.signOfDet2x2(dx1, dy1, dx2, dy2)\n};\nRobustDeterminant.signOfDet2x2 = function signOfDet2x2 (x1, y1, x2, y2) {\n  var sign = null;\n  var swap = null;\n  var k = null;\n  sign = 1;\n  if (x1 === 0.0 || y2 === 0.0) {\n    if (y1 === 0.0 || x2 === 0.0) {\n      return 0\n    } else if (y1 > 0) {\n      if (x2 > 0) {\n        return -sign\n      } else {\n        return sign\n      }\n    } else {\n      if (x2 > 0) {\n        return sign\n      } else {\n        return -sign\n      }\n    }\n  }\n  if (y1 === 0.0 || x2 === 0.0) {\n    if (y2 > 0) {\n      if (x1 > 0) {\n        return sign\n      } else {\n        return -sign\n      }\n    } else {\n      if (x1 > 0) {\n        return -sign\n      } else {\n        return sign\n      }\n    }\n  }\n  if (y1 > 0.0) {\n    if (y2 > 0.0) {\n      if (y1 <= y2) {\n        \n      } else {\n        sign = -sign;\n        swap = x1;\n        x1 = x2;\n        x2 = swap;\n        swap = y1;\n        y1 = y2;\n        y2 = swap;\n      }\n    } else {\n      if (y1 <= -y2) {\n        sign = -sign;\n        x2 = -x2;\n        y2 = -y2;\n      } else {\n        swap = x1;\n        x1 = -x2;\n        x2 = swap;\n        swap = y1;\n        y1 = -y2;\n        y2 = swap;\n      }\n    }\n  } else {\n    if (y2 > 0.0) {\n      if (-y1 <= y2) {\n        sign = -sign;\n        x1 = -x1;\n        y1 = -y1;\n      } else {\n        swap = -x1;\n        x1 = x2;\n        x2 = swap;\n        swap = -y1;\n        y1 = y2;\n        y2 = swap;\n      }\n    } else {\n      if (y1 >= y2) {\n        x1 = -x1;\n        y1 = -y1;\n        x2 = -x2;\n        y2 = -y2;\n      } else {\n        sign = -sign;\n        swap = -x1;\n        x1 = -x2;\n        x2 = swap;\n        swap = -y1;\n        y1 = -y2;\n        y2 = swap;\n      }\n    }\n  }\n  if (x1 > 0.0) {\n    if (x2 > 0.0) {\n      if (x1 <= x2) {\n        \n      } else {\n        return sign\n      }\n    } else {\n      return sign\n    }\n  } else {\n    if (x2 > 0.0) {\n      return -sign\n    } else {\n      if (x1 >= x2) {\n        sign = -sign;\n        x1 = -x1;\n        x2 = -x2;\n      } else {\n        return -sign\n      }\n    }\n  }\n  while (true) {\n    k = Math.floor(x2 / x1);\n    x2 = x2 - k * x1;\n    y2 = y2 - k * y1;\n    if (y2 < 0.0) {\n      return -sign\n    }\n    if (y2 > y1) {\n      return sign\n    }\n    if (x1 > x2 + x2) {\n      if (y1 < y2 + y2) {\n        return sign\n      }\n    } else {\n      if (y1 > y2 + y2) {\n        return -sign\n      } else {\n        x2 = x1 - x2;\n        y2 = y1 - y2;\n        sign = -sign;\n      }\n    }\n    if (y2 === 0.0) {\n      if (x2 === 0.0) {\n        return 0\n      } else {\n        return -sign\n      }\n    }\n    if (x2 === 0.0) {\n      return sign\n    }\n    k = Math.floor(x1 / x2);\n    x1 = x1 - k * x2;\n    y1 = y1 - k * y2;\n    if (y1 < 0.0) {\n      return sign\n    }\n    if (y1 > y2) {\n      return -sign\n    }\n    if (x2 > x1 + x1) {\n      if (y2 < y1 + y1) {\n        return -sign\n      }\n    } else {\n      if (y2 > y1 + y1) {\n        return sign\n      } else {\n        x1 = x2 - x1;\n        y1 = y2 - y1;\n        sign = -sign;\n      }\n    }\n    if (y1 === 0.0) {\n      if (x1 === 0.0) {\n        return 0\n      } else {\n        return sign\n      }\n    }\n    if (x1 === 0.0) {\n      return -sign\n    }\n  }\n};\n\nvar RayCrossingCounter = function RayCrossingCounter () {\n  this._p = null;\n  this._crossingCount = 0;\n  this._isPointOnSegment = false;\n  var p = arguments[0];\n  this._p = p;\n};\nRayCrossingCounter.prototype.countSegment = function countSegment (p1, p2) {\n  if (p1.x < this._p.x && p2.x < this._p.x) { return null }\n  if (this._p.x === p2.x && this._p.y === p2.y) {\n    this._isPointOnSegment = true;\n    return null\n  }\n  if (p1.y === this._p.y && p2.y === this._p.y) {\n    var minx = p1.x;\n    var maxx = p2.x;\n    if (minx > maxx) {\n      minx = p2.x;\n      maxx = p1.x;\n    }\n    if (this._p.x >= minx && this._p.x <= maxx) {\n      this._isPointOnSegment = true;\n    }\n    return null\n  }\n  if ((p1.y > this._p.y && p2.y <= this._p.y) || (p2.y > this._p.y && p1.y <= this._p.y)) {\n    var x1 = p1.x - this._p.x;\n    var y1 = p1.y - this._p.y;\n    var x2 = p2.x - this._p.x;\n    var y2 = p2.y - this._p.y;\n    var xIntSign = RobustDeterminant.signOfDet2x2(x1, y1, x2, y2);\n    if (xIntSign === 0.0) {\n      this._isPointOnSegment = true;\n      return null\n    }\n    if (y2 < y1) { xIntSign = -xIntSign; }\n    if (xIntSign > 0.0) {\n      this._crossingCount++;\n    }\n  }\n};\nRayCrossingCounter.prototype.isPointInPolygon = function isPointInPolygon () {\n  return this.getLocation() !== Location.EXTERIOR\n};\nRayCrossingCounter.prototype.getLocation = function getLocation () {\n  if (this._isPointOnSegment) { return Location.BOUNDARY }\n  if (this._crossingCount % 2 === 1) {\n    return Location.INTERIOR\n  }\n  return Location.EXTERIOR\n};\nRayCrossingCounter.prototype.isOnSegment = function isOnSegment () {\n  return this._isPointOnSegment\n};\nRayCrossingCounter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRayCrossingCounter.prototype.getClass = function getClass () {\n  return RayCrossingCounter\n};\nRayCrossingCounter.locatePointInRing = function locatePointInRing () {\n  if (arguments[0] instanceof Coordinate && hasInterface(arguments[1], CoordinateSequence)) {\n    var p = arguments[0];\n    var ring = arguments[1];\n    var counter = new RayCrossingCounter(p);\n    var p1 = new Coordinate();\n    var p2 = new Coordinate();\n    for (var i = 1; i < ring.size(); i++) {\n      ring.getCoordinate(i, p1);\n      ring.getCoordinate(i - 1, p2);\n      counter.countSegment(p1, p2);\n      if (counter.isOnSegment()) { return counter.getLocation() }\n    }\n    return counter.getLocation()\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Array) {\n    var p$1 = arguments[0];\n    var ring$1 = arguments[1];\n    var counter$1 = new RayCrossingCounter(p$1);\n    for (var i$1 = 1; i$1 < ring$1.length; i$1++) {\n      var p1$1 = ring$1[i$1];\n      var p2$1 = ring$1[i$1 - 1];\n      counter$1.countSegment(p1$1, p2$1);\n      if (counter$1.isOnSegment()) { return counter$1.getLocation() }\n    }\n    return counter$1.getLocation()\n  }\n};\n\nvar CGAlgorithms = function CGAlgorithms () {};\n\nvar staticAccessors$3 = { CLOCKWISE: { configurable: true },RIGHT: { configurable: true },COUNTERCLOCKWISE: { configurable: true },LEFT: { configurable: true },COLLINEAR: { configurable: true },STRAIGHT: { configurable: true } };\n\nCGAlgorithms.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCGAlgorithms.prototype.getClass = function getClass () {\n  return CGAlgorithms\n};\nCGAlgorithms.orientationIndex = function orientationIndex (p1, p2, q) {\n  return CGAlgorithmsDD.orientationIndex(p1, p2, q)\n};\nCGAlgorithms.signedArea = function signedArea () {\n  if (arguments[0] instanceof Array) {\n    var ring = arguments[0];\n    if (ring.length < 3) { return 0.0 }\n    var sum = 0.0;\n    var x0 = ring[0].x;\n    for (var i = 1; i < ring.length - 1; i++) {\n      var x = ring[i].x - x0;\n      var y1 = ring[i + 1].y;\n      var y2 = ring[i - 1].y;\n      sum += x * (y2 - y1);\n    }\n    return sum / 2.0\n  } else if (hasInterface(arguments[0], CoordinateSequence)) {\n    var ring$1 = arguments[0];\n    var n = ring$1.size();\n    if (n < 3) { return 0.0 }\n    var p0 = new Coordinate();\n    var p1 = new Coordinate();\n    var p2 = new Coordinate();\n    ring$1.getCoordinate(0, p1);\n    ring$1.getCoordinate(1, p2);\n    var x0$1 = p1.x;\n    p2.x -= x0$1;\n    var sum$1 = 0.0;\n    for (var i$1 = 1; i$1 < n - 1; i$1++) {\n      p0.y = p1.y;\n      p1.x = p2.x;\n      p1.y = p2.y;\n      ring$1.getCoordinate(i$1 + 1, p2);\n      p2.x -= x0$1;\n      sum$1 += p1.x * (p0.y - p2.y);\n    }\n    return sum$1 / 2.0\n  }\n};\nCGAlgorithms.distanceLineLine = function distanceLineLine (A, B, C, D) {\n  if (A.equals(B)) { return CGAlgorithms.distancePointLine(A, C, D) }\n  if (C.equals(D)) { return CGAlgorithms.distancePointLine(D, A, B) }\n  var noIntersection = false;\n  if (!Envelope.intersects(A, B, C, D)) {\n    noIntersection = true;\n  } else {\n    var denom = (B.x - A.x) * (D.y - C.y) - (B.y - A.y) * (D.x - C.x);\n    if (denom === 0) {\n      noIntersection = true;\n    } else {\n      var rNumb = (A.y - C.y) * (D.x - C.x) - (A.x - C.x) * (D.y - C.y);\n      var sNum = (A.y - C.y) * (B.x - A.x) - (A.x - C.x) * (B.y - A.y);\n      var s = sNum / denom;\n      var r = rNumb / denom;\n      if (r < 0 || r > 1 || s < 0 || s > 1) {\n        noIntersection = true;\n      }\n    }\n  }\n  if (noIntersection) {\n    return MathUtil.min(CGAlgorithms.distancePointLine(A, C, D), CGAlgorithms.distancePointLine(B, C, D), CGAlgorithms.distancePointLine(C, A, B), CGAlgorithms.distancePointLine(D, A, B))\n  }\n  return 0.0\n};\nCGAlgorithms.isPointInRing = function isPointInRing (p, ring) {\n  return CGAlgorithms.locatePointInRing(p, ring) !== Location.EXTERIOR\n};\nCGAlgorithms.computeLength = function computeLength (pts) {\n  var n = pts.size();\n  if (n <= 1) { return 0.0 }\n  var len = 0.0;\n  var p = new Coordinate();\n  pts.getCoordinate(0, p);\n  var x0 = p.x;\n  var y0 = p.y;\n  for (var i = 1; i < n; i++) {\n    pts.getCoordinate(i, p);\n    var x1 = p.x;\n    var y1 = p.y;\n    var dx = x1 - x0;\n    var dy = y1 - y0;\n    len += Math.sqrt(dx * dx + dy * dy);\n    x0 = x1;\n    y0 = y1;\n  }\n  return len\n};\nCGAlgorithms.isCCW = function isCCW (ring) {\n  var nPts = ring.length - 1;\n  if (nPts < 3) { throw new IllegalArgumentException('Ring has fewer than 4 points, so orientation cannot be determined') }\n  var hiPt = ring[0];\n  var hiIndex = 0;\n  for (var i = 1; i <= nPts; i++) {\n    var p = ring[i];\n    if (p.y > hiPt.y) {\n      hiPt = p;\n      hiIndex = i;\n    }\n  }\n  var iPrev = hiIndex;\n  do {\n    iPrev = iPrev - 1;\n    if (iPrev < 0) { iPrev = nPts; }\n  } while (ring[iPrev].equals2D(hiPt) && iPrev !== hiIndex)\n  var iNext = hiIndex;\n  do {\n    iNext = (iNext + 1) % nPts;\n  } while (ring[iNext].equals2D(hiPt) && iNext !== hiIndex)\n  var prev = ring[iPrev];\n  var next = ring[iNext];\n  if (prev.equals2D(hiPt) || next.equals2D(hiPt) || prev.equals2D(next)) { return false }\n  var disc = CGAlgorithms.computeOrientation(prev, hiPt, next);\n  var isCCW = false;\n  if (disc === 0) {\n    isCCW = prev.x > next.x;\n  } else {\n    isCCW = disc > 0;\n  }\n  return isCCW\n};\nCGAlgorithms.locatePointInRing = function locatePointInRing (p, ring) {\n  return RayCrossingCounter.locatePointInRing(p, ring)\n};\nCGAlgorithms.distancePointLinePerpendicular = function distancePointLinePerpendicular (p, A, B) {\n  var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n  var s = ((A.y - p.y) * (B.x - A.x) - (A.x - p.x) * (B.y - A.y)) / len2;\n  return Math.abs(s) * Math.sqrt(len2)\n};\nCGAlgorithms.computeOrientation = function computeOrientation (p1, p2, q) {\n  return CGAlgorithms.orientationIndex(p1, p2, q)\n};\nCGAlgorithms.distancePointLine = function distancePointLine () {\n  if (arguments.length === 2) {\n    var p = arguments[0];\n    var line = arguments[1];\n    if (line.length === 0) { throw new IllegalArgumentException('Line array must contain at least one vertex') }\n    var minDistance = p.distance(line[0]);\n    for (var i = 0; i < line.length - 1; i++) {\n      var dist = CGAlgorithms.distancePointLine(p, line[i], line[i + 1]);\n      if (dist < minDistance) {\n        minDistance = dist;\n      }\n    }\n    return minDistance\n  } else if (arguments.length === 3) {\n    var p$1 = arguments[0];\n    var A = arguments[1];\n    var B = arguments[2];\n    if (A.x === B.x && A.y === B.y) { return p$1.distance(A) }\n    var len2 = (B.x - A.x) * (B.x - A.x) + (B.y - A.y) * (B.y - A.y);\n    var r = ((p$1.x - A.x) * (B.x - A.x) + (p$1.y - A.y) * (B.y - A.y)) / len2;\n    if (r <= 0.0) { return p$1.distance(A) }\n    if (r >= 1.0) { return p$1.distance(B) }\n    var s = ((A.y - p$1.y) * (B.x - A.x) - (A.x - p$1.x) * (B.y - A.y)) / len2;\n    return Math.abs(s) * Math.sqrt(len2)\n  }\n};\nCGAlgorithms.isOnLine = function isOnLine (p, pt) {\n  var lineIntersector = new RobustLineIntersector();\n  for (var i = 1; i < pt.length; i++) {\n    var p0 = pt[i - 1];\n    var p1 = pt[i];\n    lineIntersector.computeIntersection(p, p0, p1);\n    if (lineIntersector.hasIntersection()) {\n      return true\n    }\n  }\n  return false\n};\nstaticAccessors$3.CLOCKWISE.get = function () { return -1 };\nstaticAccessors$3.RIGHT.get = function () { return CGAlgorithms.CLOCKWISE };\nstaticAccessors$3.COUNTERCLOCKWISE.get = function () { return 1 };\nstaticAccessors$3.LEFT.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };\nstaticAccessors$3.COLLINEAR.get = function () { return 0 };\nstaticAccessors$3.STRAIGHT.get = function () { return CGAlgorithms.COLLINEAR };\n\nObject.defineProperties( CGAlgorithms, staticAccessors$3 );\n\nvar GeometryComponentFilter = function GeometryComponentFilter () {};\n\nGeometryComponentFilter.prototype.filter = function filter (geom) {};\nGeometryComponentFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryComponentFilter.prototype.getClass = function getClass () {\n  return GeometryComponentFilter\n};\n\nvar Geometry = function Geometry () {\n  var factory = arguments[0];\n\n  this._envelope = null;\n  this._factory = null;\n  this._SRID = null;\n  this._userData = null;\n  this._factory = factory;\n  this._SRID = factory.getSRID();\n};\n\nvar staticAccessors$11 = { serialVersionUID: { configurable: true },SORTINDEX_POINT: { configurable: true },SORTINDEX_MULTIPOINT: { configurable: true },SORTINDEX_LINESTRING: { configurable: true },SORTINDEX_LINEARRING: { configurable: true },SORTINDEX_MULTILINESTRING: { configurable: true },SORTINDEX_POLYGON: { configurable: true },SORTINDEX_MULTIPOLYGON: { configurable: true },SORTINDEX_GEOMETRYCOLLECTION: { configurable: true },geometryChangedFilter: { configurable: true } };\nGeometry.prototype.isGeometryCollection = function isGeometryCollection () {\n  return this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION\n};\nGeometry.prototype.getFactory = function getFactory () {\n  return this._factory\n};\nGeometry.prototype.getGeometryN = function getGeometryN (n) {\n  return this\n};\nGeometry.prototype.getArea = function getArea () {\n  return 0.0\n};\nGeometry.prototype.isRectangle = function isRectangle () {\n  return false\n};\nGeometry.prototype.equals = function equals () {\n  if (arguments[0] instanceof Geometry) {\n    var g$1 = arguments[0];\n    if (g$1 === null) { return false }\n    return this.equalsTopo(g$1)\n  } else if (arguments[0] instanceof Object) {\n    var o = arguments[0];\n    if (!(o instanceof Geometry)) { return false }\n    var g = o;\n    return this.equalsExact(g)\n  }\n};\nGeometry.prototype.equalsExact = function equalsExact (other) {\n  return this === other || this.equalsExact(other, 0)\n};\nGeometry.prototype.geometryChanged = function geometryChanged () {\n  this.apply(Geometry.geometryChangedFilter);\n};\nGeometry.prototype.geometryChangedAction = function geometryChangedAction () {\n  this._envelope = null;\n};\nGeometry.prototype.equalsNorm = function equalsNorm (g) {\n  if (g === null) { return false }\n  return this.norm().equalsExact(g.norm())\n};\nGeometry.prototype.getLength = function getLength () {\n  return 0.0\n};\nGeometry.prototype.getNumGeometries = function getNumGeometries () {\n  return 1\n};\nGeometry.prototype.compareTo = function compareTo () {\n  if (arguments.length === 1) {\n    var o = arguments[0];\n    var other = o;\n    if (this.getSortIndex() !== other.getSortIndex()) {\n      return this.getSortIndex() - other.getSortIndex()\n    }\n    if (this.isEmpty() && other.isEmpty()) {\n      return 0\n    }\n    if (this.isEmpty()) {\n      return -1\n    }\n    if (other.isEmpty()) {\n      return 1\n    }\n    return this.compareToSameClass(o)\n  } else if (arguments.length === 2) {\n    var other$1 = arguments[0];\n    var comp = arguments[1];\n    if (this.getSortIndex() !== other$1.getSortIndex()) {\n      return this.getSortIndex() - other$1.getSortIndex()\n    }\n    if (this.isEmpty() && other$1.isEmpty()) {\n      return 0\n    }\n    if (this.isEmpty()) {\n      return -1\n    }\n    if (other$1.isEmpty()) {\n      return 1\n    }\n    return this.compareToSameClass(other$1, comp)\n  }\n};\nGeometry.prototype.getUserData = function getUserData () {\n  return this._userData\n};\nGeometry.prototype.getSRID = function getSRID () {\n  return this._SRID\n};\nGeometry.prototype.getEnvelope = function getEnvelope () {\n  return this.getFactory().toGeometry(this.getEnvelopeInternal())\n};\nGeometry.prototype.checkNotGeometryCollection = function checkNotGeometryCollection (g) {\n  if (g.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION) {\n    throw new IllegalArgumentException('This method does not support GeometryCollection arguments')\n  }\n};\nGeometry.prototype.equal = function equal (a, b, tolerance) {\n  if (tolerance === 0) {\n    return a.equals(b)\n  }\n  return a.distance(b) <= tolerance\n};\nGeometry.prototype.norm = function norm () {\n  var copy = this.copy();\n  copy.normalize();\n  return copy\n};\nGeometry.prototype.getPrecisionModel = function getPrecisionModel () {\n  return this._factory.getPrecisionModel()\n};\nGeometry.prototype.getEnvelopeInternal = function getEnvelopeInternal () {\n  if (this._envelope === null) {\n    this._envelope = this.computeEnvelopeInternal();\n  }\n  return new Envelope(this._envelope)\n};\nGeometry.prototype.setSRID = function setSRID (SRID) {\n  this._SRID = SRID;\n};\nGeometry.prototype.setUserData = function setUserData (userData) {\n  this._userData = userData;\n};\nGeometry.prototype.compare = function compare (a, b) {\n  var i = a.iterator();\n  var j = b.iterator();\n  while (i.hasNext() && j.hasNext()) {\n    var aElement = i.next();\n    var bElement = j.next();\n    var comparison = aElement.compareTo(bElement);\n    if (comparison !== 0) {\n      return comparison\n    }\n  }\n  if (i.hasNext()) {\n    return 1\n  }\n  if (j.hasNext()) {\n    return -1\n  }\n  return 0\n};\nGeometry.prototype.hashCode = function hashCode () {\n  return this.getEnvelopeInternal().hashCode()\n};\nGeometry.prototype.isGeometryCollectionOrDerived = function isGeometryCollectionOrDerived () {\n  if (this.getSortIndex() === Geometry.SORTINDEX_GEOMETRYCOLLECTION || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOINT || this.getSortIndex() === Geometry.SORTINDEX_MULTILINESTRING || this.getSortIndex() === Geometry.SORTINDEX_MULTIPOLYGON) {\n    return true\n  }\n  return false\n};\nGeometry.prototype.interfaces_ = function interfaces_ () {\n  return [Clonable, Comparable, Serializable]\n};\nGeometry.prototype.getClass = function getClass () {\n  return Geometry\n};\nGeometry.hasNonEmptyElements = function hasNonEmptyElements (geometries) {\n  for (var i = 0; i < geometries.length; i++) {\n    if (!geometries[i].isEmpty()) {\n      return true\n    }\n  }\n  return false\n};\nGeometry.hasNullElements = function hasNullElements (array) {\n  for (var i = 0; i < array.length; i++) {\n    if (array[i] === null) {\n      return true\n    }\n  }\n  return false\n};\nstaticAccessors$11.serialVersionUID.get = function () { return 8763622679187376702 };\nstaticAccessors$11.SORTINDEX_POINT.get = function () { return 0 };\nstaticAccessors$11.SORTINDEX_MULTIPOINT.get = function () { return 1 };\nstaticAccessors$11.SORTINDEX_LINESTRING.get = function () { return 2 };\nstaticAccessors$11.SORTINDEX_LINEARRING.get = function () { return 3 };\nstaticAccessors$11.SORTINDEX_MULTILINESTRING.get = function () { return 4 };\nstaticAccessors$11.SORTINDEX_POLYGON.get = function () { return 5 };\nstaticAccessors$11.SORTINDEX_MULTIPOLYGON.get = function () { return 6 };\nstaticAccessors$11.SORTINDEX_GEOMETRYCOLLECTION.get = function () { return 7 };\nstaticAccessors$11.geometryChangedFilter.get = function () { return geometryChangedFilter };\n\nObject.defineProperties( Geometry, staticAccessors$11 );\n\nvar geometryChangedFilter = function geometryChangedFilter () {};\n\ngeometryChangedFilter.interfaces_ = function interfaces_ () {\n  return [GeometryComponentFilter]\n};\ngeometryChangedFilter.filter = function filter (geom) {\n  geom.geometryChangedAction();\n};\n\nvar CoordinateFilter = function CoordinateFilter () {};\n\nCoordinateFilter.prototype.filter = function filter (coord) {};\nCoordinateFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateFilter.prototype.getClass = function getClass () {\n  return CoordinateFilter\n};\n\nvar BoundaryNodeRule = function BoundaryNodeRule () {};\n\nvar staticAccessors$12 = { Mod2BoundaryNodeRule: { configurable: true },EndPointBoundaryNodeRule: { configurable: true },MultiValentEndPointBoundaryNodeRule: { configurable: true },MonoValentEndPointBoundaryNodeRule: { configurable: true },MOD2_BOUNDARY_RULE: { configurable: true },ENDPOINT_BOUNDARY_RULE: { configurable: true },MULTIVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true },MONOVALENT_ENDPOINT_BOUNDARY_RULE: { configurable: true },OGC_SFS_BOUNDARY_RULE: { configurable: true } };\n\nBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {};\nBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundaryNodeRule.prototype.getClass = function getClass () {\n  return BoundaryNodeRule\n};\nstaticAccessors$12.Mod2BoundaryNodeRule.get = function () { return Mod2BoundaryNodeRule };\nstaticAccessors$12.EndPointBoundaryNodeRule.get = function () { return EndPointBoundaryNodeRule };\nstaticAccessors$12.MultiValentEndPointBoundaryNodeRule.get = function () { return MultiValentEndPointBoundaryNodeRule };\nstaticAccessors$12.MonoValentEndPointBoundaryNodeRule.get = function () { return MonoValentEndPointBoundaryNodeRule };\nstaticAccessors$12.MOD2_BOUNDARY_RULE.get = function () { return new Mod2BoundaryNodeRule() };\nstaticAccessors$12.ENDPOINT_BOUNDARY_RULE.get = function () { return new EndPointBoundaryNodeRule() };\nstaticAccessors$12.MULTIVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MultiValentEndPointBoundaryNodeRule() };\nstaticAccessors$12.MONOVALENT_ENDPOINT_BOUNDARY_RULE.get = function () { return new MonoValentEndPointBoundaryNodeRule() };\nstaticAccessors$12.OGC_SFS_BOUNDARY_RULE.get = function () { return BoundaryNodeRule.MOD2_BOUNDARY_RULE };\n\nObject.defineProperties( BoundaryNodeRule, staticAccessors$12 );\n\nvar Mod2BoundaryNodeRule = function Mod2BoundaryNodeRule () {};\n\nMod2BoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount % 2 === 1\n};\nMod2BoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMod2BoundaryNodeRule.prototype.getClass = function getClass () {\n  return Mod2BoundaryNodeRule\n};\n\nvar EndPointBoundaryNodeRule = function EndPointBoundaryNodeRule () {};\n\nEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount > 0\n};\nEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return EndPointBoundaryNodeRule\n};\n\nvar MultiValentEndPointBoundaryNodeRule = function MultiValentEndPointBoundaryNodeRule () {};\n\nMultiValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount > 1\n};\nMultiValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMultiValentEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return MultiValentEndPointBoundaryNodeRule\n};\n\nvar MonoValentEndPointBoundaryNodeRule = function MonoValentEndPointBoundaryNodeRule () {};\n\nMonoValentEndPointBoundaryNodeRule.prototype.isInBoundary = function isInBoundary (boundaryCount) {\n  return boundaryCount === 1\n};\nMonoValentEndPointBoundaryNodeRule.prototype.interfaces_ = function interfaces_ () {\n  return [BoundaryNodeRule]\n};\nMonoValentEndPointBoundaryNodeRule.prototype.getClass = function getClass () {\n  return MonoValentEndPointBoundaryNodeRule\n};\n\n// import Iterator from './Iterator'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Collection.html\n *\n * @constructor\n * @private\n */\nvar Collection = function Collection () {};\n\nCollection.prototype.add = function add () {};\n\n/**\n * Appends all of the elements in the specified collection to the end of this\n * list, in the order that they are returned by the specified collection's\n * iterator (optional operation).\n * @param {javascript.util.Collection} c\n * @return {boolean}\n */\nCollection.prototype.addAll = function addAll () {};\n\n/**\n * Returns true if this collection contains no elements.\n * @return {boolean}\n */\nCollection.prototype.isEmpty = function isEmpty () {};\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {javascript.util.Iterator}\n */\nCollection.prototype.iterator = function iterator () {};\n\n/**\n * Returns an iterator over the elements in this collection.\n * @return {number}\n */\nCollection.prototype.size = function size () {};\n\n/**\n * Returns an array containing all of the elements in this collection.\n * @return {Array}\n */\nCollection.prototype.toArray = function toArray () {};\n\n/**\n * Removes a single instance of the specified element from this collection if it\n * is present. (optional)\n * @param {Object} e\n * @return {boolean}\n */\nCollection.prototype.remove = function remove () {};\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction IndexOutOfBoundsException (message) {\n  this.message = message || '';\n}\nIndexOutOfBoundsException.prototype = new Error();\n\n/**\n * @type {string}\n */\nIndexOutOfBoundsException.prototype.name = 'IndexOutOfBoundsException';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Iterator.html\n * @constructor\n * @private\n */\nvar Iterator = function Iterator () {};\n\nIterator.prototype.hasNext = function hasNext () {};\n\n/**\n * Returns the next element in the iteration.\n * @return {Object}\n */\nIterator.prototype.next = function next () {};\n\n/**\n * Removes from the underlying collection the last element returned by the\n * iterator (optional operation).\n */\nIterator.prototype.remove = function remove () {};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/List.html\n *\n * @extends {javascript.util.Collection}\n * @constructor\n * @private\n */\nvar List = (function (Collection$$1) {\n  function List () {\n    Collection$$1.apply(this, arguments);\n  }\n\n  if ( Collection$$1 ) List.__proto__ = Collection$$1;\n  List.prototype = Object.create( Collection$$1 && Collection$$1.prototype );\n  List.prototype.constructor = List;\n\n  List.prototype.get = function get () { };\n\n  /**\n   * Replaces the element at the specified position in this list with the\n   * specified element (optional operation).\n   * @param {number} index\n   * @param {Object} e\n   * @return {Object}\n   */\n  List.prototype.set = function set () { };\n\n  /**\n   * Returns true if this collection contains no elements.\n   * @return {boolean}\n   */\n  List.prototype.isEmpty = function isEmpty () { };\n\n  return List;\n}(Collection));\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction NoSuchElementException (message) {\n  this.message = message || '';\n}\nNoSuchElementException.prototype = new Error();\n\n/**\n * @type {string}\n */\nNoSuchElementException.prototype.name = 'NoSuchElementException';\n\n// import OperationNotSupported from './OperationNotSupported'\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/ArrayList.html\n *\n * @extends List\n * @private\n */\nvar ArrayList = (function (List$$1) {\n  function ArrayList () {\n    List$$1.call(this);\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n\n  if ( List$$1 ) ArrayList.__proto__ = List$$1;\n  ArrayList.prototype = Object.create( List$$1 && List$$1.prototype );\n  ArrayList.prototype.constructor = ArrayList;\n\n  ArrayList.prototype.ensureCapacity = function ensureCapacity () {};\n  ArrayList.prototype.interfaces_ = function interfaces_ () { return [List$$1, Collection] };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.add = function add (e) {\n    if (arguments.length === 1) {\n      this.array_.push(e);\n    } else {\n      this.array_.splice(arguments[0], arguments[1]);\n    }\n    return true\n  };\n\n  ArrayList.prototype.clear = function clear () {\n    this.array_ = [];\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.addAll = function addAll (c) {\n    var this$1 = this;\n\n    for (var i = c.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    return true\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.set = function set (index, element) {\n    var oldElement = this.array_[index];\n    this.array_[index] = element;\n    return oldElement\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.iterator = function iterator () {\n    return new Iterator_(this)\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.get = function get (index) {\n    if (index < 0 || index >= this.size()) {\n      throw new IndexOutOfBoundsException()\n    }\n\n    return this.array_[index]\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.isEmpty = function isEmpty () {\n    return this.array_.length === 0\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.size = function size () {\n    return this.array_.length\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.toArray = function toArray () {\n    var this$1 = this;\n\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this$1.array_[i]);\n    }\n\n    return array\n  };\n\n  /**\n   * @override\n   */\n  ArrayList.prototype.remove = function remove (o) {\n    var this$1 = this;\n\n    var found = false;\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      if (this$1.array_[i] === o) {\n        this$1.array_.splice(i, 1);\n        found = true;\n        break\n      }\n    }\n\n    return found\n  };\n\n  return ArrayList;\n}(List));\n\n/**\n * @extends {Iterator}\n * @param {ArrayList} arrayList\n * @constructor\n * @private\n */\nvar Iterator_ = (function (Iterator$$1) {\n  function Iterator_ (arrayList) {\n    Iterator$$1.call(this);\n    /**\n     * @type {ArrayList}\n     * @private\n    */\n    this.arrayList_ = arrayList;\n    /**\n     * @type {number}\n     * @private\n    */\n    this.position_ = 0;\n  }\n\n  if ( Iterator$$1 ) Iterator_.__proto__ = Iterator$$1;\n  Iterator_.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  Iterator_.prototype.constructor = Iterator_;\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.next = function next () {\n    if (this.position_ === this.arrayList_.size()) {\n      throw new NoSuchElementException()\n    }\n    return this.arrayList_.get(this.position_++)\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.hasNext = function hasNext () {\n    if (this.position_ < this.arrayList_.size()) {\n      return true\n    } else {\n      return false\n    }\n  };\n\n  /**\n   * TODO: should be in ListIterator\n   * @override\n   */\n  Iterator_.prototype.set = function set (element) {\n    return this.arrayList_.set(this.position_ - 1, element)\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.remove = function remove () {\n    this.arrayList_.remove(this.arrayList_.get(this.position_));\n  };\n\n  return Iterator_;\n}(Iterator));\n\nvar CoordinateList = (function (ArrayList$$1) {\n  function CoordinateList () {\n    ArrayList$$1.call(this);\n    if (arguments.length === 0) {\n    } else if (arguments.length === 1) {\n      var coord = arguments[0];\n      this.ensureCapacity(coord.length);\n      this.add(coord, true);\n    } else if (arguments.length === 2) {\n      var coord$1 = arguments[0];\n      var allowRepeated = arguments[1];\n      this.ensureCapacity(coord$1.length);\n      this.add(coord$1, allowRepeated);\n    }\n  }\n\n  if ( ArrayList$$1 ) CoordinateList.__proto__ = ArrayList$$1;\n  CoordinateList.prototype = Object.create( ArrayList$$1 && ArrayList$$1.prototype );\n  CoordinateList.prototype.constructor = CoordinateList;\n\n  var staticAccessors = { coordArrayType: { configurable: true } };\n  staticAccessors.coordArrayType.get = function () { return new Array(0).fill(null) };\n  CoordinateList.prototype.getCoordinate = function getCoordinate (i) {\n    return this.get(i)\n  };\n  CoordinateList.prototype.addAll = function addAll () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var coll = arguments[0];\n      var allowRepeated = arguments[1];\n      var isChanged = false;\n      for (var i = coll.iterator(); i.hasNext();) {\n        this$1.add(i.next(), allowRepeated);\n        isChanged = true;\n      }\n      return isChanged\n    } else { return ArrayList$$1.prototype.addAll.apply(this, arguments) }\n  };\n  CoordinateList.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var clone = ArrayList$$1.prototype.clone.call(this);\n    for (var i = 0; i < this.size(); i++) {\n      clone.add(i, this$1.get(i).copy());\n    }\n    return clone\n  };\n  CoordinateList.prototype.toCoordinateArray = function toCoordinateArray () {\n    return this.toArray(CoordinateList.coordArrayType)\n  };\n  CoordinateList.prototype.add = function add () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var coord = arguments[0];\n      ArrayList$$1.prototype.add.call(this, coord);\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof Array && typeof arguments[1] === 'boolean') {\n        var coord$1 = arguments[0];\n        var allowRepeated = arguments[1];\n        this.add(coord$1, allowRepeated, true);\n        return true\n      } else if (arguments[0] instanceof Coordinate && typeof arguments[1] === 'boolean') {\n        var coord$2 = arguments[0];\n        var allowRepeated$1 = arguments[1];\n        if (!allowRepeated$1) {\n          if (this.size() >= 1) {\n            var last = this.get(this.size() - 1);\n            if (last.equals2D(coord$2)) { return null }\n          }\n        }\n        ArrayList$$1.prototype.add.call(this, coord$2);\n      } else if (arguments[0] instanceof Object && typeof arguments[1] === 'boolean') {\n        var obj = arguments[0];\n        var allowRepeated$2 = arguments[1];\n        this.add(obj, allowRepeated$2);\n        return true\n      }\n    } else if (arguments.length === 3) {\n      if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Array && typeof arguments[1] === 'boolean')) {\n        var coord$3 = arguments[0];\n        var allowRepeated$3 = arguments[1];\n        var direction = arguments[2];\n        if (direction) {\n          for (var i$1 = 0; i$1 < coord$3.length; i$1++) {\n            this$1.add(coord$3[i$1], allowRepeated$3);\n          }\n        } else {\n          for (var i$2 = coord$3.length - 1; i$2 >= 0; i$2--) {\n            this$1.add(coord$3[i$2], allowRepeated$3);\n          }\n        }\n        return true\n      } else if (typeof arguments[2] === 'boolean' && (Number.isInteger(arguments[0]) && arguments[1] instanceof Coordinate)) {\n        var i$3 = arguments[0];\n        var coord$4 = arguments[1];\n        var allowRepeated$4 = arguments[2];\n        if (!allowRepeated$4) {\n          var size = this.size();\n          if (size > 0) {\n            if (i$3 > 0) {\n              var prev = this.get(i$3 - 1);\n              if (prev.equals2D(coord$4)) { return null }\n            }\n            if (i$3 < size) {\n              var next = this.get(i$3);\n              if (next.equals2D(coord$4)) { return null }\n            }\n          }\n        }\n        ArrayList$$1.prototype.add.call(this, i$3, coord$4);\n      }\n    } else if (arguments.length === 4) {\n      var coord$5 = arguments[0];\n      var allowRepeated$5 = arguments[1];\n      var start = arguments[2];\n      var end = arguments[3];\n      var inc = 1;\n      if (start > end) { inc = -1; }\n      for (var i = start; i !== end; i += inc) {\n        this$1.add(coord$5[i], allowRepeated$5);\n      }\n      return true\n    }\n  };\n  CoordinateList.prototype.closeRing = function closeRing () {\n    if (this.size() > 0) { this.add(new Coordinate(this.get(0)), false); }\n  };\n  CoordinateList.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  CoordinateList.prototype.getClass = function getClass () {\n    return CoordinateList\n  };\n\n  Object.defineProperties( CoordinateList, staticAccessors );\n\n  return CoordinateList;\n}(ArrayList));\n\nvar CoordinateArrays = function CoordinateArrays () {};\n\nvar staticAccessors$13 = { ForwardComparator: { configurable: true },BidirectionalComparator: { configurable: true },coordArrayType: { configurable: true } };\n\nstaticAccessors$13.ForwardComparator.get = function () { return ForwardComparator };\nstaticAccessors$13.BidirectionalComparator.get = function () { return BidirectionalComparator };\nstaticAccessors$13.coordArrayType.get = function () { return new Array(0).fill(null) };\n\nCoordinateArrays.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateArrays.prototype.getClass = function getClass () {\n  return CoordinateArrays\n};\nCoordinateArrays.isRing = function isRing (pts) {\n  if (pts.length < 4) { return false }\n  if (!pts[0].equals2D(pts[pts.length - 1])) { return false }\n  return true\n};\nCoordinateArrays.ptNotInList = function ptNotInList (testPts, pts) {\n  for (var i = 0; i < testPts.length; i++) {\n    var testPt = testPts[i];\n    if (CoordinateArrays.indexOf(testPt, pts) < 0) { return testPt }\n  }\n  return null\n};\nCoordinateArrays.scroll = function scroll (coordinates, firstCoordinate) {\n  var i = CoordinateArrays.indexOf(firstCoordinate, coordinates);\n  if (i < 0) { return null }\n  var newCoordinates = new Array(coordinates.length).fill(null);\n  System.arraycopy(coordinates, i, newCoordinates, 0, coordinates.length - i);\n  System.arraycopy(coordinates, 0, newCoordinates, coordinates.length - i, i);\n  System.arraycopy(newCoordinates, 0, coordinates, 0, coordinates.length);\n};\nCoordinateArrays.equals = function equals () {\n  if (arguments.length === 2) {\n    var coord1 = arguments[0];\n    var coord2 = arguments[1];\n    if (coord1 === coord2) { return true }\n    if (coord1 === null || coord2 === null) { return false }\n    if (coord1.length !== coord2.length) { return false }\n    for (var i = 0; i < coord1.length; i++) {\n      if (!coord1[i].equals(coord2[i])) { return false }\n    }\n    return true\n  } else if (arguments.length === 3) {\n    var coord1$1 = arguments[0];\n    var coord2$1 = arguments[1];\n    var coordinateComparator = arguments[2];\n    if (coord1$1 === coord2$1) { return true }\n    if (coord1$1 === null || coord2$1 === null) { return false }\n    if (coord1$1.length !== coord2$1.length) { return false }\n    for (var i$1 = 0; i$1 < coord1$1.length; i$1++) {\n      if (coordinateComparator.compare(coord1$1[i$1], coord2$1[i$1]) !== 0) { return false }\n    }\n    return true\n  }\n};\nCoordinateArrays.intersection = function intersection (coordinates, env) {\n  var coordList = new CoordinateList();\n  for (var i = 0; i < coordinates.length; i++) {\n    if (env.intersects(coordinates[i])) { coordList.add(coordinates[i], true); }\n  }\n  return coordList.toCoordinateArray()\n};\nCoordinateArrays.hasRepeatedPoints = function hasRepeatedPoints (coord) {\n  for (var i = 1; i < coord.length; i++) {\n    if (coord[i - 1].equals(coord[i])) {\n      return true\n    }\n  }\n  return false\n};\nCoordinateArrays.removeRepeatedPoints = function removeRepeatedPoints (coord) {\n  if (!CoordinateArrays.hasRepeatedPoints(coord)) { return coord }\n  var coordList = new CoordinateList(coord, false);\n  return coordList.toCoordinateArray()\n};\nCoordinateArrays.reverse = function reverse (coord) {\n  var last = coord.length - 1;\n  var mid = Math.trunc(last / 2);\n  for (var i = 0; i <= mid; i++) {\n    var tmp = coord[i];\n    coord[i] = coord[last - i];\n    coord[last - i] = tmp;\n  }\n};\nCoordinateArrays.removeNull = function removeNull (coord) {\n  var nonNull = 0;\n  for (var i = 0; i < coord.length; i++) {\n    if (coord[i] !== null) { nonNull++; }\n  }\n  var newCoord = new Array(nonNull).fill(null);\n  if (nonNull === 0) { return newCoord }\n  var j = 0;\n  for (var i$1 = 0; i$1 < coord.length; i$1++) {\n    if (coord[i$1] !== null) { newCoord[j++] = coord[i$1]; }\n  }\n  return newCoord\n};\nCoordinateArrays.copyDeep = function copyDeep () {\n  if (arguments.length === 1) {\n    var coordinates = arguments[0];\n    var copy = new Array(coordinates.length).fill(null);\n    for (var i = 0; i < coordinates.length; i++) {\n      copy[i] = new Coordinate(coordinates[i]);\n    }\n    return copy\n  } else if (arguments.length === 5) {\n    var src = arguments[0];\n    var srcStart = arguments[1];\n    var dest = arguments[2];\n    var destStart = arguments[3];\n    var length = arguments[4];\n    for (var i$1 = 0; i$1 < length; i$1++) {\n      dest[destStart + i$1] = new Coordinate(src[srcStart + i$1]);\n    }\n  }\n};\nCoordinateArrays.isEqualReversed = function isEqualReversed (pts1, pts2) {\n  for (var i = 0; i < pts1.length; i++) {\n    var p1 = pts1[i];\n    var p2 = pts2[pts1.length - i - 1];\n    if (p1.compareTo(p2) !== 0) { return false }\n  }\n  return true\n};\nCoordinateArrays.envelope = function envelope (coordinates) {\n  var env = new Envelope();\n  for (var i = 0; i < coordinates.length; i++) {\n    env.expandToInclude(coordinates[i]);\n  }\n  return env\n};\nCoordinateArrays.toCoordinateArray = function toCoordinateArray (coordList) {\n  return coordList.toArray(CoordinateArrays.coordArrayType)\n};\nCoordinateArrays.atLeastNCoordinatesOrNothing = function atLeastNCoordinatesOrNothing (n, c) {\n  return c.length >= n ? c : []\n};\nCoordinateArrays.indexOf = function indexOf (coordinate, coordinates) {\n  for (var i = 0; i < coordinates.length; i++) {\n    if (coordinate.equals(coordinates[i])) {\n      return i\n    }\n  }\n  return -1\n};\nCoordinateArrays.increasingDirection = function increasingDirection (pts) {\n  for (var i = 0; i < Math.trunc(pts.length / 2); i++) {\n    var j = pts.length - 1 - i;\n    var comp = pts[i].compareTo(pts[j]);\n    if (comp !== 0) { return comp }\n  }\n  return 1\n};\nCoordinateArrays.compare = function compare (pts1, pts2) {\n  var i = 0;\n  while (i < pts1.length && i < pts2.length) {\n    var compare = pts1[i].compareTo(pts2[i]);\n    if (compare !== 0) { return compare }\n    i++;\n  }\n  if (i < pts2.length) { return -1 }\n  if (i < pts1.length) { return 1 }\n  return 0\n};\nCoordinateArrays.minCoordinate = function minCoordinate (coordinates) {\n  var minCoord = null;\n  for (var i = 0; i < coordinates.length; i++) {\n    if (minCoord === null || minCoord.compareTo(coordinates[i]) > 0) {\n      minCoord = coordinates[i];\n    }\n  }\n  return minCoord\n};\nCoordinateArrays.extract = function extract (pts, start, end) {\n  start = MathUtil.clamp(start, 0, pts.length);\n  end = MathUtil.clamp(end, -1, pts.length);\n  var npts = end - start + 1;\n  if (end < 0) { npts = 0; }\n  if (start >= pts.length) { npts = 0; }\n  if (end < start) { npts = 0; }\n  var extractPts = new Array(npts).fill(null);\n  if (npts === 0) { return extractPts }\n  var iPts = 0;\n  for (var i = start; i <= end; i++) {\n    extractPts[iPts++] = pts[i];\n  }\n  return extractPts\n};\n\nObject.defineProperties( CoordinateArrays, staticAccessors$13 );\n\nvar ForwardComparator = function ForwardComparator () {};\n\nForwardComparator.prototype.compare = function compare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  return CoordinateArrays.compare(pts1, pts2)\n};\nForwardComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nForwardComparator.prototype.getClass = function getClass () {\n  return ForwardComparator\n};\n\nvar BidirectionalComparator = function BidirectionalComparator () {};\n\nBidirectionalComparator.prototype.compare = function compare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  if (pts1.length < pts2.length) { return -1 }\n  if (pts1.length > pts2.length) { return 1 }\n  if (pts1.length === 0) { return 0 }\n  var forwardComp = CoordinateArrays.compare(pts1, pts2);\n  var isEqualRev = CoordinateArrays.isEqualReversed(pts1, pts2);\n  if (isEqualRev) { return 0 }\n  return forwardComp\n};\nBidirectionalComparator.prototype.OLDcompare = function OLDcompare (o1, o2) {\n  var pts1 = o1;\n  var pts2 = o2;\n  if (pts1.length < pts2.length) { return -1 }\n  if (pts1.length > pts2.length) { return 1 }\n  if (pts1.length === 0) { return 0 }\n  var dir1 = CoordinateArrays.increasingDirection(pts1);\n  var dir2 = CoordinateArrays.increasingDirection(pts2);\n  var i1 = dir1 > 0 ? 0 : pts1.length - 1;\n  var i2 = dir2 > 0 ? 0 : pts1.length - 1;\n  for (var i = 0; i < pts1.length; i++) {\n    var comparePt = pts1[i1].compareTo(pts2[i2]);\n    if (comparePt !== 0) { return comparePt }\n    i1 += dir1;\n    i2 += dir2;\n  }\n  return 0\n};\nBidirectionalComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nBidirectionalComparator.prototype.getClass = function getClass () {\n  return BidirectionalComparator\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Map.html\n *\n * @constructor\n * @private\n */\nvar Map$1 = function Map () {};\n\nMap$1.prototype.get = function get () {};\n/**\n * Associates the specified value with the specified key in this map (optional\n * operation).\n * @param {Object} key\n * @param {Object} value\n * @return {Object}\n */\nMap$1.prototype.put = function put () {};\n\n/**\n * Returns the number of key-value mappings in this map.\n * @return {number}\n */\nMap$1.prototype.size = function size () {};\n\n/**\n * Returns a Collection view of the values contained in this map.\n * @return {javascript.util.Collection}\n */\nMap$1.prototype.values = function values () {};\n\n/**\n * Returns a {@link Set} view of the mappings contained in this map.\n * The set is backed by the map, so changes to the map are\n * reflected in the set, and vice-versa.If the map is modified\n * while an iteration over the set is in progress (except through\n * the iterator's own <tt>remove</tt> operation, or through the\n * <tt>setValue</tt> operation on a map entry returned by the\n * iterator) the results of the iteration are undefined.The set\n * supports element removal, which removes the corresponding\n * mapping from the map, via the <tt>Iterator.remove</tt>,\n * <tt>Set.remove</tt>, <tt>removeAll</tt>, <tt>retainAll</tt> and\n * <tt>clear</tt> operations.It does not support the\n * <tt>add</tt> or <tt>addAll</tt> operations.\n *\n * @return {Set} a set view of the mappings contained in this map\n */\nMap$1.prototype.entrySet = function entrySet () {};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedMap.html\n *\n * @extends {Map}\n * @constructor\n * @private\n */\nvar SortedMap = (function (Map) {\n\tfunction SortedMap () {\n\t\tMap.apply(this, arguments);\n\t}if ( Map ) SortedMap.__proto__ = Map;\n\tSortedMap.prototype = Object.create( Map && Map.prototype );\n\tSortedMap.prototype.constructor = SortedMap;\n\n\t\n\n\treturn SortedMap;\n}(Map$1));\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction OperationNotSupported (message) {\n  this.message = message || '';\n}\nOperationNotSupported.prototype = new Error();\n\n/**\n * @type {string}\n */\nOperationNotSupported.prototype.name = 'OperationNotSupported';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Set.html\n *\n * @extends {Collection}\n * @constructor\n * @private\n */\nfunction Set() {}\nSet.prototype = new Collection();\n\n\n/**\n * Returns true if this set contains the specified element. More formally,\n * returns true if and only if this set contains an element e such that (o==null ?\n * e==null : o.equals(e)).\n * @param {Object} e\n * @return {boolean}\n */\nSet.prototype.contains = function() {};\n\n/**\n * @see http://docs.oracle.com/javase/6/docs/api/java/util/HashSet.html\n *\n * @extends {javascript.util.Set}\n * @constructor\n * @private\n */\nvar HashSet = (function (Set$$1) {\n  function HashSet () {\n    Set$$1.call(this);\n    this.array_ = [];\n\n    if (arguments[0] instanceof Collection) {\n      this.addAll(arguments[0]);\n    }\n  }\n\n  if ( Set$$1 ) HashSet.__proto__ = Set$$1;\n  HashSet.prototype = Object.create( Set$$1 && Set$$1.prototype );\n  HashSet.prototype.constructor = HashSet;\n\n  /**\n   * @override\n   */\n  HashSet.prototype.contains = function contains (o) {\n    var this$1 = this;\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      var e = this$1.array_[i];\n      if (e === o) {\n        return true\n      }\n    }\n    return false\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.add = function add (o) {\n    if (this.contains(o)) {\n      return false\n    }\n\n    this.array_.push(o);\n\n    return true\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.addAll = function addAll (c) {\n    var this$1 = this;\n\n    for (var i = c.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    return true\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.remove = function remove (o) {\n    // throw new javascript.util.OperationNotSupported()\n    throw new Error()\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.size = function size () {\n    return this.array_.length\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.isEmpty = function isEmpty () {\n    return this.array_.length === 0\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.toArray = function toArray () {\n    var this$1 = this;\n\n    var array = [];\n\n    for (var i = 0, len = this.array_.length; i < len; i++) {\n      array.push(this$1.array_[i]);\n    }\n\n    return array\n  };\n\n  /**\n   * @override\n   */\n  HashSet.prototype.iterator = function iterator () {\n    return new Iterator_$1(this)\n  };\n\n  return HashSet;\n}(Set));\n\n/**\n   * @extends {Iterator}\n   * @param {HashSet} hashSet\n   * @constructor\n   * @private\n   */\nvar Iterator_$1 = (function (Iterator$$1) {\n  function Iterator_ (hashSet) {\n    Iterator$$1.call(this);\n    /**\n     * @type {HashSet}\n     * @private\n     */\n    this.hashSet_ = hashSet;\n    /**\n     * @type {number}\n     * @private\n     */\n    this.position_ = 0;\n  }\n\n  if ( Iterator$$1 ) Iterator_.__proto__ = Iterator$$1;\n  Iterator_.prototype = Object.create( Iterator$$1 && Iterator$$1.prototype );\n  Iterator_.prototype.constructor = Iterator_;\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.next = function next () {\n    if (this.position_ === this.hashSet_.size()) {\n      throw new NoSuchElementException()\n    }\n    return this.hashSet_.array_[this.position_++]\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.hasNext = function hasNext () {\n    if (this.position_ < this.hashSet_.size()) {\n      return true\n    } else {\n      return false\n    }\n  };\n\n  /**\n   * @override\n   */\n  Iterator_.prototype.remove = function remove () {\n    throw new OperationNotSupported()\n  };\n\n  return Iterator_;\n}(Iterator));\n\nvar BLACK = 0;\nvar RED = 1;\nfunction colorOf (p) { return (p === null ? BLACK : p.color) }\nfunction parentOf (p) { return (p === null ? null : p.parent) }\nfunction setColor (p, c) { if (p !== null) { p.color = c; } }\nfunction leftOf (p) { return (p === null ? null : p.left) }\nfunction rightOf (p) { return (p === null ? null : p.right) }\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeMap.html\n *\n * @extends {SortedMap}\n * @constructor\n * @private\n */\nfunction TreeMap () {\n  /**\n   * @type {Object}\n   * @private\n   */\n  this.root_ = null;\n  /**\n   * @type {number}\n   * @private\n  */\n  this.size_ = 0;\n}\nTreeMap.prototype = new SortedMap();\n\n/**\n * @override\n */\nTreeMap.prototype.get = function (key) {\n  var p = this.root_;\n  while (p !== null) {\n    var cmp = key['compareTo'](p.key);\n    if (cmp < 0) { p = p.left; }\n    else if (cmp > 0) { p = p.right; }\n    else { return p.value }\n  }\n  return null\n};\n\n/**\n * @override\n */\nTreeMap.prototype.put = function (key, value) {\n  if (this.root_ === null) {\n    this.root_ = {\n      key: key,\n      value: value,\n      left: null,\n      right: null,\n      parent: null,\n      color: BLACK,\n      getValue: function getValue () { return this.value },\n      getKey: function getKey () { return this.key }\n    };\n    this.size_ = 1;\n    return null\n  }\n  var t = this.root_;\n  var parent;\n  var cmp;\n  do {\n    parent = t;\n    cmp = key['compareTo'](t.key);\n    if (cmp < 0) {\n      t = t.left;\n    } else if (cmp > 0) {\n      t = t.right;\n    } else {\n      var oldValue = t.value;\n      t.value = value;\n      return oldValue\n    }\n  } while (t !== null)\n  var e = {\n    key: key,\n    left: null,\n    right: null,\n    value: value,\n    parent: parent,\n    color: BLACK,\n    getValue: function getValue () { return this.value },\n    getKey: function getKey () { return this.key }\n  };\n  if (cmp < 0) {\n    parent.left = e;\n  } else {\n    parent.right = e;\n  }\n  this.fixAfterInsertion(e);\n  this.size_++;\n  return null\n};\n\n/**\n * @param {Object} x\n */\nTreeMap.prototype.fixAfterInsertion = function (x) {\n  var this$1 = this;\n\n  x.color = RED;\n  while (x != null && x !== this.root_ && x.parent.color === RED) {\n    if (parentOf(x) === leftOf(parentOf(parentOf(x)))) {\n      var y = rightOf(parentOf(parentOf(x)));\n      if (colorOf(y) === RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x === rightOf(parentOf(x))) {\n          x = parentOf(x);\n          this$1.rotateLeft(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this$1.rotateRight(parentOf(parentOf(x)));\n      }\n    } else {\n      var y$1 = leftOf(parentOf(parentOf(x)));\n      if (colorOf(y$1) === RED) {\n        setColor(parentOf(x), BLACK);\n        setColor(y$1, BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        x = parentOf(parentOf(x));\n      } else {\n        if (x === leftOf(parentOf(x))) {\n          x = parentOf(x);\n          this$1.rotateRight(x);\n        }\n        setColor(parentOf(x), BLACK);\n        setColor(parentOf(parentOf(x)), RED);\n        this$1.rotateLeft(parentOf(parentOf(x)));\n      }\n    }\n  }\n  this.root_.color = BLACK;\n};\n\n/**\n * @override\n */\nTreeMap.prototype.values = function () {\n  var arrayList = new ArrayList();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    arrayList.add(p.value);\n    while ((p = TreeMap.successor(p)) !== null) {\n      arrayList.add(p.value);\n    }\n  }\n  return arrayList\n};\n\n/**\n * @override\n */\nTreeMap.prototype.entrySet = function () {\n  var hashSet = new HashSet();\n  var p = this.getFirstEntry();\n  if (p !== null) {\n    hashSet.add(p);\n    while ((p = TreeMap.successor(p)) !== null) {\n      hashSet.add(p);\n    }\n  }\n  return hashSet\n};\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateLeft = function (p) {\n  if (p != null) {\n    var r = p.right;\n    p.right = r.left;\n    if (r.left != null) { r.left.parent = p; }\n    r.parent = p.parent;\n    if (p.parent === null) { this.root_ = r; } else if (p.parent.left === p) { p.parent.left = r; } else { p.parent.right = r; }\n    r.left = p;\n    p.parent = r;\n  }\n};\n\n/**\n * @param {Object} p\n */\nTreeMap.prototype.rotateRight = function (p) {\n  if (p != null) {\n    var l = p.left;\n    p.left = l.right;\n    if (l.right != null) { l.right.parent = p; }\n    l.parent = p.parent;\n    if (p.parent === null) { this.root_ = l; } else if (p.parent.right === p) { p.parent.right = l; } else { p.parent.left = l; }\n    l.right = p;\n    p.parent = l;\n  }\n};\n\n/**\n * @return {Object}\n */\nTreeMap.prototype.getFirstEntry = function () {\n  var p = this.root_;\n  if (p != null) {\n    while (p.left != null) {\n      p = p.left;\n    }\n  }\n  return p\n};\n\n/**\n * @param {Object} t\n * @return {Object}\n * @private\n */\nTreeMap.successor = function (t) {\n  if (t === null) { return null } else if (t.right !== null) {\n    var p = t.right;\n    while (p.left !== null) {\n      p = p.left;\n    }\n    return p\n  } else {\n    var p$1 = t.parent;\n    var ch = t;\n    while (p$1 !== null && ch === p$1.right) {\n      ch = p$1;\n      p$1 = p$1.parent;\n    }\n    return p$1\n  }\n};\n\n/**\n * @override\n */\nTreeMap.prototype.size = function () {\n  return this.size_\n};\n\nvar Lineal = function Lineal () {};\n\nLineal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineal.prototype.getClass = function getClass () {\n  return Lineal\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/SortedSet.html\n *\n * @extends {Set}\n * @constructor\n * @private\n */\nfunction SortedSet () {}\nSortedSet.prototype = new Set();\n\n// import Iterator from './Iterator'\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/TreeSet.html\n *\n * @extends {SortedSet}\n * @constructor\n * @private\n */\nfunction TreeSet () {\n  /**\n   * @type {Array}\n   * @private\n  */\n  this.array_ = [];\n\n  if (arguments[0] instanceof Collection) {\n    this.addAll(arguments[0]);\n  }\n}\nTreeSet.prototype = new SortedSet();\n\n/**\n * @override\n */\nTreeSet.prototype.contains = function (o) {\n  var this$1 = this;\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this$1.array_[i];\n    if (e['compareTo'](o) === 0) {\n      return true\n    }\n  }\n  return false\n};\n\n/**\n * @override\n */\nTreeSet.prototype.add = function (o) {\n  var this$1 = this;\n\n  if (this.contains(o)) {\n    return false\n  }\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    var e = this$1.array_[i];\n    if (e['compareTo'](o) === 1) {\n      this$1.array_.splice(i, 0, o);\n      return true\n    }\n  }\n\n  this.array_.push(o);\n\n  return true\n};\n\n/**\n * @override\n */\nTreeSet.prototype.addAll = function (c) {\n  var this$1 = this;\n\n  for (var i = c.iterator(); i.hasNext();) {\n    this$1.add(i.next());\n  }\n  return true\n};\n\n/**\n * @override\n */\nTreeSet.prototype.remove = function (e) {\n  throw new OperationNotSupported()\n};\n\n/**\n * @override\n */\nTreeSet.prototype.size = function () {\n  return this.array_.length\n};\n\n/**\n * @override\n */\nTreeSet.prototype.isEmpty = function () {\n  return this.array_.length === 0\n};\n\n/**\n * @override\n */\nTreeSet.prototype.toArray = function () {\n  var this$1 = this;\n\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this$1.array_[i]);\n  }\n\n  return array\n};\n\n/**\n * @override\n */\nTreeSet.prototype.iterator = function () {\n  return new Iterator_$2(this)\n};\n\n/**\n * @extends {javascript.util.Iterator}\n * @param {javascript.util.TreeSet} treeSet\n * @constructor\n * @private\n */\nvar Iterator_$2 = function (treeSet) {\n  /**\n   * @type {javascript.util.TreeSet}\n   * @private\n   */\n  this.treeSet_ = treeSet;\n  /**\n   * @type {number}\n   * @private\n   */\n  this.position_ = 0;\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.next = function () {\n  if (this.position_ === this.treeSet_.size()) {\n    throw new NoSuchElementException()\n  }\n  return this.treeSet_.array_[this.position_++]\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.hasNext = function () {\n  if (this.position_ < this.treeSet_.size()) {\n    return true\n  } else {\n    return false\n  }\n};\n\n/**\n * @override\n */\nIterator_$2.prototype.remove = function () {\n  throw new OperationNotSupported()\n};\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Arrays.html\n *\n * @constructor\n * @private\n */\nvar Arrays = function Arrays () {};\n\nArrays.sort = function sort () {\n  var a = arguments[0];\n  var i;\n  var t;\n  var comparator;\n  var compare;\n  if (arguments.length === 1) {\n    compare = function (a, b) {\n      return a.compareTo(b)\n    };\n    a.sort(compare);\n  } else if (arguments.length === 2) {\n    comparator = arguments[1];\n    compare = function (a, b) {\n      return comparator['compare'](a, b)\n    };\n    a.sort(compare);\n  } else if (arguments.length === 3) {\n    t = a.slice(arguments[1], arguments[2]);\n    t.sort();\n    var r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n  } else if (arguments.length === 4) {\n    t = a.slice(arguments[1], arguments[2]);\n    comparator = arguments[3];\n    compare = function (a, b) {\n      return comparator['compare'](a, b)\n    };\n    t.sort(compare);\n    r = a.slice(0, arguments[1]).concat(t, a.slice(arguments[2], a.length));\n    a.splice(0, a.length);\n    for (i = 0; i < r.length; i++) {\n      a.push(r[i]);\n    }\n  }\n};\n/**\n * @param {Array} array\n * @return {ArrayList}\n */\nArrays.asList = function asList (array) {\n  var arrayList = new ArrayList();\n  for (var i = 0, len = array.length; i < len; i++) {\n    arrayList.add(array[i]);\n  }\n  return arrayList\n};\n\nvar Dimension = function Dimension () {};\n\nvar staticAccessors$14 = { P: { configurable: true },L: { configurable: true },A: { configurable: true },FALSE: { configurable: true },TRUE: { configurable: true },DONTCARE: { configurable: true },SYM_FALSE: { configurable: true },SYM_TRUE: { configurable: true },SYM_DONTCARE: { configurable: true },SYM_P: { configurable: true },SYM_L: { configurable: true },SYM_A: { configurable: true } };\n\nstaticAccessors$14.P.get = function () { return 0 };\nstaticAccessors$14.L.get = function () { return 1 };\nstaticAccessors$14.A.get = function () { return 2 };\nstaticAccessors$14.FALSE.get = function () { return -1 };\nstaticAccessors$14.TRUE.get = function () { return -2 };\nstaticAccessors$14.DONTCARE.get = function () { return -3 };\nstaticAccessors$14.SYM_FALSE.get = function () { return 'F' };\nstaticAccessors$14.SYM_TRUE.get = function () { return 'T' };\nstaticAccessors$14.SYM_DONTCARE.get = function () { return '*' };\nstaticAccessors$14.SYM_P.get = function () { return '0' };\nstaticAccessors$14.SYM_L.get = function () { return '1' };\nstaticAccessors$14.SYM_A.get = function () { return '2' };\n\nDimension.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDimension.prototype.getClass = function getClass () {\n  return Dimension\n};\nDimension.toDimensionSymbol = function toDimensionSymbol (dimensionValue) {\n  switch (dimensionValue) {\n    case Dimension.FALSE:\n      return Dimension.SYM_FALSE\n    case Dimension.TRUE:\n      return Dimension.SYM_TRUE\n    case Dimension.DONTCARE:\n      return Dimension.SYM_DONTCARE\n    case Dimension.P:\n      return Dimension.SYM_P\n    case Dimension.L:\n      return Dimension.SYM_L\n    case Dimension.A:\n      return Dimension.SYM_A\n    default:\n  }\n  throw new IllegalArgumentException('Unknown dimension value: ' + dimensionValue)\n};\nDimension.toDimensionValue = function toDimensionValue (dimensionSymbol) {\n  switch (Character.toUpperCase(dimensionSymbol)) {\n    case Dimension.SYM_FALSE:\n      return Dimension.FALSE\n    case Dimension.SYM_TRUE:\n      return Dimension.TRUE\n    case Dimension.SYM_DONTCARE:\n      return Dimension.DONTCARE\n    case Dimension.SYM_P:\n      return Dimension.P\n    case Dimension.SYM_L:\n      return Dimension.L\n    case Dimension.SYM_A:\n      return Dimension.A\n    default:\n  }\n  throw new IllegalArgumentException('Unknown dimension symbol: ' + dimensionSymbol)\n};\n\nObject.defineProperties( Dimension, staticAccessors$14 );\n\nvar GeometryFilter = function GeometryFilter () {};\n\nGeometryFilter.prototype.filter = function filter (geom) {};\nGeometryFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryFilter.prototype.getClass = function getClass () {\n  return GeometryFilter\n};\n\nvar CoordinateSequenceFilter = function CoordinateSequenceFilter () {};\n\nCoordinateSequenceFilter.prototype.filter = function filter (seq, i) {};\nCoordinateSequenceFilter.prototype.isDone = function isDone () {};\nCoordinateSequenceFilter.prototype.isGeometryChanged = function isGeometryChanged () {};\nCoordinateSequenceFilter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequenceFilter.prototype.getClass = function getClass () {\n  return CoordinateSequenceFilter\n};\n\nvar GeometryCollection = (function (Geometry$$1) {\n  function GeometryCollection (geometries, factory) {\n    Geometry$$1.call(this, factory);\n    this._geometries = geometries || [];\n\n    if (Geometry$$1.hasNullElements(this._geometries)) {\n      throw new IllegalArgumentException('geometries must not contain null elements')\n    }\n  }\n\n  if ( Geometry$$1 ) GeometryCollection.__proto__ = Geometry$$1;\n  GeometryCollection.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  GeometryCollection.prototype.constructor = GeometryCollection;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  GeometryCollection.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    var this$1 = this;\n\n    var envelope = new Envelope();\n    for (var i = 0; i < this._geometries.length; i++) {\n      envelope.expandToInclude(this$1._geometries[i].getEnvelopeInternal());\n    }\n    return envelope\n  };\n  GeometryCollection.prototype.getGeometryN = function getGeometryN (n) {\n    return this._geometries[n]\n  };\n  GeometryCollection.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_GEOMETRYCOLLECTION\n  };\n  GeometryCollection.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n    var coordinates = new Array(this.getNumPoints()).fill(null);\n    var k = -1;\n    for (var i = 0; i < this._geometries.length; i++) {\n      var childCoordinates = this$1._geometries[i].getCoordinates();\n      for (var j = 0; j < childCoordinates.length; j++) {\n        k++;\n        coordinates[k] = childCoordinates[j];\n      }\n    }\n    return coordinates\n  };\n  GeometryCollection.prototype.getArea = function getArea () {\n    var this$1 = this;\n\n    var area = 0.0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      area += this$1._geometries[i].getArea();\n    }\n    return area\n  };\n  GeometryCollection.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherCollection = other;\n      if (this._geometries.length !== otherCollection._geometries.length) {\n        return false\n      }\n      for (var i = 0; i < this._geometries.length; i++) {\n        if (!this$1._geometries[i].equalsExact(otherCollection._geometries[i], tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  GeometryCollection.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    for (var i = 0; i < this._geometries.length; i++) {\n      this$1._geometries[i].normalize();\n    }\n    Arrays.sort(this._geometries);\n  };\n  GeometryCollection.prototype.getCoordinate = function getCoordinate () {\n    if (this.isEmpty()) { return null }\n    return this._geometries[0].getCoordinate()\n  };\n  GeometryCollection.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    var this$1 = this;\n\n    var dimension = Dimension.FALSE;\n    for (var i = 0; i < this._geometries.length; i++) {\n      dimension = Math.max(dimension, this$1._geometries[i].getBoundaryDimension());\n    }\n    return dimension\n  };\n  GeometryCollection.prototype.getDimension = function getDimension () {\n    var this$1 = this;\n\n    var dimension = Dimension.FALSE;\n    for (var i = 0; i < this._geometries.length; i++) {\n      dimension = Math.max(dimension, this$1._geometries[i].getDimension());\n    }\n    return dimension\n  };\n  GeometryCollection.prototype.getLength = function getLength () {\n    var this$1 = this;\n\n    var sum = 0.0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      sum += this$1._geometries[i].getLength();\n    }\n    return sum\n  };\n  GeometryCollection.prototype.getNumPoints = function getNumPoints () {\n    var this$1 = this;\n\n    var numPoints = 0;\n    for (var i = 0; i < this._geometries.length; i++) {\n      numPoints += this$1._geometries[i].getNumPoints();\n    }\n    return numPoints\n  };\n  GeometryCollection.prototype.getNumGeometries = function getNumGeometries () {\n    return this._geometries.length\n  };\n  GeometryCollection.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var n = this._geometries.length;\n    var revGeoms = new Array(n).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revGeoms[i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createGeometryCollection(revGeoms)\n  };\n  GeometryCollection.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var theseElements = new TreeSet(Arrays.asList(this._geometries));\n      var otherElements = new TreeSet(Arrays.asList(o._geometries));\n      return this.compare(theseElements, otherElements)\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var gc = o$1;\n      var n1 = this.getNumGeometries();\n      var n2 = gc.getNumGeometries();\n      var i = 0;\n      while (i < n1 && i < n2) {\n        var thisGeom = this$1.getGeometryN(i);\n        var otherGeom = gc.getGeometryN(i);\n        var holeComp = thisGeom.compareToSameClass(otherGeom, comp);\n        if (holeComp !== 0) { return holeComp }\n        i++;\n      }\n      if (i < n1) { return 1 }\n      if (i < n2) { return -1 }\n      return 0\n    }\n  };\n  GeometryCollection.prototype.apply = function apply () {\n    var this$1 = this;\n\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      for (var i = 0; i < this._geometries.length; i++) {\n        this$1._geometries[i].apply(filter);\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this._geometries.length === 0) { return null }\n      for (var i$1 = 0; i$1 < this._geometries.length; i$1++) {\n        this$1._geometries[i$1].apply(filter$1);\n        if (filter$1.isDone()) {\n          break\n        }\n      }\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n      for (var i$2 = 0; i$2 < this._geometries.length; i$2++) {\n        this$1._geometries[i$2].apply(filter$2);\n      }\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n      for (var i$3 = 0; i$3 < this._geometries.length; i$3++) {\n        this$1._geometries[i$3].apply(filter$3);\n      }\n    }\n  };\n  GeometryCollection.prototype.getBoundary = function getBoundary () {\n    this.checkNotGeometryCollection(this);\n    Assert.shouldNeverReachHere();\n    return null\n  };\n  GeometryCollection.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var gc = Geometry$$1.prototype.clone.call(this);\n    gc._geometries = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      gc._geometries[i] = this$1._geometries[i].clone();\n    }\n    return gc\n  };\n  GeometryCollection.prototype.getGeometryType = function getGeometryType () {\n    return 'GeometryCollection'\n  };\n  GeometryCollection.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var geometries = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < geometries.length; i++) {\n      geometries[i] = this$1._geometries[i].copy();\n    }\n    return new GeometryCollection(geometries, this._factory)\n  };\n  GeometryCollection.prototype.isEmpty = function isEmpty () {\n    var this$1 = this;\n\n    for (var i = 0; i < this._geometries.length; i++) {\n      if (!this$1._geometries[i].isEmpty()) {\n        return false\n      }\n    }\n    return true\n  };\n  GeometryCollection.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  GeometryCollection.prototype.getClass = function getClass () {\n    return GeometryCollection\n  };\n  staticAccessors.serialVersionUID.get = function () { return -5694727726395021467 };\n\n  Object.defineProperties( GeometryCollection, staticAccessors );\n\n  return GeometryCollection;\n}(Geometry));\n\nvar MultiLineString = (function (GeometryCollection$$1) {\n  function MultiLineString () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiLineString.__proto__ = GeometryCollection$$1;\n  MultiLineString.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiLineString.prototype.constructor = MultiLineString;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiLineString.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTILINESTRING\n  };\n  MultiLineString.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiLineString.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    if (this.isClosed()) {\n      return Dimension.FALSE\n    }\n    return 0\n  };\n  MultiLineString.prototype.isClosed = function isClosed () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return false\n    }\n    for (var i = 0; i < this._geometries.length; i++) {\n      if (!this$1._geometries[i].isClosed()) {\n        return false\n      }\n    }\n    return true\n  };\n  MultiLineString.prototype.getDimension = function getDimension () {\n    return 1\n  };\n  MultiLineString.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var nLines = this._geometries.length;\n    var revLines = new Array(nLines).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revLines[nLines - 1 - i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createMultiLineString(revLines)\n  };\n  MultiLineString.prototype.getBoundary = function getBoundary () {\n    return new BoundaryOp(this).getBoundary()\n  };\n  MultiLineString.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiLineString'\n  };\n  MultiLineString.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var lineStrings = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < lineStrings.length; i++) {\n      lineStrings[i] = this$1._geometries[i].copy();\n    }\n    return new MultiLineString(lineStrings, this._factory)\n  };\n  MultiLineString.prototype.interfaces_ = function interfaces_ () {\n    return [Lineal]\n  };\n  MultiLineString.prototype.getClass = function getClass () {\n    return MultiLineString\n  };\n  staticAccessors.serialVersionUID.get = function () { return 8166665132445433741 };\n\n  Object.defineProperties( MultiLineString, staticAccessors );\n\n  return MultiLineString;\n}(GeometryCollection));\n\nvar BoundaryOp = function BoundaryOp () {\n  this._geom = null;\n  this._geomFact = null;\n  this._bnRule = null;\n  this._endpointMap = null;\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    var bnRule = BoundaryNodeRule.MOD2_BOUNDARY_RULE;\n    this._geom = geom;\n    this._geomFact = geom.getFactory();\n    this._bnRule = bnRule;\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var bnRule$1 = arguments[1];\n    this._geom = geom$1;\n    this._geomFact = geom$1.getFactory();\n    this._bnRule = bnRule$1;\n  }\n};\nBoundaryOp.prototype.boundaryMultiLineString = function boundaryMultiLineString (mLine) {\n  if (this._geom.isEmpty()) {\n    return this.getEmptyMultiPoint()\n  }\n  var bdyPts = this.computeBoundaryCoordinates(mLine);\n  if (bdyPts.length === 1) {\n    return this._geomFact.createPoint(bdyPts[0])\n  }\n  return this._geomFact.createMultiPointFromCoords(bdyPts)\n};\nBoundaryOp.prototype.getBoundary = function getBoundary () {\n  if (this._geom instanceof LineString) { return this.boundaryLineString(this._geom) }\n  if (this._geom instanceof MultiLineString) { return this.boundaryMultiLineString(this._geom) }\n  return this._geom.getBoundary()\n};\nBoundaryOp.prototype.boundaryLineString = function boundaryLineString (line) {\n  if (this._geom.isEmpty()) {\n    return this.getEmptyMultiPoint()\n  }\n  if (line.isClosed()) {\n    var closedEndpointOnBoundary = this._bnRule.isInBoundary(2);\n    if (closedEndpointOnBoundary) {\n      return line.getStartPoint()\n    } else {\n      return this._geomFact.createMultiPoint()\n    }\n  }\n  return this._geomFact.createMultiPoint([line.getStartPoint(), line.getEndPoint()])\n};\nBoundaryOp.prototype.getEmptyMultiPoint = function getEmptyMultiPoint () {\n  return this._geomFact.createMultiPoint()\n};\nBoundaryOp.prototype.computeBoundaryCoordinates = function computeBoundaryCoordinates (mLine) {\n    var this$1 = this;\n\n  var bdyPts = new ArrayList();\n  this._endpointMap = new TreeMap();\n  for (var i = 0; i < mLine.getNumGeometries(); i++) {\n    var line = mLine.getGeometryN(i);\n    if (line.getNumPoints() === 0) { continue }\n    this$1.addEndpoint(line.getCoordinateN(0));\n    this$1.addEndpoint(line.getCoordinateN(line.getNumPoints() - 1));\n  }\n  for (var it = this._endpointMap.entrySet().iterator(); it.hasNext();) {\n    var entry = it.next();\n    var counter = entry.getValue();\n    var valence = counter.count;\n    if (this$1._bnRule.isInBoundary(valence)) {\n      bdyPts.add(entry.getKey());\n    }\n  }\n  return CoordinateArrays.toCoordinateArray(bdyPts)\n};\nBoundaryOp.prototype.addEndpoint = function addEndpoint (pt) {\n  var counter = this._endpointMap.get(pt);\n  if (counter === null) {\n    counter = new Counter();\n    this._endpointMap.put(pt, counter);\n  }\n  counter.count++;\n};\nBoundaryOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundaryOp.prototype.getClass = function getClass () {\n  return BoundaryOp\n};\nBoundaryOp.getBoundary = function getBoundary () {\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    var bop = new BoundaryOp(g);\n    return bop.getBoundary()\n  } else if (arguments.length === 2) {\n    var g$1 = arguments[0];\n    var bnRule = arguments[1];\n    var bop$1 = new BoundaryOp(g$1, bnRule);\n    return bop$1.getBoundary()\n  }\n};\n\nvar Counter = function Counter () {\n  this.count = null;\n};\nCounter.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCounter.prototype.getClass = function getClass () {\n  return Counter\n};\n\n// boundary\n\nfunction PrintStream () {}\n\nfunction StringReader () {}\n\nvar DecimalFormat = function DecimalFormat () {};\n\nfunction ByteArrayOutputStream () {}\n\nfunction IOException () {}\n\nfunction LineNumberReader () {}\n\nvar StringUtil = function StringUtil () {};\n\nvar staticAccessors$15 = { NEWLINE: { configurable: true },SIMPLE_ORDINATE_FORMAT: { configurable: true } };\n\nStringUtil.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nStringUtil.prototype.getClass = function getClass () {\n  return StringUtil\n};\nStringUtil.chars = function chars (c, n) {\n  var ch = new Array(n).fill(null);\n  for (var i = 0; i < n; i++) {\n    ch[i] = c;\n  }\n  return String(ch)\n};\nStringUtil.getStackTrace = function getStackTrace () {\n  if (arguments.length === 1) {\n    var t = arguments[0];\n    var os = new ByteArrayOutputStream();\n    var ps = new PrintStream(os);\n    t.printStackTrace(ps);\n    return os.toString()\n  } else if (arguments.length === 2) {\n    var t$1 = arguments[0];\n    var depth = arguments[1];\n    var stackTrace = '';\n    var stringReader = new StringReader(StringUtil.getStackTrace(t$1));\n    var lineNumberReader = new LineNumberReader(stringReader);\n    for (var i = 0; i < depth; i++) {\n      try {\n        stackTrace += lineNumberReader.readLine() + StringUtil.NEWLINE;\n      } catch (e) {\n        if (e instanceof IOException) {\n          Assert.shouldNeverReachHere();\n        } else { throw e }\n      } finally {}\n    }\n    return stackTrace\n  }\n};\nStringUtil.split = function split (s, separator) {\n  var separatorlen = separator.length;\n  var tokenList = new ArrayList();\n  var tmpString = '' + s;\n  var pos = tmpString.indexOf(separator);\n  while (pos >= 0) {\n    var token = tmpString.substring(0, pos);\n    tokenList.add(token);\n    tmpString = tmpString.substring(pos + separatorlen);\n    pos = tmpString.indexOf(separator);\n  }\n  if (tmpString.length > 0) { tokenList.add(tmpString); }\n  var res = new Array(tokenList.size()).fill(null);\n  for (var i = 0; i < res.length; i++) {\n    res[i] = tokenList.get(i);\n  }\n  return res\n};\nStringUtil.toString = function toString () {\n  if (arguments.length === 1) {\n    var d = arguments[0];\n    return StringUtil.SIMPLE_ORDINATE_FORMAT.format(d)\n  }\n};\nStringUtil.spaces = function spaces (n) {\n  return StringUtil.chars(' ', n)\n};\nstaticAccessors$15.NEWLINE.get = function () { return System.getProperty('line.separator') };\nstaticAccessors$15.SIMPLE_ORDINATE_FORMAT.get = function () { return new DecimalFormat('0.#') };\n\nObject.defineProperties( StringUtil, staticAccessors$15 );\n\nvar CoordinateSequences = function CoordinateSequences () {};\n\nCoordinateSequences.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCoordinateSequences.prototype.getClass = function getClass () {\n  return CoordinateSequences\n};\nCoordinateSequences.copyCoord = function copyCoord (src, srcPos, dest, destPos) {\n  var minDim = Math.min(src.getDimension(), dest.getDimension());\n  for (var dim = 0; dim < minDim; dim++) {\n    dest.setOrdinate(destPos, dim, src.getOrdinate(srcPos, dim));\n  }\n};\nCoordinateSequences.isRing = function isRing (seq) {\n  var n = seq.size();\n  if (n === 0) { return true }\n  if (n <= 3) { return false }\n  return seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y)\n};\nCoordinateSequences.isEqual = function isEqual (cs1, cs2) {\n  var cs1Size = cs1.size();\n  var cs2Size = cs2.size();\n  if (cs1Size !== cs2Size) { return false }\n  var dim = Math.min(cs1.getDimension(), cs2.getDimension());\n  for (var i = 0; i < cs1Size; i++) {\n    for (var d = 0; d < dim; d++) {\n      var v1 = cs1.getOrdinate(i, d);\n      var v2 = cs2.getOrdinate(i, d);\n      if (cs1.getOrdinate(i, d) === cs2.getOrdinate(i, d)) { continue }\n      if (Double.isNaN(v1) && Double.isNaN(v2)) { continue }\n      return false\n    }\n  }\n  return true\n};\nCoordinateSequences.extend = function extend (fact, seq, size) {\n  var newseq = fact.create(size, seq.getDimension());\n  var n = seq.size();\n  CoordinateSequences.copy(seq, 0, newseq, 0, n);\n  if (n > 0) {\n    for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, n - 1, newseq, i, 1); }\n  }\n  return newseq\n};\nCoordinateSequences.reverse = function reverse (seq) {\n  var last = seq.size() - 1;\n  var mid = Math.trunc(last / 2);\n  for (var i = 0; i <= mid; i++) {\n    CoordinateSequences.swap(seq, i, last - i);\n  }\n};\nCoordinateSequences.swap = function swap (seq, i, j) {\n  if (i === j) { return null }\n  for (var dim = 0; dim < seq.getDimension(); dim++) {\n    var tmp = seq.getOrdinate(i, dim);\n    seq.setOrdinate(i, dim, seq.getOrdinate(j, dim));\n    seq.setOrdinate(j, dim, tmp);\n  }\n};\nCoordinateSequences.copy = function copy (src, srcPos, dest, destPos, length) {\n  for (var i = 0; i < length; i++) {\n    CoordinateSequences.copyCoord(src, srcPos + i, dest, destPos + i);\n  }\n};\nCoordinateSequences.toString = function toString () {\n  if (arguments.length === 1) {\n    var cs = arguments[0];\n    var size = cs.size();\n    if (size === 0) { return '()' }\n    var dim = cs.getDimension();\n    var buf = new StringBuffer();\n    buf.append('(');\n    for (var i = 0; i < size; i++) {\n      if (i > 0) { buf.append(' '); }\n      for (var d = 0; d < dim; d++) {\n        if (d > 0) { buf.append(','); }\n        buf.append(StringUtil.toString(cs.getOrdinate(i, d)));\n      }\n    }\n    buf.append(')');\n    return buf.toString()\n  }\n};\nCoordinateSequences.ensureValidRing = function ensureValidRing (fact, seq) {\n  var n = seq.size();\n  if (n === 0) { return seq }\n  if (n <= 3) { return CoordinateSequences.createClosedRing(fact, seq, 4) }\n  var isClosed = seq.getOrdinate(0, CoordinateSequence.X) === seq.getOrdinate(n - 1, CoordinateSequence.X) && seq.getOrdinate(0, CoordinateSequence.Y) === seq.getOrdinate(n - 1, CoordinateSequence.Y);\n  if (isClosed) { return seq }\n  return CoordinateSequences.createClosedRing(fact, seq, n + 1)\n};\nCoordinateSequences.createClosedRing = function createClosedRing (fact, seq, size) {\n  var newseq = fact.create(size, seq.getDimension());\n  var n = seq.size();\n  CoordinateSequences.copy(seq, 0, newseq, 0, n);\n  for (var i = n; i < size; i++) { CoordinateSequences.copy(seq, 0, newseq, i, 1); }\n  return newseq\n};\n\nvar LineString = (function (Geometry$$1) {\n  function LineString (points, factory) {\n    Geometry$$1.call(this, factory);\n    this._points = null;\n    this.init(points);\n  }\n\n  if ( Geometry$$1 ) LineString.__proto__ = Geometry$$1;\n  LineString.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  LineString.prototype.constructor = LineString;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  LineString.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    if (this.isEmpty()) {\n      return new Envelope()\n    }\n    return this._points.expandEnvelope(new Envelope())\n  };\n  LineString.prototype.isRing = function isRing () {\n    return this.isClosed() && this.isSimple()\n  };\n  LineString.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_LINESTRING\n  };\n  LineString.prototype.getCoordinates = function getCoordinates () {\n    return this._points.toCoordinateArray()\n  };\n  LineString.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherLineString = other;\n      if (this._points.size() !== otherLineString._points.size()) {\n        return false\n      }\n      for (var i = 0; i < this._points.size(); i++) {\n        if (!this$1.equal(this$1._points.getCoordinate(i), otherLineString._points.getCoordinate(i), tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  LineString.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    for (var i = 0; i < Math.trunc(this._points.size() / 2); i++) {\n      var j = this$1._points.size() - 1 - i;\n      if (!this$1._points.getCoordinate(i).equals(this$1._points.getCoordinate(j))) {\n        if (this$1._points.getCoordinate(i).compareTo(this$1._points.getCoordinate(j)) > 0) {\n          CoordinateSequences.reverse(this$1._points);\n        }\n        return null\n      }\n    }\n  };\n  LineString.prototype.getCoordinate = function getCoordinate () {\n    if (this.isEmpty()) { return null }\n    return this._points.getCoordinate(0)\n  };\n  LineString.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    if (this.isClosed()) {\n      return Dimension.FALSE\n    }\n    return 0\n  };\n  LineString.prototype.isClosed = function isClosed () {\n    if (this.isEmpty()) {\n      return false\n    }\n    return this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints() - 1))\n  };\n  LineString.prototype.getEndPoint = function getEndPoint () {\n    if (this.isEmpty()) {\n      return null\n    }\n    return this.getPointN(this.getNumPoints() - 1)\n  };\n  LineString.prototype.getDimension = function getDimension () {\n    return 1\n  };\n  LineString.prototype.getLength = function getLength () {\n    return CGAlgorithms.computeLength(this._points)\n  };\n  LineString.prototype.getNumPoints = function getNumPoints () {\n    return this._points.size()\n  };\n  LineString.prototype.reverse = function reverse () {\n    var seq = this._points.copy();\n    CoordinateSequences.reverse(seq);\n    var revLine = this.getFactory().createLineString(seq);\n    return revLine\n  };\n  LineString.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var line = o;\n      var i = 0;\n      var j = 0;\n      while (i < this._points.size() && j < line._points.size()) {\n        var comparison = this$1._points.getCoordinate(i).compareTo(line._points.getCoordinate(j));\n        if (comparison !== 0) {\n          return comparison\n        }\n        i++;\n        j++;\n      }\n      if (i < this._points.size()) {\n        return 1\n      }\n      if (j < line._points.size()) {\n        return -1\n      }\n      return 0\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var line$1 = o$1;\n      return comp.compare(this._points, line$1._points)\n    }\n  };\n  LineString.prototype.apply = function apply () {\n    var this$1 = this;\n\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      for (var i = 0; i < this._points.size(); i++) {\n        filter.filter(this$1._points.getCoordinate(i));\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this._points.size() === 0) { return null }\n      for (var i$1 = 0; i$1 < this._points.size(); i$1++) {\n        filter$1.filter(this$1._points, i$1);\n        if (filter$1.isDone()) { break }\n      }\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n    }\n  };\n  LineString.prototype.getBoundary = function getBoundary () {\n    return new BoundaryOp(this).getBoundary()\n  };\n  LineString.prototype.isEquivalentClass = function isEquivalentClass (other) {\n    return other instanceof LineString\n  };\n  LineString.prototype.clone = function clone () {\n    var ls = Geometry$$1.prototype.clone.call(this);\n    ls._points = this._points.clone();\n    return ls\n  };\n  LineString.prototype.getCoordinateN = function getCoordinateN (n) {\n    return this._points.getCoordinate(n)\n  };\n  LineString.prototype.getGeometryType = function getGeometryType () {\n    return 'LineString'\n  };\n  LineString.prototype.copy = function copy () {\n    return new LineString(this._points.copy(), this._factory)\n  };\n  LineString.prototype.getCoordinateSequence = function getCoordinateSequence () {\n    return this._points\n  };\n  LineString.prototype.isEmpty = function isEmpty () {\n    return this._points.size() === 0\n  };\n  LineString.prototype.init = function init (points) {\n    if (points === null) {\n      points = this.getFactory().getCoordinateSequenceFactory().create([]);\n    }\n    if (points.size() === 1) {\n      throw new IllegalArgumentException('Invalid number of points in LineString (found ' + points.size() + ' - must be 0 or >= 2)')\n    }\n    this._points = points;\n  };\n  LineString.prototype.isCoordinate = function isCoordinate (pt) {\n    var this$1 = this;\n\n    for (var i = 0; i < this._points.size(); i++) {\n      if (this$1._points.getCoordinate(i).equals(pt)) {\n        return true\n      }\n    }\n    return false\n  };\n  LineString.prototype.getStartPoint = function getStartPoint () {\n    if (this.isEmpty()) {\n      return null\n    }\n    return this.getPointN(0)\n  };\n  LineString.prototype.getPointN = function getPointN (n) {\n    return this.getFactory().createPoint(this._points.getCoordinate(n))\n  };\n  LineString.prototype.interfaces_ = function interfaces_ () {\n    return [Lineal]\n  };\n  LineString.prototype.getClass = function getClass () {\n    return LineString\n  };\n  staticAccessors.serialVersionUID.get = function () { return 3110669828065365560 };\n\n  Object.defineProperties( LineString, staticAccessors );\n\n  return LineString;\n}(Geometry));\n\nvar Puntal = function Puntal () {};\n\nPuntal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPuntal.prototype.getClass = function getClass () {\n  return Puntal\n};\n\nvar Point = (function (Geometry$$1) {\n  function Point (coordinates, factory) {\n    Geometry$$1.call(this, factory);\n    this._coordinates = coordinates || null;\n    this.init(this._coordinates);\n  }\n\n  if ( Geometry$$1 ) Point.__proto__ = Geometry$$1;\n  Point.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  Point.prototype.constructor = Point;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  Point.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    if (this.isEmpty()) {\n      return new Envelope()\n    }\n    var env = new Envelope();\n    env.expandToInclude(this._coordinates.getX(0), this._coordinates.getY(0));\n    return env\n  };\n  Point.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_POINT\n  };\n  Point.prototype.getCoordinates = function getCoordinates () {\n    return this.isEmpty() ? [] : [this.getCoordinate()]\n  };\n  Point.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      if (this.isEmpty() && other.isEmpty()) {\n        return true\n      }\n      if (this.isEmpty() !== other.isEmpty()) {\n        return false\n      }\n      return this.equal(other.getCoordinate(), this.getCoordinate(), tolerance)\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  Point.prototype.normalize = function normalize () {};\n  Point.prototype.getCoordinate = function getCoordinate () {\n    return this._coordinates.size() !== 0 ? this._coordinates.getCoordinate(0) : null\n  };\n  Point.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  Point.prototype.getDimension = function getDimension () {\n    return 0\n  };\n  Point.prototype.getNumPoints = function getNumPoints () {\n    return this.isEmpty() ? 0 : 1\n  };\n  Point.prototype.reverse = function reverse () {\n    return this.copy()\n  };\n  Point.prototype.getX = function getX () {\n    if (this.getCoordinate() === null) {\n      throw new Error('getX called on empty Point')\n    }\n    return this.getCoordinate().x\n  };\n  Point.prototype.compareToSameClass = function compareToSameClass () {\n    if (arguments.length === 1) {\n      var other = arguments[0];\n      var point$1 = other;\n      return this.getCoordinate().compareTo(point$1.getCoordinate())\n    } else if (arguments.length === 2) {\n      var other$1 = arguments[0];\n      var comp = arguments[1];\n      var point = other$1;\n      return comp.compare(this._coordinates, point._coordinates)\n    }\n  };\n  Point.prototype.apply = function apply () {\n    if (hasInterface(arguments[0], CoordinateFilter)) {\n      var filter = arguments[0];\n      if (this.isEmpty()) {\n        return null\n      }\n      filter.filter(this.getCoordinate());\n    } else if (hasInterface(arguments[0], CoordinateSequenceFilter)) {\n      var filter$1 = arguments[0];\n      if (this.isEmpty()) { return null }\n      filter$1.filter(this._coordinates, 0);\n      if (filter$1.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(arguments[0], GeometryFilter)) {\n      var filter$2 = arguments[0];\n      filter$2.filter(this);\n    } else if (hasInterface(arguments[0], GeometryComponentFilter)) {\n      var filter$3 = arguments[0];\n      filter$3.filter(this);\n    }\n  };\n  Point.prototype.getBoundary = function getBoundary () {\n    return this.getFactory().createGeometryCollection(null)\n  };\n  Point.prototype.clone = function clone () {\n    var p = Geometry$$1.prototype.clone.call(this);\n    p._coordinates = this._coordinates.clone();\n    return p\n  };\n  Point.prototype.getGeometryType = function getGeometryType () {\n    return 'Point'\n  };\n  Point.prototype.copy = function copy () {\n    return new Point(this._coordinates.copy(), this._factory)\n  };\n  Point.prototype.getCoordinateSequence = function getCoordinateSequence () {\n    return this._coordinates\n  };\n  Point.prototype.getY = function getY () {\n    if (this.getCoordinate() === null) {\n      throw new Error('getY called on empty Point')\n    }\n    return this.getCoordinate().y\n  };\n  Point.prototype.isEmpty = function isEmpty () {\n    return this._coordinates.size() === 0\n  };\n  Point.prototype.init = function init (coordinates) {\n    if (coordinates === null) {\n      coordinates = this.getFactory().getCoordinateSequenceFactory().create([]);\n    }\n    Assert.isTrue(coordinates.size() <= 1);\n    this._coordinates = coordinates;\n  };\n  Point.prototype.isSimple = function isSimple () {\n    return true\n  };\n  Point.prototype.interfaces_ = function interfaces_ () {\n    return [Puntal]\n  };\n  Point.prototype.getClass = function getClass () {\n    return Point\n  };\n  staticAccessors.serialVersionUID.get = function () { return 4902022702746614570 };\n\n  Object.defineProperties( Point, staticAccessors );\n\n  return Point;\n}(Geometry));\n\nvar Polygonal = function Polygonal () {};\n\nPolygonal.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPolygonal.prototype.getClass = function getClass () {\n  return Polygonal\n};\n\nvar Polygon = (function (Geometry$$1) {\n  function Polygon (shell, holes, factory) {\n    Geometry$$1.call(this, factory);\n    this._shell = null;\n    this._holes = null;\n    if (shell === null) {\n      shell = this.getFactory().createLinearRing();\n    }\n    if (holes === null) {\n      holes = [];\n    }\n    if (Geometry$$1.hasNullElements(holes)) {\n      throw new IllegalArgumentException('holes must not contain null elements')\n    }\n    if (shell.isEmpty() && Geometry$$1.hasNonEmptyElements(holes)) {\n      throw new IllegalArgumentException('shell is empty but holes are not')\n    }\n    this._shell = shell;\n    this._holes = holes;\n  }\n\n  if ( Geometry$$1 ) Polygon.__proto__ = Geometry$$1;\n  Polygon.prototype = Object.create( Geometry$$1 && Geometry$$1.prototype );\n  Polygon.prototype.constructor = Polygon;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n  Polygon.prototype.computeEnvelopeInternal = function computeEnvelopeInternal () {\n    return this._shell.getEnvelopeInternal()\n  };\n  Polygon.prototype.getSortIndex = function getSortIndex () {\n    return Geometry$$1.SORTINDEX_POLYGON\n  };\n  Polygon.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return []\n    }\n    var coordinates = new Array(this.getNumPoints()).fill(null);\n    var k = -1;\n    var shellCoordinates = this._shell.getCoordinates();\n    for (var x = 0; x < shellCoordinates.length; x++) {\n      k++;\n      coordinates[k] = shellCoordinates[x];\n    }\n    for (var i = 0; i < this._holes.length; i++) {\n      var childCoordinates = this$1._holes[i].getCoordinates();\n      for (var j = 0; j < childCoordinates.length; j++) {\n        k++;\n        coordinates[k] = childCoordinates[j];\n      }\n    }\n    return coordinates\n  };\n  Polygon.prototype.getArea = function getArea () {\n    var this$1 = this;\n\n    var area = 0.0;\n    area += Math.abs(CGAlgorithms.signedArea(this._shell.getCoordinateSequence()));\n    for (var i = 0; i < this._holes.length; i++) {\n      area -= Math.abs(CGAlgorithms.signedArea(this$1._holes[i].getCoordinateSequence()));\n    }\n    return area\n  };\n  Polygon.prototype.isRectangle = function isRectangle () {\n    if (this.getNumInteriorRing() !== 0) { return false }\n    if (this._shell === null) { return false }\n    if (this._shell.getNumPoints() !== 5) { return false }\n    var seq = this._shell.getCoordinateSequence();\n    var env = this.getEnvelopeInternal();\n    for (var i = 0; i < 5; i++) {\n      var x = seq.getX(i);\n      if (!(x === env.getMinX() || x === env.getMaxX())) { return false }\n      var y = seq.getY(i);\n      if (!(y === env.getMinY() || y === env.getMaxY())) { return false }\n    }\n    var prevX = seq.getX(0);\n    var prevY = seq.getY(0);\n    for (var i$1 = 1; i$1 <= 4; i$1++) {\n      var x$1 = seq.getX(i$1);\n      var y$1 = seq.getY(i$1);\n      var xChanged = x$1 !== prevX;\n      var yChanged = y$1 !== prevY;\n      if (xChanged === yChanged) { return false }\n      prevX = x$1;\n      prevY = y$1;\n    }\n    return true\n  };\n  Polygon.prototype.equalsExact = function equalsExact () {\n    var this$1 = this;\n\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      var otherPolygon = other;\n      var thisShell = this._shell;\n      var otherPolygonShell = otherPolygon._shell;\n      if (!thisShell.equalsExact(otherPolygonShell, tolerance)) {\n        return false\n      }\n      if (this._holes.length !== otherPolygon._holes.length) {\n        return false\n      }\n      for (var i = 0; i < this._holes.length; i++) {\n        if (!this$1._holes[i].equalsExact(otherPolygon._holes[i], tolerance)) {\n          return false\n        }\n      }\n      return true\n    } else { return Geometry$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  Polygon.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n    if (arguments.length === 0) {\n      this.normalize(this._shell, true);\n      for (var i = 0; i < this._holes.length; i++) {\n        this$1.normalize(this$1._holes[i], false);\n      }\n      Arrays.sort(this._holes);\n    } else if (arguments.length === 2) {\n      var ring = arguments[0];\n      var clockwise = arguments[1];\n      if (ring.isEmpty()) {\n        return null\n      }\n      var uniqueCoordinates = new Array(ring.getCoordinates().length - 1).fill(null);\n      System.arraycopy(ring.getCoordinates(), 0, uniqueCoordinates, 0, uniqueCoordinates.length);\n      var minCoordinate = CoordinateArrays.minCoordinate(ring.getCoordinates());\n      CoordinateArrays.scroll(uniqueCoordinates, minCoordinate);\n      System.arraycopy(uniqueCoordinates, 0, ring.getCoordinates(), 0, uniqueCoordinates.length);\n      ring.getCoordinates()[uniqueCoordinates.length] = uniqueCoordinates[0];\n      if (CGAlgorithms.isCCW(ring.getCoordinates()) === clockwise) {\n        CoordinateArrays.reverse(ring.getCoordinates());\n      }\n    }\n  };\n  Polygon.prototype.getCoordinate = function getCoordinate () {\n    return this._shell.getCoordinate()\n  };\n  Polygon.prototype.getNumInteriorRing = function getNumInteriorRing () {\n    return this._holes.length\n  };\n  Polygon.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return 1\n  };\n  Polygon.prototype.getDimension = function getDimension () {\n    return 2\n  };\n  Polygon.prototype.getLength = function getLength () {\n    var this$1 = this;\n\n    var len = 0.0;\n    len += this._shell.getLength();\n    for (var i = 0; i < this._holes.length; i++) {\n      len += this$1._holes[i].getLength();\n    }\n    return len\n  };\n  Polygon.prototype.getNumPoints = function getNumPoints () {\n    var this$1 = this;\n\n    var numPoints = this._shell.getNumPoints();\n    for (var i = 0; i < this._holes.length; i++) {\n      numPoints += this$1._holes[i].getNumPoints();\n    }\n    return numPoints\n  };\n  Polygon.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var poly = this.copy();\n    poly._shell = this._shell.copy().reverse();\n    poly._holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < this._holes.length; i++) {\n      poly._holes[i] = this$1._holes[i].copy().reverse();\n    }\n    return poly\n  };\n  Polygon.prototype.convexHull = function convexHull () {\n    return this.getExteriorRing().convexHull()\n  };\n  Polygon.prototype.compareToSameClass = function compareToSameClass () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var o = arguments[0];\n      var thisShell = this._shell;\n      var otherShell = o._shell;\n      return thisShell.compareToSameClass(otherShell)\n    } else if (arguments.length === 2) {\n      var o$1 = arguments[0];\n      var comp = arguments[1];\n      var poly = o$1;\n      var thisShell$1 = this._shell;\n      var otherShell$1 = poly._shell;\n      var shellComp = thisShell$1.compareToSameClass(otherShell$1, comp);\n      if (shellComp !== 0) { return shellComp }\n      var nHole1 = this.getNumInteriorRing();\n      var nHole2 = poly.getNumInteriorRing();\n      var i = 0;\n      while (i < nHole1 && i < nHole2) {\n        var thisHole = this$1.getInteriorRingN(i);\n        var otherHole = poly.getInteriorRingN(i);\n        var holeComp = thisHole.compareToSameClass(otherHole, comp);\n        if (holeComp !== 0) { return holeComp }\n        i++;\n      }\n      if (i < nHole1) { return 1 }\n      if (i < nHole2) { return -1 }\n      return 0\n    }\n  };\n  Polygon.prototype.apply = function apply (filter) {\n    var this$1 = this;\n\n    if (hasInterface(filter, CoordinateFilter)) {\n      this._shell.apply(filter);\n      for (var i$1 = 0; i$1 < this._holes.length; i$1++) {\n        this$1._holes[i$1].apply(filter);\n      }\n    } else if (hasInterface(filter, CoordinateSequenceFilter)) {\n      this._shell.apply(filter);\n      if (!filter.isDone()) {\n        for (var i$2 = 0; i$2 < this._holes.length; i$2++) {\n          this$1._holes[i$2].apply(filter);\n          if (filter.isDone()) { break }\n        }\n      }\n      if (filter.isGeometryChanged()) { this.geometryChanged(); }\n    } else if (hasInterface(filter, GeometryFilter)) {\n      filter.filter(this);\n    } else if (hasInterface(filter, GeometryComponentFilter)) {\n      filter.filter(this);\n      this._shell.apply(filter);\n      for (var i = 0; i < this._holes.length; i++) {\n        this$1._holes[i].apply(filter);\n      }\n    }\n  };\n  Polygon.prototype.getBoundary = function getBoundary () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return this.getFactory().createMultiLineString()\n    }\n    var rings = new Array(this._holes.length + 1).fill(null);\n    rings[0] = this._shell;\n    for (var i = 0; i < this._holes.length; i++) {\n      rings[i + 1] = this$1._holes[i];\n    }\n    if (rings.length <= 1) { return this.getFactory().createLinearRing(rings[0].getCoordinateSequence()) }\n    return this.getFactory().createMultiLineString(rings)\n  };\n  Polygon.prototype.clone = function clone () {\n    var this$1 = this;\n\n    var poly = Geometry$$1.prototype.clone.call(this);\n    poly._shell = this._shell.clone();\n    poly._holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < this._holes.length; i++) {\n      poly._holes[i] = this$1._holes[i].clone();\n    }\n    return poly\n  };\n  Polygon.prototype.getGeometryType = function getGeometryType () {\n    return 'Polygon'\n  };\n  Polygon.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var shell = this._shell.copy();\n    var holes = new Array(this._holes.length).fill(null);\n    for (var i = 0; i < holes.length; i++) {\n      holes[i] = this$1._holes[i].copy();\n    }\n    return new Polygon(shell, holes, this._factory)\n  };\n  Polygon.prototype.getExteriorRing = function getExteriorRing () {\n    return this._shell\n  };\n  Polygon.prototype.isEmpty = function isEmpty () {\n    return this._shell.isEmpty()\n  };\n  Polygon.prototype.getInteriorRingN = function getInteriorRingN (n) {\n    return this._holes[n]\n  };\n  Polygon.prototype.interfaces_ = function interfaces_ () {\n    return [Polygonal]\n  };\n  Polygon.prototype.getClass = function getClass () {\n    return Polygon\n  };\n  staticAccessors.serialVersionUID.get = function () { return -3494792200821764533 };\n\n  Object.defineProperties( Polygon, staticAccessors );\n\n  return Polygon;\n}(Geometry));\n\nvar MultiPoint = (function (GeometryCollection$$1) {\n  function MultiPoint () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiPoint.__proto__ = GeometryCollection$$1;\n  MultiPoint.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiPoint.prototype.constructor = MultiPoint;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiPoint.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTIPOINT\n  };\n  MultiPoint.prototype.isValid = function isValid () {\n    return true\n  };\n  MultiPoint.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiPoint.prototype.getCoordinate = function getCoordinate () {\n    if (arguments.length === 1) {\n      var n = arguments[0];\n      return this._geometries[n].getCoordinate()\n    } else { return GeometryCollection$$1.prototype.getCoordinate.apply(this, arguments) }\n  };\n  MultiPoint.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  MultiPoint.prototype.getDimension = function getDimension () {\n    return 0\n  };\n  MultiPoint.prototype.getBoundary = function getBoundary () {\n    return this.getFactory().createGeometryCollection(null)\n  };\n  MultiPoint.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiPoint'\n  };\n  MultiPoint.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var points = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < points.length; i++) {\n      points[i] = this$1._geometries[i].copy();\n    }\n    return new MultiPoint(points, this._factory)\n  };\n  MultiPoint.prototype.interfaces_ = function interfaces_ () {\n    return [Puntal]\n  };\n  MultiPoint.prototype.getClass = function getClass () {\n    return MultiPoint\n  };\n  staticAccessors.serialVersionUID.get = function () { return -8048474874175355449 };\n\n  Object.defineProperties( MultiPoint, staticAccessors );\n\n  return MultiPoint;\n}(GeometryCollection));\n\nvar LinearRing = (function (LineString$$1) {\n  function LinearRing (points, factory) {\n    if (points instanceof Coordinate && factory instanceof GeometryFactory) {\n      points = factory.getCoordinateSequenceFactory().create(points);\n    }\n    LineString$$1.call(this, points, factory);\n    this.validateConstruction();\n  }\n\n  if ( LineString$$1 ) LinearRing.__proto__ = LineString$$1;\n  LinearRing.prototype = Object.create( LineString$$1 && LineString$$1.prototype );\n  LinearRing.prototype.constructor = LinearRing;\n\n  var staticAccessors = { MINIMUM_VALID_SIZE: { configurable: true },serialVersionUID: { configurable: true } };\n  LinearRing.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_LINEARRING\n  };\n  LinearRing.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return Dimension.FALSE\n  };\n  LinearRing.prototype.isClosed = function isClosed () {\n    if (this.isEmpty()) {\n      return true\n    }\n    return LineString$$1.prototype.isClosed.call(this)\n  };\n  LinearRing.prototype.reverse = function reverse () {\n    var seq = this._points.copy();\n    CoordinateSequences.reverse(seq);\n    var rev = this.getFactory().createLinearRing(seq);\n    return rev\n  };\n  LinearRing.prototype.validateConstruction = function validateConstruction () {\n    if (!this.isEmpty() && !LineString$$1.prototype.isClosed.call(this)) {\n      throw new IllegalArgumentException('Points of LinearRing do not form a closed linestring')\n    }\n    if (this.getCoordinateSequence().size() >= 1 && this.getCoordinateSequence().size() < LinearRing.MINIMUM_VALID_SIZE) {\n      throw new IllegalArgumentException('Invalid number of points in LinearRing (found ' + this.getCoordinateSequence().size() + ' - must be 0 or >= 4)')\n    }\n  };\n  LinearRing.prototype.getGeometryType = function getGeometryType () {\n    return 'LinearRing'\n  };\n  LinearRing.prototype.copy = function copy () {\n    return new LinearRing(this._points.copy(), this._factory)\n  };\n  LinearRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  LinearRing.prototype.getClass = function getClass () {\n    return LinearRing\n  };\n  staticAccessors.MINIMUM_VALID_SIZE.get = function () { return 4 };\n  staticAccessors.serialVersionUID.get = function () { return -4261142084085851829 };\n\n  Object.defineProperties( LinearRing, staticAccessors );\n\n  return LinearRing;\n}(LineString));\n\nvar MultiPolygon = (function (GeometryCollection$$1) {\n  function MultiPolygon () {\n    GeometryCollection$$1.apply(this, arguments);\n  }\n\n  if ( GeometryCollection$$1 ) MultiPolygon.__proto__ = GeometryCollection$$1;\n  MultiPolygon.prototype = Object.create( GeometryCollection$$1 && GeometryCollection$$1.prototype );\n  MultiPolygon.prototype.constructor = MultiPolygon;\n\n  var staticAccessors = { serialVersionUID: { configurable: true } };\n\n  MultiPolygon.prototype.getSortIndex = function getSortIndex () {\n    return Geometry.SORTINDEX_MULTIPOLYGON\n  };\n  MultiPolygon.prototype.equalsExact = function equalsExact () {\n    if (arguments.length === 2) {\n      var other = arguments[0];\n      var tolerance = arguments[1];\n      if (!this.isEquivalentClass(other)) {\n        return false\n      }\n      return GeometryCollection$$1.prototype.equalsExact.call(this, other, tolerance)\n    } else { return GeometryCollection$$1.prototype.equalsExact.apply(this, arguments) }\n  };\n  MultiPolygon.prototype.getBoundaryDimension = function getBoundaryDimension () {\n    return 1\n  };\n  MultiPolygon.prototype.getDimension = function getDimension () {\n    return 2\n  };\n  MultiPolygon.prototype.reverse = function reverse () {\n    var this$1 = this;\n\n    var n = this._geometries.length;\n    var revGeoms = new Array(n).fill(null);\n    for (var i = 0; i < this._geometries.length; i++) {\n      revGeoms[i] = this$1._geometries[i].reverse();\n    }\n    return this.getFactory().createMultiPolygon(revGeoms)\n  };\n  MultiPolygon.prototype.getBoundary = function getBoundary () {\n    var this$1 = this;\n\n    if (this.isEmpty()) {\n      return this.getFactory().createMultiLineString()\n    }\n    var allRings = new ArrayList();\n    for (var i = 0; i < this._geometries.length; i++) {\n      var polygon = this$1._geometries[i];\n      var rings = polygon.getBoundary();\n      for (var j = 0; j < rings.getNumGeometries(); j++) {\n        allRings.add(rings.getGeometryN(j));\n      }\n    }\n    var allRingsArray = new Array(allRings.size()).fill(null);\n    return this.getFactory().createMultiLineString(allRings.toArray(allRingsArray))\n  };\n  MultiPolygon.prototype.getGeometryType = function getGeometryType () {\n    return 'MultiPolygon'\n  };\n  MultiPolygon.prototype.copy = function copy () {\n    var this$1 = this;\n\n    var polygons = new Array(this._geometries.length).fill(null);\n    for (var i = 0; i < polygons.length; i++) {\n      polygons[i] = this$1._geometries[i].copy();\n    }\n    return new MultiPolygon(polygons, this._factory)\n  };\n  MultiPolygon.prototype.interfaces_ = function interfaces_ () {\n    return [Polygonal]\n  };\n  MultiPolygon.prototype.getClass = function getClass () {\n    return MultiPolygon\n  };\n  staticAccessors.serialVersionUID.get = function () { return -551033529766975875 };\n\n  Object.defineProperties( MultiPolygon, staticAccessors );\n\n  return MultiPolygon;\n}(GeometryCollection));\n\nvar GeometryEditor = function GeometryEditor (factory) {\n  this._factory = factory || null;\n  this._isUserDataCopied = false;\n};\n\nvar staticAccessors$16 = { NoOpGeometryOperation: { configurable: true },CoordinateOperation: { configurable: true },CoordinateSequenceOperation: { configurable: true } };\nGeometryEditor.prototype.setCopyUserData = function setCopyUserData (isUserDataCopied) {\n  this._isUserDataCopied = isUserDataCopied;\n};\nGeometryEditor.prototype.edit = function edit (geometry, operation) {\n  if (geometry === null) { return null }\n  var result = this.editInternal(geometry, operation);\n  if (this._isUserDataCopied) {\n    result.setUserData(geometry.getUserData());\n  }\n  return result\n};\nGeometryEditor.prototype.editInternal = function editInternal (geometry, operation) {\n  if (this._factory === null) { this._factory = geometry.getFactory(); }\n  if (geometry instanceof GeometryCollection) {\n    return this.editGeometryCollection(geometry, operation)\n  }\n  if (geometry instanceof Polygon) {\n    return this.editPolygon(geometry, operation)\n  }\n  if (geometry instanceof Point) {\n    return operation.edit(geometry, this._factory)\n  }\n  if (geometry instanceof LineString) {\n    return operation.edit(geometry, this._factory)\n  }\n  Assert.shouldNeverReachHere('Unsupported Geometry class: ' + geometry.getClass().getName());\n  return null\n};\nGeometryEditor.prototype.editGeometryCollection = function editGeometryCollection (collection, operation) {\n    var this$1 = this;\n\n  var collectionForType = operation.edit(collection, this._factory);\n  var geometries = new ArrayList();\n  for (var i = 0; i < collectionForType.getNumGeometries(); i++) {\n    var geometry = this$1.edit(collectionForType.getGeometryN(i), operation);\n    if (geometry === null || geometry.isEmpty()) {\n      continue\n    }\n    geometries.add(geometry);\n  }\n  if (collectionForType.getClass() === MultiPoint) {\n    return this._factory.createMultiPoint(geometries.toArray([]))\n  }\n  if (collectionForType.getClass() === MultiLineString) {\n    return this._factory.createMultiLineString(geometries.toArray([]))\n  }\n  if (collectionForType.getClass() === MultiPolygon) {\n    return this._factory.createMultiPolygon(geometries.toArray([]))\n  }\n  return this._factory.createGeometryCollection(geometries.toArray([]))\n};\nGeometryEditor.prototype.editPolygon = function editPolygon (polygon, operation) {\n    var this$1 = this;\n\n  var newPolygon = operation.edit(polygon, this._factory);\n  if (newPolygon === null) { newPolygon = this._factory.createPolygon(null); }\n  if (newPolygon.isEmpty()) {\n    return newPolygon\n  }\n  var shell = this.edit(newPolygon.getExteriorRing(), operation);\n  if (shell === null || shell.isEmpty()) {\n    return this._factory.createPolygon()\n  }\n  var holes = new ArrayList();\n  for (var i = 0; i < newPolygon.getNumInteriorRing(); i++) {\n    var hole = this$1.edit(newPolygon.getInteriorRingN(i), operation);\n    if (hole === null || hole.isEmpty()) {\n      continue\n    }\n    holes.add(hole);\n  }\n  return this._factory.createPolygon(shell, holes.toArray([]))\n};\nGeometryEditor.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryEditor.prototype.getClass = function getClass () {\n  return GeometryEditor\n};\nGeometryEditor.GeometryEditorOperation = function GeometryEditorOperation () {};\nstaticAccessors$16.NoOpGeometryOperation.get = function () { return NoOpGeometryOperation };\nstaticAccessors$16.CoordinateOperation.get = function () { return CoordinateOperation };\nstaticAccessors$16.CoordinateSequenceOperation.get = function () { return CoordinateSequenceOperation };\n\nObject.defineProperties( GeometryEditor, staticAccessors$16 );\n\nvar NoOpGeometryOperation = function NoOpGeometryOperation () {};\n\nNoOpGeometryOperation.prototype.edit = function edit (geometry, factory) {\n  return geometry\n};\nNoOpGeometryOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nNoOpGeometryOperation.prototype.getClass = function getClass () {\n  return NoOpGeometryOperation\n};\n\nvar CoordinateOperation = function CoordinateOperation () {};\n\nCoordinateOperation.prototype.edit = function edit (geometry, factory) {\n  var coords = this.editCoordinates(geometry.getCoordinates(), geometry);\n  if (coords === null) { return geometry }\n  if (geometry instanceof LinearRing) {\n    return factory.createLinearRing(coords)\n  }\n  if (geometry instanceof LineString) {\n    return factory.createLineString(coords)\n  }\n  if (geometry instanceof Point) {\n    if (coords.length > 0) {\n      return factory.createPoint(coords[0])\n    } else {\n      return factory.createPoint()\n    }\n  }\n  return geometry\n};\nCoordinateOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nCoordinateOperation.prototype.getClass = function getClass () {\n  return CoordinateOperation\n};\n\nvar CoordinateSequenceOperation = function CoordinateSequenceOperation () {};\n\nCoordinateSequenceOperation.prototype.edit = function edit (geometry, factory) {\n  if (geometry instanceof LinearRing) {\n    return factory.createLinearRing(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  if (geometry instanceof LineString) {\n    return factory.createLineString(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  if (geometry instanceof Point) {\n    return factory.createPoint(this.edit(geometry.getCoordinateSequence(), geometry))\n  }\n  return geometry\n};\nCoordinateSequenceOperation.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryEditor.GeometryEditorOperation]\n};\nCoordinateSequenceOperation.prototype.getClass = function getClass () {\n  return CoordinateSequenceOperation\n};\n\nvar CoordinateArraySequence = function CoordinateArraySequence () {\n  var this$1 = this;\n\n  this._dimension = 3;\n  this._coordinates = null;\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      this._coordinates = arguments[0];\n      this._dimension = 3;\n    } else if (Number.isInteger(arguments[0])) {\n      var size = arguments[0];\n      this._coordinates = new Array(size).fill(null);\n      for (var i = 0; i < size; i++) {\n        this$1._coordinates[i] = new Coordinate();\n      }\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordSeq = arguments[0];\n      if (coordSeq === null) {\n        this._coordinates = new Array(0).fill(null);\n        return null\n      }\n      this._dimension = coordSeq.getDimension();\n      this._coordinates = new Array(coordSeq.size()).fill(null);\n      for (var i$1 = 0; i$1 < this._coordinates.length; i$1++) {\n        this$1._coordinates[i$1] = coordSeq.getCoordinateCopy(i$1);\n      }\n    }\n  } else if (arguments.length === 2) {\n    if (arguments[0] instanceof Array && Number.isInteger(arguments[1])) {\n      var coordinates = arguments[0];\n      var dimension = arguments[1];\n      this._coordinates = coordinates;\n      this._dimension = dimension;\n      if (coordinates === null) { this._coordinates = new Array(0).fill(null); }\n    } else if (Number.isInteger(arguments[0]) && Number.isInteger(arguments[1])) {\n      var size$1 = arguments[0];\n      var dimension$1 = arguments[1];\n      this._coordinates = new Array(size$1).fill(null);\n      this._dimension = dimension$1;\n      for (var i$2 = 0; i$2 < size$1; i$2++) {\n        this$1._coordinates[i$2] = new Coordinate();\n      }\n    }\n  }\n};\n\nvar staticAccessors$18 = { serialVersionUID: { configurable: true } };\nCoordinateArraySequence.prototype.setOrdinate = function setOrdinate (index, ordinateIndex, value) {\n  switch (ordinateIndex) {\n    case CoordinateSequence.X:\n      this._coordinates[index].x = value;\n      break\n    case CoordinateSequence.Y:\n      this._coordinates[index].y = value;\n      break\n    case CoordinateSequence.Z:\n      this._coordinates[index].z = value;\n      break\n    default:\n      throw new IllegalArgumentException('invalid ordinateIndex')\n  }\n};\nCoordinateArraySequence.prototype.size = function size () {\n  return this._coordinates.length\n};\nCoordinateArraySequence.prototype.getOrdinate = function getOrdinate (index, ordinateIndex) {\n  switch (ordinateIndex) {\n    case CoordinateSequence.X:\n      return this._coordinates[index].x\n    case CoordinateSequence.Y:\n      return this._coordinates[index].y\n    case CoordinateSequence.Z:\n      return this._coordinates[index].z\n    default:\n  }\n  return Double.NaN\n};\nCoordinateArraySequence.prototype.getCoordinate = function getCoordinate () {\n  if (arguments.length === 1) {\n    var i = arguments[0];\n    return this._coordinates[i]\n  } else if (arguments.length === 2) {\n    var index = arguments[0];\n    var coord = arguments[1];\n    coord.x = this._coordinates[index].x;\n    coord.y = this._coordinates[index].y;\n    coord.z = this._coordinates[index].z;\n  }\n};\nCoordinateArraySequence.prototype.getCoordinateCopy = function getCoordinateCopy (i) {\n  return new Coordinate(this._coordinates[i])\n};\nCoordinateArraySequence.prototype.getDimension = function getDimension () {\n  return this._dimension\n};\nCoordinateArraySequence.prototype.getX = function getX (index) {\n  return this._coordinates[index].x\n};\nCoordinateArraySequence.prototype.clone = function clone () {\n    var this$1 = this;\n\n  var cloneCoordinates = new Array(this.size()).fill(null);\n  for (var i = 0; i < this._coordinates.length; i++) {\n    cloneCoordinates[i] = this$1._coordinates[i].clone();\n  }\n  return new CoordinateArraySequence(cloneCoordinates, this._dimension)\n};\nCoordinateArraySequence.prototype.expandEnvelope = function expandEnvelope (env) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._coordinates.length; i++) {\n    env.expandToInclude(this$1._coordinates[i]);\n  }\n  return env\n};\nCoordinateArraySequence.prototype.copy = function copy () {\n    var this$1 = this;\n\n  var cloneCoordinates = new Array(this.size()).fill(null);\n  for (var i = 0; i < this._coordinates.length; i++) {\n    cloneCoordinates[i] = this$1._coordinates[i].copy();\n  }\n  return new CoordinateArraySequence(cloneCoordinates, this._dimension)\n};\nCoordinateArraySequence.prototype.toString = function toString () {\n    var this$1 = this;\n\n  if (this._coordinates.length > 0) {\n    var strBuf = new StringBuffer(17 * this._coordinates.length);\n    strBuf.append('(');\n    strBuf.append(this._coordinates[0]);\n    for (var i = 1; i < this._coordinates.length; i++) {\n      strBuf.append(', ');\n      strBuf.append(this$1._coordinates[i]);\n    }\n    strBuf.append(')');\n    return strBuf.toString()\n  } else {\n    return '()'\n  }\n};\nCoordinateArraySequence.prototype.getY = function getY (index) {\n  return this._coordinates[index].y\n};\nCoordinateArraySequence.prototype.toCoordinateArray = function toCoordinateArray () {\n  return this._coordinates\n};\nCoordinateArraySequence.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequence, Serializable]\n};\nCoordinateArraySequence.prototype.getClass = function getClass () {\n  return CoordinateArraySequence\n};\nstaticAccessors$18.serialVersionUID.get = function () { return -915438501601840650 };\n\nObject.defineProperties( CoordinateArraySequence, staticAccessors$18 );\n\nvar CoordinateArraySequenceFactory = function CoordinateArraySequenceFactory () {};\n\nvar staticAccessors$17 = { serialVersionUID: { configurable: true },instanceObject: { configurable: true } };\n\nCoordinateArraySequenceFactory.prototype.readResolve = function readResolve () {\n  return CoordinateArraySequenceFactory.instance()\n};\nCoordinateArraySequenceFactory.prototype.create = function create () {\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return new CoordinateArraySequence(coordinates)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordSeq = arguments[0];\n      return new CoordinateArraySequence(coordSeq)\n    }\n  } else if (arguments.length === 2) {\n    var size = arguments[0];\n    var dimension = arguments[1];\n    if (dimension > 3) { dimension = 3; }\n    if (dimension < 2) { return new CoordinateArraySequence(size) }\n    return new CoordinateArraySequence(size, dimension)\n  }\n};\nCoordinateArraySequenceFactory.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFactory, Serializable]\n};\nCoordinateArraySequenceFactory.prototype.getClass = function getClass () {\n  return CoordinateArraySequenceFactory\n};\nCoordinateArraySequenceFactory.instance = function instance () {\n  return CoordinateArraySequenceFactory.instanceObject\n};\n\nstaticAccessors$17.serialVersionUID.get = function () { return -4099577099607551657 };\nstaticAccessors$17.instanceObject.get = function () { return new CoordinateArraySequenceFactory() };\n\nObject.defineProperties( CoordinateArraySequenceFactory, staticAccessors$17 );\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/HashMap.html\n *\n * @extends {javascript.util.Map}\n * @constructor\n * @private\n */\nvar HashMap = (function (MapInterface) {\n  function HashMap () {\n    MapInterface.call(this);\n    this.map_ = new Map();\n  }\n\n  if ( MapInterface ) HashMap.__proto__ = MapInterface;\n  HashMap.prototype = Object.create( MapInterface && MapInterface.prototype );\n  HashMap.prototype.constructor = HashMap;\n  /**\n   * @override\n   */\n  HashMap.prototype.get = function get (key) {\n    return this.map_.get(key) || null\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.put = function put (key, value) {\n    this.map_.set(key, value);\n    return value\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.values = function values () {\n    var arrayList = new ArrayList();\n    var it = this.map_.values();\n    var o = it.next();\n    while (!o.done) {\n      arrayList.add(o.value);\n      o = it.next();\n    }\n    return arrayList\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.entrySet = function entrySet () {\n    var hashSet = new HashSet();\n    this.map_.entries().forEach(function (entry) { return hashSet.add(entry); });\n    return hashSet\n  };\n\n  /**\n   * @override\n   */\n  HashMap.prototype.size = function size () {\n    return this.map_.size()\n  };\n\n  return HashMap;\n}(Map$1));\n\nvar PrecisionModel = function PrecisionModel () {\n  this._modelType = null;\n  this._scale = null;\n  if (arguments.length === 0) {\n    this._modelType = PrecisionModel.FLOATING;\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Type) {\n      var modelType = arguments[0];\n      this._modelType = modelType;\n      if (modelType === PrecisionModel.FIXED) {\n        this.setScale(1.0);\n      }\n    } else if (typeof arguments[0] === 'number') {\n      var scale = arguments[0];\n      this._modelType = PrecisionModel.FIXED;\n      this.setScale(scale);\n    } else if (arguments[0] instanceof PrecisionModel) {\n      var pm = arguments[0];\n      this._modelType = pm._modelType;\n      this._scale = pm._scale;\n    }\n  }\n};\n\nvar staticAccessors$19 = { serialVersionUID: { configurable: true },maximumPreciseValue: { configurable: true } };\nPrecisionModel.prototype.equals = function equals (other) {\n  if (!(other instanceof PrecisionModel)) {\n    return false\n  }\n  var otherPrecisionModel = other;\n  return this._modelType === otherPrecisionModel._modelType && this._scale === otherPrecisionModel._scale\n};\nPrecisionModel.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  var sigDigits = this.getMaximumSignificantDigits();\n  var otherSigDigits = other.getMaximumSignificantDigits();\n  return new Integer(sigDigits).compareTo(new Integer(otherSigDigits))\n};\nPrecisionModel.prototype.getScale = function getScale () {\n  return this._scale\n};\nPrecisionModel.prototype.isFloating = function isFloating () {\n  return this._modelType === PrecisionModel.FLOATING || this._modelType === PrecisionModel.FLOATING_SINGLE\n};\nPrecisionModel.prototype.getType = function getType () {\n  return this._modelType\n};\nPrecisionModel.prototype.toString = function toString () {\n  var description = 'UNKNOWN';\n  if (this._modelType === PrecisionModel.FLOATING) {\n    description = 'Floating';\n  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n    description = 'Floating-Single';\n  } else if (this._modelType === PrecisionModel.FIXED) {\n    description = 'Fixed (Scale=' + this.getScale() + ')';\n  }\n  return description\n};\nPrecisionModel.prototype.makePrecise = function makePrecise () {\n  if (typeof arguments[0] === 'number') {\n    var val = arguments[0];\n    if (Double.isNaN(val)) { return val }\n    if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n      var floatSingleVal = val;\n      return floatSingleVal\n    }\n    if (this._modelType === PrecisionModel.FIXED) {\n      return Math.round(val * this._scale) / this._scale\n    }\n    return val\n  } else if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    if (this._modelType === PrecisionModel.FLOATING) { return null }\n    coord.x = this.makePrecise(coord.x);\n    coord.y = this.makePrecise(coord.y);\n  }\n};\nPrecisionModel.prototype.getMaximumSignificantDigits = function getMaximumSignificantDigits () {\n  var maxSigDigits = 16;\n  if (this._modelType === PrecisionModel.FLOATING) {\n    maxSigDigits = 16;\n  } else if (this._modelType === PrecisionModel.FLOATING_SINGLE) {\n    maxSigDigits = 6;\n  } else if (this._modelType === PrecisionModel.FIXED) {\n    maxSigDigits = 1 + Math.trunc(Math.ceil(Math.log(this.getScale()) / Math.log(10)));\n  }\n  return maxSigDigits\n};\nPrecisionModel.prototype.setScale = function setScale (scale) {\n  this._scale = Math.abs(scale);\n};\nPrecisionModel.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable, Comparable]\n};\nPrecisionModel.prototype.getClass = function getClass () {\n  return PrecisionModel\n};\nPrecisionModel.mostPrecise = function mostPrecise (pm1, pm2) {\n  if (pm1.compareTo(pm2) >= 0) { return pm1 }\n  return pm2\n};\nstaticAccessors$19.serialVersionUID.get = function () { return 7777263578777803835 };\nstaticAccessors$19.maximumPreciseValue.get = function () { return 9007199254740992.0 };\n\nObject.defineProperties( PrecisionModel, staticAccessors$19 );\n\nvar Type = function Type (name) {\n  this._name = name || null;\n  Type.nameToTypeMap.put(name, this);\n};\n\nvar staticAccessors$1$1 = { serialVersionUID: { configurable: true },nameToTypeMap: { configurable: true } };\nType.prototype.readResolve = function readResolve () {\n  return Type.nameToTypeMap.get(this._name)\n};\nType.prototype.toString = function toString () {\n  return this._name\n};\nType.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nType.prototype.getClass = function getClass () {\n  return Type\n};\nstaticAccessors$1$1.serialVersionUID.get = function () { return -5528602631731589822 };\nstaticAccessors$1$1.nameToTypeMap.get = function () { return new HashMap() };\n\nObject.defineProperties( Type, staticAccessors$1$1 );\n\nPrecisionModel.Type = Type;\nPrecisionModel.FIXED = new Type('FIXED');\nPrecisionModel.FLOATING = new Type('FLOATING');\nPrecisionModel.FLOATING_SINGLE = new Type('FLOATING SINGLE');\n\nvar GeometryFactory = function GeometryFactory () {\n  this._precisionModel = new PrecisionModel();\n  this._SRID = 0;\n  this._coordinateSequenceFactory = GeometryFactory.getDefaultCoordinateSequenceFactory();\n\n  if (arguments.length === 0) {\n  } else if (arguments.length === 1) {\n    if (hasInterface(arguments[0], CoordinateSequenceFactory)) {\n      this._coordinateSequenceFactory = arguments[0];\n    } else if (arguments[0] instanceof PrecisionModel) {\n      this._precisionModel = arguments[0];\n    }\n  } else if (arguments.length === 2) {\n    this._precisionModel = arguments[0];\n    this._SRID = arguments[1];\n  } else if (arguments.length === 3) {\n    this._precisionModel = arguments[0];\n    this._SRID = arguments[1];\n    this._coordinateSequenceFactory = arguments[2];\n  }\n};\n\nvar staticAccessors$2 = { serialVersionUID: { configurable: true } };\nGeometryFactory.prototype.toGeometry = function toGeometry (envelope) {\n  if (envelope.isNull()) {\n    return this.createPoint(null)\n  }\n  if (envelope.getMinX() === envelope.getMaxX() && envelope.getMinY() === envelope.getMaxY()) {\n    return this.createPoint(new Coordinate(envelope.getMinX(), envelope.getMinY()))\n  }\n  if (envelope.getMinX() === envelope.getMaxX() || envelope.getMinY() === envelope.getMaxY()) {\n    return this.createLineString([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY())])\n  }\n  return this.createPolygon(this.createLinearRing([new Coordinate(envelope.getMinX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMaxY()), new Coordinate(envelope.getMaxX(), envelope.getMinY()), new Coordinate(envelope.getMinX(), envelope.getMinY())]), null)\n};\nGeometryFactory.prototype.createLineString = function createLineString (coordinates) {\n  if (!coordinates) { return new LineString(this.getCoordinateSequenceFactory().create([]), this) }\n  else if (coordinates instanceof Array) { return new LineString(this.getCoordinateSequenceFactory().create(coordinates), this) }\n  else if (hasInterface(coordinates, CoordinateSequence)) { return new LineString(coordinates, this) }\n};\nGeometryFactory.prototype.createMultiLineString = function createMultiLineString () {\n  if (arguments.length === 0) {\n    return new MultiLineString(null, this)\n  } else if (arguments.length === 1) {\n    var lineStrings = arguments[0];\n    return new MultiLineString(lineStrings, this)\n  }\n};\nGeometryFactory.prototype.buildGeometry = function buildGeometry (geomList) {\n  var geomClass = null;\n  var isHeterogeneous = false;\n  var hasGeometryCollection = false;\n  for (var i = geomList.iterator(); i.hasNext();) {\n    var geom = i.next();\n    var partClass = geom.getClass();\n    if (geomClass === null) {\n      geomClass = partClass;\n    }\n    if (partClass !== geomClass) {\n      isHeterogeneous = true;\n    }\n    if (geom.isGeometryCollectionOrDerived()) { hasGeometryCollection = true; }\n  }\n  if (geomClass === null) {\n    return this.createGeometryCollection()\n  }\n  if (isHeterogeneous || hasGeometryCollection) {\n    return this.createGeometryCollection(GeometryFactory.toGeometryArray(geomList))\n  }\n  var geom0 = geomList.iterator().next();\n  var isCollection = geomList.size() > 1;\n  if (isCollection) {\n    if (geom0 instanceof Polygon) {\n      return this.createMultiPolygon(GeometryFactory.toPolygonArray(geomList))\n    } else if (geom0 instanceof LineString) {\n      return this.createMultiLineString(GeometryFactory.toLineStringArray(geomList))\n    } else if (geom0 instanceof Point) {\n      return this.createMultiPoint(GeometryFactory.toPointArray(geomList))\n    }\n    Assert.shouldNeverReachHere('Unhandled class: ' + geom0.getClass().getName());\n  }\n  return geom0\n};\nGeometryFactory.prototype.createMultiPointFromCoords = function createMultiPointFromCoords (coordinates) {\n  return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n};\nGeometryFactory.prototype.createPoint = function createPoint () {\n  if (arguments.length === 0) {\n    return this.createPoint(this.getCoordinateSequenceFactory().create([]))\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Coordinate) {\n      var coordinate = arguments[0];\n      return this.createPoint(coordinate !== null ? this.getCoordinateSequenceFactory().create([coordinate]) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates = arguments[0];\n      return new Point(coordinates, this)\n    }\n  }\n};\nGeometryFactory.prototype.getCoordinateSequenceFactory = function getCoordinateSequenceFactory () {\n  return this._coordinateSequenceFactory\n};\nGeometryFactory.prototype.createPolygon = function createPolygon () {\n  if (arguments.length === 0) {\n    return new Polygon(null, null, this)\n  } else if (arguments.length === 1) {\n    if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates = arguments[0];\n      return this.createPolygon(this.createLinearRing(coordinates))\n    } else if (arguments[0] instanceof Array) {\n      var coordinates$1 = arguments[0];\n      return this.createPolygon(this.createLinearRing(coordinates$1))\n    } else if (arguments[0] instanceof LinearRing) {\n      var shell = arguments[0];\n      return this.createPolygon(shell, null)\n    }\n  } else if (arguments.length === 2) {\n    var shell$1 = arguments[0];\n    var holes = arguments[1];\n    return new Polygon(shell$1, holes, this)\n  }\n};\nGeometryFactory.prototype.getSRID = function getSRID () {\n  return this._SRID\n};\nGeometryFactory.prototype.createGeometryCollection = function createGeometryCollection () {\n  if (arguments.length === 0) {\n    return new GeometryCollection(null, this)\n  } else if (arguments.length === 1) {\n    var geometries = arguments[0];\n    return new GeometryCollection(geometries, this)\n  }\n};\nGeometryFactory.prototype.createGeometry = function createGeometry (g) {\n  var editor = new GeometryEditor(this);\n  return editor.edit(g, {\n    edit: function () {\n      if (arguments.length === 2) {\n        var coordSeq = arguments[0];\n        // const geometry = arguments[1]\n        return this._coordinateSequenceFactory.create(coordSeq)\n      }\n    }\n  })\n};\nGeometryFactory.prototype.getPrecisionModel = function getPrecisionModel () {\n  return this._precisionModel\n};\nGeometryFactory.prototype.createLinearRing = function createLinearRing () {\n  if (arguments.length === 0) {\n    return this.createLinearRing(this.getCoordinateSequenceFactory().create([]))\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return this.createLinearRing(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates$1 = arguments[0];\n      return new LinearRing(coordinates$1, this)\n    }\n  }\n};\nGeometryFactory.prototype.createMultiPolygon = function createMultiPolygon () {\n  if (arguments.length === 0) {\n    return new MultiPolygon(null, this)\n  } else if (arguments.length === 1) {\n    var polygons = arguments[0];\n    return new MultiPolygon(polygons, this)\n  }\n};\nGeometryFactory.prototype.createMultiPoint = function createMultiPoint () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    return new MultiPoint(null, this)\n  } else if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var point = arguments[0];\n      return new MultiPoint(point, this)\n    } else if (arguments[0] instanceof Array) {\n      var coordinates = arguments[0];\n      return this.createMultiPoint(coordinates !== null ? this.getCoordinateSequenceFactory().create(coordinates) : null)\n    } else if (hasInterface(arguments[0], CoordinateSequence)) {\n      var coordinates$1 = arguments[0];\n      if (coordinates$1 === null) {\n        return this.createMultiPoint(new Array(0).fill(null))\n      }\n      var points = new Array(coordinates$1.size()).fill(null);\n      for (var i = 0; i < coordinates$1.size(); i++) {\n        var ptSeq = this$1.getCoordinateSequenceFactory().create(1, coordinates$1.getDimension());\n        CoordinateSequences.copy(coordinates$1, i, ptSeq, 0, 1);\n        points[i] = this$1.createPoint(ptSeq);\n      }\n      return this.createMultiPoint(points)\n    }\n  }\n};\nGeometryFactory.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nGeometryFactory.prototype.getClass = function getClass () {\n  return GeometryFactory\n};\nGeometryFactory.toMultiPolygonArray = function toMultiPolygonArray (multiPolygons) {\n  var multiPolygonArray = new Array(multiPolygons.size()).fill(null);\n  return multiPolygons.toArray(multiPolygonArray)\n};\nGeometryFactory.toGeometryArray = function toGeometryArray (geometries) {\n  if (geometries === null) { return null }\n  var geometryArray = new Array(geometries.size()).fill(null);\n  return geometries.toArray(geometryArray)\n};\nGeometryFactory.getDefaultCoordinateSequenceFactory = function getDefaultCoordinateSequenceFactory () {\n  return CoordinateArraySequenceFactory.instance()\n};\nGeometryFactory.toMultiLineStringArray = function toMultiLineStringArray (multiLineStrings) {\n  var multiLineStringArray = new Array(multiLineStrings.size()).fill(null);\n  return multiLineStrings.toArray(multiLineStringArray)\n};\nGeometryFactory.toLineStringArray = function toLineStringArray (lineStrings) {\n  var lineStringArray = new Array(lineStrings.size()).fill(null);\n  return lineStrings.toArray(lineStringArray)\n};\nGeometryFactory.toMultiPointArray = function toMultiPointArray (multiPoints) {\n  var multiPointArray = new Array(multiPoints.size()).fill(null);\n  return multiPoints.toArray(multiPointArray)\n};\nGeometryFactory.toLinearRingArray = function toLinearRingArray (linearRings) {\n  var linearRingArray = new Array(linearRings.size()).fill(null);\n  return linearRings.toArray(linearRingArray)\n};\nGeometryFactory.toPointArray = function toPointArray (points) {\n  var pointArray = new Array(points.size()).fill(null);\n  return points.toArray(pointArray)\n};\nGeometryFactory.toPolygonArray = function toPolygonArray (polygons) {\n  var polygonArray = new Array(polygons.size()).fill(null);\n  return polygons.toArray(polygonArray)\n};\nGeometryFactory.createPointFromInternalCoord = function createPointFromInternalCoord (coord, exemplar) {\n  exemplar.getPrecisionModel().makePrecise(coord);\n  return exemplar.getFactory().createPoint(coord)\n};\nstaticAccessors$2.serialVersionUID.get = function () { return -6820524753094095635 };\n\nObject.defineProperties( GeometryFactory, staticAccessors$2 );\n\nvar geometryTypes = ['Point', 'MultiPoint', 'LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];\n\n/**\n * Class for reading and writing Well-Known Text.Create a new parser for GeoJSON\n * NOTE: Adapted from OpenLayers 2.11 implementation.\n */\n\n/**\n * Create a new parser for GeoJSON\n *\n * @param {GeometryFactory} geometryFactory\n * @return An instance of GeoJsonParser.\n * @constructor\n * @private\n */\nvar GeoJSONParser = function GeoJSONParser (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n};\n/**\n * Deserialize a GeoJSON object and return the Geometry or Feature(Collection) with JSTS Geometries\n *\n * @param {}\n *        A GeoJSON object.\n * @return {} A Geometry instance or object representing a Feature(Collection) with Geometry instances.\n * @private\n */\nGeoJSONParser.prototype.read = function read (json) {\n  var obj;\n  if (typeof json === 'string') {\n    obj = JSON.parse(json);\n  } else {\n    obj = json;\n  }\n\n  var type = obj.type;\n\n  if (!parse[type]) {\n    throw new Error('Unknown GeoJSON type: ' + obj.type)\n  }\n\n  if (geometryTypes.indexOf(type) !== -1) {\n    return parse[type].apply(this, [obj.coordinates])\n  } else if (type === 'GeometryCollection') {\n    return parse[type].apply(this, [obj.geometries])\n  }\n\n  // feature or feature collection\n  return parse[type].apply(this, [obj])\n};\n\n/**\n * Serialize a Geometry object into GeoJSON\n *\n * @param {Geometry}\n *        geometry A Geometry or array of Geometries.\n * @return {Object} A GeoJSON object represting the input Geometry/Geometries.\n * @private\n */\nGeoJSONParser.prototype.write = function write (geometry) {\n  var type = geometry.getGeometryType();\n\n  if (!extract[type]) {\n    throw new Error('Geometry is not supported')\n  }\n\n  return extract[type].apply(this, [geometry])\n};\n\nvar parse = {\n  /**\n   * Parse a GeoJSON Feature object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} Feature with geometry/bbox converted to JSTS Geometries.\n   */\n  Feature: function (obj) {\n    var feature = {};\n\n    // copy features\n    for (var key in obj) {\n      feature[key] = obj[key];\n    }\n\n    // parse geometry\n    if (obj.geometry) {\n      var type = obj.geometry.type;\n      if (!parse[type]) {\n        throw new Error('Unknown GeoJSON type: ' + obj.type)\n      }\n      feature.geometry = this.read(obj.geometry);\n    }\n\n    // bbox\n    if (obj.bbox) {\n      feature.bbox = parse.bbox.apply(this, [obj.bbox]);\n    }\n\n    return feature\n  },\n\n  /**\n   * Parse a GeoJSON FeatureCollection object\n   *\n   * @param {Object}\n   *          obj Object to parse.\n   *\n   * @return {Object} FeatureCollection with geometry/bbox converted to JSTS Geometries.\n   */\n  FeatureCollection: function (obj) {\n    var this$1 = this;\n\n    var featureCollection = {};\n\n    if (obj.features) {\n      featureCollection.features = [];\n\n      for (var i = 0; i < obj.features.length; ++i) {\n        featureCollection.features.push(this$1.read(obj.features[i]));\n      }\n    }\n\n    if (obj.bbox) {\n      featureCollection.bbox = this.parse.bbox.apply(this, [obj.bbox]);\n    }\n\n    return featureCollection\n  },\n\n  /**\n   * Convert the ordinates in an array to an array of Coordinates\n   *\n   * @param {Array}\n   *          array Array with {Number}s.\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  coordinates: function (array) {\n    var coordinates = [];\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i];\n      coordinates.push(new Coordinate(sub[0], sub[1]));\n    }\n    return coordinates\n  },\n\n  /**\n   * Convert the bbox to a LinearRing\n   *\n   * @param {Array}\n   *          array Array with [xMin, yMin, xMax, yMax].\n   *\n   * @return {Array} Array with Coordinates.\n   */\n  bbox: function (array) {\n    return this.geometryFactory.createLinearRing([\n      new Coordinate(array[0], array[1]),\n      new Coordinate(array[2], array[1]),\n      new Coordinate(array[2], array[3]),\n      new Coordinate(array[0], array[3]),\n      new Coordinate(array[0], array[1])\n    ])\n  },\n\n  /**\n   * Convert an Array with ordinates to a Point\n   *\n   * @param {Array}\n   *          array Array with ordinates.\n   *\n   * @return {Point} Point.\n   */\n  Point: function (array) {\n    var coordinate = new Coordinate(array[0], array[1]);\n    return this.geometryFactory.createPoint(coordinate)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiPoint\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiPoint} MultiPoint.\n   */\n  MultiPoint: function (array) {\n    var this$1 = this;\n\n    var points = [];\n    for (var i = 0; i < array.length; ++i) {\n      points.push(parse.Point.apply(this$1, [array[i]]));\n    }\n    return this.geometryFactory.createMultiPoint(points)\n  },\n\n  /**\n   * Convert an Array with coordinates to a LineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {LineString} LineString.\n   */\n  LineString: function (array) {\n    var coordinates = parse.coordinates.apply(this, [array]);\n    return this.geometryFactory.createLineString(coordinates)\n  },\n\n  /**\n   * Convert an Array with coordinates to a MultiLineString\n   *\n   * @param {Array}\n   *          array Array with coordinates.\n   *\n   * @return {MultiLineString} MultiLineString.\n   */\n  MultiLineString: function (array) {\n    var this$1 = this;\n\n    var lineStrings = [];\n    for (var i = 0; i < array.length; ++i) {\n      lineStrings.push(parse.LineString.apply(this$1, [array[i]]));\n    }\n    return this.geometryFactory.createMultiLineString(lineStrings)\n  },\n\n  /**\n   * Convert an Array to a Polygon\n   *\n   * @param {Array}\n   *          array Array with shell and holes.\n   *\n   * @return {Polygon} Polygon.\n   */\n  Polygon: function (array) {\n    var this$1 = this;\n\n    var shellCoordinates = parse.coordinates.apply(this, [array[0]]);\n    var shell = this.geometryFactory.createLinearRing(shellCoordinates);\n    var holes = [];\n    for (var i = 1; i < array.length; ++i) {\n      var hole = array[i];\n      var coordinates = parse.coordinates.apply(this$1, [hole]);\n      var linearRing = this$1.geometryFactory.createLinearRing(coordinates);\n      holes.push(linearRing);\n    }\n    return this.geometryFactory.createPolygon(shell, holes)\n  },\n\n  /**\n   * Convert an Array to a MultiPolygon\n   *\n   * @param {Array}\n   *          array Array of arrays with shell and rings.\n   *\n   * @return {MultiPolygon} MultiPolygon.\n   */\n  MultiPolygon: function (array) {\n    var this$1 = this;\n\n    var polygons = [];\n    for (var i = 0; i < array.length; ++i) {\n      var polygon = array[i];\n      polygons.push(parse.Polygon.apply(this$1, [polygon]));\n    }\n    return this.geometryFactory.createMultiPolygon(polygons)\n  },\n\n  /**\n   * Convert an Array to a GeometryCollection\n   *\n   * @param {Array}\n   *          array Array of GeoJSON geometries.\n   *\n   * @return {GeometryCollection} GeometryCollection.\n   */\n  GeometryCollection: function (array) {\n    var this$1 = this;\n\n    var geometries = [];\n    for (var i = 0; i < array.length; ++i) {\n      var geometry = array[i];\n      geometries.push(this$1.read(geometry));\n    }\n    return this.geometryFactory.createGeometryCollection(geometries)\n  }\n};\n\nvar extract = {\n  /**\n   * Convert a Coordinate to an Array\n   *\n   * @param {Coordinate}\n   *          coordinate Coordinate to convert.\n   *\n   * @return {Array} Array of ordinates.\n   */\n  coordinate: function (coordinate) {\n    return [coordinate.x, coordinate.y]\n  },\n\n  /**\n   * Convert a Point to a GeoJSON object\n   *\n   * @param {Point}\n   *          point Point to convert.\n   *\n   * @return {Array} Array of 2 ordinates (paired to a coordinate).\n   */\n  Point: function (point) {\n    var array = extract.coordinate.apply(this, [point.getCoordinate()]);\n    return {\n      type: 'Point',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPoint to a GeoJSON object\n   *\n   * @param {MultiPoint}\n   *          multipoint MultiPoint to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  MultiPoint: function (multipoint) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multipoint._geometries.length; ++i) {\n      var point = multipoint._geometries[i];\n      var geoJson = extract.Point.apply(this$1, [point]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiPoint',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a LineString to a GeoJSON object\n   *\n   * @param {LineString}\n   *          linestring LineString to convert.\n   *\n   * @return {Array} Array of coordinates.\n   */\n  LineString: function (linestring) {\n    var this$1 = this;\n\n    var array = [];\n    var coordinates = linestring.getCoordinates();\n    for (var i = 0; i < coordinates.length; ++i) {\n      var coordinate = coordinates[i];\n      array.push(extract.coordinate.apply(this$1, [coordinate]));\n    }\n    return {\n      type: 'LineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiLineString to a GeoJSON object\n   *\n   * @param {MultiLineString}\n   *          multilinestring MultiLineString to convert.\n   *\n   * @return {Array} Array of Array of coordinates.\n   */\n  MultiLineString: function (multilinestring) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multilinestring._geometries.length; ++i) {\n      var linestring = multilinestring._geometries[i];\n      var geoJson = extract.LineString.apply(this$1, [linestring]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiLineString',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a Polygon to a GeoJSON object\n   *\n   * @param {Polygon}\n   *          polygon Polygon to convert.\n   *\n   * @return {Array} Array with shell, holes.\n   */\n  Polygon: function (polygon) {\n    var this$1 = this;\n\n    var array = [];\n    var shellGeoJson = extract.LineString.apply(this, [polygon._shell]);\n    array.push(shellGeoJson.coordinates);\n    for (var i = 0; i < polygon._holes.length; ++i) {\n      var hole = polygon._holes[i];\n      var holeGeoJson = extract.LineString.apply(this$1, [hole]);\n      array.push(holeGeoJson.coordinates);\n    }\n    return {\n      type: 'Polygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a MultiPolygon to a GeoJSON object\n   *\n   * @param {MultiPolygon}\n   *          multipolygon MultiPolygon to convert.\n   *\n   * @return {Array} Array of polygons.\n   */\n  MultiPolygon: function (multipolygon) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < multipolygon._geometries.length; ++i) {\n      var polygon = multipolygon._geometries[i];\n      var geoJson = extract.Polygon.apply(this$1, [polygon]);\n      array.push(geoJson.coordinates);\n    }\n    return {\n      type: 'MultiPolygon',\n      coordinates: array\n    }\n  },\n\n  /**\n   * Convert a GeometryCollection to a GeoJSON object\n   *\n   * @param {GeometryCollection}\n   *          collection GeometryCollection to convert.\n   *\n   * @return {Array} Array of geometries.\n   */\n  GeometryCollection: function (collection) {\n    var this$1 = this;\n\n    var array = [];\n    for (var i = 0; i < collection._geometries.length; ++i) {\n      var geometry = collection._geometries[i];\n      var type = geometry.getGeometryType();\n      array.push(extract[type].apply(this$1, [geometry]));\n    }\n    return {\n      type: 'GeometryCollection',\n      geometries: array\n    }\n  }\n};\n\n/**\n * Converts a geometry in GeoJSON to a {@link Geometry}.\n */\n\n/**\n * A <code>GeoJSONReader</code> is parameterized by a <code>GeometryFactory</code>,\n * to allow it to create <code>Geometry</code> objects of the appropriate\n * implementation. In particular, the <code>GeometryFactory</code> determines\n * the <code>PrecisionModel</code> and <code>SRID</code> that is used.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar GeoJSONReader = function GeoJSONReader (geometryFactory) {\n  this.geometryFactory = geometryFactory || new GeometryFactory();\n  this.precisionModel = this.geometryFactory.getPrecisionModel();\n  this.parser = new GeoJSONParser(this.geometryFactory);\n};\n/**\n * Reads a GeoJSON representation of a {@link Geometry}\n *\n * Will also parse GeoJSON Features/FeatureCollections as custom objects.\n *\n * @param {Object|String} geoJson a GeoJSON Object or String.\n * @return {Geometry|Object} a <code>Geometry or Feature/FeatureCollection representation.</code>\n * @memberof GeoJSONReader\n */\nGeoJSONReader.prototype.read = function read (geoJson) {\n  var geometry = this.parser.read(geoJson);\n\n  if (this.precisionModel.getType() === PrecisionModel.FIXED) {\n    this.reducePrecision(geometry);\n  }\n\n  return geometry\n};\n\n// NOTE: this is a hack\nGeoJSONReader.prototype.reducePrecision = function reducePrecision (geometry) {\n    var this$1 = this;\n\n  var i, len;\n\n  if (geometry.coordinate) {\n    this.precisionModel.makePrecise(geometry.coordinate);\n  } else if (geometry.points) {\n    for (i = 0, len = geometry.points.length; i < len; i++) {\n      this$1.precisionModel.makePrecise(geometry.points[i]);\n    }\n  } else if (geometry.geometries) {\n    for (i = 0, len = geometry.geometries.length; i < len; i++) {\n      this$1.reducePrecision(geometry.geometries[i]);\n    }\n  }\n};\n\n/**\n * @module GeoJSONWriter\n */\n\n/**\n * Writes the GeoJSON representation of a {@link Geometry}. The\n * The GeoJSON format is defined <A\n * HREF=\"http://geojson.org/geojson-spec.html\">here</A>.\n */\n\n/**\n * The <code>GeoJSONWriter</code> outputs coordinates rounded to the precision\n * model. Only the maximum number of decimal places necessary to represent the\n * ordinates to the required precision will be output.\n *\n * @param {GeometryFactory} geometryFactory\n * @constructor\n */\nvar GeoJSONWriter = function GeoJSONWriter () {\n  this.parser = new GeoJSONParser(this.geometryFactory);\n};\n/**\n * Converts a <code>Geometry</code> to its GeoJSON representation.\n *\n * @param {Geometry}\n *        geometry a <code>Geometry</code> to process.\n * @return {Object} The GeoJSON representation of the Geometry.\n * @memberof GeoJSONWriter\n */\nGeoJSONWriter.prototype.write = function write (geometry) {\n  return this.parser.write(geometry)\n};\n\n/* eslint-disable no-undef */\n\n// io\n\nvar Position = function Position () {};\n\nvar staticAccessors$20 = { ON: { configurable: true },LEFT: { configurable: true },RIGHT: { configurable: true } };\n\nPosition.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPosition.prototype.getClass = function getClass () {\n  return Position\n};\nPosition.opposite = function opposite (position) {\n  if (position === Position.LEFT) { return Position.RIGHT }\n  if (position === Position.RIGHT) { return Position.LEFT }\n  return position\n};\nstaticAccessors$20.ON.get = function () { return 0 };\nstaticAccessors$20.LEFT.get = function () { return 1 };\nstaticAccessors$20.RIGHT.get = function () { return 2 };\n\nObject.defineProperties( Position, staticAccessors$20 );\n\n/**\n * @param {string=} message Optional message\n * @extends {Error}\n * @constructor\n * @private\n */\nfunction EmptyStackException (message) {\n  this.message = message || '';\n}\nEmptyStackException.prototype = new Error();\n\n/**\n * @type {string}\n */\nEmptyStackException.prototype.name = 'EmptyStackException';\n\n/**\n * @see http://download.oracle.com/javase/6/docs/api/java/util/Stack.html\n *\n * @extends {List}\n * @constructor\n * @private\n */\nfunction Stack () {\n  /**\n   * @type {Array}\n   * @private\n   */\n  this.array_ = [];\n}\nStack.prototype = new List();\n\n/**\n * @override\n */\nStack.prototype.add = function (e) {\n  this.array_.push(e);\n  return true\n};\n\n/**\n * @override\n */\nStack.prototype.get = function (index) {\n  if (index < 0 || index >= this.size()) {\n    throw new Error()\n  }\n\n  return this.array_[index]\n};\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.push = function (e) {\n  this.array_.push(e);\n  return e\n};\n\n/**\n * Pushes an item onto the top of this stack.\n * @param {Object} e\n * @return {Object}\n */\nStack.prototype.pop = function (e) {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException()\n  }\n\n  return this.array_.pop()\n};\n\n/**\n * Looks at the object at the top of this stack without removing it from the\n * stack.\n * @return {Object}\n */\nStack.prototype.peek = function () {\n  if (this.array_.length === 0) {\n    throw new EmptyStackException()\n  }\n\n  return this.array_[this.array_.length - 1]\n};\n\n/**\n * Tests if this stack is empty.\n * @return {boolean} true if and only if this stack contains no items; false\n *         otherwise.\n */\nStack.prototype.empty = function () {\n  if (this.array_.length === 0) {\n    return true\n  } else {\n    return false\n  }\n};\n\n/**\n * @return {boolean}\n */\nStack.prototype.isEmpty = function () {\n  return this.empty()\n};\n\n/**\n * Returns the 1-based position where an object is on this stack. If the object\n * o occurs as an item in this stack, this method returns the distance from the\n * top of the stack of the occurrence nearest the top of the stack; the topmost\n * item on the stack is considered to be at distance 1. The equals method is\n * used to compare o to the items in this stack.\n *\n * NOTE: does not currently actually use equals. (=== is used)\n *\n * @param {Object} o\n * @return {number} the 1-based position from the top of the stack where the\n *         object is located; the return value -1 indicates that the object is\n *         not on the stack.\n */\nStack.prototype.search = function (o) {\n  return this.array_.indexOf(o)\n};\n\n/**\n * @return {number}\n * @export\n */\nStack.prototype.size = function () {\n  return this.array_.length\n};\n\n/**\n * @return {Array}\n */\nStack.prototype.toArray = function () {\n  var this$1 = this;\n\n  var array = [];\n\n  for (var i = 0, len = this.array_.length; i < len; i++) {\n    array.push(this$1.array_[i]);\n  }\n\n  return array\n};\n\nvar RightmostEdgeFinder = function RightmostEdgeFinder () {\n  this._minIndex = -1;\n  this._minCoord = null;\n  this._minDe = null;\n  this._orientedDe = null;\n};\nRightmostEdgeFinder.prototype.getCoordinate = function getCoordinate () {\n  return this._minCoord\n};\nRightmostEdgeFinder.prototype.getRightmostSide = function getRightmostSide (de, index) {\n  var side = this.getRightmostSideOfSegment(de, index);\n  if (side < 0) { side = this.getRightmostSideOfSegment(de, index - 1); }\n  if (side < 0) {\n    this._minCoord = null;\n    this.checkForRightmostCoordinate(de);\n  }\n  return side\n};\nRightmostEdgeFinder.prototype.findRightmostEdgeAtVertex = function findRightmostEdgeAtVertex () {\n  var pts = this._minDe.getEdge().getCoordinates();\n  Assert.isTrue(this._minIndex > 0 && this._minIndex < pts.length, 'rightmost point expected to be interior vertex of edge');\n  var pPrev = pts[this._minIndex - 1];\n  var pNext = pts[this._minIndex + 1];\n  var orientation = CGAlgorithms.computeOrientation(this._minCoord, pNext, pPrev);\n  var usePrev = false;\n  if (pPrev.y < this._minCoord.y && pNext.y < this._minCoord.y && orientation === CGAlgorithms.COUNTERCLOCKWISE) {\n    usePrev = true;\n  } else if (pPrev.y > this._minCoord.y && pNext.y > this._minCoord.y && orientation === CGAlgorithms.CLOCKWISE) {\n    usePrev = true;\n  }\n  if (usePrev) {\n    this._minIndex = this._minIndex - 1;\n  }\n};\nRightmostEdgeFinder.prototype.getRightmostSideOfSegment = function getRightmostSideOfSegment (de, i) {\n  var e = de.getEdge();\n  var coord = e.getCoordinates();\n  if (i < 0 || i + 1 >= coord.length) { return -1 }\n  if (coord[i].y === coord[i + 1].y) { return -1 }\n  var pos = Position.LEFT;\n  if (coord[i].y < coord[i + 1].y) { pos = Position.RIGHT; }\n  return pos\n};\nRightmostEdgeFinder.prototype.getEdge = function getEdge () {\n  return this._orientedDe\n};\nRightmostEdgeFinder.prototype.checkForRightmostCoordinate = function checkForRightmostCoordinate (de) {\n    var this$1 = this;\n\n  var coord = de.getEdge().getCoordinates();\n  for (var i = 0; i < coord.length - 1; i++) {\n    if (this$1._minCoord === null || coord[i].x > this$1._minCoord.x) {\n      this$1._minDe = de;\n      this$1._minIndex = i;\n      this$1._minCoord = coord[i];\n    }\n  }\n};\nRightmostEdgeFinder.prototype.findRightmostEdgeAtNode = function findRightmostEdgeAtNode () {\n  var node = this._minDe.getNode();\n  var star = node.getEdges();\n  this._minDe = star.getRightmostEdge();\n  if (!this._minDe.isForward()) {\n    this._minDe = this._minDe.getSym();\n    this._minIndex = this._minDe.getEdge().getCoordinates().length - 1;\n  }\n};\nRightmostEdgeFinder.prototype.findEdge = function findEdge (dirEdgeList) {\n    var this$1 = this;\n\n  for (var i = dirEdgeList.iterator(); i.hasNext();) {\n    var de = i.next();\n    if (!de.isForward()) { continue }\n    this$1.checkForRightmostCoordinate(de);\n  }\n  Assert.isTrue(this._minIndex !== 0 || this._minCoord.equals(this._minDe.getCoordinate()), 'inconsistency in rightmost processing');\n  if (this._minIndex === 0) {\n    this.findRightmostEdgeAtNode();\n  } else {\n    this.findRightmostEdgeAtVertex();\n  }\n  this._orientedDe = this._minDe;\n  var rightmostSide = this.getRightmostSide(this._minDe, this._minIndex);\n  if (rightmostSide === Position.LEFT) {\n    this._orientedDe = this._minDe.getSym();\n  }\n};\nRightmostEdgeFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nRightmostEdgeFinder.prototype.getClass = function getClass () {\n  return RightmostEdgeFinder\n};\n\nvar TopologyException = (function (RuntimeException$$1) {\n  function TopologyException (msg, pt) {\n    RuntimeException$$1.call(this, TopologyException.msgWithCoord(msg, pt));\n    this.pt = pt ? new Coordinate(pt) : null;\n    this.name = 'TopologyException';\n  }\n\n  if ( RuntimeException$$1 ) TopologyException.__proto__ = RuntimeException$$1;\n  TopologyException.prototype = Object.create( RuntimeException$$1 && RuntimeException$$1.prototype );\n  TopologyException.prototype.constructor = TopologyException;\n  TopologyException.prototype.getCoordinate = function getCoordinate () {\n    return this.pt\n  };\n  TopologyException.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  TopologyException.prototype.getClass = function getClass () {\n    return TopologyException\n  };\n  TopologyException.msgWithCoord = function msgWithCoord (msg, pt) {\n    if (!pt) { return msg + ' [ ' + pt + ' ]' }\n    return msg\n  };\n\n  return TopologyException;\n}(RuntimeException));\n\nvar LinkedList = function LinkedList () {\n  this.array_ = [];\n};\nLinkedList.prototype.addLast = function addLast (e) {\n  this.array_.push(e);\n};\nLinkedList.prototype.removeFirst = function removeFirst () {\n  return this.array_.shift()\n};\nLinkedList.prototype.isEmpty = function isEmpty () {\n  return this.array_.length === 0\n};\n\nvar BufferSubgraph = function BufferSubgraph () {\n  this._finder = null;\n  this._dirEdgeList = new ArrayList();\n  this._nodes = new ArrayList();\n  this._rightMostCoord = null;\n  this._env = null;\n  this._finder = new RightmostEdgeFinder();\n};\nBufferSubgraph.prototype.clearVisitedEdges = function clearVisitedEdges () {\n  for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n    var de = it.next();\n    de.setVisited(false);\n  }\n};\nBufferSubgraph.prototype.getRightmostCoordinate = function getRightmostCoordinate () {\n  return this._rightMostCoord\n};\nBufferSubgraph.prototype.computeNodeDepth = function computeNodeDepth (n) {\n    var this$1 = this;\n\n  var startEdge = null;\n  for (var i = n.getEdges().iterator(); i.hasNext();) {\n    var de = i.next();\n    if (de.isVisited() || de.getSym().isVisited()) {\n      startEdge = de;\n      break\n    }\n  }\n  if (startEdge === null) { throw new TopologyException('unable to find edge to compute depths at ' + n.getCoordinate()) }\n  n.getEdges().computeDepths(startEdge);\n  for (var i$1 = n.getEdges().iterator(); i$1.hasNext();) {\n    var de$1 = i$1.next();\n    de$1.setVisited(true);\n    this$1.copySymDepths(de$1);\n  }\n};\nBufferSubgraph.prototype.computeDepth = function computeDepth (outsideDepth) {\n  this.clearVisitedEdges();\n  var de = this._finder.getEdge();\n  // const n = de.getNode()\n  // const label = de.getLabel()\n  de.setEdgeDepths(Position.RIGHT, outsideDepth);\n  this.copySymDepths(de);\n  this.computeDepths(de);\n};\nBufferSubgraph.prototype.create = function create (node) {\n  this.addReachable(node);\n  this._finder.findEdge(this._dirEdgeList);\n  this._rightMostCoord = this._finder.getCoordinate();\n};\nBufferSubgraph.prototype.findResultEdges = function findResultEdges () {\n  for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n    var de = it.next();\n    if (de.getDepth(Position.RIGHT) >= 1 && de.getDepth(Position.LEFT) <= 0 && !de.isInteriorAreaEdge()) {\n      de.setInResult(true);\n    }\n  }\n};\nBufferSubgraph.prototype.computeDepths = function computeDepths (startEdge) {\n    var this$1 = this;\n\n  var nodesVisited = new HashSet();\n  var nodeQueue = new LinkedList();\n  var startNode = startEdge.getNode();\n  nodeQueue.addLast(startNode);\n  nodesVisited.add(startNode);\n  startEdge.setVisited(true);\n  while (!nodeQueue.isEmpty()) {\n    var n = nodeQueue.removeFirst();\n    nodesVisited.add(n);\n    this$1.computeNodeDepth(n);\n    for (var i = n.getEdges().iterator(); i.hasNext();) {\n      var de = i.next();\n      var sym = de.getSym();\n      if (sym.isVisited()) { continue }\n      var adjNode = sym.getNode();\n      if (!nodesVisited.contains(adjNode)) {\n        nodeQueue.addLast(adjNode);\n        nodesVisited.add(adjNode);\n      }\n    }\n  }\n};\nBufferSubgraph.prototype.compareTo = function compareTo (o) {\n  var graph = o;\n  if (this._rightMostCoord.x < graph._rightMostCoord.x) {\n    return -1\n  }\n  if (this._rightMostCoord.x > graph._rightMostCoord.x) {\n    return 1\n  }\n  return 0\n};\nBufferSubgraph.prototype.getEnvelope = function getEnvelope () {\n  if (this._env === null) {\n    var edgeEnv = new Envelope();\n    for (var it = this._dirEdgeList.iterator(); it.hasNext();) {\n      var dirEdge = it.next();\n      var pts = dirEdge.getEdge().getCoordinates();\n      for (var i = 0; i < pts.length - 1; i++) {\n        edgeEnv.expandToInclude(pts[i]);\n      }\n    }\n    this._env = edgeEnv;\n  }\n  return this._env\n};\nBufferSubgraph.prototype.addReachable = function addReachable (startNode) {\n    var this$1 = this;\n\n  var nodeStack = new Stack();\n  nodeStack.add(startNode);\n  while (!nodeStack.empty()) {\n    var node = nodeStack.pop();\n    this$1.add(node, nodeStack);\n  }\n};\nBufferSubgraph.prototype.copySymDepths = function copySymDepths (de) {\n  var sym = de.getSym();\n  sym.setDepth(Position.LEFT, de.getDepth(Position.RIGHT));\n  sym.setDepth(Position.RIGHT, de.getDepth(Position.LEFT));\n};\nBufferSubgraph.prototype.add = function add (node, nodeStack) {\n    var this$1 = this;\n\n  node.setVisited(true);\n  this._nodes.add(node);\n  for (var i = node.getEdges().iterator(); i.hasNext();) {\n    var de = i.next();\n    this$1._dirEdgeList.add(de);\n    var sym = de.getSym();\n    var symNode = sym.getNode();\n    if (!symNode.isVisited()) { nodeStack.push(symNode); }\n  }\n};\nBufferSubgraph.prototype.getNodes = function getNodes () {\n  return this._nodes\n};\nBufferSubgraph.prototype.getDirectedEdges = function getDirectedEdges () {\n  return this._dirEdgeList\n};\nBufferSubgraph.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nBufferSubgraph.prototype.getClass = function getClass () {\n  return BufferSubgraph\n};\n\nvar TopologyLocation = function TopologyLocation () {\n  var this$1 = this;\n\n  this.location = null;\n  if (arguments.length === 1) {\n    if (arguments[0] instanceof Array) {\n      var location = arguments[0];\n      this.init(location.length);\n    } else if (Number.isInteger(arguments[0])) {\n      var on = arguments[0];\n      this.init(1);\n      this.location[Position.ON] = on;\n    } else if (arguments[0] instanceof TopologyLocation) {\n      var gl = arguments[0];\n      this.init(gl.location.length);\n      if (gl !== null) {\n        for (var i = 0; i < this.location.length; i++) {\n          this$1.location[i] = gl.location[i];\n        }\n      }\n    }\n  } else if (arguments.length === 3) {\n    var on$1 = arguments[0];\n    var left = arguments[1];\n    var right = arguments[2];\n    this.init(3);\n    this.location[Position.ON] = on$1;\n    this.location[Position.LEFT] = left;\n    this.location[Position.RIGHT] = right;\n  }\n};\nTopologyLocation.prototype.setAllLocations = function setAllLocations (locValue) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    this$1.location[i] = locValue;\n  }\n};\nTopologyLocation.prototype.isNull = function isNull () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] !== Location.NONE) { return false }\n  }\n  return true\n};\nTopologyLocation.prototype.setAllLocationsIfNull = function setAllLocationsIfNull (locValue) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE) { this$1.location[i] = locValue; }\n  }\n};\nTopologyLocation.prototype.isLine = function isLine () {\n  return this.location.length === 1\n};\nTopologyLocation.prototype.merge = function merge (gl) {\n    var this$1 = this;\n\n  if (gl.location.length > this.location.length) {\n    var newLoc = new Array(3).fill(null);\n    newLoc[Position.ON] = this.location[Position.ON];\n    newLoc[Position.LEFT] = Location.NONE;\n    newLoc[Position.RIGHT] = Location.NONE;\n    this.location = newLoc;\n  }\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE && i < gl.location.length) { this$1.location[i] = gl.location[i]; }\n  }\n};\nTopologyLocation.prototype.getLocations = function getLocations () {\n  return this.location\n};\nTopologyLocation.prototype.flip = function flip () {\n  if (this.location.length <= 1) { return null }\n  var temp = this.location[Position.LEFT];\n  this.location[Position.LEFT] = this.location[Position.RIGHT];\n  this.location[Position.RIGHT] = temp;\n};\nTopologyLocation.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position.LEFT])); }\n  buf.append(Location.toLocationSymbol(this.location[Position.ON]));\n  if (this.location.length > 1) { buf.append(Location.toLocationSymbol(this.location[Position.RIGHT])); }\n  return buf.toString()\n};\nTopologyLocation.prototype.setLocations = function setLocations (on, left, right) {\n  this.location[Position.ON] = on;\n  this.location[Position.LEFT] = left;\n  this.location[Position.RIGHT] = right;\n};\nTopologyLocation.prototype.get = function get (posIndex) {\n  if (posIndex < this.location.length) { return this.location[posIndex] }\n  return Location.NONE\n};\nTopologyLocation.prototype.isArea = function isArea () {\n  return this.location.length > 1\n};\nTopologyLocation.prototype.isAnyNull = function isAnyNull () {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] === Location.NONE) { return true }\n  }\n  return false\n};\nTopologyLocation.prototype.setLocation = function setLocation () {\n  if (arguments.length === 1) {\n    var locValue = arguments[0];\n    this.setLocation(Position.ON, locValue);\n  } else if (arguments.length === 2) {\n    var locIndex = arguments[0];\n    var locValue$1 = arguments[1];\n    this.location[locIndex] = locValue$1;\n  }\n};\nTopologyLocation.prototype.init = function init (size) {\n  this.location = new Array(size).fill(null);\n  this.setAllLocations(Location.NONE);\n};\nTopologyLocation.prototype.isEqualOnSide = function isEqualOnSide (le, locIndex) {\n  return this.location[locIndex] === le.location[locIndex]\n};\nTopologyLocation.prototype.allPositionsEqual = function allPositionsEqual (loc) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.location.length; i++) {\n    if (this$1.location[i] !== loc) { return false }\n  }\n  return true\n};\nTopologyLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nTopologyLocation.prototype.getClass = function getClass () {\n  return TopologyLocation\n};\n\nvar Label = function Label () {\n  this.elt = new Array(2).fill(null);\n  if (arguments.length === 1) {\n    if (Number.isInteger(arguments[0])) {\n      var onLoc = arguments[0];\n      this.elt[0] = new TopologyLocation(onLoc);\n      this.elt[1] = new TopologyLocation(onLoc);\n    } else if (arguments[0] instanceof Label) {\n      var lbl = arguments[0];\n      this.elt[0] = new TopologyLocation(lbl.elt[0]);\n      this.elt[1] = new TopologyLocation(lbl.elt[1]);\n    }\n  } else if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var onLoc$1 = arguments[1];\n    this.elt[0] = new TopologyLocation(Location.NONE);\n    this.elt[1] = new TopologyLocation(Location.NONE);\n    this.elt[geomIndex].setLocation(onLoc$1);\n  } else if (arguments.length === 3) {\n    var onLoc$2 = arguments[0];\n    var leftLoc = arguments[1];\n    var rightLoc = arguments[2];\n    this.elt[0] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);\n    this.elt[1] = new TopologyLocation(onLoc$2, leftLoc, rightLoc);\n  } else if (arguments.length === 4) {\n    var geomIndex$1 = arguments[0];\n    var onLoc$3 = arguments[1];\n    var leftLoc$1 = arguments[2];\n    var rightLoc$1 = arguments[3];\n    this.elt[0] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n    this.elt[1] = new TopologyLocation(Location.NONE, Location.NONE, Location.NONE);\n    this.elt[geomIndex$1].setLocations(onLoc$3, leftLoc$1, rightLoc$1);\n  }\n};\nLabel.prototype.getGeometryCount = function getGeometryCount () {\n  var count = 0;\n  if (!this.elt[0].isNull()) { count++; }\n  if (!this.elt[1].isNull()) { count++; }\n  return count\n};\nLabel.prototype.setAllLocations = function setAllLocations (geomIndex, location) {\n  this.elt[geomIndex].setAllLocations(location);\n};\nLabel.prototype.isNull = function isNull (geomIndex) {\n  return this.elt[geomIndex].isNull()\n};\nLabel.prototype.setAllLocationsIfNull = function setAllLocationsIfNull () {\n  if (arguments.length === 1) {\n    var location = arguments[0];\n    this.setAllLocationsIfNull(0, location);\n    this.setAllLocationsIfNull(1, location);\n  } else if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var location$1 = arguments[1];\n    this.elt[geomIndex].setAllLocationsIfNull(location$1);\n  }\n};\nLabel.prototype.isLine = function isLine (geomIndex) {\n  return this.elt[geomIndex].isLine()\n};\nLabel.prototype.merge = function merge (lbl) {\n    var this$1 = this;\n\n  for (var i = 0; i < 2; i++) {\n    if (this$1.elt[i] === null && lbl.elt[i] !== null) {\n      this$1.elt[i] = new TopologyLocation(lbl.elt[i]);\n    } else {\n      this$1.elt[i].merge(lbl.elt[i]);\n    }\n  }\n};\nLabel.prototype.flip = function flip () {\n  this.elt[0].flip();\n  this.elt[1].flip();\n};\nLabel.prototype.getLocation = function getLocation () {\n  if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this.elt[geomIndex].get(Position.ON)\n  } else if (arguments.length === 2) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    return this.elt[geomIndex$1].get(posIndex)\n  }\n};\nLabel.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  if (this.elt[0] !== null) {\n    buf.append('A:');\n    buf.append(this.elt[0].toString());\n  }\n  if (this.elt[1] !== null) {\n    buf.append(' B:');\n    buf.append(this.elt[1].toString());\n  }\n  return buf.toString()\n};\nLabel.prototype.isArea = function isArea () {\n  if (arguments.length === 0) {\n    return this.elt[0].isArea() || this.elt[1].isArea()\n  } else if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this.elt[geomIndex].isArea()\n  }\n};\nLabel.prototype.isAnyNull = function isAnyNull (geomIndex) {\n  return this.elt[geomIndex].isAnyNull()\n};\nLabel.prototype.setLocation = function setLocation () {\n  if (arguments.length === 2) {\n    var geomIndex = arguments[0];\n    var location = arguments[1];\n    this.elt[geomIndex].setLocation(Position.ON, location);\n  } else if (arguments.length === 3) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    var location$1 = arguments[2];\n    this.elt[geomIndex$1].setLocation(posIndex, location$1);\n  }\n};\nLabel.prototype.isEqualOnSide = function isEqualOnSide (lbl, side) {\n  return this.elt[0].isEqualOnSide(lbl.elt[0], side) && this.elt[1].isEqualOnSide(lbl.elt[1], side)\n};\nLabel.prototype.allPositionsEqual = function allPositionsEqual (geomIndex, loc) {\n  return this.elt[geomIndex].allPositionsEqual(loc)\n};\nLabel.prototype.toLine = function toLine (geomIndex) {\n  if (this.elt[geomIndex].isArea()) { this.elt[geomIndex] = new TopologyLocation(this.elt[geomIndex].location[0]); }\n};\nLabel.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLabel.prototype.getClass = function getClass () {\n  return Label\n};\nLabel.toLineLabel = function toLineLabel (label) {\n  var lineLabel = new Label(Location.NONE);\n  for (var i = 0; i < 2; i++) {\n    lineLabel.setLocation(i, label.getLocation(i));\n  }\n  return lineLabel\n};\n\nvar EdgeRing = function EdgeRing () {\n  this._startDe = null;\n  this._maxNodeDegree = -1;\n  this._edges = new ArrayList();\n  this._pts = new ArrayList();\n  this._label = new Label(Location.NONE);\n  this._ring = null;\n  this._isHole = null;\n  this._shell = null;\n  this._holes = new ArrayList();\n  this._geometryFactory = null;\n  var start = arguments[0];\n  var geometryFactory = arguments[1];\n  this._geometryFactory = geometryFactory;\n  this.computePoints(start);\n  this.computeRing();\n};\nEdgeRing.prototype.computeRing = function computeRing () {\n    var this$1 = this;\n\n  if (this._ring !== null) { return null }\n  var coord = new Array(this._pts.size()).fill(null);\n  for (var i = 0; i < this._pts.size(); i++) {\n    coord[i] = this$1._pts.get(i);\n  }\n  this._ring = this._geometryFactory.createLinearRing(coord);\n  this._isHole = CGAlgorithms.isCCW(this._ring.getCoordinates());\n};\nEdgeRing.prototype.isIsolated = function isIsolated () {\n  return this._label.getGeometryCount() === 1\n};\nEdgeRing.prototype.computePoints = function computePoints (start) {\n    var this$1 = this;\n\n  this._startDe = start;\n  var de = start;\n  var isFirstEdge = true;\n  do {\n    if (de === null) { throw new TopologyException('Found null DirectedEdge') }\n    if (de.getEdgeRing() === this$1) { throw new TopologyException('Directed Edge visited twice during ring-building at ' + de.getCoordinate()) }\n    this$1._edges.add(de);\n    var label = de.getLabel();\n    Assert.isTrue(label.isArea());\n    this$1.mergeLabel(label);\n    this$1.addPoints(de.getEdge(), de.isForward(), isFirstEdge);\n    isFirstEdge = false;\n    this$1.setEdgeRing(de, this$1);\n    de = this$1.getNext(de);\n  } while (de !== this._startDe)\n};\nEdgeRing.prototype.getLinearRing = function getLinearRing () {\n  return this._ring\n};\nEdgeRing.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts.get(i)\n};\nEdgeRing.prototype.computeMaxNodeDegree = function computeMaxNodeDegree () {\n    var this$1 = this;\n\n  this._maxNodeDegree = 0;\n  var de = this._startDe;\n  do {\n    var node = de.getNode();\n    var degree = node.getEdges().getOutgoingDegree(this$1);\n    if (degree > this$1._maxNodeDegree) { this$1._maxNodeDegree = degree; }\n    de = this$1.getNext(de);\n  } while (de !== this._startDe)\n  this._maxNodeDegree *= 2;\n};\nEdgeRing.prototype.addPoints = function addPoints (edge, isForward, isFirstEdge) {\n    var this$1 = this;\n\n  var edgePts = edge.getCoordinates();\n  if (isForward) {\n    var startIndex = 1;\n    if (isFirstEdge) { startIndex = 0; }\n    for (var i = startIndex; i < edgePts.length; i++) {\n      this$1._pts.add(edgePts[i]);\n    }\n  } else {\n    var startIndex$1 = edgePts.length - 2;\n    if (isFirstEdge) { startIndex$1 = edgePts.length - 1; }\n    for (var i$1 = startIndex$1; i$1 >= 0; i$1--) {\n      this$1._pts.add(edgePts[i$1]);\n    }\n  }\n};\nEdgeRing.prototype.isHole = function isHole () {\n  return this._isHole\n};\nEdgeRing.prototype.setInResult = function setInResult () {\n  var de = this._startDe;\n  do {\n    de.getEdge().setInResult(true);\n    de = de.getNext();\n  } while (de !== this._startDe)\n};\nEdgeRing.prototype.containsPoint = function containsPoint (p) {\n  var shell = this.getLinearRing();\n  var env = shell.getEnvelopeInternal();\n  if (!env.contains(p)) { return false }\n  if (!CGAlgorithms.isPointInRing(p, shell.getCoordinates())) { return false }\n  for (var i = this._holes.iterator(); i.hasNext();) {\n    var hole = i.next();\n    if (hole.containsPoint(p)) { return false }\n  }\n  return true\n};\nEdgeRing.prototype.addHole = function addHole (ring) {\n  this._holes.add(ring);\n};\nEdgeRing.prototype.isShell = function isShell () {\n  return this._shell === null\n};\nEdgeRing.prototype.getLabel = function getLabel () {\n  return this._label\n};\nEdgeRing.prototype.getEdges = function getEdges () {\n  return this._edges\n};\nEdgeRing.prototype.getMaxNodeDegree = function getMaxNodeDegree () {\n  if (this._maxNodeDegree < 0) { this.computeMaxNodeDegree(); }\n  return this._maxNodeDegree\n};\nEdgeRing.prototype.getShell = function getShell () {\n  return this._shell\n};\nEdgeRing.prototype.mergeLabel = function mergeLabel () {\n  if (arguments.length === 1) {\n    var deLabel = arguments[0];\n    this.mergeLabel(deLabel, 0);\n    this.mergeLabel(deLabel, 1);\n  } else if (arguments.length === 2) {\n    var deLabel$1 = arguments[0];\n    var geomIndex = arguments[1];\n    var loc = deLabel$1.getLocation(geomIndex, Position.RIGHT);\n    if (loc === Location.NONE) { return null }\n    if (this._label.getLocation(geomIndex) === Location.NONE) {\n      this._label.setLocation(geomIndex, loc);\n      return null\n    }\n  }\n};\nEdgeRing.prototype.setShell = function setShell (shell) {\n  this._shell = shell;\n  if (shell !== null) { shell.addHole(this); }\n};\nEdgeRing.prototype.toPolygon = function toPolygon (geometryFactory) {\n    var this$1 = this;\n\n  var holeLR = new Array(this._holes.size()).fill(null);\n  for (var i = 0; i < this._holes.size(); i++) {\n    holeLR[i] = this$1._holes.get(i).getLinearRing();\n  }\n  var poly = geometryFactory.createPolygon(this.getLinearRing(), holeLR);\n  return poly\n};\nEdgeRing.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeRing.prototype.getClass = function getClass () {\n  return EdgeRing\n};\n\nvar MinimalEdgeRing = (function (EdgeRing$$1) {\n  function MinimalEdgeRing () {\n    var start = arguments[0];\n    var geometryFactory = arguments[1];\n    EdgeRing$$1.call(this, start, geometryFactory);\n  }\n\n  if ( EdgeRing$$1 ) MinimalEdgeRing.__proto__ = EdgeRing$$1;\n  MinimalEdgeRing.prototype = Object.create( EdgeRing$$1 && EdgeRing$$1.prototype );\n  MinimalEdgeRing.prototype.constructor = MinimalEdgeRing;\n  MinimalEdgeRing.prototype.setEdgeRing = function setEdgeRing (de, er) {\n    de.setMinEdgeRing(er);\n  };\n  MinimalEdgeRing.prototype.getNext = function getNext (de) {\n    return de.getNextMin()\n  };\n  MinimalEdgeRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MinimalEdgeRing.prototype.getClass = function getClass () {\n    return MinimalEdgeRing\n  };\n\n  return MinimalEdgeRing;\n}(EdgeRing));\n\nvar MaximalEdgeRing = (function (EdgeRing$$1) {\n  function MaximalEdgeRing () {\n    var start = arguments[0];\n    var geometryFactory = arguments[1];\n    EdgeRing$$1.call(this, start, geometryFactory);\n  }\n\n  if ( EdgeRing$$1 ) MaximalEdgeRing.__proto__ = EdgeRing$$1;\n  MaximalEdgeRing.prototype = Object.create( EdgeRing$$1 && EdgeRing$$1.prototype );\n  MaximalEdgeRing.prototype.constructor = MaximalEdgeRing;\n  MaximalEdgeRing.prototype.buildMinimalRings = function buildMinimalRings () {\n    var this$1 = this;\n\n    var minEdgeRings = new ArrayList();\n    var de = this._startDe;\n    do {\n      if (de.getMinEdgeRing() === null) {\n        var minEr = new MinimalEdgeRing(de, this$1._geometryFactory);\n        minEdgeRings.add(minEr);\n      }\n      de = de.getNext();\n    } while (de !== this._startDe)\n    return minEdgeRings\n  };\n  MaximalEdgeRing.prototype.setEdgeRing = function setEdgeRing (de, er) {\n    de.setEdgeRing(er);\n  };\n  MaximalEdgeRing.prototype.linkDirectedEdgesForMinimalEdgeRings = function linkDirectedEdgesForMinimalEdgeRings () {\n    var this$1 = this;\n\n    var de = this._startDe;\n    do {\n      var node = de.getNode();\n      node.getEdges().linkMinimalDirectedEdges(this$1);\n      de = de.getNext();\n    } while (de !== this._startDe)\n  };\n  MaximalEdgeRing.prototype.getNext = function getNext (de) {\n    return de.getNext()\n  };\n  MaximalEdgeRing.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MaximalEdgeRing.prototype.getClass = function getClass () {\n    return MaximalEdgeRing\n  };\n\n  return MaximalEdgeRing;\n}(EdgeRing));\n\nvar GraphComponent = function GraphComponent () {\n  this._label = null;\n  this._isInResult = false;\n  this._isCovered = false;\n  this._isCoveredSet = false;\n  this._isVisited = false;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var label = arguments[0];\n    this._label = label;\n  }\n};\nGraphComponent.prototype.setVisited = function setVisited (isVisited) {\n  this._isVisited = isVisited;\n};\nGraphComponent.prototype.setInResult = function setInResult (isInResult) {\n  this._isInResult = isInResult;\n};\nGraphComponent.prototype.isCovered = function isCovered () {\n  return this._isCovered\n};\nGraphComponent.prototype.isCoveredSet = function isCoveredSet () {\n  return this._isCoveredSet\n};\nGraphComponent.prototype.setLabel = function setLabel (label) {\n  this._label = label;\n};\nGraphComponent.prototype.getLabel = function getLabel () {\n  return this._label\n};\nGraphComponent.prototype.setCovered = function setCovered (isCovered) {\n  this._isCovered = isCovered;\n  this._isCoveredSet = true;\n};\nGraphComponent.prototype.updateIM = function updateIM (im) {\n  Assert.isTrue(this._label.getGeometryCount() >= 2, 'found partial label');\n  this.computeIM(im);\n};\nGraphComponent.prototype.isInResult = function isInResult () {\n  return this._isInResult\n};\nGraphComponent.prototype.isVisited = function isVisited () {\n  return this._isVisited\n};\nGraphComponent.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGraphComponent.prototype.getClass = function getClass () {\n  return GraphComponent\n};\n\nvar Node = (function (GraphComponent$$1) {\n  function Node () {\n    GraphComponent$$1.call(this);\n    this._coord = null;\n    this._edges = null;\n    var coord = arguments[0];\n    var edges = arguments[1];\n    this._coord = coord;\n    this._edges = edges;\n    this._label = new Label(0, Location.NONE);\n  }\n\n  if ( GraphComponent$$1 ) Node.__proto__ = GraphComponent$$1;\n  Node.prototype = Object.create( GraphComponent$$1 && GraphComponent$$1.prototype );\n  Node.prototype.constructor = Node;\n  Node.prototype.isIncidentEdgeInResult = function isIncidentEdgeInResult () {\n    for (var it = this.getEdges().getEdges().iterator(); it.hasNext();) {\n      var de = it.next();\n      if (de.getEdge().isInResult()) { return true }\n    }\n    return false\n  };\n  Node.prototype.isIsolated = function isIsolated () {\n    return this._label.getGeometryCount() === 1\n  };\n  Node.prototype.getCoordinate = function getCoordinate () {\n    return this._coord\n  };\n  Node.prototype.print = function print (out) {\n    out.println('node ' + this._coord + ' lbl: ' + this._label);\n  };\n  Node.prototype.computeIM = function computeIM (im) {};\n  Node.prototype.computeMergedLocation = function computeMergedLocation (label2, eltIndex) {\n    var loc = Location.NONE;\n    loc = this._label.getLocation(eltIndex);\n    if (!label2.isNull(eltIndex)) {\n      var nLoc = label2.getLocation(eltIndex);\n      if (loc !== Location.BOUNDARY) { loc = nLoc; }\n    }\n    return loc\n  };\n  Node.prototype.setLabel = function setLabel () {\n    if (arguments.length === 2) {\n      var argIndex = arguments[0];\n      var onLocation = arguments[1];\n      if (this._label === null) {\n        this._label = new Label(argIndex, onLocation);\n      } else { this._label.setLocation(argIndex, onLocation); }\n    } else { return GraphComponent$$1.prototype.setLabel.apply(this, arguments) }\n  };\n  Node.prototype.getEdges = function getEdges () {\n    return this._edges\n  };\n  Node.prototype.mergeLabel = function mergeLabel () {\n    var this$1 = this;\n\n    if (arguments[0] instanceof Node) {\n      var n = arguments[0];\n      this.mergeLabel(n._label);\n    } else if (arguments[0] instanceof Label) {\n      var label2 = arguments[0];\n      for (var i = 0; i < 2; i++) {\n        var loc = this$1.computeMergedLocation(label2, i);\n        var thisLoc = this$1._label.getLocation(i);\n        if (thisLoc === Location.NONE) { this$1._label.setLocation(i, loc); }\n      }\n    }\n  };\n  Node.prototype.add = function add (e) {\n    this._edges.insert(e);\n    e.setNode(this);\n  };\n  Node.prototype.setLabelBoundary = function setLabelBoundary (argIndex) {\n    if (this._label === null) { return null }\n    var loc = Location.NONE;\n    if (this._label !== null) { loc = this._label.getLocation(argIndex); }\n    var newLoc = null;\n    switch (loc) {\n      case Location.BOUNDARY:\n        newLoc = Location.INTERIOR;\n        break\n      case Location.INTERIOR:\n        newLoc = Location.BOUNDARY;\n        break\n      default:\n        newLoc = Location.BOUNDARY;\n        break\n    }\n    this._label.setLocation(argIndex, newLoc);\n  };\n  Node.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  Node.prototype.getClass = function getClass () {\n    return Node\n  };\n\n  return Node;\n}(GraphComponent));\n\nvar NodeMap = function NodeMap () {\n  this.nodeMap = new TreeMap();\n  this.nodeFact = null;\n  var nodeFact = arguments[0];\n  this.nodeFact = nodeFact;\n};\nNodeMap.prototype.find = function find (coord) {\n  return this.nodeMap.get(coord)\n};\nNodeMap.prototype.addNode = function addNode () {\n  if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    var node = this.nodeMap.get(coord);\n    if (node === null) {\n      node = this.nodeFact.createNode(coord);\n      this.nodeMap.put(coord, node);\n    }\n    return node\n  } else if (arguments[0] instanceof Node) {\n    var n = arguments[0];\n    var node$1 = this.nodeMap.get(n.getCoordinate());\n    if (node$1 === null) {\n      this.nodeMap.put(n.getCoordinate(), n);\n      return n\n    }\n    node$1.mergeLabel(n);\n    return node$1\n  }\n};\nNodeMap.prototype.print = function print (out) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var n = it.next();\n    n.print(out);\n  }\n};\nNodeMap.prototype.iterator = function iterator () {\n  return this.nodeMap.values().iterator()\n};\nNodeMap.prototype.values = function values () {\n  return this.nodeMap.values()\n};\nNodeMap.prototype.getBoundaryNodes = function getBoundaryNodes (geomIndex) {\n  var bdyNodes = new ArrayList();\n  for (var i = this.iterator(); i.hasNext();) {\n    var node = i.next();\n    if (node.getLabel().getLocation(geomIndex) === Location.BOUNDARY) { bdyNodes.add(node); }\n  }\n  return bdyNodes\n};\nNodeMap.prototype.add = function add (e) {\n  var p = e.getCoordinate();\n  var n = this.addNode(p);\n  n.add(e);\n};\nNodeMap.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodeMap.prototype.getClass = function getClass () {\n  return NodeMap\n};\n\nvar Quadrant = function Quadrant () {};\n\nvar staticAccessors$21 = { NE: { configurable: true },NW: { configurable: true },SW: { configurable: true },SE: { configurable: true } };\n\nQuadrant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nQuadrant.prototype.getClass = function getClass () {\n  return Quadrant\n};\nQuadrant.isNorthern = function isNorthern (quad) {\n  return quad === Quadrant.NE || quad === Quadrant.NW\n};\nQuadrant.isOpposite = function isOpposite (quad1, quad2) {\n  if (quad1 === quad2) { return false }\n  var diff = (quad1 - quad2 + 4) % 4;\n  if (diff === 2) { return true }\n  return false\n};\nQuadrant.commonHalfPlane = function commonHalfPlane (quad1, quad2) {\n  if (quad1 === quad2) { return quad1 }\n  var diff = (quad1 - quad2 + 4) % 4;\n  if (diff === 2) { return -1 }\n  var min = quad1 < quad2 ? quad1 : quad2;\n  var max = quad1 > quad2 ? quad1 : quad2;\n  if (min === 0 && max === 3) { return 3 }\n  return min\n};\nQuadrant.isInHalfPlane = function isInHalfPlane (quad, halfPlane) {\n  if (halfPlane === Quadrant.SE) {\n    return quad === Quadrant.SE || quad === Quadrant.SW\n  }\n  return quad === halfPlane || quad === halfPlane + 1\n};\nQuadrant.quadrant = function quadrant () {\n  if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n    var dx = arguments[0];\n    var dy = arguments[1];\n    if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException('Cannot compute the quadrant for point ( ' + dx + ', ' + dy + ' )') }\n    if (dx >= 0.0) {\n      if (dy >= 0.0) { return Quadrant.NE; } else { return Quadrant.SE }\n    } else {\n      if (dy >= 0.0) { return Quadrant.NW; } else { return Quadrant.SW }\n    }\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (p1.x === p0.x && p1.y === p0.y) { throw new IllegalArgumentException('Cannot compute the quadrant for two identical points ' + p0) }\n    if (p1.x >= p0.x) {\n      if (p1.y >= p0.y) { return Quadrant.NE; } else { return Quadrant.SE }\n    } else {\n      if (p1.y >= p0.y) { return Quadrant.NW; } else { return Quadrant.SW }\n    }\n  }\n};\nstaticAccessors$21.NE.get = function () { return 0 };\nstaticAccessors$21.NW.get = function () { return 1 };\nstaticAccessors$21.SW.get = function () { return 2 };\nstaticAccessors$21.SE.get = function () { return 3 };\n\nObject.defineProperties( Quadrant, staticAccessors$21 );\n\nvar EdgeEnd = function EdgeEnd () {\n  this._edge = null;\n  this._label = null;\n  this._node = null;\n  this._p0 = null;\n  this._p1 = null;\n  this._dx = null;\n  this._dy = null;\n  this._quadrant = null;\n  if (arguments.length === 1) {\n    var edge = arguments[0];\n    this._edge = edge;\n  } else if (arguments.length === 3) {\n    var edge$1 = arguments[0];\n    var p0 = arguments[1];\n    var p1 = arguments[2];\n    var label = null;\n    this._edge = edge$1;\n    this.init(p0, p1);\n    this._label = label;\n  } else if (arguments.length === 4) {\n    var edge$2 = arguments[0];\n    var p0$1 = arguments[1];\n    var p1$1 = arguments[2];\n    var label$1 = arguments[3];\n    this._edge = edge$2;\n    this.init(p0$1, p1$1);\n    this._label = label$1;\n  }\n};\nEdgeEnd.prototype.compareDirection = function compareDirection (e) {\n  if (this._dx === e._dx && this._dy === e._dy) { return 0 }\n  if (this._quadrant > e._quadrant) { return 1 }\n  if (this._quadrant < e._quadrant) { return -1 }\n  return CGAlgorithms.computeOrientation(e._p0, e._p1, this._p1)\n};\nEdgeEnd.prototype.getDy = function getDy () {\n  return this._dy\n};\nEdgeEnd.prototype.getCoordinate = function getCoordinate () {\n  return this._p0\n};\nEdgeEnd.prototype.setNode = function setNode (node) {\n  this._node = node;\n};\nEdgeEnd.prototype.print = function print (out) {\n  var angle = Math.atan2(this._dy, this._dx);\n  var className = this.getClass().getName();\n  var lastDotPos = className.lastIndexOf('.');\n  var name = className.substring(lastDotPos + 1);\n  out.print('  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label);\n};\nEdgeEnd.prototype.compareTo = function compareTo (obj) {\n  var e = obj;\n  return this.compareDirection(e)\n};\nEdgeEnd.prototype.getDirectedCoordinate = function getDirectedCoordinate () {\n  return this._p1\n};\nEdgeEnd.prototype.getDx = function getDx () {\n  return this._dx\n};\nEdgeEnd.prototype.getLabel = function getLabel () {\n  return this._label\n};\nEdgeEnd.prototype.getEdge = function getEdge () {\n  return this._edge\n};\nEdgeEnd.prototype.getQuadrant = function getQuadrant () {\n  return this._quadrant\n};\nEdgeEnd.prototype.getNode = function getNode () {\n  return this._node\n};\nEdgeEnd.prototype.toString = function toString () {\n  var angle = Math.atan2(this._dy, this._dx);\n  var className = this.getClass().getName();\n  var lastDotPos = className.lastIndexOf('.');\n  var name = className.substring(lastDotPos + 1);\n  return '  ' + name + ': ' + this._p0 + ' - ' + this._p1 + ' ' + this._quadrant + ':' + angle + '   ' + this._label\n};\nEdgeEnd.prototype.computeLabel = function computeLabel (boundaryNodeRule) {};\nEdgeEnd.prototype.init = function init (p0, p1) {\n  this._p0 = p0;\n  this._p1 = p1;\n  this._dx = p1.x - p0.x;\n  this._dy = p1.y - p0.y;\n  this._quadrant = Quadrant.quadrant(this._dx, this._dy);\n  Assert.isTrue(!(this._dx === 0 && this._dy === 0), 'EdgeEnd with identical endpoints found');\n};\nEdgeEnd.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nEdgeEnd.prototype.getClass = function getClass () {\n  return EdgeEnd\n};\n\nvar DirectedEdge = (function (EdgeEnd$$1) {\n  function DirectedEdge () {\n    var edge = arguments[0];\n    var isForward = arguments[1];\n    EdgeEnd$$1.call(this, edge);\n    this._isForward = null;\n    this._isInResult = false;\n    this._isVisited = false;\n    this._sym = null;\n    this._next = null;\n    this._nextMin = null;\n    this._edgeRing = null;\n    this._minEdgeRing = null;\n    this._depth = [0, -999, -999];\n    this._isForward = isForward;\n    if (isForward) {\n      this.init(edge.getCoordinate(0), edge.getCoordinate(1));\n    } else {\n      var n = edge.getNumPoints() - 1;\n      this.init(edge.getCoordinate(n), edge.getCoordinate(n - 1));\n    }\n    this.computeDirectedLabel();\n  }\n\n  if ( EdgeEnd$$1 ) DirectedEdge.__proto__ = EdgeEnd$$1;\n  DirectedEdge.prototype = Object.create( EdgeEnd$$1 && EdgeEnd$$1.prototype );\n  DirectedEdge.prototype.constructor = DirectedEdge;\n  DirectedEdge.prototype.getNextMin = function getNextMin () {\n    return this._nextMin\n  };\n  DirectedEdge.prototype.getDepth = function getDepth (position) {\n    return this._depth[position]\n  };\n  DirectedEdge.prototype.setVisited = function setVisited (isVisited) {\n    this._isVisited = isVisited;\n  };\n  DirectedEdge.prototype.computeDirectedLabel = function computeDirectedLabel () {\n    this._label = new Label(this._edge.getLabel());\n    if (!this._isForward) { this._label.flip(); }\n  };\n  DirectedEdge.prototype.getNext = function getNext () {\n    return this._next\n  };\n  DirectedEdge.prototype.setDepth = function setDepth (position, depthVal) {\n    if (this._depth[position] !== -999) {\n      if (this._depth[position] !== depthVal) { throw new TopologyException('assigned depths do not match', this.getCoordinate()) }\n    }\n    this._depth[position] = depthVal;\n  };\n  DirectedEdge.prototype.isInteriorAreaEdge = function isInteriorAreaEdge () {\n    var this$1 = this;\n\n    var isInteriorAreaEdge = true;\n    for (var i = 0; i < 2; i++) {\n      if (!(this$1._label.isArea(i) && this$1._label.getLocation(i, Position.LEFT) === Location.INTERIOR && this$1._label.getLocation(i, Position.RIGHT) === Location.INTERIOR)) {\n        isInteriorAreaEdge = false;\n      }\n    }\n    return isInteriorAreaEdge\n  };\n  DirectedEdge.prototype.setNextMin = function setNextMin (nextMin) {\n    this._nextMin = nextMin;\n  };\n  DirectedEdge.prototype.print = function print (out) {\n    EdgeEnd$$1.prototype.print.call(this, out);\n    out.print(' ' + this._depth[Position.LEFT] + '/' + this._depth[Position.RIGHT]);\n    out.print(' (' + this.getDepthDelta() + ')');\n    if (this._isInResult) { out.print(' inResult'); }\n  };\n  DirectedEdge.prototype.setMinEdgeRing = function setMinEdgeRing (minEdgeRing) {\n    this._minEdgeRing = minEdgeRing;\n  };\n  DirectedEdge.prototype.isLineEdge = function isLineEdge () {\n    var isLine = this._label.isLine(0) || this._label.isLine(1);\n    var isExteriorIfArea0 = !this._label.isArea(0) || this._label.allPositionsEqual(0, Location.EXTERIOR);\n    var isExteriorIfArea1 = !this._label.isArea(1) || this._label.allPositionsEqual(1, Location.EXTERIOR);\n    return isLine && isExteriorIfArea0 && isExteriorIfArea1\n  };\n  DirectedEdge.prototype.setEdgeRing = function setEdgeRing (edgeRing) {\n    this._edgeRing = edgeRing;\n  };\n  DirectedEdge.prototype.getMinEdgeRing = function getMinEdgeRing () {\n    return this._minEdgeRing\n  };\n  DirectedEdge.prototype.getDepthDelta = function getDepthDelta () {\n    var depthDelta = this._edge.getDepthDelta();\n    if (!this._isForward) { depthDelta = -depthDelta; }\n    return depthDelta\n  };\n  DirectedEdge.prototype.setInResult = function setInResult (isInResult) {\n    this._isInResult = isInResult;\n  };\n  DirectedEdge.prototype.getSym = function getSym () {\n    return this._sym\n  };\n  DirectedEdge.prototype.isForward = function isForward () {\n    return this._isForward\n  };\n  DirectedEdge.prototype.getEdge = function getEdge () {\n    return this._edge\n  };\n  DirectedEdge.prototype.printEdge = function printEdge (out) {\n    this.print(out);\n    out.print(' ');\n    if (this._isForward) { this._edge.print(out); } else { this._edge.printReverse(out); }\n  };\n  DirectedEdge.prototype.setSym = function setSym (de) {\n    this._sym = de;\n  };\n  DirectedEdge.prototype.setVisitedEdge = function setVisitedEdge (isVisited) {\n    this.setVisited(isVisited);\n    this._sym.setVisited(isVisited);\n  };\n  DirectedEdge.prototype.setEdgeDepths = function setEdgeDepths (position, depth) {\n    var depthDelta = this.getEdge().getDepthDelta();\n    if (!this._isForward) { depthDelta = -depthDelta; }\n    var directionFactor = 1;\n    if (position === Position.LEFT) { directionFactor = -1; }\n    var oppositePos = Position.opposite(position);\n    var delta = depthDelta * directionFactor;\n    var oppositeDepth = depth + delta;\n    this.setDepth(position, depth);\n    this.setDepth(oppositePos, oppositeDepth);\n  };\n  DirectedEdge.prototype.getEdgeRing = function getEdgeRing () {\n    return this._edgeRing\n  };\n  DirectedEdge.prototype.isInResult = function isInResult () {\n    return this._isInResult\n  };\n  DirectedEdge.prototype.setNext = function setNext (next) {\n    this._next = next;\n  };\n  DirectedEdge.prototype.isVisited = function isVisited () {\n    return this._isVisited\n  };\n  DirectedEdge.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  DirectedEdge.prototype.getClass = function getClass () {\n    return DirectedEdge\n  };\n  DirectedEdge.depthFactor = function depthFactor (currLocation, nextLocation) {\n    if (currLocation === Location.EXTERIOR && nextLocation === Location.INTERIOR) { return 1; } else if (currLocation === Location.INTERIOR && nextLocation === Location.EXTERIOR) { return -1 }\n    return 0\n  };\n\n  return DirectedEdge;\n}(EdgeEnd));\n\nvar NodeFactory = function NodeFactory () {};\n\nNodeFactory.prototype.createNode = function createNode (coord) {\n  return new Node(coord, null)\n};\nNodeFactory.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodeFactory.prototype.getClass = function getClass () {\n  return NodeFactory\n};\n\nvar PlanarGraph = function PlanarGraph () {\n  this._edges = new ArrayList();\n  this._nodes = null;\n  this._edgeEndList = new ArrayList();\n  if (arguments.length === 0) {\n    this._nodes = new NodeMap(new NodeFactory());\n  } else if (arguments.length === 1) {\n    var nodeFact = arguments[0];\n    this._nodes = new NodeMap(nodeFact);\n  }\n};\nPlanarGraph.prototype.printEdges = function printEdges (out) {\n    var this$1 = this;\n\n  out.println('Edges:');\n  for (var i = 0; i < this._edges.size(); i++) {\n    out.println('edge ' + i + ':');\n    var e = this$1._edges.get(i);\n    e.print(out);\n    e.eiList.print(out);\n  }\n};\nPlanarGraph.prototype.find = function find (coord) {\n  return this._nodes.find(coord)\n};\nPlanarGraph.prototype.addNode = function addNode () {\n  if (arguments[0] instanceof Node) {\n    var node = arguments[0];\n    return this._nodes.addNode(node)\n  } else if (arguments[0] instanceof Coordinate) {\n    var coord = arguments[0];\n    return this._nodes.addNode(coord)\n  }\n};\nPlanarGraph.prototype.getNodeIterator = function getNodeIterator () {\n  return this._nodes.iterator()\n};\nPlanarGraph.prototype.linkResultDirectedEdges = function linkResultDirectedEdges () {\n  for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkResultDirectedEdges();\n  }\n};\nPlanarGraph.prototype.debugPrintln = function debugPrintln (o) {\n  System.out.println(o);\n};\nPlanarGraph.prototype.isBoundaryNode = function isBoundaryNode (geomIndex, coord) {\n  var node = this._nodes.find(coord);\n  if (node === null) { return false }\n  var label = node.getLabel();\n  if (label !== null && label.getLocation(geomIndex) === Location.BOUNDARY) { return true }\n  return false\n};\nPlanarGraph.prototype.linkAllDirectedEdges = function linkAllDirectedEdges () {\n  for (var nodeit = this._nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkAllDirectedEdges();\n  }\n};\nPlanarGraph.prototype.matchInSameDirection = function matchInSameDirection (p0, p1, ep0, ep1) {\n  if (!p0.equals(ep0)) { return false }\n  if (CGAlgorithms.computeOrientation(p0, p1, ep1) === CGAlgorithms.COLLINEAR && Quadrant.quadrant(p0, p1) === Quadrant.quadrant(ep0, ep1)) { return true }\n  return false\n};\nPlanarGraph.prototype.getEdgeEnds = function getEdgeEnds () {\n  return this._edgeEndList\n};\nPlanarGraph.prototype.debugPrint = function debugPrint (o) {\n  System.out.print(o);\n};\nPlanarGraph.prototype.getEdgeIterator = function getEdgeIterator () {\n  return this._edges.iterator()\n};\nPlanarGraph.prototype.findEdgeInSameDirection = function findEdgeInSameDirection (p0, p1) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    var e = this$1._edges.get(i);\n    var eCoord = e.getCoordinates();\n    if (this$1.matchInSameDirection(p0, p1, eCoord[0], eCoord[1])) { return e }\n    if (this$1.matchInSameDirection(p0, p1, eCoord[eCoord.length - 1], eCoord[eCoord.length - 2])) { return e }\n  }\n  return null\n};\nPlanarGraph.prototype.insertEdge = function insertEdge (e) {\n  this._edges.add(e);\n};\nPlanarGraph.prototype.findEdgeEnd = function findEdgeEnd (e) {\n  for (var i = this.getEdgeEnds().iterator(); i.hasNext();) {\n    var ee = i.next();\n    if (ee.getEdge() === e) { return ee }\n  }\n  return null\n};\nPlanarGraph.prototype.addEdges = function addEdges (edgesToAdd) {\n    var this$1 = this;\n\n  for (var it = edgesToAdd.iterator(); it.hasNext();) {\n    var e = it.next();\n    this$1._edges.add(e);\n    var de1 = new DirectedEdge(e, true);\n    var de2 = new DirectedEdge(e, false);\n    de1.setSym(de2);\n    de2.setSym(de1);\n    this$1.add(de1);\n    this$1.add(de2);\n  }\n};\nPlanarGraph.prototype.add = function add (e) {\n  this._nodes.add(e);\n  this._edgeEndList.add(e);\n};\nPlanarGraph.prototype.getNodes = function getNodes () {\n  return this._nodes.values()\n};\nPlanarGraph.prototype.findEdge = function findEdge (p0, p1) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    var e = this$1._edges.get(i);\n    var eCoord = e.getCoordinates();\n    if (p0.equals(eCoord[0]) && p1.equals(eCoord[1])) { return e }\n  }\n  return null\n};\nPlanarGraph.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPlanarGraph.prototype.getClass = function getClass () {\n  return PlanarGraph\n};\nPlanarGraph.linkResultDirectedEdges = function linkResultDirectedEdges (nodes) {\n  for (var nodeit = nodes.iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().linkResultDirectedEdges();\n  }\n};\n\nvar PolygonBuilder = function PolygonBuilder () {\n  this._geometryFactory = null;\n  this._shellList = new ArrayList();\n  var geometryFactory = arguments[0];\n  this._geometryFactory = geometryFactory;\n};\nPolygonBuilder.prototype.sortShellsAndHoles = function sortShellsAndHoles (edgeRings, shellList, freeHoleList) {\n  for (var it = edgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.isHole()) {\n      freeHoleList.add(er);\n    } else {\n      shellList.add(er);\n    }\n  }\n};\nPolygonBuilder.prototype.computePolygons = function computePolygons (shellList) {\n    var this$1 = this;\n\n  var resultPolyList = new ArrayList();\n  for (var it = shellList.iterator(); it.hasNext();) {\n    var er = it.next();\n    var poly = er.toPolygon(this$1._geometryFactory);\n    resultPolyList.add(poly);\n  }\n  return resultPolyList\n};\nPolygonBuilder.prototype.placeFreeHoles = function placeFreeHoles (shellList, freeHoleList) {\n    var this$1 = this;\n\n  for (var it = freeHoleList.iterator(); it.hasNext();) {\n    var hole = it.next();\n    if (hole.getShell() === null) {\n      var shell = this$1.findEdgeRingContaining(hole, shellList);\n      if (shell === null) { throw new TopologyException('unable to assign hole to a shell', hole.getCoordinate(0)) }\n      hole.setShell(shell);\n    }\n  }\n};\nPolygonBuilder.prototype.buildMinimalEdgeRings = function buildMinimalEdgeRings (maxEdgeRings, shellList, freeHoleList) {\n    var this$1 = this;\n\n  var edgeRings = new ArrayList();\n  for (var it = maxEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.getMaxNodeDegree() > 2) {\n      er.linkDirectedEdgesForMinimalEdgeRings();\n      var minEdgeRings = er.buildMinimalRings();\n      var shell = this$1.findShell(minEdgeRings);\n      if (shell !== null) {\n        this$1.placePolygonHoles(shell, minEdgeRings);\n        shellList.add(shell);\n      } else {\n        freeHoleList.addAll(minEdgeRings);\n      }\n    } else {\n      edgeRings.add(er);\n    }\n  }\n  return edgeRings\n};\nPolygonBuilder.prototype.containsPoint = function containsPoint (p) {\n  for (var it = this._shellList.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.containsPoint(p)) { return true }\n  }\n  return false\n};\nPolygonBuilder.prototype.buildMaximalEdgeRings = function buildMaximalEdgeRings (dirEdges) {\n    var this$1 = this;\n\n  var maxEdgeRings = new ArrayList();\n  for (var it = dirEdges.iterator(); it.hasNext();) {\n    var de = it.next();\n    if (de.isInResult() && de.getLabel().isArea()) {\n      if (de.getEdgeRing() === null) {\n        var er = new MaximalEdgeRing(de, this$1._geometryFactory);\n        maxEdgeRings.add(er);\n        er.setInResult();\n      }\n    }\n  }\n  return maxEdgeRings\n};\nPolygonBuilder.prototype.placePolygonHoles = function placePolygonHoles (shell, minEdgeRings) {\n  for (var it = minEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (er.isHole()) {\n      er.setShell(shell);\n    }\n  }\n};\nPolygonBuilder.prototype.getPolygons = function getPolygons () {\n  var resultPolyList = this.computePolygons(this._shellList);\n  return resultPolyList\n};\nPolygonBuilder.prototype.findEdgeRingContaining = function findEdgeRingContaining (testEr, shellList) {\n  var testRing = testEr.getLinearRing();\n  var testEnv = testRing.getEnvelopeInternal();\n  var testPt = testRing.getCoordinateN(0);\n  var minShell = null;\n  var minEnv = null;\n  for (var it = shellList.iterator(); it.hasNext();) {\n    var tryShell = it.next();\n    var tryRing = tryShell.getLinearRing();\n    var tryEnv = tryRing.getEnvelopeInternal();\n    if (minShell !== null) { minEnv = minShell.getLinearRing().getEnvelopeInternal(); }\n    var isContained = false;\n    if (tryEnv.contains(testEnv) && CGAlgorithms.isPointInRing(testPt, tryRing.getCoordinates())) { isContained = true; }\n    if (isContained) {\n      if (minShell === null || minEnv.contains(tryEnv)) {\n        minShell = tryShell;\n      }\n    }\n  }\n  return minShell\n};\nPolygonBuilder.prototype.findShell = function findShell (minEdgeRings) {\n  var shellCount = 0;\n  var shell = null;\n  for (var it = minEdgeRings.iterator(); it.hasNext();) {\n    var er = it.next();\n    if (!er.isHole()) {\n      shell = er;\n      shellCount++;\n    }\n  }\n  Assert.isTrue(shellCount <= 1, 'found two shells in MinimalEdgeRing list');\n  return shell\n};\nPolygonBuilder.prototype.add = function add () {\n  if (arguments.length === 1) {\n    var graph = arguments[0];\n    this.add(graph.getEdgeEnds(), graph.getNodes());\n  } else if (arguments.length === 2) {\n    var dirEdges = arguments[0];\n    var nodes = arguments[1];\n    PlanarGraph.linkResultDirectedEdges(nodes);\n    var maxEdgeRings = this.buildMaximalEdgeRings(dirEdges);\n    var freeHoleList = new ArrayList();\n    var edgeRings = this.buildMinimalEdgeRings(maxEdgeRings, this._shellList, freeHoleList);\n    this.sortShellsAndHoles(edgeRings, this._shellList, freeHoleList);\n    this.placeFreeHoles(this._shellList, freeHoleList);\n  }\n};\nPolygonBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPolygonBuilder.prototype.getClass = function getClass () {\n  return PolygonBuilder\n};\n\nvar Boundable = function Boundable () {};\n\nBoundable.prototype.getBounds = function getBounds () {};\nBoundable.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBoundable.prototype.getClass = function getClass () {\n  return Boundable\n};\n\nvar ItemBoundable = function ItemBoundable () {\n  this._bounds = null;\n  this._item = null;\n  var bounds = arguments[0];\n  var item = arguments[1];\n  this._bounds = bounds;\n  this._item = item;\n};\nItemBoundable.prototype.getItem = function getItem () {\n  return this._item\n};\nItemBoundable.prototype.getBounds = function getBounds () {\n  return this._bounds\n};\nItemBoundable.prototype.interfaces_ = function interfaces_ () {\n  return [Boundable, Serializable]\n};\nItemBoundable.prototype.getClass = function getClass () {\n  return ItemBoundable\n};\n\nvar PriorityQueue = function PriorityQueue () {\n  this._size = null;\n  this._items = null;\n  this._size = 0;\n  this._items = new ArrayList();\n  this._items.add(null);\n};\nPriorityQueue.prototype.poll = function poll () {\n  if (this.isEmpty()) { return null }\n  var minItem = this._items.get(1);\n  this._items.set(1, this._items.get(this._size));\n  this._size -= 1;\n  this.reorder(1);\n  return minItem\n};\nPriorityQueue.prototype.size = function size () {\n  return this._size\n};\nPriorityQueue.prototype.reorder = function reorder (hole) {\n    var this$1 = this;\n\n  var child = null;\n  var tmp = this._items.get(hole);\n  for (; hole * 2 <= this._size; hole = child) {\n    child = hole * 2;\n    if (child !== this$1._size && this$1._items.get(child + 1).compareTo(this$1._items.get(child)) < 0) { child++; }\n    if (this$1._items.get(child).compareTo(tmp) < 0) { this$1._items.set(hole, this$1._items.get(child)); } else { break }\n  }\n  this._items.set(hole, tmp);\n};\nPriorityQueue.prototype.clear = function clear () {\n  this._size = 0;\n  this._items.clear();\n};\nPriorityQueue.prototype.isEmpty = function isEmpty () {\n  return this._size === 0\n};\nPriorityQueue.prototype.add = function add (x) {\n    var this$1 = this;\n\n  this._items.add(null);\n  this._size += 1;\n  var hole = this._size;\n  this._items.set(0, x);\n  for (; x.compareTo(this._items.get(Math.trunc(hole / 2))) < 0; hole /= 2) {\n    this$1._items.set(hole, this$1._items.get(Math.trunc(hole / 2)));\n  }\n  this._items.set(hole, x);\n};\nPriorityQueue.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPriorityQueue.prototype.getClass = function getClass () {\n  return PriorityQueue\n};\n\nvar ItemVisitor = function ItemVisitor () {};\n\nItemVisitor.prototype.visitItem = function visitItem (item) {};\nItemVisitor.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nItemVisitor.prototype.getClass = function getClass () {\n  return ItemVisitor\n};\n\nvar SpatialIndex = function SpatialIndex () {};\n\nSpatialIndex.prototype.insert = function insert (itemEnv, item) {};\nSpatialIndex.prototype.remove = function remove (itemEnv, item) {};\nSpatialIndex.prototype.query = function query () {\n  // if (arguments.length === 1) {\n  // const searchEnv = arguments[0]\n  // } else if (arguments.length === 2) {\n  // const searchEnv = arguments[0]\n  // const visitor = arguments[1]\n  // }\n};\nSpatialIndex.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSpatialIndex.prototype.getClass = function getClass () {\n  return SpatialIndex\n};\n\nvar AbstractNode = function AbstractNode () {\n  this._childBoundables = new ArrayList();\n  this._bounds = null;\n  this._level = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var level = arguments[0];\n    this._level = level;\n  }\n};\n\nvar staticAccessors$22 = { serialVersionUID: { configurable: true } };\nAbstractNode.prototype.getLevel = function getLevel () {\n  return this._level\n};\nAbstractNode.prototype.size = function size () {\n  return this._childBoundables.size()\n};\nAbstractNode.prototype.getChildBoundables = function getChildBoundables () {\n  return this._childBoundables\n};\nAbstractNode.prototype.addChildBoundable = function addChildBoundable (childBoundable) {\n  Assert.isTrue(this._bounds === null);\n  this._childBoundables.add(childBoundable);\n};\nAbstractNode.prototype.isEmpty = function isEmpty () {\n  return this._childBoundables.isEmpty()\n};\nAbstractNode.prototype.getBounds = function getBounds () {\n  if (this._bounds === null) {\n    this._bounds = this.computeBounds();\n  }\n  return this._bounds\n};\nAbstractNode.prototype.interfaces_ = function interfaces_ () {\n  return [Boundable, Serializable]\n};\nAbstractNode.prototype.getClass = function getClass () {\n  return AbstractNode\n};\nstaticAccessors$22.serialVersionUID.get = function () { return 6493722185909573708 };\n\nObject.defineProperties( AbstractNode, staticAccessors$22 );\n\nvar Collections = function Collections () {};\n\nCollections.reverseOrder = function reverseOrder () {\n  return {\n    compare: function compare (a, b) {\n      return b.compareTo(a)\n    }\n  }\n};\nCollections.min = function min (l) {\n  Collections.sort(l);\n  return l.get(0)\n};\nCollections.sort = function sort (l, c) {\n  var a = l.toArray();\n  if (c) {\n    Arrays.sort(a, c);\n  } else {\n    Arrays.sort(a);\n  }\n  var i = l.iterator();\n  for (var pos = 0, alen = a.length; pos < alen; pos++) {\n    i.next();\n    i.set(a[pos]);\n  }\n};\nCollections.singletonList = function singletonList (o) {\n  var arrayList = new ArrayList();\n  arrayList.add(o);\n  return arrayList\n};\n\nvar BoundablePair = function BoundablePair () {\n  this._boundable1 = null;\n  this._boundable2 = null;\n  this._distance = null;\n  this._itemDistance = null;\n  var boundable1 = arguments[0];\n  var boundable2 = arguments[1];\n  var itemDistance = arguments[2];\n  this._boundable1 = boundable1;\n  this._boundable2 = boundable2;\n  this._itemDistance = itemDistance;\n  this._distance = this.distance();\n};\nBoundablePair.prototype.expandToQueue = function expandToQueue (priQ, minDistance) {\n  var isComp1 = BoundablePair.isComposite(this._boundable1);\n  var isComp2 = BoundablePair.isComposite(this._boundable2);\n  if (isComp1 && isComp2) {\n    if (BoundablePair.area(this._boundable1) > BoundablePair.area(this._boundable2)) {\n      this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n      return null\n    } else {\n      this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n      return null\n    }\n  } else if (isComp1) {\n    this.expand(this._boundable1, this._boundable2, priQ, minDistance);\n    return null\n  } else if (isComp2) {\n    this.expand(this._boundable2, this._boundable1, priQ, minDistance);\n    return null\n  }\n  throw new IllegalArgumentException('neither boundable is composite')\n};\nBoundablePair.prototype.isLeaves = function isLeaves () {\n  return !(BoundablePair.isComposite(this._boundable1) || BoundablePair.isComposite(this._boundable2))\n};\nBoundablePair.prototype.compareTo = function compareTo (o) {\n  var nd = o;\n  if (this._distance < nd._distance) { return -1 }\n  if (this._distance > nd._distance) { return 1 }\n  return 0\n};\nBoundablePair.prototype.expand = function expand (bndComposite, bndOther, priQ, minDistance) {\n    var this$1 = this;\n\n  var children = bndComposite.getChildBoundables();\n  for (var i = children.iterator(); i.hasNext();) {\n    var child = i.next();\n    var bp = new BoundablePair(child, bndOther, this$1._itemDistance);\n    if (bp.getDistance() < minDistance) {\n      priQ.add(bp);\n    }\n  }\n};\nBoundablePair.prototype.getBoundable = function getBoundable (i) {\n  if (i === 0) { return this._boundable1 }\n  return this._boundable2\n};\nBoundablePair.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nBoundablePair.prototype.distance = function distance () {\n  if (this.isLeaves()) {\n    return this._itemDistance.distance(this._boundable1, this._boundable2)\n  }\n  return this._boundable1.getBounds().distance(this._boundable2.getBounds())\n};\nBoundablePair.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nBoundablePair.prototype.getClass = function getClass () {\n  return BoundablePair\n};\nBoundablePair.area = function area (b) {\n  return b.getBounds().getArea()\n};\nBoundablePair.isComposite = function isComposite (item) {\n  return item instanceof AbstractNode\n};\n\nvar AbstractSTRtree = function AbstractSTRtree () {\n  this._root = null;\n  this._built = false;\n  this._itemBoundables = new ArrayList();\n  this._nodeCapacity = null;\n  if (arguments.length === 0) {\n    var nodeCapacity = AbstractSTRtree.DEFAULT_NODE_CAPACITY;\n    this._nodeCapacity = nodeCapacity;\n  } else if (arguments.length === 1) {\n    var nodeCapacity$1 = arguments[0];\n    Assert.isTrue(nodeCapacity$1 > 1, 'Node capacity must be greater than 1');\n    this._nodeCapacity = nodeCapacity$1;\n  }\n};\n\nvar staticAccessors$23 = { IntersectsOp: { configurable: true },serialVersionUID: { configurable: true },DEFAULT_NODE_CAPACITY: { configurable: true } };\nAbstractSTRtree.prototype.getNodeCapacity = function getNodeCapacity () {\n  return this._nodeCapacity\n};\nAbstractSTRtree.prototype.lastNode = function lastNode (nodes) {\n  return nodes.get(nodes.size() - 1)\n};\nAbstractSTRtree.prototype.size = function size () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isEmpty()) {\n      return 0\n    }\n    this.build();\n    return this.size(this._root)\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var size = 0;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        size += this$1.size(childBoundable);\n      } else if (childBoundable instanceof ItemBoundable) {\n        size += 1;\n      }\n    }\n    return size\n  }\n};\nAbstractSTRtree.prototype.removeItem = function removeItem (node, item) {\n  var childToRemove = null;\n  for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n    var childBoundable = i.next();\n    if (childBoundable instanceof ItemBoundable) {\n      if (childBoundable.getItem() === item) { childToRemove = childBoundable; }\n    }\n  }\n  if (childToRemove !== null) {\n    node.getChildBoundables().remove(childToRemove);\n    return true\n  }\n  return false\n};\nAbstractSTRtree.prototype.itemsTree = function itemsTree () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    this.build();\n    var valuesTree = this.itemsTree(this._root);\n    if (valuesTree === null) { return new ArrayList() }\n    return valuesTree\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var valuesTreeForNode = new ArrayList();\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        var valuesTreeForChild = this$1.itemsTree(childBoundable);\n        if (valuesTreeForChild !== null) { valuesTreeForNode.add(valuesTreeForChild); }\n      } else if (childBoundable instanceof ItemBoundable) {\n        valuesTreeForNode.add(childBoundable.getItem());\n      } else {\n        Assert.shouldNeverReachHere();\n      }\n    }\n    if (valuesTreeForNode.size() <= 0) { return null }\n    return valuesTreeForNode\n  }\n};\nAbstractSTRtree.prototype.insert = function insert (bounds, item) {\n  Assert.isTrue(!this._built, 'Cannot insert items into an STR packed R-tree after it has been built.');\n  this._itemBoundables.add(new ItemBoundable(bounds, item));\n};\nAbstractSTRtree.prototype.boundablesAtLevel = function boundablesAtLevel () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var level = arguments[0];\n    var boundables = new ArrayList();\n    this.boundablesAtLevel(level, this._root, boundables);\n    return boundables\n  } else if (arguments.length === 3) {\n    var level$1 = arguments[0];\n    var top = arguments[1];\n    var boundables$1 = arguments[2];\n    Assert.isTrue(level$1 > -2);\n    if (top.getLevel() === level$1) {\n      boundables$1.add(top);\n      return null\n    }\n    for (var i = top.getChildBoundables().iterator(); i.hasNext();) {\n      var boundable = i.next();\n      if (boundable instanceof AbstractNode) {\n        this$1.boundablesAtLevel(level$1, boundable, boundables$1);\n      } else {\n        Assert.isTrue(boundable instanceof ItemBoundable);\n        if (level$1 === -1) {\n          boundables$1.add(boundable);\n        }\n      }\n    }\n    return null\n  }\n};\nAbstractSTRtree.prototype.query = function query () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var searchBounds = arguments[0];\n    this.build();\n    var matches = new ArrayList();\n    if (this.isEmpty()) {\n      return matches\n    }\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n      this.query(searchBounds, this._root, matches);\n    }\n    return matches\n  } else if (arguments.length === 2) {\n    var searchBounds$1 = arguments[0];\n    var visitor = arguments[1];\n    this.build();\n    if (this.isEmpty()) {\n      return null\n    }\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds$1)) {\n      this.query(searchBounds$1, this._root, visitor);\n    }\n  } else if (arguments.length === 3) {\n    if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      var searchBounds$2 = arguments[0];\n      var node = arguments[1];\n      var visitor$1 = arguments[2];\n      var childBoundables = node.getChildBoundables();\n      for (var i = 0; i < childBoundables.size(); i++) {\n        var childBoundable = childBoundables.get(i);\n        if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$2)) {\n          continue\n        }\n        if (childBoundable instanceof AbstractNode) {\n          this$1.query(searchBounds$2, childBoundable, visitor$1);\n        } else if (childBoundable instanceof ItemBoundable) {\n          visitor$1.visitItem(childBoundable.getItem());\n        } else {\n          Assert.shouldNeverReachHere();\n        }\n      }\n    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n      var searchBounds$3 = arguments[0];\n      var node$1 = arguments[1];\n      var matches$1 = arguments[2];\n      var childBoundables$1 = node$1.getChildBoundables();\n      for (var i$1 = 0; i$1 < childBoundables$1.size(); i$1++) {\n        var childBoundable$1 = childBoundables$1.get(i$1);\n        if (!this$1.getIntersectsOp().intersects(childBoundable$1.getBounds(), searchBounds$3)) {\n          continue\n        }\n        if (childBoundable$1 instanceof AbstractNode) {\n          this$1.query(searchBounds$3, childBoundable$1, matches$1);\n        } else if (childBoundable$1 instanceof ItemBoundable) {\n          matches$1.add(childBoundable$1.getItem());\n        } else {\n          Assert.shouldNeverReachHere();\n        }\n      }\n    }\n  }\n};\nAbstractSTRtree.prototype.build = function build () {\n  if (this._built) { return null }\n  this._root = this._itemBoundables.isEmpty() ? this.createNode(0) : this.createHigherLevels(this._itemBoundables, -1);\n  this._itemBoundables = null;\n  this._built = true;\n};\nAbstractSTRtree.prototype.getRoot = function getRoot () {\n  this.build();\n  return this._root\n};\nAbstractSTRtree.prototype.remove = function remove () {\n    var this$1 = this;\n\n  if (arguments.length === 2) {\n    var searchBounds = arguments[0];\n    var item = arguments[1];\n    this.build();\n    if (this.getIntersectsOp().intersects(this._root.getBounds(), searchBounds)) {\n      return this.remove(searchBounds, this._root, item)\n    }\n    return false\n  } else if (arguments.length === 3) {\n    var searchBounds$1 = arguments[0];\n    var node = arguments[1];\n    var item$1 = arguments[2];\n    var found = this.removeItem(node, item$1);\n    if (found) { return true }\n    var childToPrune = null;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (!this$1.getIntersectsOp().intersects(childBoundable.getBounds(), searchBounds$1)) {\n        continue\n      }\n      if (childBoundable instanceof AbstractNode) {\n        found = this$1.remove(searchBounds$1, childBoundable, item$1);\n        if (found) {\n          childToPrune = childBoundable;\n          break\n        }\n      }\n    }\n    if (childToPrune !== null) {\n      if (childToPrune.getChildBoundables().isEmpty()) {\n        node.getChildBoundables().remove(childToPrune);\n      }\n    }\n    return found\n  }\n};\nAbstractSTRtree.prototype.createHigherLevels = function createHigherLevels (boundablesOfALevel, level) {\n  Assert.isTrue(!boundablesOfALevel.isEmpty());\n  var parentBoundables = this.createParentBoundables(boundablesOfALevel, level + 1);\n  if (parentBoundables.size() === 1) {\n    return parentBoundables.get(0)\n  }\n  return this.createHigherLevels(parentBoundables, level + 1)\n};\nAbstractSTRtree.prototype.depth = function depth () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this.isEmpty()) {\n      return 0\n    }\n    this.build();\n    return this.depth(this._root)\n  } else if (arguments.length === 1) {\n    var node = arguments[0];\n    var maxChildDepth = 0;\n    for (var i = node.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (childBoundable instanceof AbstractNode) {\n        var childDepth = this$1.depth(childBoundable);\n        if (childDepth > maxChildDepth) { maxChildDepth = childDepth; }\n      }\n    }\n    return maxChildDepth + 1\n  }\n};\nAbstractSTRtree.prototype.createParentBoundables = function createParentBoundables (childBoundables, newLevel) {\n    var this$1 = this;\n\n  Assert.isTrue(!childBoundables.isEmpty());\n  var parentBoundables = new ArrayList();\n  parentBoundables.add(this.createNode(newLevel));\n  var sortedChildBoundables = new ArrayList(childBoundables);\n  Collections.sort(sortedChildBoundables, this.getComparator());\n  for (var i = sortedChildBoundables.iterator(); i.hasNext();) {\n    var childBoundable = i.next();\n    if (this$1.lastNode(parentBoundables).getChildBoundables().size() === this$1.getNodeCapacity()) {\n      parentBoundables.add(this$1.createNode(newLevel));\n    }\n    this$1.lastNode(parentBoundables).addChildBoundable(childBoundable);\n  }\n  return parentBoundables\n};\nAbstractSTRtree.prototype.isEmpty = function isEmpty () {\n  if (!this._built) { return this._itemBoundables.isEmpty() }\n  return this._root.isEmpty()\n};\nAbstractSTRtree.prototype.interfaces_ = function interfaces_ () {\n  return [Serializable]\n};\nAbstractSTRtree.prototype.getClass = function getClass () {\n  return AbstractSTRtree\n};\nAbstractSTRtree.compareDoubles = function compareDoubles (a, b) {\n  return a > b ? 1 : a < b ? -1 : 0\n};\nstaticAccessors$23.IntersectsOp.get = function () { return IntersectsOp };\nstaticAccessors$23.serialVersionUID.get = function () { return -3886435814360241337 };\nstaticAccessors$23.DEFAULT_NODE_CAPACITY.get = function () { return 10 };\n\nObject.defineProperties( AbstractSTRtree, staticAccessors$23 );\n\nvar IntersectsOp = function IntersectsOp () {};\n\nvar ItemDistance = function ItemDistance () {};\n\nItemDistance.prototype.distance = function distance (item1, item2) {};\nItemDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nItemDistance.prototype.getClass = function getClass () {\n  return ItemDistance\n};\n\nvar STRtree = (function (AbstractSTRtree$$1) {\n  function STRtree (nodeCapacity) {\n    nodeCapacity = nodeCapacity || STRtree.DEFAULT_NODE_CAPACITY;\n    AbstractSTRtree$$1.call(this, nodeCapacity);\n  }\n\n  if ( AbstractSTRtree$$1 ) STRtree.__proto__ = AbstractSTRtree$$1;\n  STRtree.prototype = Object.create( AbstractSTRtree$$1 && AbstractSTRtree$$1.prototype );\n  STRtree.prototype.constructor = STRtree;\n\n  var staticAccessors = { STRtreeNode: { configurable: true },serialVersionUID: { configurable: true },xComparator: { configurable: true },yComparator: { configurable: true },intersectsOp: { configurable: true },DEFAULT_NODE_CAPACITY: { configurable: true } };\n  STRtree.prototype.createParentBoundablesFromVerticalSlices = function createParentBoundablesFromVerticalSlices (verticalSlices, newLevel) {\n    var this$1 = this;\n\n    Assert.isTrue(verticalSlices.length > 0);\n    var parentBoundables = new ArrayList();\n    for (var i = 0; i < verticalSlices.length; i++) {\n      parentBoundables.addAll(this$1.createParentBoundablesFromVerticalSlice(verticalSlices[i], newLevel));\n    }\n    return parentBoundables\n  };\n  STRtree.prototype.createNode = function createNode (level) {\n    return new STRtreeNode(level)\n  };\n  STRtree.prototype.size = function size () {\n    if (arguments.length === 0) {\n      return AbstractSTRtree$$1.prototype.size.call(this)\n    } else { return AbstractSTRtree$$1.prototype.size.apply(this, arguments) }\n  };\n  STRtree.prototype.insert = function insert () {\n    if (arguments.length === 2) {\n      var itemEnv = arguments[0];\n      var item = arguments[1];\n      if (itemEnv.isNull()) {\n        return null\n      }\n      AbstractSTRtree$$1.prototype.insert.call(this, itemEnv, item);\n    } else { return AbstractSTRtree$$1.prototype.insert.apply(this, arguments) }\n  };\n  STRtree.prototype.getIntersectsOp = function getIntersectsOp () {\n    return STRtree.intersectsOp\n  };\n  STRtree.prototype.verticalSlices = function verticalSlices (childBoundables, sliceCount) {\n    var sliceCapacity = Math.trunc(Math.ceil(childBoundables.size() / sliceCount));\n    var slices = new Array(sliceCount).fill(null);\n    var i = childBoundables.iterator();\n    for (var j = 0; j < sliceCount; j++) {\n      slices[j] = new ArrayList();\n      var boundablesAddedToSlice = 0;\n      while (i.hasNext() && boundablesAddedToSlice < sliceCapacity) {\n        var childBoundable = i.next();\n        slices[j].add(childBoundable);\n        boundablesAddedToSlice++;\n      }\n    }\n    return slices\n  };\n  STRtree.prototype.query = function query () {\n    if (arguments.length === 1) {\n      var searchEnv = arguments[0];\n      return AbstractSTRtree$$1.prototype.query.call(this, searchEnv)\n    } else if (arguments.length === 2) {\n      var searchEnv$1 = arguments[0];\n      var visitor = arguments[1];\n      AbstractSTRtree$$1.prototype.query.call(this, searchEnv$1, visitor);\n    } else if (arguments.length === 3) {\n      if (hasInterface(arguments[2], ItemVisitor) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n        var searchBounds = arguments[0];\n        var node = arguments[1];\n        var visitor$1 = arguments[2];\n        AbstractSTRtree$$1.prototype.query.call(this, searchBounds, node, visitor$1);\n      } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Object && arguments[1] instanceof AbstractNode)) {\n        var searchBounds$1 = arguments[0];\n        var node$1 = arguments[1];\n        var matches = arguments[2];\n        AbstractSTRtree$$1.prototype.query.call(this, searchBounds$1, node$1, matches);\n      }\n    }\n  };\n  STRtree.prototype.getComparator = function getComparator () {\n    return STRtree.yComparator\n  };\n  STRtree.prototype.createParentBoundablesFromVerticalSlice = function createParentBoundablesFromVerticalSlice (childBoundables, newLevel) {\n    return AbstractSTRtree$$1.prototype.createParentBoundables.call(this, childBoundables, newLevel)\n  };\n  STRtree.prototype.remove = function remove () {\n    if (arguments.length === 2) {\n      var itemEnv = arguments[0];\n      var item = arguments[1];\n      return AbstractSTRtree$$1.prototype.remove.call(this, itemEnv, item)\n    } else { return AbstractSTRtree$$1.prototype.remove.apply(this, arguments) }\n  };\n  STRtree.prototype.depth = function depth () {\n    if (arguments.length === 0) {\n      return AbstractSTRtree$$1.prototype.depth.call(this)\n    } else { return AbstractSTRtree$$1.prototype.depth.apply(this, arguments) }\n  };\n  STRtree.prototype.createParentBoundables = function createParentBoundables (childBoundables, newLevel) {\n    Assert.isTrue(!childBoundables.isEmpty());\n    var minLeafCount = Math.trunc(Math.ceil(childBoundables.size() / this.getNodeCapacity()));\n    var sortedChildBoundables = new ArrayList(childBoundables);\n    Collections.sort(sortedChildBoundables, STRtree.xComparator);\n    var verticalSlices = this.verticalSlices(sortedChildBoundables, Math.trunc(Math.ceil(Math.sqrt(minLeafCount))));\n    return this.createParentBoundablesFromVerticalSlices(verticalSlices, newLevel)\n  };\n  STRtree.prototype.nearestNeighbour = function nearestNeighbour () {\n    if (arguments.length === 1) {\n      if (hasInterface(arguments[0], ItemDistance)) {\n        var itemDist = arguments[0];\n        var bp = new BoundablePair(this.getRoot(), this.getRoot(), itemDist);\n        return this.nearestNeighbour(bp)\n      } else if (arguments[0] instanceof BoundablePair) {\n        var initBndPair = arguments[0];\n        return this.nearestNeighbour(initBndPair, Double.POSITIVE_INFINITY)\n      }\n    } else if (arguments.length === 2) {\n      if (arguments[0] instanceof STRtree && hasInterface(arguments[1], ItemDistance)) {\n        var tree = arguments[0];\n        var itemDist$1 = arguments[1];\n        var bp$1 = new BoundablePair(this.getRoot(), tree.getRoot(), itemDist$1);\n        return this.nearestNeighbour(bp$1)\n      } else if (arguments[0] instanceof BoundablePair && typeof arguments[1] === 'number') {\n        var initBndPair$1 = arguments[0];\n        var maxDistance = arguments[1];\n        var distanceLowerBound = maxDistance;\n        var minPair = null;\n        var priQ = new PriorityQueue();\n        priQ.add(initBndPair$1);\n        while (!priQ.isEmpty() && distanceLowerBound > 0.0) {\n          var bndPair = priQ.poll();\n          var currentDistance = bndPair.getDistance();\n          if (currentDistance >= distanceLowerBound) { break }\n          if (bndPair.isLeaves()) {\n            distanceLowerBound = currentDistance;\n            minPair = bndPair;\n          } else {\n            bndPair.expandToQueue(priQ, distanceLowerBound);\n          }\n        }\n        return [minPair.getBoundable(0).getItem(), minPair.getBoundable(1).getItem()]\n      }\n    } else if (arguments.length === 3) {\n      var env = arguments[0];\n      var item = arguments[1];\n      var itemDist$2 = arguments[2];\n      var bnd = new ItemBoundable(env, item);\n      var bp$2 = new BoundablePair(this.getRoot(), bnd, itemDist$2);\n      return this.nearestNeighbour(bp$2)[0]\n    }\n  };\n  STRtree.prototype.interfaces_ = function interfaces_ () {\n    return [SpatialIndex, Serializable]\n  };\n  STRtree.prototype.getClass = function getClass () {\n    return STRtree\n  };\n  STRtree.centreX = function centreX (e) {\n    return STRtree.avg(e.getMinX(), e.getMaxX())\n  };\n  STRtree.avg = function avg (a, b) {\n    return (a + b) / 2\n  };\n  STRtree.centreY = function centreY (e) {\n    return STRtree.avg(e.getMinY(), e.getMaxY())\n  };\n  staticAccessors.STRtreeNode.get = function () { return STRtreeNode };\n  staticAccessors.serialVersionUID.get = function () { return 259274702368956900 };\n  staticAccessors.xComparator.get = function () {\n    return {\n      interfaces_: function () {\n        return [Comparator]\n      },\n      compare: function (o1, o2) {\n        return AbstractSTRtree$$1.compareDoubles(STRtree.centreX(o1.getBounds()), STRtree.centreX(o2.getBounds()))\n      }\n    }\n  };\n  staticAccessors.yComparator.get = function () {\n    return {\n      interfaces_: function () {\n        return [Comparator]\n      },\n      compare: function (o1, o2) {\n        return AbstractSTRtree$$1.compareDoubles(STRtree.centreY(o1.getBounds()), STRtree.centreY(o2.getBounds()))\n      }\n    }\n  };\n  staticAccessors.intersectsOp.get = function () {\n    return {\n      interfaces_: function () {\n        return [AbstractSTRtree$$1.IntersectsOp]\n      },\n      intersects: function (aBounds, bBounds) {\n        return aBounds.intersects(bBounds)\n      }\n    }\n  };\n  staticAccessors.DEFAULT_NODE_CAPACITY.get = function () { return 10 };\n\n  Object.defineProperties( STRtree, staticAccessors );\n\n  return STRtree;\n}(AbstractSTRtree));\n\nvar STRtreeNode = (function (AbstractNode$$1) {\n  function STRtreeNode () {\n    var level = arguments[0];\n    AbstractNode$$1.call(this, level);\n  }\n\n  if ( AbstractNode$$1 ) STRtreeNode.__proto__ = AbstractNode$$1;\n  STRtreeNode.prototype = Object.create( AbstractNode$$1 && AbstractNode$$1.prototype );\n  STRtreeNode.prototype.constructor = STRtreeNode;\n  STRtreeNode.prototype.computeBounds = function computeBounds () {\n    var bounds = null;\n    for (var i = this.getChildBoundables().iterator(); i.hasNext();) {\n      var childBoundable = i.next();\n      if (bounds === null) {\n        bounds = new Envelope(childBoundable.getBounds());\n      } else {\n        bounds.expandToInclude(childBoundable.getBounds());\n      }\n    }\n    return bounds\n  };\n  STRtreeNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  STRtreeNode.prototype.getClass = function getClass () {\n    return STRtreeNode\n  };\n\n  return STRtreeNode;\n}(AbstractNode));\n\nvar SegmentPointComparator = function SegmentPointComparator () {};\n\nSegmentPointComparator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentPointComparator.prototype.getClass = function getClass () {\n  return SegmentPointComparator\n};\nSegmentPointComparator.relativeSign = function relativeSign (x0, x1) {\n  if (x0 < x1) { return -1 }\n  if (x0 > x1) { return 1 }\n  return 0\n};\nSegmentPointComparator.compare = function compare (octant, p0, p1) {\n  if (p0.equals2D(p1)) { return 0 }\n  var xSign = SegmentPointComparator.relativeSign(p0.x, p1.x);\n  var ySign = SegmentPointComparator.relativeSign(p0.y, p1.y);\n  switch (octant) {\n    case 0:\n      return SegmentPointComparator.compareValue(xSign, ySign)\n    case 1:\n      return SegmentPointComparator.compareValue(ySign, xSign)\n    case 2:\n      return SegmentPointComparator.compareValue(ySign, -xSign)\n    case 3:\n      return SegmentPointComparator.compareValue(-xSign, ySign)\n    case 4:\n      return SegmentPointComparator.compareValue(-xSign, -ySign)\n    case 5:\n      return SegmentPointComparator.compareValue(-ySign, -xSign)\n    case 6:\n      return SegmentPointComparator.compareValue(-ySign, xSign)\n    case 7:\n      return SegmentPointComparator.compareValue(xSign, -ySign)\n    default:\n  }\n  Assert.shouldNeverReachHere('invalid octant value');\n  return 0\n};\nSegmentPointComparator.compareValue = function compareValue (compareSign0, compareSign1) {\n  if (compareSign0 < 0) { return -1 }\n  if (compareSign0 > 0) { return 1 }\n  if (compareSign1 < 0) { return -1 }\n  if (compareSign1 > 0) { return 1 }\n  return 0\n};\n\nvar SegmentNode = function SegmentNode () {\n  this._segString = null;\n  this.coord = null;\n  this.segmentIndex = null;\n  this._segmentOctant = null;\n  this._isInterior = null;\n  var segString = arguments[0];\n  var coord = arguments[1];\n  var segmentIndex = arguments[2];\n  var segmentOctant = arguments[3];\n  this._segString = segString;\n  this.coord = new Coordinate(coord);\n  this.segmentIndex = segmentIndex;\n  this._segmentOctant = segmentOctant;\n  this._isInterior = !coord.equals2D(segString.getCoordinate(segmentIndex));\n};\nSegmentNode.prototype.getCoordinate = function getCoordinate () {\n  return this.coord\n};\nSegmentNode.prototype.print = function print (out) {\n  out.print(this.coord);\n  out.print(' seg # = ' + this.segmentIndex);\n};\nSegmentNode.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  if (this.segmentIndex < other.segmentIndex) { return -1 }\n  if (this.segmentIndex > other.segmentIndex) { return 1 }\n  if (this.coord.equals2D(other.coord)) { return 0 }\n  return SegmentPointComparator.compare(this._segmentOctant, this.coord, other.coord)\n};\nSegmentNode.prototype.isEndPoint = function isEndPoint (maxSegmentIndex) {\n  if (this.segmentIndex === 0 && !this._isInterior) { return true }\n  if (this.segmentIndex === maxSegmentIndex) { return true }\n  return false\n};\nSegmentNode.prototype.isInterior = function isInterior () {\n  return this._isInterior\n};\nSegmentNode.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nSegmentNode.prototype.getClass = function getClass () {\n  return SegmentNode\n};\n\n// import Iterator from '../../../../java/util/Iterator'\nvar SegmentNodeList = function SegmentNodeList () {\n  this._nodeMap = new TreeMap();\n  this._edge = null;\n  var edge = arguments[0];\n  this._edge = edge;\n};\nSegmentNodeList.prototype.getSplitCoordinates = function getSplitCoordinates () {\n    var this$1 = this;\n\n  var coordList = new CoordinateList();\n  this.addEndpoints();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    this$1.addEdgeCoordinates(eiPrev, ei, coordList);\n    eiPrev = ei;\n  }\n  return coordList.toCoordinateArray()\n};\nSegmentNodeList.prototype.addCollapsedNodes = function addCollapsedNodes () {\n    var this$1 = this;\n\n  var collapsedVertexIndexes = new ArrayList();\n  this.findCollapsesFromInsertedNodes(collapsedVertexIndexes);\n  this.findCollapsesFromExistingVertices(collapsedVertexIndexes);\n  for (var it = collapsedVertexIndexes.iterator(); it.hasNext();) {\n    var vertexIndex = it.next().intValue();\n    this$1.add(this$1._edge.getCoordinate(vertexIndex), vertexIndex);\n  }\n};\nSegmentNodeList.prototype.print = function print (out) {\n  out.println('Intersections:');\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    ei.print(out);\n  }\n};\nSegmentNodeList.prototype.findCollapsesFromExistingVertices = function findCollapsesFromExistingVertices (collapsedVertexIndexes) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edge.size() - 2; i++) {\n    var p0 = this$1._edge.getCoordinate(i);\n    // const p1 = this._edge.getCoordinate(i + 1)\n    var p2 = this$1._edge.getCoordinate(i + 2);\n    if (p0.equals2D(p2)) {\n      collapsedVertexIndexes.add(new Integer(i + 1));\n    }\n  }\n};\nSegmentNodeList.prototype.addEdgeCoordinates = function addEdgeCoordinates (ei0, ei1, coordList) {\n    var this$1 = this;\n\n  // let npts = ei1.segmentIndex - ei0.segmentIndex + 2\n  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  // if (!useIntPt1) {\n  // npts--\n  // }\n  // const ipt = 0\n  coordList.add(new Coordinate(ei0.coord), false);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    coordList.add(this$1._edge.getCoordinate(i));\n  }\n  if (useIntPt1) {\n    coordList.add(new Coordinate(ei1.coord));\n  }\n};\nSegmentNodeList.prototype.iterator = function iterator () {\n  return this._nodeMap.values().iterator()\n};\nSegmentNodeList.prototype.addSplitEdges = function addSplitEdges (edgeList) {\n    var this$1 = this;\n\n  this.addEndpoints();\n  this.addCollapsedNodes();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var newEdge = this$1.createSplitEdge(eiPrev, ei);\n    edgeList.add(newEdge);\n    eiPrev = ei;\n  }\n};\nSegmentNodeList.prototype.findCollapseIndex = function findCollapseIndex (ei0, ei1, collapsedVertexIndex) {\n  if (!ei0.coord.equals2D(ei1.coord)) { return false }\n  var numVerticesBetween = ei1.segmentIndex - ei0.segmentIndex;\n  if (!ei1.isInterior()) {\n    numVerticesBetween--;\n  }\n  if (numVerticesBetween === 1) {\n    collapsedVertexIndex[0] = ei0.segmentIndex + 1;\n    return true\n  }\n  return false\n};\nSegmentNodeList.prototype.findCollapsesFromInsertedNodes = function findCollapsesFromInsertedNodes (collapsedVertexIndexes) {\n    var this$1 = this;\n\n  var collapsedVertexIndex = new Array(1).fill(null);\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var isCollapsed = this$1.findCollapseIndex(eiPrev, ei, collapsedVertexIndex);\n    if (isCollapsed) { collapsedVertexIndexes.add(new Integer(collapsedVertexIndex[0])); }\n    eiPrev = ei;\n  }\n};\nSegmentNodeList.prototype.getEdge = function getEdge () {\n  return this._edge\n};\nSegmentNodeList.prototype.addEndpoints = function addEndpoints () {\n  var maxSegIndex = this._edge.size() - 1;\n  this.add(this._edge.getCoordinate(0), 0);\n  this.add(this._edge.getCoordinate(maxSegIndex), maxSegIndex);\n};\nSegmentNodeList.prototype.createSplitEdge = function createSplitEdge (ei0, ei1) {\n    var this$1 = this;\n\n  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  var lastSegStartPt = this._edge.getCoordinate(ei1.segmentIndex);\n  var useIntPt1 = ei1.isInterior() || !ei1.coord.equals2D(lastSegStartPt);\n  if (!useIntPt1) {\n    npts--;\n  }\n  var pts = new Array(npts).fill(null);\n  var ipt = 0;\n  pts[ipt++] = new Coordinate(ei0.coord);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    pts[ipt++] = this$1._edge.getCoordinate(i);\n  }\n  if (useIntPt1) { pts[ipt] = new Coordinate(ei1.coord); }\n  return new NodedSegmentString(pts, this._edge.getData())\n};\nSegmentNodeList.prototype.add = function add (intPt, segmentIndex) {\n  var eiNew = new SegmentNode(this._edge, intPt, segmentIndex, this._edge.getSegmentOctant(segmentIndex));\n  var ei = this._nodeMap.get(eiNew);\n  if (ei !== null) {\n    Assert.isTrue(ei.coord.equals2D(intPt), 'Found equal nodes with different coordinates');\n    return ei\n  }\n  this._nodeMap.put(eiNew, eiNew);\n  return eiNew\n};\nSegmentNodeList.prototype.checkSplitEdgesCorrectness = function checkSplitEdgesCorrectness (splitEdges) {\n  var edgePts = this._edge.getCoordinates();\n  var split0 = splitEdges.get(0);\n  var pt0 = split0.getCoordinate(0);\n  if (!pt0.equals2D(edgePts[0])) { throw new RuntimeException('bad split edge start point at ' + pt0) }\n  var splitn = splitEdges.get(splitEdges.size() - 1);\n  var splitnPts = splitn.getCoordinates();\n  var ptn = splitnPts[splitnPts.length - 1];\n  if (!ptn.equals2D(edgePts[edgePts.length - 1])) { throw new RuntimeException('bad split edge end point at ' + ptn) }\n};\nSegmentNodeList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentNodeList.prototype.getClass = function getClass () {\n  return SegmentNodeList\n};\n\n\n\n// class NodeVertexIterator {\n//   constructor () {\n//     this._nodeList = null\n//     this._edge = null\n//     this._nodeIt = null\n//     this._currNode = null\n//     this._nextNode = null\n//     this._currSegIndex = 0\n//     let nodeList = arguments[0]\n//     this._nodeList = nodeList\n//     this._edge = nodeList.getEdge()\n//     this._nodeIt = nodeList.iterator()\n//     this.readNextNode()\n//   }\n//   next () {\n//     if (this._currNode === null) {\n//       this._currNode = this._nextNode\n//       this._currSegIndex = this._currNode.segmentIndex\n//       this.readNextNode()\n//       return this._currNode\n//     }\n//     if (this._nextNode === null) return null\n//     if (this._nextNode.segmentIndex === this._currNode.segmentIndex) {\n//       this._currNode = this._nextNode\n//       this._currSegIndex = this._currNode.segmentIndex\n//       this.readNextNode()\n//       return this._currNode\n//     }\n//     if (this._nextNode.segmentIndex > this._currNode.segmentIndex) {}\n//     return null\n//   }\n//   remove () {\n//     // throw new UnsupportedOperationException(this.getClass().getName())\n//   }\n//   hasNext () {\n//     if (this._nextNode === null) return false\n//     return true\n//   }\n//   readNextNode () {\n//     if (this._nodeIt.hasNext()) this._nextNode = this._nodeIt.next(); else this._nextNode = null\n//   }\n//   interfaces_ () {\n//     return [Iterator]\n//   }\n//   getClass () {\n//     return NodeVertexIterator\n//   }\n// }\n\nvar Octant = function Octant () {};\n\nOctant.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOctant.prototype.getClass = function getClass () {\n  return Octant\n};\nOctant.octant = function octant () {\n  if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {\n    var dx = arguments[0];\n    var dy = arguments[1];\n    if (dx === 0.0 && dy === 0.0) { throw new IllegalArgumentException('Cannot compute the octant for point ( ' + dx + ', ' + dy + ' )') }\n    var adx = Math.abs(dx);\n    var ady = Math.abs(dy);\n    if (dx >= 0) {\n      if (dy >= 0) {\n        if (adx >= ady) { return 0; } else { return 1 }\n      } else {\n        if (adx >= ady) { return 7; } else { return 6 }\n      }\n    } else {\n      if (dy >= 0) {\n        if (adx >= ady) { return 3; } else { return 2 }\n      } else {\n        if (adx >= ady) { return 4; } else { return 5 }\n      }\n    }\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Coordinate) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    var dx$1 = p1.x - p0.x;\n    var dy$1 = p1.y - p0.y;\n    if (dx$1 === 0.0 && dy$1 === 0.0) { throw new IllegalArgumentException('Cannot compute the octant for two identical points ' + p0) }\n    return Octant.octant(dx$1, dy$1)\n  }\n};\n\nvar SegmentString = function SegmentString () {};\n\nSegmentString.prototype.getCoordinates = function getCoordinates () {};\nSegmentString.prototype.size = function size () {};\nSegmentString.prototype.getCoordinate = function getCoordinate (i) {};\nSegmentString.prototype.isClosed = function isClosed () {};\nSegmentString.prototype.setData = function setData (data) {};\nSegmentString.prototype.getData = function getData () {};\nSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentString.prototype.getClass = function getClass () {\n  return SegmentString\n};\n\nvar NodableSegmentString = function NodableSegmentString () {};\n\nNodableSegmentString.prototype.addIntersection = function addIntersection (intPt, segmentIndex) {};\nNodableSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentString]\n};\nNodableSegmentString.prototype.getClass = function getClass () {\n  return NodableSegmentString\n};\n\nvar NodedSegmentString = function NodedSegmentString () {\n  this._nodeList = new SegmentNodeList(this);\n  this._pts = null;\n  this._data = null;\n  var pts = arguments[0];\n  var data = arguments[1];\n  this._pts = pts;\n  this._data = data;\n};\nNodedSegmentString.prototype.getCoordinates = function getCoordinates () {\n  return this._pts\n};\nNodedSegmentString.prototype.size = function size () {\n  return this._pts.length\n};\nNodedSegmentString.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts[i]\n};\nNodedSegmentString.prototype.isClosed = function isClosed () {\n  return this._pts[0].equals(this._pts[this._pts.length - 1])\n};\nNodedSegmentString.prototype.getSegmentOctant = function getSegmentOctant (index) {\n  if (index === this._pts.length - 1) { return -1 }\n  return this.safeOctant(this.getCoordinate(index), this.getCoordinate(index + 1))\n};\nNodedSegmentString.prototype.setData = function setData (data) {\n  this._data = data;\n};\nNodedSegmentString.prototype.safeOctant = function safeOctant (p0, p1) {\n  if (p0.equals2D(p1)) { return 0 }\n  return Octant.octant(p0, p1)\n};\nNodedSegmentString.prototype.getData = function getData () {\n  return this._data\n};\nNodedSegmentString.prototype.addIntersection = function addIntersection () {\n  if (arguments.length === 2) {\n    var intPt$1 = arguments[0];\n    var segmentIndex = arguments[1];\n    this.addIntersectionNode(intPt$1, segmentIndex);\n  } else if (arguments.length === 4) {\n    var li = arguments[0];\n    var segmentIndex$1 = arguments[1];\n    // const geomIndex = arguments[2]\n    var intIndex = arguments[3];\n    var intPt = new Coordinate(li.getIntersection(intIndex));\n    this.addIntersection(intPt, segmentIndex$1);\n  }\n};\nNodedSegmentString.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))\n};\nNodedSegmentString.prototype.getNodeList = function getNodeList () {\n  return this._nodeList\n};\nNodedSegmentString.prototype.addIntersectionNode = function addIntersectionNode (intPt, segmentIndex) {\n  var normalizedSegmentIndex = segmentIndex;\n  var nextSegIndex = normalizedSegmentIndex + 1;\n  if (nextSegIndex < this._pts.length) {\n    var nextPt = this._pts[nextSegIndex];\n    if (intPt.equals2D(nextPt)) {\n      normalizedSegmentIndex = nextSegIndex;\n    }\n  }\n  var ei = this._nodeList.add(intPt, normalizedSegmentIndex);\n  return ei\n};\nNodedSegmentString.prototype.addIntersections = function addIntersections (li, segmentIndex, geomIndex) {\n    var this$1 = this;\n\n  for (var i = 0; i < li.getIntersectionNum(); i++) {\n    this$1.addIntersection(li, segmentIndex, geomIndex, i);\n  }\n};\nNodedSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [NodableSegmentString]\n};\nNodedSegmentString.prototype.getClass = function getClass () {\n  return NodedSegmentString\n};\nNodedSegmentString.getNodedSubstrings = function getNodedSubstrings () {\n  if (arguments.length === 1) {\n    var segStrings = arguments[0];\n    var resultEdgelist = new ArrayList();\n    NodedSegmentString.getNodedSubstrings(segStrings, resultEdgelist);\n    return resultEdgelist\n  } else if (arguments.length === 2) {\n    var segStrings$1 = arguments[0];\n    var resultEdgelist$1 = arguments[1];\n    for (var i = segStrings$1.iterator(); i.hasNext();) {\n      var ss = i.next();\n      ss.getNodeList().addSplitEdges(resultEdgelist$1);\n    }\n  }\n};\n\nvar LineSegment = function LineSegment () {\n  this.p0 = null;\n  this.p1 = null;\n  if (arguments.length === 0) {\n    this.p0 = new Coordinate();\n    this.p1 = new Coordinate();\n  } else if (arguments.length === 1) {\n    var ls = arguments[0];\n    this.p0 = new Coordinate(ls.p0);\n    this.p1 = new Coordinate(ls.p1);\n  } else if (arguments.length === 2) {\n    this.p0 = arguments[0];\n    this.p1 = arguments[1];\n  } else if (arguments.length === 4) {\n    var x0 = arguments[0];\n    var y0 = arguments[1];\n    var x1 = arguments[2];\n    var y1 = arguments[3];\n    this.p0 = new Coordinate(x0, y0);\n    this.p1 = new Coordinate(x1, y1);\n  }\n};\n\nvar staticAccessors$24 = { serialVersionUID: { configurable: true } };\nLineSegment.prototype.minX = function minX () {\n  return Math.min(this.p0.x, this.p1.x)\n};\nLineSegment.prototype.orientationIndex = function orientationIndex () {\n  if (arguments[0] instanceof LineSegment) {\n    var seg = arguments[0];\n    var orient0 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p0);\n    var orient1 = CGAlgorithms.orientationIndex(this.p0, this.p1, seg.p1);\n    if (orient0 >= 0 && orient1 >= 0) { return Math.max(orient0, orient1) }\n    if (orient0 <= 0 && orient1 <= 0) { return Math.max(orient0, orient1) }\n    return 0\n  } else if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    return CGAlgorithms.orientationIndex(this.p0, this.p1, p)\n  }\n};\nLineSegment.prototype.toGeometry = function toGeometry (geomFactory) {\n  return geomFactory.createLineString([this.p0, this.p1])\n};\nLineSegment.prototype.isVertical = function isVertical () {\n  return this.p0.x === this.p1.x\n};\nLineSegment.prototype.equals = function equals (o) {\n  if (!(o instanceof LineSegment)) {\n    return false\n  }\n  var other = o;\n  return this.p0.equals(other.p0) && this.p1.equals(other.p1)\n};\nLineSegment.prototype.intersection = function intersection (line) {\n  var li = new RobustLineIntersector();\n  li.computeIntersection(this.p0, this.p1, line.p0, line.p1);\n  if (li.hasIntersection()) { return li.getIntersection(0) }\n  return null\n};\nLineSegment.prototype.project = function project () {\n  if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    if (p.equals(this.p0) || p.equals(this.p1)) { return new Coordinate(p) }\n    var r = this.projectionFactor(p);\n    var coord = new Coordinate();\n    coord.x = this.p0.x + r * (this.p1.x - this.p0.x);\n    coord.y = this.p0.y + r * (this.p1.y - this.p0.y);\n    return coord\n  } else if (arguments[0] instanceof LineSegment) {\n    var seg = arguments[0];\n    var pf0 = this.projectionFactor(seg.p0);\n    var pf1 = this.projectionFactor(seg.p1);\n    if (pf0 >= 1.0 && pf1 >= 1.0) { return null }\n    if (pf0 <= 0.0 && pf1 <= 0.0) { return null }\n    var newp0 = this.project(seg.p0);\n    if (pf0 < 0.0) { newp0 = this.p0; }\n    if (pf0 > 1.0) { newp0 = this.p1; }\n    var newp1 = this.project(seg.p1);\n    if (pf1 < 0.0) { newp1 = this.p0; }\n    if (pf1 > 1.0) { newp1 = this.p1; }\n    return new LineSegment(newp0, newp1)\n  }\n};\nLineSegment.prototype.normalize = function normalize () {\n  if (this.p1.compareTo(this.p0) < 0) { this.reverse(); }\n};\nLineSegment.prototype.angle = function angle () {\n  return Math.atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)\n};\nLineSegment.prototype.getCoordinate = function getCoordinate (i) {\n  if (i === 0) { return this.p0 }\n  return this.p1\n};\nLineSegment.prototype.distancePerpendicular = function distancePerpendicular (p) {\n  return CGAlgorithms.distancePointLinePerpendicular(p, this.p0, this.p1)\n};\nLineSegment.prototype.minY = function minY () {\n  return Math.min(this.p0.y, this.p1.y)\n};\nLineSegment.prototype.midPoint = function midPoint () {\n  return LineSegment.midPoint(this.p0, this.p1)\n};\nLineSegment.prototype.projectionFactor = function projectionFactor (p) {\n  if (p.equals(this.p0)) { return 0.0 }\n  if (p.equals(this.p1)) { return 1.0 }\n  var dx = this.p1.x - this.p0.x;\n  var dy = this.p1.y - this.p0.y;\n  var len = dx * dx + dy * dy;\n  if (len <= 0.0) { return Double.NaN }\n  var r = ((p.x - this.p0.x) * dx + (p.y - this.p0.y) * dy) / len;\n  return r\n};\nLineSegment.prototype.closestPoints = function closestPoints (line) {\n  var intPt = this.intersection(line);\n  if (intPt !== null) {\n    return [intPt, intPt]\n  }\n  var closestPt = new Array(2).fill(null);\n  var minDistance = Double.MAX_VALUE;\n  var dist = null;\n  var close00 = this.closestPoint(line.p0);\n  minDistance = close00.distance(line.p0);\n  closestPt[0] = close00;\n  closestPt[1] = line.p0;\n  var close01 = this.closestPoint(line.p1);\n  dist = close01.distance(line.p1);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = close01;\n    closestPt[1] = line.p1;\n  }\n  var close10 = line.closestPoint(this.p0);\n  dist = close10.distance(this.p0);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = this.p0;\n    closestPt[1] = close10;\n  }\n  var close11 = line.closestPoint(this.p1);\n  dist = close11.distance(this.p1);\n  if (dist < minDistance) {\n    minDistance = dist;\n    closestPt[0] = this.p1;\n    closestPt[1] = close11;\n  }\n  return closestPt\n};\nLineSegment.prototype.closestPoint = function closestPoint (p) {\n  var factor = this.projectionFactor(p);\n  if (factor > 0 && factor < 1) {\n    return this.project(p)\n  }\n  var dist0 = this.p0.distance(p);\n  var dist1 = this.p1.distance(p);\n  if (dist0 < dist1) { return this.p0 }\n  return this.p1\n};\nLineSegment.prototype.maxX = function maxX () {\n  return Math.max(this.p0.x, this.p1.x)\n};\nLineSegment.prototype.getLength = function getLength () {\n  return this.p0.distance(this.p1)\n};\nLineSegment.prototype.compareTo = function compareTo (o) {\n  var other = o;\n  var comp0 = this.p0.compareTo(other.p0);\n  if (comp0 !== 0) { return comp0 }\n  return this.p1.compareTo(other.p1)\n};\nLineSegment.prototype.reverse = function reverse () {\n  var temp = this.p0;\n  this.p0 = this.p1;\n  this.p1 = temp;\n};\nLineSegment.prototype.equalsTopo = function equalsTopo (other) {\n  return this.p0.equals(other.p0) &&\n        (this.p1.equals(other.p1) || this.p0.equals(other.p1)) &&\n         this.p1.equals(other.p0)\n};\nLineSegment.prototype.lineIntersection = function lineIntersection (line) {\n  try {\n    var intPt = HCoordinate.intersection(this.p0, this.p1, line.p0, line.p1);\n    return intPt\n  } catch (ex) {\n    if (ex instanceof NotRepresentableException) {} else { throw ex }\n  } finally {}\n  return null\n};\nLineSegment.prototype.maxY = function maxY () {\n  return Math.max(this.p0.y, this.p1.y)\n};\nLineSegment.prototype.pointAlongOffset = function pointAlongOffset (segmentLengthFraction, offsetDistance) {\n  var segx = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  var segy = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  var dx = this.p1.x - this.p0.x;\n  var dy = this.p1.y - this.p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = 0.0;\n  var uy = 0.0;\n  if (offsetDistance !== 0.0) {\n    if (len <= 0.0) { throw new Error('Cannot compute offset from zero-length line segment') }\n    ux = offsetDistance * dx / len;\n    uy = offsetDistance * dy / len;\n  }\n  var offsetx = segx - uy;\n  var offsety = segy + ux;\n  var coord = new Coordinate(offsetx, offsety);\n  return coord\n};\nLineSegment.prototype.setCoordinates = function setCoordinates () {\n  if (arguments.length === 1) {\n    var ls = arguments[0];\n    this.setCoordinates(ls.p0, ls.p1);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this.p0.x = p0.x;\n    this.p0.y = p0.y;\n    this.p1.x = p1.x;\n    this.p1.y = p1.y;\n  }\n};\nLineSegment.prototype.segmentFraction = function segmentFraction (inputPt) {\n  var segFrac = this.projectionFactor(inputPt);\n  if (segFrac < 0.0) { segFrac = 0.0; } else if (segFrac > 1.0 || Double.isNaN(segFrac)) { segFrac = 1.0; }\n  return segFrac\n};\nLineSegment.prototype.toString = function toString () {\n  return 'LINESTRING( ' + this.p0.x + ' ' + this.p0.y + ', ' + this.p1.x + ' ' + this.p1.y + ')'\n};\nLineSegment.prototype.isHorizontal = function isHorizontal () {\n  return this.p0.y === this.p1.y\n};\nLineSegment.prototype.distance = function distance () {\n  if (arguments[0] instanceof LineSegment) {\n    var ls = arguments[0];\n    return CGAlgorithms.distanceLineLine(this.p0, this.p1, ls.p0, ls.p1)\n  } else if (arguments[0] instanceof Coordinate) {\n    var p = arguments[0];\n    return CGAlgorithms.distancePointLine(p, this.p0, this.p1)\n  }\n};\nLineSegment.prototype.pointAlong = function pointAlong (segmentLengthFraction) {\n  var coord = new Coordinate();\n  coord.x = this.p0.x + segmentLengthFraction * (this.p1.x - this.p0.x);\n  coord.y = this.p0.y + segmentLengthFraction * (this.p1.y - this.p0.y);\n  return coord\n};\nLineSegment.prototype.hashCode = function hashCode () {\n  var bits0 = Double.doubleToLongBits(this.p0.x);\n  bits0 ^= Double.doubleToLongBits(this.p0.y) * 31;\n  var hash0 = Math.trunc(bits0) ^ Math.trunc(bits0 >> 32);\n  var bits1 = Double.doubleToLongBits(this.p1.x);\n  bits1 ^= Double.doubleToLongBits(this.p1.y) * 31;\n  var hash1 = Math.trunc(bits1) ^ Math.trunc(bits1 >> 32);\n  return hash0 ^ hash1\n};\nLineSegment.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable, Serializable]\n};\nLineSegment.prototype.getClass = function getClass () {\n  return LineSegment\n};\nLineSegment.midPoint = function midPoint (p0, p1) {\n  return new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2)\n};\nstaticAccessors$24.serialVersionUID.get = function () { return 3252005833466256227 };\n\nObject.defineProperties( LineSegment, staticAccessors$24 );\n\nvar MonotoneChainOverlapAction = function MonotoneChainOverlapAction () {\n  this.tempEnv1 = new Envelope();\n  this.tempEnv2 = new Envelope();\n  this._overlapSeg1 = new LineSegment();\n  this._overlapSeg2 = new LineSegment();\n};\nMonotoneChainOverlapAction.prototype.overlap = function overlap () {\n  if (arguments.length === 2) {\n    // const seg1 = arguments[0]\n    // const seg2 = arguments[1]\n  } else if (arguments.length === 4) {\n    var mc1 = arguments[0];\n    var start1 = arguments[1];\n    var mc2 = arguments[2];\n    var start2 = arguments[3];\n    mc1.getLineSegment(start1, this._overlapSeg1);\n    mc2.getLineSegment(start2, this._overlapSeg2);\n    this.overlap(this._overlapSeg1, this._overlapSeg2);\n  }\n};\nMonotoneChainOverlapAction.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainOverlapAction.prototype.getClass = function getClass () {\n  return MonotoneChainOverlapAction\n};\n\nvar MonotoneChain = function MonotoneChain () {\n  this._pts = null;\n  this._start = null;\n  this._end = null;\n  this._env = null;\n  this._context = null;\n  this._id = null;\n  var pts = arguments[0];\n  var start = arguments[1];\n  var end = arguments[2];\n  var context = arguments[3];\n  this._pts = pts;\n  this._start = start;\n  this._end = end;\n  this._context = context;\n};\nMonotoneChain.prototype.getLineSegment = function getLineSegment (index, ls) {\n  ls.p0 = this._pts[index];\n  ls.p1 = this._pts[index + 1];\n};\nMonotoneChain.prototype.computeSelect = function computeSelect (searchEnv, start0, end0, mcs) {\n  var p0 = this._pts[start0];\n  var p1 = this._pts[end0];\n  mcs.tempEnv1.init(p0, p1);\n  if (end0 - start0 === 1) {\n    mcs.select(this, start0);\n    return null\n  }\n  if (!searchEnv.intersects(mcs.tempEnv1)) { return null }\n  var mid = Math.trunc((start0 + end0) / 2);\n  if (start0 < mid) {\n    this.computeSelect(searchEnv, start0, mid, mcs);\n  }\n  if (mid < end0) {\n    this.computeSelect(searchEnv, mid, end0, mcs);\n  }\n};\nMonotoneChain.prototype.getCoordinates = function getCoordinates () {\n    var this$1 = this;\n\n  var coord = new Array(this._end - this._start + 1).fill(null);\n  var index = 0;\n  for (var i = this._start; i <= this._end; i++) {\n    coord[index++] = this$1._pts[i];\n  }\n  return coord\n};\nMonotoneChain.prototype.computeOverlaps = function computeOverlaps (mc, mco) {\n  this.computeOverlapsInternal(this._start, this._end, mc, mc._start, mc._end, mco);\n};\nMonotoneChain.prototype.setId = function setId (id) {\n  this._id = id;\n};\nMonotoneChain.prototype.select = function select (searchEnv, mcs) {\n  this.computeSelect(searchEnv, this._start, this._end, mcs);\n};\nMonotoneChain.prototype.getEnvelope = function getEnvelope () {\n  if (this._env === null) {\n    var p0 = this._pts[this._start];\n    var p1 = this._pts[this._end];\n    this._env = new Envelope(p0, p1);\n  }\n  return this._env\n};\nMonotoneChain.prototype.getEndIndex = function getEndIndex () {\n  return this._end\n};\nMonotoneChain.prototype.getStartIndex = function getStartIndex () {\n  return this._start\n};\nMonotoneChain.prototype.getContext = function getContext () {\n  return this._context\n};\nMonotoneChain.prototype.getId = function getId () {\n  return this._id\n};\nMonotoneChain.prototype.computeOverlapsInternal = function computeOverlapsInternal (start0, end0, mc, start1, end1, mco) {\n  var p00 = this._pts[start0];\n  var p01 = this._pts[end0];\n  var p10 = mc._pts[start1];\n  var p11 = mc._pts[end1];\n  if (end0 - start0 === 1 && end1 - start1 === 1) {\n    mco.overlap(this, start0, mc, start1);\n    return null\n  }\n  mco.tempEnv1.init(p00, p01);\n  mco.tempEnv2.init(p10, p11);\n  if (!mco.tempEnv1.intersects(mco.tempEnv2)) { return null }\n  var mid0 = Math.trunc((start0 + end0) / 2);\n  var mid1 = Math.trunc((start1 + end1) / 2);\n  if (start0 < mid0) {\n    if (start1 < mid1) { this.computeOverlapsInternal(start0, mid0, mc, start1, mid1, mco); }\n    if (mid1 < end1) { this.computeOverlapsInternal(start0, mid0, mc, mid1, end1, mco); }\n  }\n  if (mid0 < end0) {\n    if (start1 < mid1) { this.computeOverlapsInternal(mid0, end0, mc, start1, mid1, mco); }\n    if (mid1 < end1) { this.computeOverlapsInternal(mid0, end0, mc, mid1, end1, mco); }\n  }\n};\nMonotoneChain.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChain.prototype.getClass = function getClass () {\n  return MonotoneChain\n};\n\nvar MonotoneChainBuilder = function MonotoneChainBuilder () {};\n\nMonotoneChainBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainBuilder.prototype.getClass = function getClass () {\n  return MonotoneChainBuilder\n};\nMonotoneChainBuilder.getChainStartIndices = function getChainStartIndices (pts) {\n  var start = 0;\n  var startIndexList = new ArrayList();\n  startIndexList.add(new Integer(start));\n  do {\n    var last = MonotoneChainBuilder.findChainEnd(pts, start);\n    startIndexList.add(new Integer(last));\n    start = last;\n  } while (start < pts.length - 1)\n  var startIndex = MonotoneChainBuilder.toIntArray(startIndexList);\n  return startIndex\n};\nMonotoneChainBuilder.findChainEnd = function findChainEnd (pts, start) {\n  var safeStart = start;\n  while (safeStart < pts.length - 1 && pts[safeStart].equals2D(pts[safeStart + 1])) {\n    safeStart++;\n  }\n  if (safeStart >= pts.length - 1) {\n    return pts.length - 1\n  }\n  var chainQuad = Quadrant.quadrant(pts[safeStart], pts[safeStart + 1]);\n  var last = start + 1;\n  while (last < pts.length) {\n    if (!pts[last - 1].equals2D(pts[last])) {\n      var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n      if (quad !== chainQuad) { break }\n    }\n    last++;\n  }\n  return last - 1\n};\nMonotoneChainBuilder.getChains = function getChains () {\n  if (arguments.length === 1) {\n    var pts = arguments[0];\n    return MonotoneChainBuilder.getChains(pts, null)\n  } else if (arguments.length === 2) {\n    var pts$1 = arguments[0];\n    var context = arguments[1];\n    var mcList = new ArrayList();\n    var startIndex = MonotoneChainBuilder.getChainStartIndices(pts$1);\n    for (var i = 0; i < startIndex.length - 1; i++) {\n      var mc = new MonotoneChain(pts$1, startIndex[i], startIndex[i + 1], context);\n      mcList.add(mc);\n    }\n    return mcList\n  }\n};\nMonotoneChainBuilder.toIntArray = function toIntArray (list) {\n  var array = new Array(list.size()).fill(null);\n  for (var i = 0; i < array.length; i++) {\n    array[i] = list.get(i).intValue();\n  }\n  return array\n};\n\nvar Noder = function Noder () {};\n\nNoder.prototype.computeNodes = function computeNodes (segStrings) {};\nNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {};\nNoder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNoder.prototype.getClass = function getClass () {\n  return Noder\n};\n\nvar SinglePassNoder = function SinglePassNoder () {\n  this._segInt = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var segInt = arguments[0];\n    this.setSegmentIntersector(segInt);\n  }\n};\nSinglePassNoder.prototype.setSegmentIntersector = function setSegmentIntersector (segInt) {\n  this._segInt = segInt;\n};\nSinglePassNoder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nSinglePassNoder.prototype.getClass = function getClass () {\n  return SinglePassNoder\n};\n\nvar MCIndexNoder = (function (SinglePassNoder$$1) {\n  function MCIndexNoder (si) {\n    if (si) { SinglePassNoder$$1.call(this, si); }\n    else { SinglePassNoder$$1.call(this); }\n    this._monoChains = new ArrayList();\n    this._index = new STRtree();\n    this._idCounter = 0;\n    this._nodedSegStrings = null;\n    this._nOverlaps = 0;\n  }\n\n  if ( SinglePassNoder$$1 ) MCIndexNoder.__proto__ = SinglePassNoder$$1;\n  MCIndexNoder.prototype = Object.create( SinglePassNoder$$1 && SinglePassNoder$$1.prototype );\n  MCIndexNoder.prototype.constructor = MCIndexNoder;\n\n  var staticAccessors = { SegmentOverlapAction: { configurable: true } };\n  MCIndexNoder.prototype.getMonotoneChains = function getMonotoneChains () {\n    return this._monoChains\n  };\n  MCIndexNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n    return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n  };\n  MCIndexNoder.prototype.getIndex = function getIndex () {\n    return this._index\n  };\n  MCIndexNoder.prototype.add = function add (segStr) {\n    var this$1 = this;\n\n    var segChains = MonotoneChainBuilder.getChains(segStr.getCoordinates(), segStr);\n    for (var i = segChains.iterator(); i.hasNext();) {\n      var mc = i.next();\n      mc.setId(this$1._idCounter++);\n      this$1._index.insert(mc.getEnvelope(), mc);\n      this$1._monoChains.add(mc);\n    }\n  };\n  MCIndexNoder.prototype.computeNodes = function computeNodes (inputSegStrings) {\n    var this$1 = this;\n\n    this._nodedSegStrings = inputSegStrings;\n    for (var i = inputSegStrings.iterator(); i.hasNext();) {\n      this$1.add(i.next());\n    }\n    this.intersectChains();\n  };\n  MCIndexNoder.prototype.intersectChains = function intersectChains () {\n    var this$1 = this;\n\n    var overlapAction = new SegmentOverlapAction(this._segInt);\n    for (var i = this._monoChains.iterator(); i.hasNext();) {\n      var queryChain = i.next();\n      var overlapChains = this$1._index.query(queryChain.getEnvelope());\n      for (var j = overlapChains.iterator(); j.hasNext();) {\n        var testChain = j.next();\n        if (testChain.getId() > queryChain.getId()) {\n          queryChain.computeOverlaps(testChain, overlapAction);\n          this$1._nOverlaps++;\n        }\n        if (this$1._segInt.isDone()) { return null }\n      }\n    }\n  };\n  MCIndexNoder.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  MCIndexNoder.prototype.getClass = function getClass () {\n    return MCIndexNoder\n  };\n  staticAccessors.SegmentOverlapAction.get = function () { return SegmentOverlapAction };\n\n  Object.defineProperties( MCIndexNoder, staticAccessors );\n\n  return MCIndexNoder;\n}(SinglePassNoder));\n\nvar SegmentOverlapAction = (function (MonotoneChainOverlapAction$$1) {\n  function SegmentOverlapAction () {\n    MonotoneChainOverlapAction$$1.call(this);\n    this._si = null;\n    var si = arguments[0];\n    this._si = si;\n  }\n\n  if ( MonotoneChainOverlapAction$$1 ) SegmentOverlapAction.__proto__ = MonotoneChainOverlapAction$$1;\n  SegmentOverlapAction.prototype = Object.create( MonotoneChainOverlapAction$$1 && MonotoneChainOverlapAction$$1.prototype );\n  SegmentOverlapAction.prototype.constructor = SegmentOverlapAction;\n  SegmentOverlapAction.prototype.overlap = function overlap () {\n    if (arguments.length === 4) {\n      var mc1 = arguments[0];\n      var start1 = arguments[1];\n      var mc2 = arguments[2];\n      var start2 = arguments[3];\n      var ss1 = mc1.getContext();\n      var ss2 = mc2.getContext();\n      this._si.processIntersections(ss1, start1, ss2, start2);\n    } else { return MonotoneChainOverlapAction$$1.prototype.overlap.apply(this, arguments) }\n  };\n  SegmentOverlapAction.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SegmentOverlapAction.prototype.getClass = function getClass () {\n    return SegmentOverlapAction\n  };\n\n  return SegmentOverlapAction;\n}(MonotoneChainOverlapAction));\n\nvar BufferParameters = function BufferParameters () {\n  this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  this._endCapStyle = BufferParameters.CAP_ROUND;\n  this._joinStyle = BufferParameters.JOIN_ROUND;\n  this._mitreLimit = BufferParameters.DEFAULT_MITRE_LIMIT;\n  this._isSingleSided = false;\n  this._simplifyFactor = BufferParameters.DEFAULT_SIMPLIFY_FACTOR;\n\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var quadrantSegments = arguments[0];\n    this.setQuadrantSegments(quadrantSegments);\n  } else if (arguments.length === 2) {\n    var quadrantSegments$1 = arguments[0];\n    var endCapStyle = arguments[1];\n    this.setQuadrantSegments(quadrantSegments$1);\n    this.setEndCapStyle(endCapStyle);\n  } else if (arguments.length === 4) {\n    var quadrantSegments$2 = arguments[0];\n    var endCapStyle$1 = arguments[1];\n    var joinStyle = arguments[2];\n    var mitreLimit = arguments[3];\n    this.setQuadrantSegments(quadrantSegments$2);\n    this.setEndCapStyle(endCapStyle$1);\n    this.setJoinStyle(joinStyle);\n    this.setMitreLimit(mitreLimit);\n  }\n};\n\nvar staticAccessors$25 = { CAP_ROUND: { configurable: true },CAP_FLAT: { configurable: true },CAP_SQUARE: { configurable: true },JOIN_ROUND: { configurable: true },JOIN_MITRE: { configurable: true },JOIN_BEVEL: { configurable: true },DEFAULT_QUADRANT_SEGMENTS: { configurable: true },DEFAULT_MITRE_LIMIT: { configurable: true },DEFAULT_SIMPLIFY_FACTOR: { configurable: true } };\nBufferParameters.prototype.getEndCapStyle = function getEndCapStyle () {\n  return this._endCapStyle\n};\nBufferParameters.prototype.isSingleSided = function isSingleSided () {\n  return this._isSingleSided\n};\nBufferParameters.prototype.setQuadrantSegments = function setQuadrantSegments (quadSegs) {\n  this._quadrantSegments = quadSegs;\n  if (this._quadrantSegments === 0) { this._joinStyle = BufferParameters.JOIN_BEVEL; }\n  if (this._quadrantSegments < 0) {\n    this._joinStyle = BufferParameters.JOIN_MITRE;\n    this._mitreLimit = Math.abs(this._quadrantSegments);\n  }\n  if (quadSegs <= 0) {\n    this._quadrantSegments = 1;\n  }\n  if (this._joinStyle !== BufferParameters.JOIN_ROUND) {\n    this._quadrantSegments = BufferParameters.DEFAULT_QUADRANT_SEGMENTS;\n  }\n};\nBufferParameters.prototype.getJoinStyle = function getJoinStyle () {\n  return this._joinStyle\n};\nBufferParameters.prototype.setJoinStyle = function setJoinStyle (joinStyle) {\n  this._joinStyle = joinStyle;\n};\nBufferParameters.prototype.setSimplifyFactor = function setSimplifyFactor (simplifyFactor) {\n  this._simplifyFactor = simplifyFactor < 0 ? 0 : simplifyFactor;\n};\nBufferParameters.prototype.getSimplifyFactor = function getSimplifyFactor () {\n  return this._simplifyFactor\n};\nBufferParameters.prototype.getQuadrantSegments = function getQuadrantSegments () {\n  return this._quadrantSegments\n};\nBufferParameters.prototype.setEndCapStyle = function setEndCapStyle (endCapStyle) {\n  this._endCapStyle = endCapStyle;\n};\nBufferParameters.prototype.getMitreLimit = function getMitreLimit () {\n  return this._mitreLimit\n};\nBufferParameters.prototype.setMitreLimit = function setMitreLimit (mitreLimit) {\n  this._mitreLimit = mitreLimit;\n};\nBufferParameters.prototype.setSingleSided = function setSingleSided (isSingleSided) {\n  this._isSingleSided = isSingleSided;\n};\nBufferParameters.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferParameters.prototype.getClass = function getClass () {\n  return BufferParameters\n};\nBufferParameters.bufferDistanceError = function bufferDistanceError (quadSegs) {\n  var alpha = Math.PI / 2.0 / quadSegs;\n  return 1 - Math.cos(alpha / 2.0)\n};\nstaticAccessors$25.CAP_ROUND.get = function () { return 1 };\nstaticAccessors$25.CAP_FLAT.get = function () { return 2 };\nstaticAccessors$25.CAP_SQUARE.get = function () { return 3 };\nstaticAccessors$25.JOIN_ROUND.get = function () { return 1 };\nstaticAccessors$25.JOIN_MITRE.get = function () { return 2 };\nstaticAccessors$25.JOIN_BEVEL.get = function () { return 3 };\nstaticAccessors$25.DEFAULT_QUADRANT_SEGMENTS.get = function () { return 8 };\nstaticAccessors$25.DEFAULT_MITRE_LIMIT.get = function () { return 5.0 };\nstaticAccessors$25.DEFAULT_SIMPLIFY_FACTOR.get = function () { return 0.01 };\n\nObject.defineProperties( BufferParameters, staticAccessors$25 );\n\nvar BufferInputLineSimplifier = function BufferInputLineSimplifier (inputLine) {\n  this._distanceTol = null;\n  this._isDeleted = null;\n  this._angleOrientation = CGAlgorithms.COUNTERCLOCKWISE;\n  this._inputLine = inputLine || null;\n};\n\nvar staticAccessors$26 = { INIT: { configurable: true },DELETE: { configurable: true },KEEP: { configurable: true },NUM_PTS_TO_CHECK: { configurable: true } };\nBufferInputLineSimplifier.prototype.isDeletable = function isDeletable (i0, i1, i2, distanceTol) {\n  var p0 = this._inputLine[i0];\n  var p1 = this._inputLine[i1];\n  var p2 = this._inputLine[i2];\n  if (!this.isConcave(p0, p1, p2)) { return false }\n  if (!this.isShallow(p0, p1, p2, distanceTol)) { return false }\n  return this.isShallowSampled(p0, p1, i0, i2, distanceTol)\n};\nBufferInputLineSimplifier.prototype.deleteShallowConcavities = function deleteShallowConcavities () {\n    var this$1 = this;\n\n  var index = 1;\n  // const maxIndex = this._inputLine.length - 1\n  var midIndex = this.findNextNonDeletedIndex(index);\n  var lastIndex = this.findNextNonDeletedIndex(midIndex);\n  var isChanged = false;\n  while (lastIndex < this._inputLine.length) {\n    var isMiddleVertexDeleted = false;\n    if (this$1.isDeletable(index, midIndex, lastIndex, this$1._distanceTol)) {\n      this$1._isDeleted[midIndex] = BufferInputLineSimplifier.DELETE;\n      isMiddleVertexDeleted = true;\n      isChanged = true;\n    }\n    if (isMiddleVertexDeleted) { index = lastIndex; } else { index = midIndex; }\n    midIndex = this$1.findNextNonDeletedIndex(index);\n    lastIndex = this$1.findNextNonDeletedIndex(midIndex);\n  }\n  return isChanged\n};\nBufferInputLineSimplifier.prototype.isShallowConcavity = function isShallowConcavity (p0, p1, p2, distanceTol) {\n  var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  var isAngleToSimplify = orientation === this._angleOrientation;\n  if (!isAngleToSimplify) { return false }\n  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  return dist < distanceTol\n};\nBufferInputLineSimplifier.prototype.isShallowSampled = function isShallowSampled (p0, p2, i0, i2, distanceTol) {\n    var this$1 = this;\n\n  var inc = Math.trunc((i2 - i0) / BufferInputLineSimplifier.NUM_PTS_TO_CHECK);\n  if (inc <= 0) { inc = 1; }\n  for (var i = i0; i < i2; i += inc) {\n    if (!this$1.isShallow(p0, p2, this$1._inputLine[i], distanceTol)) { return false }\n  }\n  return true\n};\nBufferInputLineSimplifier.prototype.isConcave = function isConcave (p0, p1, p2) {\n  var orientation = CGAlgorithms.computeOrientation(p0, p1, p2);\n  var isConcave = orientation === this._angleOrientation;\n  return isConcave\n};\nBufferInputLineSimplifier.prototype.simplify = function simplify (distanceTol) {\n    var this$1 = this;\n\n  this._distanceTol = Math.abs(distanceTol);\n  if (distanceTol < 0) { this._angleOrientation = CGAlgorithms.CLOCKWISE; }\n  this._isDeleted = new Array(this._inputLine.length).fill(null);\n  var isChanged = false;\n  do {\n    isChanged = this$1.deleteShallowConcavities();\n  } while (isChanged)\n  return this.collapseLine()\n};\nBufferInputLineSimplifier.prototype.findNextNonDeletedIndex = function findNextNonDeletedIndex (index) {\n  var next = index + 1;\n  while (next < this._inputLine.length && this._isDeleted[next] === BufferInputLineSimplifier.DELETE) { next++; }\n  return next\n};\nBufferInputLineSimplifier.prototype.isShallow = function isShallow (p0, p1, p2, distanceTol) {\n  var dist = CGAlgorithms.distancePointLine(p1, p0, p2);\n  return dist < distanceTol\n};\nBufferInputLineSimplifier.prototype.collapseLine = function collapseLine () {\n    var this$1 = this;\n\n  var coordList = new CoordinateList();\n  for (var i = 0; i < this._inputLine.length; i++) {\n    if (this$1._isDeleted[i] !== BufferInputLineSimplifier.DELETE) { coordList.add(this$1._inputLine[i]); }\n  }\n  return coordList.toCoordinateArray()\n};\nBufferInputLineSimplifier.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferInputLineSimplifier.prototype.getClass = function getClass () {\n  return BufferInputLineSimplifier\n};\nBufferInputLineSimplifier.simplify = function simplify (inputLine, distanceTol) {\n  var simp = new BufferInputLineSimplifier(inputLine);\n  return simp.simplify(distanceTol)\n};\nstaticAccessors$26.INIT.get = function () { return 0 };\nstaticAccessors$26.DELETE.get = function () { return 1 };\nstaticAccessors$26.KEEP.get = function () { return 1 };\nstaticAccessors$26.NUM_PTS_TO_CHECK.get = function () { return 10 };\n\nObject.defineProperties( BufferInputLineSimplifier, staticAccessors$26 );\n\nvar OffsetSegmentString = function OffsetSegmentString () {\n  this._ptList = null;\n  this._precisionModel = null;\n  this._minimimVertexDistance = 0.0;\n  this._ptList = new ArrayList();\n};\n\nvar staticAccessors$28 = { COORDINATE_ARRAY_TYPE: { configurable: true } };\nOffsetSegmentString.prototype.getCoordinates = function getCoordinates () {\n  var coord = this._ptList.toArray(OffsetSegmentString.COORDINATE_ARRAY_TYPE);\n  return coord\n};\nOffsetSegmentString.prototype.setPrecisionModel = function setPrecisionModel (precisionModel) {\n  this._precisionModel = precisionModel;\n};\nOffsetSegmentString.prototype.addPt = function addPt (pt) {\n  var bufPt = new Coordinate(pt);\n  this._precisionModel.makePrecise(bufPt);\n  if (this.isRedundant(bufPt)) { return null }\n  this._ptList.add(bufPt);\n};\nOffsetSegmentString.prototype.revere = function revere () {};\nOffsetSegmentString.prototype.addPts = function addPts (pt, isForward) {\n    var this$1 = this;\n\n  if (isForward) {\n    for (var i = 0; i < pt.length; i++) {\n      this$1.addPt(pt[i]);\n    }\n  } else {\n    for (var i$1 = pt.length - 1; i$1 >= 0; i$1--) {\n      this$1.addPt(pt[i$1]);\n    }\n  }\n};\nOffsetSegmentString.prototype.isRedundant = function isRedundant (pt) {\n  if (this._ptList.size() < 1) { return false }\n  var lastPt = this._ptList.get(this._ptList.size() - 1);\n  var ptDist = pt.distance(lastPt);\n  if (ptDist < this._minimimVertexDistance) { return true }\n  return false\n};\nOffsetSegmentString.prototype.toString = function toString () {\n  var fact = new GeometryFactory();\n  var line = fact.createLineString(this.getCoordinates());\n  return line.toString()\n};\nOffsetSegmentString.prototype.closeRing = function closeRing () {\n  if (this._ptList.size() < 1) { return null }\n  var startPt = new Coordinate(this._ptList.get(0));\n  var lastPt = this._ptList.get(this._ptList.size() - 1);\n  // const last2Pt = null\n  // if (this._ptList.size() >= 2) last2Pt = this._ptList.get(this._ptList.size() - 2)\n  if (startPt.equals(lastPt)) { return null }\n  this._ptList.add(startPt);\n};\nOffsetSegmentString.prototype.setMinimumVertexDistance = function setMinimumVertexDistance (minimimVertexDistance) {\n  this._minimimVertexDistance = minimimVertexDistance;\n};\nOffsetSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetSegmentString.prototype.getClass = function getClass () {\n  return OffsetSegmentString\n};\nstaticAccessors$28.COORDINATE_ARRAY_TYPE.get = function () { return new Array(0).fill(null) };\n\nObject.defineProperties( OffsetSegmentString, staticAccessors$28 );\n\nvar Angle = function Angle () {};\n\nvar staticAccessors$29 = { PI_TIMES_2: { configurable: true },PI_OVER_2: { configurable: true },PI_OVER_4: { configurable: true },COUNTERCLOCKWISE: { configurable: true },CLOCKWISE: { configurable: true },NONE: { configurable: true } };\n\nAngle.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nAngle.prototype.getClass = function getClass () {\n  return Angle\n};\nAngle.toDegrees = function toDegrees (radians) {\n  return radians * 180 / Math.PI\n};\nAngle.normalize = function normalize (angle) {\n  while (angle > Math.PI) { angle -= Angle.PI_TIMES_2; }\n  while (angle <= -Math.PI) { angle += Angle.PI_TIMES_2; }\n  return angle\n};\nAngle.angle = function angle () {\n  if (arguments.length === 1) {\n    var p = arguments[0];\n    return Math.atan2(p.y, p.x)\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    var dx = p1.x - p0.x;\n    var dy = p1.y - p0.y;\n    return Math.atan2(dy, dx)\n  }\n};\nAngle.isAcute = function isAcute (p0, p1, p2) {\n  var dx0 = p0.x - p1.x;\n  var dy0 = p0.y - p1.y;\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dotprod = dx0 * dx1 + dy0 * dy1;\n  return dotprod > 0\n};\nAngle.isObtuse = function isObtuse (p0, p1, p2) {\n  var dx0 = p0.x - p1.x;\n  var dy0 = p0.y - p1.y;\n  var dx1 = p2.x - p1.x;\n  var dy1 = p2.y - p1.y;\n  var dotprod = dx0 * dx1 + dy0 * dy1;\n  return dotprod < 0\n};\nAngle.interiorAngle = function interiorAngle (p0, p1, p2) {\n  var anglePrev = Angle.angle(p1, p0);\n  var angleNext = Angle.angle(p1, p2);\n  return Math.abs(angleNext - anglePrev)\n};\nAngle.normalizePositive = function normalizePositive (angle) {\n  if (angle < 0.0) {\n    while (angle < 0.0) { angle += Angle.PI_TIMES_2; }\n    if (angle >= Angle.PI_TIMES_2) { angle = 0.0; }\n  } else {\n    while (angle >= Angle.PI_TIMES_2) { angle -= Angle.PI_TIMES_2; }\n    if (angle < 0.0) { angle = 0.0; }\n  }\n  return angle\n};\nAngle.angleBetween = function angleBetween (tip1, tail, tip2) {\n  var a1 = Angle.angle(tail, tip1);\n  var a2 = Angle.angle(tail, tip2);\n  return Angle.diff(a1, a2)\n};\nAngle.diff = function diff (ang1, ang2) {\n  var delAngle = null;\n  if (ang1 < ang2) {\n    delAngle = ang2 - ang1;\n  } else {\n    delAngle = ang1 - ang2;\n  }\n  if (delAngle > Math.PI) {\n    delAngle = 2 * Math.PI - delAngle;\n  }\n  return delAngle\n};\nAngle.toRadians = function toRadians (angleDegrees) {\n  return angleDegrees * Math.PI / 180.0\n};\nAngle.getTurn = function getTurn (ang1, ang2) {\n  var crossproduct = Math.sin(ang2 - ang1);\n  if (crossproduct > 0) {\n    return Angle.COUNTERCLOCKWISE\n  }\n  if (crossproduct < 0) {\n    return Angle.CLOCKWISE\n  }\n  return Angle.NONE\n};\nAngle.angleBetweenOriented = function angleBetweenOriented (tip1, tail, tip2) {\n  var a1 = Angle.angle(tail, tip1);\n  var a2 = Angle.angle(tail, tip2);\n  var angDel = a2 - a1;\n  if (angDel <= -Math.PI) { return angDel + Angle.PI_TIMES_2 }\n  if (angDel > Math.PI) { return angDel - Angle.PI_TIMES_2 }\n  return angDel\n};\nstaticAccessors$29.PI_TIMES_2.get = function () { return 2.0 * Math.PI };\nstaticAccessors$29.PI_OVER_2.get = function () { return Math.PI / 2.0 };\nstaticAccessors$29.PI_OVER_4.get = function () { return Math.PI / 4.0 };\nstaticAccessors$29.COUNTERCLOCKWISE.get = function () { return CGAlgorithms.COUNTERCLOCKWISE };\nstaticAccessors$29.CLOCKWISE.get = function () { return CGAlgorithms.CLOCKWISE };\nstaticAccessors$29.NONE.get = function () { return CGAlgorithms.COLLINEAR };\n\nObject.defineProperties( Angle, staticAccessors$29 );\n\nvar OffsetSegmentGenerator = function OffsetSegmentGenerator () {\n  this._maxCurveSegmentError = 0.0;\n  this._filletAngleQuantum = null;\n  this._closingSegLengthFactor = 1;\n  this._segList = null;\n  this._distance = 0.0;\n  this._precisionModel = null;\n  this._bufParams = null;\n  this._li = null;\n  this._s0 = null;\n  this._s1 = null;\n  this._s2 = null;\n  this._seg0 = new LineSegment();\n  this._seg1 = new LineSegment();\n  this._offset0 = new LineSegment();\n  this._offset1 = new LineSegment();\n  this._side = 0;\n  this._hasNarrowConcaveAngle = false;\n  var precisionModel = arguments[0];\n  var bufParams = arguments[1];\n  var distance = arguments[2];\n  this._precisionModel = precisionModel;\n  this._bufParams = bufParams;\n  this._li = new RobustLineIntersector();\n  this._filletAngleQuantum = Math.PI / 2.0 / bufParams.getQuadrantSegments();\n  if (bufParams.getQuadrantSegments() >= 8 && bufParams.getJoinStyle() === BufferParameters.JOIN_ROUND) { this._closingSegLengthFactor = OffsetSegmentGenerator.MAX_CLOSING_SEG_LEN_FACTOR; }\n  this.init(distance);\n};\n\nvar staticAccessors$27 = { OFFSET_SEGMENT_SEPARATION_FACTOR: { configurable: true },INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true },CURVE_VERTEX_SNAP_DISTANCE_FACTOR: { configurable: true },MAX_CLOSING_SEG_LEN_FACTOR: { configurable: true } };\nOffsetSegmentGenerator.prototype.addNextSegment = function addNextSegment (p, addStartPoint) {\n  this._s0 = this._s1;\n  this._s1 = this._s2;\n  this._s2 = p;\n  this._seg0.setCoordinates(this._s0, this._s1);\n  this.computeOffsetSegment(this._seg0, this._side, this._distance, this._offset0);\n  this._seg1.setCoordinates(this._s1, this._s2);\n  this.computeOffsetSegment(this._seg1, this._side, this._distance, this._offset1);\n  if (this._s1.equals(this._s2)) { return null }\n  var orientation = CGAlgorithms.computeOrientation(this._s0, this._s1, this._s2);\n  var outsideTurn = (orientation === CGAlgorithms.CLOCKWISE && this._side === Position.LEFT) || (orientation === CGAlgorithms.COUNTERCLOCKWISE && this._side === Position.RIGHT);\n  if (orientation === 0) {\n    this.addCollinear(addStartPoint);\n  } else if (outsideTurn) {\n    this.addOutsideTurn(orientation, addStartPoint);\n  } else {\n    this.addInsideTurn(orientation, addStartPoint);\n  }\n};\nOffsetSegmentGenerator.prototype.addLineEndCap = function addLineEndCap (p0, p1) {\n  var seg = new LineSegment(p0, p1);\n  var offsetL = new LineSegment();\n  this.computeOffsetSegment(seg, Position.LEFT, this._distance, offsetL);\n  var offsetR = new LineSegment();\n  this.computeOffsetSegment(seg, Position.RIGHT, this._distance, offsetR);\n  var dx = p1.x - p0.x;\n  var dy = p1.y - p0.y;\n  var angle = Math.atan2(dy, dx);\n  switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      this._segList.addPt(offsetL.p1);\n      this.addFilletArc(p1, angle + Math.PI / 2, angle - Math.PI / 2, CGAlgorithms.CLOCKWISE, this._distance);\n      this._segList.addPt(offsetR.p1);\n      break\n    case BufferParameters.CAP_FLAT:\n      this._segList.addPt(offsetL.p1);\n      this._segList.addPt(offsetR.p1);\n      break\n    case BufferParameters.CAP_SQUARE:\n      var squareCapSideOffset = new Coordinate();\n      squareCapSideOffset.x = Math.abs(this._distance) * Math.cos(angle);\n      squareCapSideOffset.y = Math.abs(this._distance) * Math.sin(angle);\n      var squareCapLOffset = new Coordinate(offsetL.p1.x + squareCapSideOffset.x, offsetL.p1.y + squareCapSideOffset.y);\n      var squareCapROffset = new Coordinate(offsetR.p1.x + squareCapSideOffset.x, offsetR.p1.y + squareCapSideOffset.y);\n      this._segList.addPt(squareCapLOffset);\n      this._segList.addPt(squareCapROffset);\n      break\n    default:\n  }\n};\nOffsetSegmentGenerator.prototype.getCoordinates = function getCoordinates () {\n  var pts = this._segList.getCoordinates();\n  return pts\n};\nOffsetSegmentGenerator.prototype.addMitreJoin = function addMitreJoin (p, offset0, offset1, distance) {\n  var isMitreWithinLimit = true;\n  var intPt = null;\n  try {\n    intPt = HCoordinate.intersection(offset0.p0, offset0.p1, offset1.p0, offset1.p1);\n    var mitreRatio = distance <= 0.0 ? 1.0 : intPt.distance(p) / Math.abs(distance);\n    if (mitreRatio > this._bufParams.getMitreLimit()) { isMitreWithinLimit = false; }\n  } catch (ex) {\n    if (ex instanceof NotRepresentableException) {\n      intPt = new Coordinate(0, 0);\n      isMitreWithinLimit = false;\n    } else { throw ex }\n  } finally {}\n  if (isMitreWithinLimit) {\n    this._segList.addPt(intPt);\n  } else {\n    this.addLimitedMitreJoin(offset0, offset1, distance, this._bufParams.getMitreLimit());\n  }\n};\nOffsetSegmentGenerator.prototype.addFilletCorner = function addFilletCorner (p, p0, p1, direction, radius) {\n  var dx0 = p0.x - p.x;\n  var dy0 = p0.y - p.y;\n  var startAngle = Math.atan2(dy0, dx0);\n  var dx1 = p1.x - p.x;\n  var dy1 = p1.y - p.y;\n  var endAngle = Math.atan2(dy1, dx1);\n  if (direction === CGAlgorithms.CLOCKWISE) {\n    if (startAngle <= endAngle) { startAngle += 2.0 * Math.PI; }\n  } else {\n    if (startAngle >= endAngle) { startAngle -= 2.0 * Math.PI; }\n  }\n  this._segList.addPt(p0);\n  this.addFilletArc(p, startAngle, endAngle, direction, radius);\n  this._segList.addPt(p1);\n};\nOffsetSegmentGenerator.prototype.addOutsideTurn = function addOutsideTurn (orientation, addStartPoint) {\n  if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.OFFSET_SEGMENT_SEPARATION_FACTOR) {\n    this._segList.addPt(this._offset0.p1);\n    return null\n  }\n  if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n    this.addMitreJoin(this._s1, this._offset0, this._offset1, this._distance);\n  } else if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL) {\n    this.addBevelJoin(this._offset0, this._offset1);\n  } else {\n    if (addStartPoint) { this._segList.addPt(this._offset0.p1); }\n    this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, orientation, this._distance);\n    this._segList.addPt(this._offset1.p0);\n  }\n};\nOffsetSegmentGenerator.prototype.createSquare = function createSquare (p) {\n  this._segList.addPt(new Coordinate(p.x + this._distance, p.y + this._distance));\n  this._segList.addPt(new Coordinate(p.x + this._distance, p.y - this._distance));\n  this._segList.addPt(new Coordinate(p.x - this._distance, p.y - this._distance));\n  this._segList.addPt(new Coordinate(p.x - this._distance, p.y + this._distance));\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.addSegments = function addSegments (pt, isForward) {\n  this._segList.addPts(pt, isForward);\n};\nOffsetSegmentGenerator.prototype.addFirstSegment = function addFirstSegment () {\n  this._segList.addPt(this._offset1.p0);\n};\nOffsetSegmentGenerator.prototype.addLastSegment = function addLastSegment () {\n  this._segList.addPt(this._offset1.p1);\n};\nOffsetSegmentGenerator.prototype.initSideSegments = function initSideSegments (s1, s2, side) {\n  this._s1 = s1;\n  this._s2 = s2;\n  this._side = side;\n  this._seg1.setCoordinates(s1, s2);\n  this.computeOffsetSegment(this._seg1, side, this._distance, this._offset1);\n};\nOffsetSegmentGenerator.prototype.addLimitedMitreJoin = function addLimitedMitreJoin (offset0, offset1, distance, mitreLimit) {\n  var basePt = this._seg0.p1;\n  var ang0 = Angle.angle(basePt, this._seg0.p0);\n  // const ang1 = Angle.angle(basePt, this._seg1.p1)\n  var angDiff = Angle.angleBetweenOriented(this._seg0.p0, basePt, this._seg1.p1);\n  var angDiffHalf = angDiff / 2;\n  var midAng = Angle.normalize(ang0 + angDiffHalf);\n  var mitreMidAng = Angle.normalize(midAng + Math.PI);\n  var mitreDist = mitreLimit * distance;\n  var bevelDelta = mitreDist * Math.abs(Math.sin(angDiffHalf));\n  var bevelHalfLen = distance - bevelDelta;\n  var bevelMidX = basePt.x + mitreDist * Math.cos(mitreMidAng);\n  var bevelMidY = basePt.y + mitreDist * Math.sin(mitreMidAng);\n  var bevelMidPt = new Coordinate(bevelMidX, bevelMidY);\n  var mitreMidLine = new LineSegment(basePt, bevelMidPt);\n  var bevelEndLeft = mitreMidLine.pointAlongOffset(1.0, bevelHalfLen);\n  var bevelEndRight = mitreMidLine.pointAlongOffset(1.0, -bevelHalfLen);\n  if (this._side === Position.LEFT) {\n    this._segList.addPt(bevelEndLeft);\n    this._segList.addPt(bevelEndRight);\n  } else {\n    this._segList.addPt(bevelEndRight);\n    this._segList.addPt(bevelEndLeft);\n  }\n};\nOffsetSegmentGenerator.prototype.computeOffsetSegment = function computeOffsetSegment (seg, side, distance, offset) {\n  var sideSign = side === Position.LEFT ? 1 : -1;\n  var dx = seg.p1.x - seg.p0.x;\n  var dy = seg.p1.y - seg.p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = sideSign * distance * dx / len;\n  var uy = sideSign * distance * dy / len;\n  offset.p0.x = seg.p0.x - uy;\n  offset.p0.y = seg.p0.y + ux;\n  offset.p1.x = seg.p1.x - uy;\n  offset.p1.y = seg.p1.y + ux;\n};\nOffsetSegmentGenerator.prototype.addFilletArc = function addFilletArc (p, startAngle, endAngle, direction, radius) {\n    var this$1 = this;\n\n  var directionFactor = direction === CGAlgorithms.CLOCKWISE ? -1 : 1;\n  var totalAngle = Math.abs(startAngle - endAngle);\n  var nSegs = Math.trunc(totalAngle / this._filletAngleQuantum + 0.5);\n  if (nSegs < 1) { return null }\n  var initAngle = 0.0;\n  var currAngleInc = totalAngle / nSegs;\n  var currAngle = initAngle;\n  var pt = new Coordinate();\n  while (currAngle < totalAngle) {\n    var angle = startAngle + directionFactor * currAngle;\n    pt.x = p.x + radius * Math.cos(angle);\n    pt.y = p.y + radius * Math.sin(angle);\n    this$1._segList.addPt(pt);\n    currAngle += currAngleInc;\n  }\n};\nOffsetSegmentGenerator.prototype.addInsideTurn = function addInsideTurn (orientation, addStartPoint) {\n  this._li.computeIntersection(this._offset0.p0, this._offset0.p1, this._offset1.p0, this._offset1.p1);\n  if (this._li.hasIntersection()) {\n    this._segList.addPt(this._li.getIntersection(0));\n  } else {\n    this._hasNarrowConcaveAngle = true;\n    if (this._offset0.p1.distance(this._offset1.p0) < this._distance * OffsetSegmentGenerator.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR) {\n      this._segList.addPt(this._offset0.p1);\n    } else {\n      this._segList.addPt(this._offset0.p1);\n      if (this._closingSegLengthFactor > 0) {\n        var mid0 = new Coordinate((this._closingSegLengthFactor * this._offset0.p1.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset0.p1.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n        this._segList.addPt(mid0);\n        var mid1 = new Coordinate((this._closingSegLengthFactor * this._offset1.p0.x + this._s1.x) / (this._closingSegLengthFactor + 1), (this._closingSegLengthFactor * this._offset1.p0.y + this._s1.y) / (this._closingSegLengthFactor + 1));\n        this._segList.addPt(mid1);\n      } else {\n        this._segList.addPt(this._s1);\n      }\n      this._segList.addPt(this._offset1.p0);\n    }\n  }\n};\nOffsetSegmentGenerator.prototype.createCircle = function createCircle (p) {\n  var pt = new Coordinate(p.x + this._distance, p.y);\n  this._segList.addPt(pt);\n  this.addFilletArc(p, 0.0, 2.0 * Math.PI, -1, this._distance);\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.addBevelJoin = function addBevelJoin (offset0, offset1) {\n  this._segList.addPt(offset0.p1);\n  this._segList.addPt(offset1.p0);\n};\nOffsetSegmentGenerator.prototype.init = function init (distance) {\n  this._distance = distance;\n  this._maxCurveSegmentError = distance * (1 - Math.cos(this._filletAngleQuantum / 2.0));\n  this._segList = new OffsetSegmentString();\n  this._segList.setPrecisionModel(this._precisionModel);\n  this._segList.setMinimumVertexDistance(distance * OffsetSegmentGenerator.CURVE_VERTEX_SNAP_DISTANCE_FACTOR);\n};\nOffsetSegmentGenerator.prototype.addCollinear = function addCollinear (addStartPoint) {\n  this._li.computeIntersection(this._s0, this._s1, this._s1, this._s2);\n  var numInt = this._li.getIntersectionNum();\n  if (numInt >= 2) {\n    if (this._bufParams.getJoinStyle() === BufferParameters.JOIN_BEVEL || this._bufParams.getJoinStyle() === BufferParameters.JOIN_MITRE) {\n      if (addStartPoint) { this._segList.addPt(this._offset0.p1); }\n      this._segList.addPt(this._offset1.p0);\n    } else {\n      this.addFilletCorner(this._s1, this._offset0.p1, this._offset1.p0, CGAlgorithms.CLOCKWISE, this._distance);\n    }\n  }\n};\nOffsetSegmentGenerator.prototype.closeRing = function closeRing () {\n  this._segList.closeRing();\n};\nOffsetSegmentGenerator.prototype.hasNarrowConcaveAngle = function hasNarrowConcaveAngle () {\n  return this._hasNarrowConcaveAngle\n};\nOffsetSegmentGenerator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetSegmentGenerator.prototype.getClass = function getClass () {\n  return OffsetSegmentGenerator\n};\nstaticAccessors$27.OFFSET_SEGMENT_SEPARATION_FACTOR.get = function () { return 1.0E-3 };\nstaticAccessors$27.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-3 };\nstaticAccessors$27.CURVE_VERTEX_SNAP_DISTANCE_FACTOR.get = function () { return 1.0E-6 };\nstaticAccessors$27.MAX_CLOSING_SEG_LEN_FACTOR.get = function () { return 80 };\n\nObject.defineProperties( OffsetSegmentGenerator, staticAccessors$27 );\n\nvar OffsetCurveBuilder = function OffsetCurveBuilder () {\n  this._distance = 0.0;\n  this._precisionModel = null;\n  this._bufParams = null;\n  var precisionModel = arguments[0];\n  var bufParams = arguments[1];\n  this._precisionModel = precisionModel;\n  this._bufParams = bufParams;\n};\nOffsetCurveBuilder.prototype.getOffsetCurve = function getOffsetCurve (inputPts, distance) {\n  this._distance = distance;\n  if (distance === 0.0) { return null }\n  var isRightSide = distance < 0.0;\n  var posDistance = Math.abs(distance);\n  var segGen = this.getSegGen(posDistance);\n  if (inputPts.length <= 1) {\n    this.computePointCurve(inputPts[0], segGen);\n  } else {\n    this.computeOffsetCurve(inputPts, isRightSide, segGen);\n  }\n  var curvePts = segGen.getCoordinates();\n  if (isRightSide) { CoordinateArrays.reverse(curvePts); }\n  return curvePts\n};\nOffsetCurveBuilder.prototype.computeSingleSidedBufferCurve = function computeSingleSidedBufferCurve (inputPts, isRightSide, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (isRightSide) {\n    segGen.addSegments(inputPts, true);\n    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n    var n2 = simp2.length - 1;\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i = n2 - 2; i >= 0; i--) {\n      segGen.addNextSegment(simp2[i], true);\n    }\n  } else {\n    segGen.addSegments(inputPts, false);\n    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n    var n1 = simp1.length - 1;\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i$1 = 2; i$1 <= n1; i$1++) {\n      segGen.addNextSegment(simp1[i$1], true);\n    }\n  }\n  segGen.addLastSegment();\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computeRingBufferCurve = function computeRingBufferCurve (inputPts, side, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (side === Position.RIGHT) { distTol = -distTol; }\n  var simp = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  var n = simp.length - 1;\n  segGen.initSideSegments(simp[n - 1], simp[0], side);\n  for (var i = 1; i <= n; i++) {\n    var addStartPoint = i !== 1;\n    segGen.addNextSegment(simp[i], addStartPoint);\n  }\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computeLineBufferCurve = function computeLineBufferCurve (inputPts, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n  var n1 = simp1.length - 1;\n  segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n  for (var i = 2; i <= n1; i++) {\n    segGen.addNextSegment(simp1[i], true);\n  }\n  segGen.addLastSegment();\n  segGen.addLineEndCap(simp1[n1 - 1], simp1[n1]);\n  var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n  var n2 = simp2.length - 1;\n  segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n  for (var i$1 = n2 - 2; i$1 >= 0; i$1--) {\n    segGen.addNextSegment(simp2[i$1], true);\n  }\n  segGen.addLastSegment();\n  segGen.addLineEndCap(simp2[1], simp2[0]);\n  segGen.closeRing();\n};\nOffsetCurveBuilder.prototype.computePointCurve = function computePointCurve (pt, segGen) {\n  switch (this._bufParams.getEndCapStyle()) {\n    case BufferParameters.CAP_ROUND:\n      segGen.createCircle(pt);\n      break\n    case BufferParameters.CAP_SQUARE:\n      segGen.createSquare(pt);\n      break\n    default:\n  }\n};\nOffsetCurveBuilder.prototype.getLineCurve = function getLineCurve (inputPts, distance) {\n  this._distance = distance;\n  if (distance < 0.0 && !this._bufParams.isSingleSided()) { return null }\n  if (distance === 0.0) { return null }\n  var posDistance = Math.abs(distance);\n  var segGen = this.getSegGen(posDistance);\n  if (inputPts.length <= 1) {\n    this.computePointCurve(inputPts[0], segGen);\n  } else {\n    if (this._bufParams.isSingleSided()) {\n      var isRightSide = distance < 0.0;\n      this.computeSingleSidedBufferCurve(inputPts, isRightSide, segGen);\n    } else { this.computeLineBufferCurve(inputPts, segGen); }\n  }\n  var lineCoord = segGen.getCoordinates();\n  return lineCoord\n};\nOffsetCurveBuilder.prototype.getBufferParameters = function getBufferParameters () {\n  return this._bufParams\n};\nOffsetCurveBuilder.prototype.simplifyTolerance = function simplifyTolerance (bufDistance) {\n  return bufDistance * this._bufParams.getSimplifyFactor()\n};\nOffsetCurveBuilder.prototype.getRingCurve = function getRingCurve (inputPts, side, distance) {\n  this._distance = distance;\n  if (inputPts.length <= 2) { return this.getLineCurve(inputPts, distance) }\n  if (distance === 0.0) {\n    return OffsetCurveBuilder.copyCoordinates(inputPts)\n  }\n  var segGen = this.getSegGen(distance);\n  this.computeRingBufferCurve(inputPts, side, segGen);\n  return segGen.getCoordinates()\n};\nOffsetCurveBuilder.prototype.computeOffsetCurve = function computeOffsetCurve (inputPts, isRightSide, segGen) {\n  var distTol = this.simplifyTolerance(this._distance);\n  if (isRightSide) {\n    var simp2 = BufferInputLineSimplifier.simplify(inputPts, -distTol);\n    var n2 = simp2.length - 1;\n    segGen.initSideSegments(simp2[n2], simp2[n2 - 1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i = n2 - 2; i >= 0; i--) {\n      segGen.addNextSegment(simp2[i], true);\n    }\n  } else {\n    var simp1 = BufferInputLineSimplifier.simplify(inputPts, distTol);\n    var n1 = simp1.length - 1;\n    segGen.initSideSegments(simp1[0], simp1[1], Position.LEFT);\n    segGen.addFirstSegment();\n    for (var i$1 = 2; i$1 <= n1; i$1++) {\n      segGen.addNextSegment(simp1[i$1], true);\n    }\n  }\n  segGen.addLastSegment();\n};\nOffsetCurveBuilder.prototype.getSegGen = function getSegGen (distance) {\n  return new OffsetSegmentGenerator(this._precisionModel, this._bufParams, distance)\n};\nOffsetCurveBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetCurveBuilder.prototype.getClass = function getClass () {\n  return OffsetCurveBuilder\n};\nOffsetCurveBuilder.copyCoordinates = function copyCoordinates (pts) {\n  var copy = new Array(pts.length).fill(null);\n  for (var i = 0; i < copy.length; i++) {\n    copy[i] = new Coordinate(pts[i]);\n  }\n  return copy\n};\n\nvar SubgraphDepthLocater = function SubgraphDepthLocater () {\n  this._subgraphs = null;\n  this._seg = new LineSegment();\n  this._cga = new CGAlgorithms();\n  var subgraphs = arguments[0];\n  this._subgraphs = subgraphs;\n};\n\nvar staticAccessors$30 = { DepthSegment: { configurable: true } };\nSubgraphDepthLocater.prototype.findStabbedSegments = function findStabbedSegments () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var stabbingRayLeftPt = arguments[0];\n    var stabbedSegments = new ArrayList();\n    for (var i = this._subgraphs.iterator(); i.hasNext();) {\n      var bsg = i.next();\n      var env = bsg.getEnvelope();\n      if (stabbingRayLeftPt.y < env.getMinY() || stabbingRayLeftPt.y > env.getMaxY()) { continue }\n      this$1.findStabbedSegments(stabbingRayLeftPt, bsg.getDirectedEdges(), stabbedSegments);\n    }\n    return stabbedSegments\n  } else if (arguments.length === 3) {\n    if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && arguments[1] instanceof DirectedEdge)) {\n      var stabbingRayLeftPt$1 = arguments[0];\n      var dirEdge = arguments[1];\n      var stabbedSegments$1 = arguments[2];\n      var pts = dirEdge.getEdge().getCoordinates();\n      for (var i$1 = 0; i$1 < pts.length - 1; i$1++) {\n        this$1._seg.p0 = pts[i$1];\n        this$1._seg.p1 = pts[i$1 + 1];\n        if (this$1._seg.p0.y > this$1._seg.p1.y) { this$1._seg.reverse(); }\n        var maxx = Math.max(this$1._seg.p0.x, this$1._seg.p1.x);\n        if (maxx < stabbingRayLeftPt$1.x) { continue }\n        if (this$1._seg.isHorizontal()) { continue }\n        if (stabbingRayLeftPt$1.y < this$1._seg.p0.y || stabbingRayLeftPt$1.y > this$1._seg.p1.y) { continue }\n        if (CGAlgorithms.computeOrientation(this$1._seg.p0, this$1._seg.p1, stabbingRayLeftPt$1) === CGAlgorithms.RIGHT) { continue }\n        var depth = dirEdge.getDepth(Position.LEFT);\n        if (!this$1._seg.p0.equals(pts[i$1])) { depth = dirEdge.getDepth(Position.RIGHT); }\n        var ds = new DepthSegment(this$1._seg, depth);\n        stabbedSegments$1.add(ds);\n      }\n    } else if (hasInterface(arguments[2], List) && (arguments[0] instanceof Coordinate && hasInterface(arguments[1], List))) {\n      var stabbingRayLeftPt$2 = arguments[0];\n      var dirEdges = arguments[1];\n      var stabbedSegments$2 = arguments[2];\n      for (var i$2 = dirEdges.iterator(); i$2.hasNext();) {\n        var de = i$2.next();\n        if (!de.isForward()) { continue }\n        this$1.findStabbedSegments(stabbingRayLeftPt$2, de, stabbedSegments$2);\n      }\n    }\n  }\n};\nSubgraphDepthLocater.prototype.getDepth = function getDepth (p) {\n  var stabbedSegments = this.findStabbedSegments(p);\n  if (stabbedSegments.size() === 0) { return 0 }\n  var ds = Collections.min(stabbedSegments);\n  return ds._leftDepth\n};\nSubgraphDepthLocater.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSubgraphDepthLocater.prototype.getClass = function getClass () {\n  return SubgraphDepthLocater\n};\nstaticAccessors$30.DepthSegment.get = function () { return DepthSegment };\n\nObject.defineProperties( SubgraphDepthLocater, staticAccessors$30 );\n\nvar DepthSegment = function DepthSegment () {\n  this._upwardSeg = null;\n  this._leftDepth = null;\n  var seg = arguments[0];\n  var depth = arguments[1];\n  this._upwardSeg = new LineSegment(seg);\n  this._leftDepth = depth;\n};\nDepthSegment.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  if (this._upwardSeg.minX() >= other._upwardSeg.maxX()) { return 1 }\n  if (this._upwardSeg.maxX() <= other._upwardSeg.minX()) { return -1 }\n  var orientIndex = this._upwardSeg.orientationIndex(other._upwardSeg);\n  if (orientIndex !== 0) { return orientIndex }\n  orientIndex = -1 * other._upwardSeg.orientationIndex(this._upwardSeg);\n  if (orientIndex !== 0) { return orientIndex }\n  return this._upwardSeg.compareTo(other._upwardSeg)\n};\nDepthSegment.prototype.compareX = function compareX (seg0, seg1) {\n  var compare0 = seg0.p0.compareTo(seg1.p0);\n  if (compare0 !== 0) { return compare0 }\n  return seg0.p1.compareTo(seg1.p1)\n};\nDepthSegment.prototype.toString = function toString () {\n  return this._upwardSeg.toString()\n};\nDepthSegment.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nDepthSegment.prototype.getClass = function getClass () {\n  return DepthSegment\n};\n\nvar Triangle = function Triangle (p0, p1, p2) {\n  this.p0 = p0 || null;\n  this.p1 = p1 || null;\n  this.p2 = p2 || null;\n};\nTriangle.prototype.area = function area () {\n  return Triangle.area(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.signedArea = function signedArea () {\n  return Triangle.signedArea(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.interpolateZ = function interpolateZ (p) {\n  if (p === null) { throw new IllegalArgumentException('Supplied point is null.') }\n  return Triangle.interpolateZ(p, this.p0, this.p1, this.p2)\n};\nTriangle.prototype.longestSideLength = function longestSideLength () {\n  return Triangle.longestSideLength(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.isAcute = function isAcute () {\n  return Triangle.isAcute(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.circumcentre = function circumcentre () {\n  return Triangle.circumcentre(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.area3D = function area3D () {\n  return Triangle.area3D(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.centroid = function centroid () {\n  return Triangle.centroid(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.inCentre = function inCentre () {\n  return Triangle.inCentre(this.p0, this.p1, this.p2)\n};\nTriangle.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nTriangle.prototype.getClass = function getClass () {\n  return Triangle\n};\nTriangle.area = function area (a, b, c) {\n  return Math.abs(((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2)\n};\nTriangle.signedArea = function signedArea (a, b, c) {\n  return ((c.x - a.x) * (b.y - a.y) - (b.x - a.x) * (c.y - a.y)) / 2\n};\nTriangle.det = function det (m00, m01, m10, m11) {\n  return m00 * m11 - m01 * m10\n};\nTriangle.interpolateZ = function interpolateZ (p, v0, v1, v2) {\n  var x0 = v0.x;\n  var y0 = v0.y;\n  var a = v1.x - x0;\n  var b = v2.x - x0;\n  var c = v1.y - y0;\n  var d = v2.y - y0;\n  var det = a * d - b * c;\n  var dx = p.x - x0;\n  var dy = p.y - y0;\n  var t = (d * dx - b * dy) / det;\n  var u = (-c * dx + a * dy) / det;\n  var z = v0.z + t * (v1.z - v0.z) + u * (v2.z - v0.z);\n  return z\n};\nTriangle.longestSideLength = function longestSideLength (a, b, c) {\n  var lenAB = a.distance(b);\n  var lenBC = b.distance(c);\n  var lenCA = c.distance(a);\n  var maxLen = lenAB;\n  if (lenBC > maxLen) { maxLen = lenBC; }\n  if (lenCA > maxLen) { maxLen = lenCA; }\n  return maxLen\n};\nTriangle.isAcute = function isAcute (a, b, c) {\n  if (!Angle.isAcute(a, b, c)) { return false }\n  if (!Angle.isAcute(b, c, a)) { return false }\n  if (!Angle.isAcute(c, a, b)) { return false }\n  return true\n};\nTriangle.circumcentre = function circumcentre (a, b, c) {\n  var cx = c.x;\n  var cy = c.y;\n  var ax = a.x - cx;\n  var ay = a.y - cy;\n  var bx = b.x - cx;\n  var by = b.y - cy;\n  var denom = 2 * Triangle.det(ax, ay, bx, by);\n  var numx = Triangle.det(ay, ax * ax + ay * ay, by, bx * bx + by * by);\n  var numy = Triangle.det(ax, ax * ax + ay * ay, bx, bx * bx + by * by);\n  var ccx = cx - numx / denom;\n  var ccy = cy + numy / denom;\n  return new Coordinate(ccx, ccy)\n};\nTriangle.perpendicularBisector = function perpendicularBisector (a, b) {\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  var l1 = new HCoordinate(a.x + dx / 2.0, a.y + dy / 2.0, 1.0);\n  var l2 = new HCoordinate(a.x - dy + dx / 2.0, a.y + dx + dy / 2.0, 1.0);\n  return new HCoordinate(l1, l2)\n};\nTriangle.angleBisector = function angleBisector (a, b, c) {\n  var len0 = b.distance(a);\n  var len2 = b.distance(c);\n  var frac = len0 / (len0 + len2);\n  var dx = c.x - a.x;\n  var dy = c.y - a.y;\n  var splitPt = new Coordinate(a.x + frac * dx, a.y + frac * dy);\n  return splitPt\n};\nTriangle.area3D = function area3D (a, b, c) {\n  var ux = b.x - a.x;\n  var uy = b.y - a.y;\n  var uz = b.z - a.z;\n  var vx = c.x - a.x;\n  var vy = c.y - a.y;\n  var vz = c.z - a.z;\n  var crossx = uy * vz - uz * vy;\n  var crossy = uz * vx - ux * vz;\n  var crossz = ux * vy - uy * vx;\n  var absSq = crossx * crossx + crossy * crossy + crossz * crossz;\n  var area3D = Math.sqrt(absSq) / 2;\n  return area3D\n};\nTriangle.centroid = function centroid (a, b, c) {\n  var x = (a.x + b.x + c.x) / 3;\n  var y = (a.y + b.y + c.y) / 3;\n  return new Coordinate(x, y)\n};\nTriangle.inCentre = function inCentre (a, b, c) {\n  var len0 = b.distance(c);\n  var len1 = a.distance(c);\n  var len2 = a.distance(b);\n  var circum = len0 + len1 + len2;\n  var inCentreX = (len0 * a.x + len1 * b.x + len2 * c.x) / circum;\n  var inCentreY = (len0 * a.y + len1 * b.y + len2 * c.y) / circum;\n  return new Coordinate(inCentreX, inCentreY)\n};\n\nvar OffsetCurveSetBuilder = function OffsetCurveSetBuilder () {\n  this._inputGeom = null;\n  this._distance = null;\n  this._curveBuilder = null;\n  this._curveList = new ArrayList();\n  var inputGeom = arguments[0];\n  var distance = arguments[1];\n  var curveBuilder = arguments[2];\n  this._inputGeom = inputGeom;\n  this._distance = distance;\n  this._curveBuilder = curveBuilder;\n};\nOffsetCurveSetBuilder.prototype.addPoint = function addPoint (p) {\n  if (this._distance <= 0.0) { return null }\n  var coord = p.getCoordinates();\n  var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n};\nOffsetCurveSetBuilder.prototype.addPolygon = function addPolygon (p) {\n    var this$1 = this;\n\n  var offsetDistance = this._distance;\n  var offsetSide = Position.LEFT;\n  if (this._distance < 0.0) {\n    offsetDistance = -this._distance;\n    offsetSide = Position.RIGHT;\n  }\n  var shell = p.getExteriorRing();\n  var shellCoord = CoordinateArrays.removeRepeatedPoints(shell.getCoordinates());\n  if (this._distance < 0.0 && this.isErodedCompletely(shell, this._distance)) { return null }\n  if (this._distance <= 0.0 && shellCoord.length < 3) { return null }\n  this.addPolygonRing(shellCoord, offsetDistance, offsetSide, Location.EXTERIOR, Location.INTERIOR);\n  for (var i = 0; i < p.getNumInteriorRing(); i++) {\n    var hole = p.getInteriorRingN(i);\n    var holeCoord = CoordinateArrays.removeRepeatedPoints(hole.getCoordinates());\n    if (this$1._distance > 0.0 && this$1.isErodedCompletely(hole, -this$1._distance)) { continue }\n    this$1.addPolygonRing(holeCoord, offsetDistance, Position.opposite(offsetSide), Location.INTERIOR, Location.EXTERIOR);\n  }\n};\nOffsetCurveSetBuilder.prototype.isTriangleErodedCompletely = function isTriangleErodedCompletely (triangleCoord, bufferDistance) {\n  var tri = new Triangle(triangleCoord[0], triangleCoord[1], triangleCoord[2]);\n  var inCentre = tri.inCentre();\n  var distToCentre = CGAlgorithms.distancePointLine(inCentre, tri.p0, tri.p1);\n  return distToCentre < Math.abs(bufferDistance)\n};\nOffsetCurveSetBuilder.prototype.addLineString = function addLineString (line) {\n  if (this._distance <= 0.0 && !this._curveBuilder.getBufferParameters().isSingleSided()) { return null }\n  var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n  var curve = this._curveBuilder.getLineCurve(coord, this._distance);\n  this.addCurve(curve, Location.EXTERIOR, Location.INTERIOR);\n};\nOffsetCurveSetBuilder.prototype.addCurve = function addCurve (coord, leftLoc, rightLoc) {\n  if (coord === null || coord.length < 2) { return null }\n  var e = new NodedSegmentString(coord, new Label(0, Location.BOUNDARY, leftLoc, rightLoc));\n  this._curveList.add(e);\n};\nOffsetCurveSetBuilder.prototype.getCurves = function getCurves () {\n  this.add(this._inputGeom);\n  return this._curveList\n};\nOffsetCurveSetBuilder.prototype.addPolygonRing = function addPolygonRing (coord, offsetDistance, side, cwLeftLoc, cwRightLoc) {\n  if (offsetDistance === 0.0 && coord.length < LinearRing.MINIMUM_VALID_SIZE) { return null }\n  var leftLoc = cwLeftLoc;\n  var rightLoc = cwRightLoc;\n  if (coord.length >= LinearRing.MINIMUM_VALID_SIZE && CGAlgorithms.isCCW(coord)) {\n    leftLoc = cwRightLoc;\n    rightLoc = cwLeftLoc;\n    side = Position.opposite(side);\n  }\n  var curve = this._curveBuilder.getRingCurve(coord, side, offsetDistance);\n  this.addCurve(curve, leftLoc, rightLoc);\n};\nOffsetCurveSetBuilder.prototype.add = function add (g) {\n  if (g.isEmpty()) { return null }\n  if (g instanceof Polygon) { this.addPolygon(g); }\n  else if (g instanceof LineString) { this.addLineString(g); }\n  else if (g instanceof Point) { this.addPoint(g); }\n  else if (g instanceof MultiPoint) { this.addCollection(g); }\n  else if (g instanceof MultiLineString) { this.addCollection(g); }\n  else if (g instanceof MultiPolygon) { this.addCollection(g); }\n  else if (g instanceof GeometryCollection) { this.addCollection(g); }\n  // else throw new UnsupportedOperationException(g.getClass().getName())\n};\nOffsetCurveSetBuilder.prototype.isErodedCompletely = function isErodedCompletely (ring, bufferDistance) {\n  var ringCoord = ring.getCoordinates();\n  // const minDiam = 0.0\n  if (ringCoord.length < 4) { return bufferDistance < 0 }\n  if (ringCoord.length === 4) { return this.isTriangleErodedCompletely(ringCoord, bufferDistance) }\n  var env = ring.getEnvelopeInternal();\n  var envMinDimension = Math.min(env.getHeight(), env.getWidth());\n  if (bufferDistance < 0.0 && 2 * Math.abs(bufferDistance) > envMinDimension) { return true }\n  return false\n};\nOffsetCurveSetBuilder.prototype.addCollection = function addCollection (gc) {\n    var this$1 = this;\n\n  for (var i = 0; i < gc.getNumGeometries(); i++) {\n    var g = gc.getGeometryN(i);\n    this$1.add(g);\n  }\n};\nOffsetCurveSetBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetCurveSetBuilder.prototype.getClass = function getClass () {\n  return OffsetCurveSetBuilder\n};\n\nvar PointOnGeometryLocator = function PointOnGeometryLocator () {};\n\nPointOnGeometryLocator.prototype.locate = function locate (p) {};\nPointOnGeometryLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointOnGeometryLocator.prototype.getClass = function getClass () {\n  return PointOnGeometryLocator\n};\n\nvar GeometryCollectionIterator = function GeometryCollectionIterator () {\n  this._parent = null;\n  this._atStart = null;\n  this._max = null;\n  this._index = null;\n  this._subcollectionIterator = null;\n  var parent = arguments[0];\n  this._parent = parent;\n  this._atStart = true;\n  this._index = 0;\n  this._max = parent.getNumGeometries();\n};\nGeometryCollectionIterator.prototype.next = function next () {\n  if (this._atStart) {\n    this._atStart = false;\n    if (GeometryCollectionIterator.isAtomic(this._parent)) { this._index++; }\n    return this._parent\n  }\n  if (this._subcollectionIterator !== null) {\n    if (this._subcollectionIterator.hasNext()) {\n      return this._subcollectionIterator.next()\n    } else {\n      this._subcollectionIterator = null;\n    }\n  }\n  if (this._index >= this._max) {\n    throw new NoSuchElementException()\n  }\n  var obj = this._parent.getGeometryN(this._index++);\n  if (obj instanceof GeometryCollection) {\n    this._subcollectionIterator = new GeometryCollectionIterator(obj);\n    return this._subcollectionIterator.next()\n  }\n  return obj\n};\nGeometryCollectionIterator.prototype.remove = function remove () {\n  throw new Error(this.getClass().getName())\n};\nGeometryCollectionIterator.prototype.hasNext = function hasNext () {\n  if (this._atStart) {\n    return true\n  }\n  if (this._subcollectionIterator !== null) {\n    if (this._subcollectionIterator.hasNext()) {\n      return true\n    }\n    this._subcollectionIterator = null;\n  }\n  if (this._index >= this._max) {\n    return false\n  }\n  return true\n};\nGeometryCollectionIterator.prototype.interfaces_ = function interfaces_ () {\n  return [Iterator]\n};\nGeometryCollectionIterator.prototype.getClass = function getClass () {\n  return GeometryCollectionIterator\n};\nGeometryCollectionIterator.isAtomic = function isAtomic (geom) {\n  return !(geom instanceof GeometryCollection)\n};\n\nvar SimplePointInAreaLocator = function SimplePointInAreaLocator () {\n  this._geom = null;\n  var geom = arguments[0];\n  this._geom = geom;\n};\nSimplePointInAreaLocator.prototype.locate = function locate (p) {\n  return SimplePointInAreaLocator.locate(p, this._geom)\n};\nSimplePointInAreaLocator.prototype.interfaces_ = function interfaces_ () {\n  return [PointOnGeometryLocator]\n};\nSimplePointInAreaLocator.prototype.getClass = function getClass () {\n  return SimplePointInAreaLocator\n};\nSimplePointInAreaLocator.isPointInRing = function isPointInRing (p, ring) {\n  if (!ring.getEnvelopeInternal().intersects(p)) { return false }\n  return CGAlgorithms.isPointInRing(p, ring.getCoordinates())\n};\nSimplePointInAreaLocator.containsPointInPolygon = function containsPointInPolygon (p, poly) {\n  if (poly.isEmpty()) { return false }\n  var shell = poly.getExteriorRing();\n  if (!SimplePointInAreaLocator.isPointInRing(p, shell)) { return false }\n  for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n    var hole = poly.getInteriorRingN(i);\n    if (SimplePointInAreaLocator.isPointInRing(p, hole)) { return false }\n  }\n  return true\n};\nSimplePointInAreaLocator.containsPoint = function containsPoint (p, geom) {\n  if (geom instanceof Polygon) {\n    return SimplePointInAreaLocator.containsPointInPolygon(p, geom)\n  } else if (geom instanceof GeometryCollection) {\n    var geomi = new GeometryCollectionIterator(geom);\n    while (geomi.hasNext()) {\n      var g2 = geomi.next();\n      if (g2 !== geom) { if (SimplePointInAreaLocator.containsPoint(p, g2)) { return true } }\n    }\n  }\n  return false\n};\nSimplePointInAreaLocator.locate = function locate (p, geom) {\n  if (geom.isEmpty()) { return Location.EXTERIOR }\n  if (SimplePointInAreaLocator.containsPoint(p, geom)) { return Location.INTERIOR }\n  return Location.EXTERIOR\n};\n\nvar EdgeEndStar = function EdgeEndStar () {\n  this._edgeMap = new TreeMap();\n  this._edgeList = null;\n  this._ptInAreaLocation = [Location.NONE, Location.NONE];\n};\nEdgeEndStar.prototype.getNextCW = function getNextCW (ee) {\n  this.getEdges();\n  var i = this._edgeList.indexOf(ee);\n  var iNextCW = i - 1;\n  if (i === 0) { iNextCW = this._edgeList.size() - 1; }\n  return this._edgeList.get(iNextCW)\n};\nEdgeEndStar.prototype.propagateSideLabels = function propagateSideLabels (geomIndex) {\n  var startLoc = Location.NONE;\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    if (label.isArea(geomIndex) && label.getLocation(geomIndex, Position.LEFT) !== Location.NONE) { startLoc = label.getLocation(geomIndex, Position.LEFT); }\n  }\n  if (startLoc === Location.NONE) { return null }\n  var currLoc = startLoc;\n  for (var it$1 = this.iterator(); it$1.hasNext();) {\n    var e$1 = it$1.next();\n    var label$1 = e$1.getLabel();\n    if (label$1.getLocation(geomIndex, Position.ON) === Location.NONE) { label$1.setLocation(geomIndex, Position.ON, currLoc); }\n    if (label$1.isArea(geomIndex)) {\n      var leftLoc = label$1.getLocation(geomIndex, Position.LEFT);\n      var rightLoc = label$1.getLocation(geomIndex, Position.RIGHT);\n      if (rightLoc !== Location.NONE) {\n        if (rightLoc !== currLoc) { throw new TopologyException('side location conflict', e$1.getCoordinate()) }\n        if (leftLoc === Location.NONE) {\n          Assert.shouldNeverReachHere('found single null side (at ' + e$1.getCoordinate() + ')');\n        }\n        currLoc = leftLoc;\n      } else {\n        Assert.isTrue(label$1.getLocation(geomIndex, Position.LEFT) === Location.NONE, 'found single null side');\n        label$1.setLocation(geomIndex, Position.RIGHT, currLoc);\n        label$1.setLocation(geomIndex, Position.LEFT, currLoc);\n      }\n    }\n  }\n};\nEdgeEndStar.prototype.getCoordinate = function getCoordinate () {\n  var it = this.iterator();\n  if (!it.hasNext()) { return null }\n  var e = it.next();\n  return e.getCoordinate()\n};\nEdgeEndStar.prototype.print = function print (out) {\n  System.out.println('EdgeEndStar:   ' + this.getCoordinate());\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    e.print(out);\n  }\n};\nEdgeEndStar.prototype.isAreaLabelsConsistent = function isAreaLabelsConsistent (geomGraph) {\n  this.computeEdgeEndLabels(geomGraph.getBoundaryNodeRule());\n  return this.checkAreaLabelsConsistent(0)\n};\nEdgeEndStar.prototype.checkAreaLabelsConsistent = function checkAreaLabelsConsistent (geomIndex) {\n  var edges = this.getEdges();\n  if (edges.size() <= 0) { return true }\n  var lastEdgeIndex = edges.size() - 1;\n  var startLabel = edges.get(lastEdgeIndex).getLabel();\n  var startLoc = startLabel.getLocation(geomIndex, Position.LEFT);\n  Assert.isTrue(startLoc !== Location.NONE, 'Found unlabelled area edge');\n  var currLoc = startLoc;\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    Assert.isTrue(label.isArea(geomIndex), 'Found non-area edge');\n    var leftLoc = label.getLocation(geomIndex, Position.LEFT);\n    var rightLoc = label.getLocation(geomIndex, Position.RIGHT);\n    if (leftLoc === rightLoc) {\n      return false\n    }\n    if (rightLoc !== currLoc) {\n      return false\n    }\n    currLoc = leftLoc;\n  }\n  return true\n};\nEdgeEndStar.prototype.findIndex = function findIndex (eSearch) {\n    var this$1 = this;\n\n  this.iterator();\n  for (var i = 0; i < this._edgeList.size(); i++) {\n    var e = this$1._edgeList.get(i);\n    if (e === eSearch) { return i }\n  }\n  return -1\n};\nEdgeEndStar.prototype.iterator = function iterator () {\n  return this.getEdges().iterator()\n};\nEdgeEndStar.prototype.getEdges = function getEdges () {\n  if (this._edgeList === null) {\n    this._edgeList = new ArrayList(this._edgeMap.values());\n  }\n  return this._edgeList\n};\nEdgeEndStar.prototype.getLocation = function getLocation (geomIndex, p, geom) {\n  if (this._ptInAreaLocation[geomIndex] === Location.NONE) {\n    this._ptInAreaLocation[geomIndex] = SimplePointInAreaLocator.locate(p, geom[geomIndex].getGeometry());\n  }\n  return this._ptInAreaLocation[geomIndex]\n};\nEdgeEndStar.prototype.toString = function toString () {\n  var buf = new StringBuffer();\n  buf.append('EdgeEndStar:   ' + this.getCoordinate());\n  buf.append('\\n');\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    buf.append(e);\n    buf.append('\\n');\n  }\n  return buf.toString()\n};\nEdgeEndStar.prototype.computeEdgeEndLabels = function computeEdgeEndLabels (boundaryNodeRule) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var ee = it.next();\n    ee.computeLabel(boundaryNodeRule);\n  }\n};\nEdgeEndStar.prototype.computeLabelling = function computeLabelling (geomGraph) {\n    var this$1 = this;\n\n  this.computeEdgeEndLabels(geomGraph[0].getBoundaryNodeRule());\n  this.propagateSideLabels(0);\n  this.propagateSideLabels(1);\n  var hasDimensionalCollapseEdge = [false, false];\n  for (var it = this.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    for (var geomi = 0; geomi < 2; geomi++) {\n      if (label.isLine(geomi) && label.getLocation(geomi) === Location.BOUNDARY) { hasDimensionalCollapseEdge[geomi] = true; }\n    }\n  }\n  for (var it$1 = this.iterator(); it$1.hasNext();) {\n    var e$1 = it$1.next();\n    var label$1 = e$1.getLabel();\n    for (var geomi$1 = 0; geomi$1 < 2; geomi$1++) {\n      if (label$1.isAnyNull(geomi$1)) {\n        var loc = Location.NONE;\n        if (hasDimensionalCollapseEdge[geomi$1]) {\n          loc = Location.EXTERIOR;\n        } else {\n          var p = e$1.getCoordinate();\n          loc = this$1.getLocation(geomi$1, p, geomGraph);\n        }\n        label$1.setAllLocationsIfNull(geomi$1, loc);\n      }\n    }\n  }\n};\nEdgeEndStar.prototype.getDegree = function getDegree () {\n  return this._edgeMap.size()\n};\nEdgeEndStar.prototype.insertEdgeEnd = function insertEdgeEnd (e, obj) {\n  this._edgeMap.put(e, obj);\n  this._edgeList = null;\n};\nEdgeEndStar.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeEndStar.prototype.getClass = function getClass () {\n  return EdgeEndStar\n};\n\nvar DirectedEdgeStar = (function (EdgeEndStar$$1) {\n  function DirectedEdgeStar () {\n    EdgeEndStar$$1.call(this);\n    this._resultAreaEdgeList = null;\n    this._label = null;\n    this._SCANNING_FOR_INCOMING = 1;\n    this._LINKING_TO_OUTGOING = 2;\n  }\n\n  if ( EdgeEndStar$$1 ) DirectedEdgeStar.__proto__ = EdgeEndStar$$1;\n  DirectedEdgeStar.prototype = Object.create( EdgeEndStar$$1 && EdgeEndStar$$1.prototype );\n  DirectedEdgeStar.prototype.constructor = DirectedEdgeStar;\n  DirectedEdgeStar.prototype.linkResultDirectedEdges = function linkResultDirectedEdges () {\n    var this$1 = this;\n\n    this.getResultAreaEdges();\n    var firstOut = null;\n    var incoming = null;\n    var state = this._SCANNING_FOR_INCOMING;\n    for (var i = 0; i < this._resultAreaEdgeList.size(); i++) {\n      var nextOut = this$1._resultAreaEdgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (!nextOut.getLabel().isArea()) { continue }\n      if (firstOut === null && nextOut.isInResult()) { firstOut = nextOut; }\n      switch (state) {\n        case this$1._SCANNING_FOR_INCOMING:\n          if (!nextIn.isInResult()) { continue }\n          incoming = nextIn;\n          state = this$1._LINKING_TO_OUTGOING;\n          break\n        case this$1._LINKING_TO_OUTGOING:\n          if (!nextOut.isInResult()) { continue }\n          incoming.setNext(nextOut);\n          state = this$1._SCANNING_FOR_INCOMING;\n          break\n        default:\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      if (firstOut === null) { throw new TopologyException('no outgoing dirEdge found', this.getCoordinate()) }\n      Assert.isTrue(firstOut.isInResult(), 'unable to link last incoming dirEdge');\n      incoming.setNext(firstOut);\n    }\n  };\n  DirectedEdgeStar.prototype.insert = function insert (ee) {\n    var de = ee;\n    this.insertEdgeEnd(de, de);\n  };\n  DirectedEdgeStar.prototype.getRightmostEdge = function getRightmostEdge () {\n    var edges = this.getEdges();\n    var size = edges.size();\n    if (size < 1) { return null }\n    var de0 = edges.get(0);\n    if (size === 1) { return de0 }\n    var deLast = edges.get(size - 1);\n    var quad0 = de0.getQuadrant();\n    var quad1 = deLast.getQuadrant();\n    if (Quadrant.isNorthern(quad0) && Quadrant.isNorthern(quad1)) { return de0; } else if (!Quadrant.isNorthern(quad0) && !Quadrant.isNorthern(quad1)) { return deLast; } else {\n      // const nonHorizontalEdge = null\n      if (de0.getDy() !== 0) { return de0; } else if (deLast.getDy() !== 0) { return deLast }\n    }\n    Assert.shouldNeverReachHere('found two horizontal edges incident on node');\n    return null\n  };\n  DirectedEdgeStar.prototype.print = function print (out) {\n    System.out.println('DirectedEdgeStar: ' + this.getCoordinate());\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      out.print('out ');\n      de.print(out);\n      out.println();\n      out.print('in ');\n      de.getSym().print(out);\n      out.println();\n    }\n  };\n  DirectedEdgeStar.prototype.getResultAreaEdges = function getResultAreaEdges () {\n    var this$1 = this;\n\n    if (this._resultAreaEdgeList !== null) { return this._resultAreaEdgeList }\n    this._resultAreaEdgeList = new ArrayList();\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      if (de.isInResult() || de.getSym().isInResult()) { this$1._resultAreaEdgeList.add(de); }\n    }\n    return this._resultAreaEdgeList\n  };\n  DirectedEdgeStar.prototype.updateLabelling = function updateLabelling (nodeLabel) {\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      label.setAllLocationsIfNull(0, nodeLabel.getLocation(0));\n      label.setAllLocationsIfNull(1, nodeLabel.getLocation(1));\n    }\n  };\n  DirectedEdgeStar.prototype.linkAllDirectedEdges = function linkAllDirectedEdges () {\n    var this$1 = this;\n\n    this.getEdges();\n    var prevOut = null;\n    var firstIn = null;\n    for (var i = this._edgeList.size() - 1; i >= 0; i--) {\n      var nextOut = this$1._edgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (firstIn === null) { firstIn = nextIn; }\n      if (prevOut !== null) { nextIn.setNext(prevOut); }\n      prevOut = nextOut;\n    }\n    firstIn.setNext(prevOut);\n  };\n  DirectedEdgeStar.prototype.computeDepths = function computeDepths () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var de = arguments[0];\n      var edgeIndex = this.findIndex(de);\n      // const label = de.getLabel()\n      var startDepth = de.getDepth(Position.LEFT);\n      var targetLastDepth = de.getDepth(Position.RIGHT);\n      var nextDepth = this.computeDepths(edgeIndex + 1, this._edgeList.size(), startDepth);\n      var lastDepth = this.computeDepths(0, edgeIndex, nextDepth);\n      if (lastDepth !== targetLastDepth) { throw new TopologyException('depth mismatch at ' + de.getCoordinate()) }\n    } else if (arguments.length === 3) {\n      var startIndex = arguments[0];\n      var endIndex = arguments[1];\n      var startDepth$1 = arguments[2];\n      var currDepth = startDepth$1;\n      for (var i = startIndex; i < endIndex; i++) {\n        var nextDe = this$1._edgeList.get(i);\n        // const label = nextDe.getLabel()\n        nextDe.setEdgeDepths(Position.RIGHT, currDepth);\n        currDepth = nextDe.getDepth(Position.LEFT);\n      }\n      return currDepth\n    }\n  };\n  DirectedEdgeStar.prototype.mergeSymLabels = function mergeSymLabels () {\n    for (var it = this.iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      label.merge(de.getSym().getLabel());\n    }\n  };\n  DirectedEdgeStar.prototype.linkMinimalDirectedEdges = function linkMinimalDirectedEdges (er) {\n    var this$1 = this;\n\n    var firstOut = null;\n    var incoming = null;\n    var state = this._SCANNING_FOR_INCOMING;\n    for (var i = this._resultAreaEdgeList.size() - 1; i >= 0; i--) {\n      var nextOut = this$1._resultAreaEdgeList.get(i);\n      var nextIn = nextOut.getSym();\n      if (firstOut === null && nextOut.getEdgeRing() === er) { firstOut = nextOut; }\n      switch (state) {\n        case this$1._SCANNING_FOR_INCOMING:\n          if (nextIn.getEdgeRing() !== er) { continue }\n          incoming = nextIn;\n          state = this$1._LINKING_TO_OUTGOING;\n          break\n        case this$1._LINKING_TO_OUTGOING:\n          if (nextOut.getEdgeRing() !== er) { continue }\n          incoming.setNextMin(nextOut);\n          state = this$1._SCANNING_FOR_INCOMING;\n          break\n        default:\n      }\n    }\n    if (state === this._LINKING_TO_OUTGOING) {\n      Assert.isTrue(firstOut !== null, 'found null for first outgoing dirEdge');\n      Assert.isTrue(firstOut.getEdgeRing() === er, 'unable to link last incoming dirEdge');\n      incoming.setNextMin(firstOut);\n    }\n  };\n  DirectedEdgeStar.prototype.getOutgoingDegree = function getOutgoingDegree () {\n    if (arguments.length === 0) {\n      var degree = 0;\n      for (var it = this.iterator(); it.hasNext();) {\n        var de = it.next();\n        if (de.isInResult()) { degree++; }\n      }\n      return degree\n    } else if (arguments.length === 1) {\n      var er = arguments[0];\n      var degree$1 = 0;\n      for (var it$1 = this.iterator(); it$1.hasNext();) {\n        var de$1 = it$1.next();\n        if (de$1.getEdgeRing() === er) { degree$1++; }\n      }\n      return degree$1\n    }\n  };\n  DirectedEdgeStar.prototype.getLabel = function getLabel () {\n    return this._label\n  };\n  DirectedEdgeStar.prototype.findCoveredLineEdges = function findCoveredLineEdges () {\n    var startLoc = Location.NONE;\n    for (var it = this.iterator(); it.hasNext();) {\n      var nextOut = it.next();\n      var nextIn = nextOut.getSym();\n      if (!nextOut.isLineEdge()) {\n        if (nextOut.isInResult()) {\n          startLoc = Location.INTERIOR;\n          break\n        }\n        if (nextIn.isInResult()) {\n          startLoc = Location.EXTERIOR;\n          break\n        }\n      }\n    }\n    if (startLoc === Location.NONE) { return null }\n    var currLoc = startLoc;\n    for (var it$1 = this.iterator(); it$1.hasNext();) {\n      var nextOut$1 = it$1.next();\n      var nextIn$1 = nextOut$1.getSym();\n      if (nextOut$1.isLineEdge()) {\n        nextOut$1.getEdge().setCovered(currLoc === Location.INTERIOR);\n      } else {\n        if (nextOut$1.isInResult()) { currLoc = Location.EXTERIOR; }\n        if (nextIn$1.isInResult()) { currLoc = Location.INTERIOR; }\n      }\n    }\n  };\n  DirectedEdgeStar.prototype.computeLabelling = function computeLabelling (geom) {\n    var this$1 = this;\n\n    EdgeEndStar$$1.prototype.computeLabelling.call(this, geom);\n    this._label = new Label(Location.NONE);\n    for (var it = this.iterator(); it.hasNext();) {\n      var ee = it.next();\n      var e = ee.getEdge();\n      var eLabel = e.getLabel();\n      for (var i = 0; i < 2; i++) {\n        var eLoc = eLabel.getLocation(i);\n        if (eLoc === Location.INTERIOR || eLoc === Location.BOUNDARY) { this$1._label.setLocation(i, Location.INTERIOR); }\n      }\n    }\n  };\n  DirectedEdgeStar.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  DirectedEdgeStar.prototype.getClass = function getClass () {\n    return DirectedEdgeStar\n  };\n\n  return DirectedEdgeStar;\n}(EdgeEndStar));\n\nvar OverlayNodeFactory = (function (NodeFactory$$1) {\n  function OverlayNodeFactory () {\n    NodeFactory$$1.apply(this, arguments);\n  }\n\n  if ( NodeFactory$$1 ) OverlayNodeFactory.__proto__ = NodeFactory$$1;\n  OverlayNodeFactory.prototype = Object.create( NodeFactory$$1 && NodeFactory$$1.prototype );\n  OverlayNodeFactory.prototype.constructor = OverlayNodeFactory;\n\n  OverlayNodeFactory.prototype.createNode = function createNode (coord) {\n    return new Node(coord, new DirectedEdgeStar())\n  };\n  OverlayNodeFactory.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  OverlayNodeFactory.prototype.getClass = function getClass () {\n    return OverlayNodeFactory\n  };\n\n  return OverlayNodeFactory;\n}(NodeFactory));\n\nvar OrientedCoordinateArray = function OrientedCoordinateArray () {\n  this._pts = null;\n  this._orientation = null;\n  var pts = arguments[0];\n  this._pts = pts;\n  this._orientation = OrientedCoordinateArray.orientation(pts);\n};\nOrientedCoordinateArray.prototype.compareTo = function compareTo (o1) {\n  var oca = o1;\n  var comp = OrientedCoordinateArray.compareOriented(this._pts, this._orientation, oca._pts, oca._orientation);\n  return comp\n};\nOrientedCoordinateArray.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nOrientedCoordinateArray.prototype.getClass = function getClass () {\n  return OrientedCoordinateArray\n};\nOrientedCoordinateArray.orientation = function orientation (pts) {\n  return CoordinateArrays.increasingDirection(pts) === 1\n};\nOrientedCoordinateArray.compareOriented = function compareOriented (pts1, orientation1, pts2, orientation2) {\n  var dir1 = orientation1 ? 1 : -1;\n  var dir2 = orientation2 ? 1 : -1;\n  var limit1 = orientation1 ? pts1.length : -1;\n  var limit2 = orientation2 ? pts2.length : -1;\n  var i1 = orientation1 ? 0 : pts1.length - 1;\n  var i2 = orientation2 ? 0 : pts2.length - 1;\n  // const comp = 0\n  while (true) {\n    var compPt = pts1[i1].compareTo(pts2[i2]);\n    if (compPt !== 0) { return compPt }\n    i1 += dir1;\n    i2 += dir2;\n    var done1 = i1 === limit1;\n    var done2 = i2 === limit2;\n    if (done1 && !done2) { return -1 }\n    if (!done1 && done2) { return 1 }\n    if (done1 && done2) { return 0 }\n  }\n};\n\nvar EdgeList = function EdgeList () {\n  this._edges = new ArrayList();\n  this._ocaMap = new TreeMap();\n};\nEdgeList.prototype.print = function print (out) {\n    var this$1 = this;\n\n  out.print('MULTILINESTRING ( ');\n  for (var j = 0; j < this._edges.size(); j++) {\n    var e = this$1._edges.get(j);\n    if (j > 0) { out.print(','); }\n    out.print('(');\n    var pts = e.getCoordinates();\n    for (var i = 0; i < pts.length; i++) {\n      if (i > 0) { out.print(','); }\n      out.print(pts[i].x + ' ' + pts[i].y);\n    }\n    out.println(')');\n  }\n  out.print(')  ');\n};\nEdgeList.prototype.addAll = function addAll (edgeColl) {\n    var this$1 = this;\n\n  for (var i = edgeColl.iterator(); i.hasNext();) {\n    this$1.add(i.next());\n  }\n};\nEdgeList.prototype.findEdgeIndex = function findEdgeIndex (e) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._edges.size(); i++) {\n    if (this$1._edges.get(i).equals(e)) { return i }\n  }\n  return -1\n};\nEdgeList.prototype.iterator = function iterator () {\n  return this._edges.iterator()\n};\nEdgeList.prototype.getEdges = function getEdges () {\n  return this._edges\n};\nEdgeList.prototype.get = function get (i) {\n  return this._edges.get(i)\n};\nEdgeList.prototype.findEqualEdge = function findEqualEdge (e) {\n  var oca = new OrientedCoordinateArray(e.getCoordinates());\n  var matchEdge = this._ocaMap.get(oca);\n  return matchEdge\n};\nEdgeList.prototype.add = function add (e) {\n  this._edges.add(e);\n  var oca = new OrientedCoordinateArray(e.getCoordinates());\n  this._ocaMap.put(oca, e);\n};\nEdgeList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeList.prototype.getClass = function getClass () {\n  return EdgeList\n};\n\nvar SegmentIntersector = function SegmentIntersector () {};\n\nSegmentIntersector.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {};\nSegmentIntersector.prototype.isDone = function isDone () {};\nSegmentIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentIntersector.prototype.getClass = function getClass () {\n  return SegmentIntersector\n};\n\nvar IntersectionAdder = function IntersectionAdder () {\n  this._hasIntersection = false;\n  this._hasProper = false;\n  this._hasProperInterior = false;\n  this._hasInterior = false;\n  this._properIntersectionPoint = null;\n  this._li = null;\n  this._isSelfIntersection = null;\n  this.numIntersections = 0;\n  this.numInteriorIntersections = 0;\n  this.numProperIntersections = 0;\n  this.numTests = 0;\n  var li = arguments[0];\n  this._li = li;\n};\nIntersectionAdder.prototype.isTrivialIntersection = function isTrivialIntersection (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1) {\n    if (this._li.getIntersectionNum() === 1) {\n      if (IntersectionAdder.isAdjacentSegments(segIndex0, segIndex1)) { return true }\n      if (e0.isClosed()) {\n        var maxSegIndex = e0.size() - 1;\n        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||\n            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {\n          return true\n        }\n      }\n    }\n  }\n  return false\n};\nIntersectionAdder.prototype.getProperIntersectionPoint = function getProperIntersectionPoint () {\n  return this._properIntersectionPoint\n};\nIntersectionAdder.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection () {\n  return this._hasProperInterior\n};\nIntersectionAdder.prototype.getLineIntersector = function getLineIntersector () {\n  return this._li\n};\nIntersectionAdder.prototype.hasProperIntersection = function hasProperIntersection () {\n  return this._hasProper\n};\nIntersectionAdder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  this.numTests++;\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    this.numIntersections++;\n    if (this._li.isInteriorIntersection()) {\n      this.numInteriorIntersections++;\n      this._hasInterior = true;\n    }\n    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n      this._hasIntersection = true;\n      e0.addIntersections(this._li, segIndex0, 0);\n      e1.addIntersections(this._li, segIndex1, 1);\n      if (this._li.isProper()) {\n        this.numProperIntersections++;\n        this._hasProper = true;\n        this._hasProperInterior = true;\n      }\n    }\n  }\n};\nIntersectionAdder.prototype.hasIntersection = function hasIntersection () {\n  return this._hasIntersection\n};\nIntersectionAdder.prototype.isDone = function isDone () {\n  return false\n};\nIntersectionAdder.prototype.hasInteriorIntersection = function hasInteriorIntersection () {\n  return this._hasInterior\n};\nIntersectionAdder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nIntersectionAdder.prototype.getClass = function getClass () {\n  return IntersectionAdder\n};\nIntersectionAdder.isAdjacentSegments = function isAdjacentSegments (i1, i2) {\n  return Math.abs(i1 - i2) === 1\n};\n\nvar EdgeIntersection = function EdgeIntersection () {\n  this.coord = null;\n  this.segmentIndex = null;\n  this.dist = null;\n  var coord = arguments[0];\n  var segmentIndex = arguments[1];\n  var dist = arguments[2];\n  this.coord = new Coordinate(coord);\n  this.segmentIndex = segmentIndex;\n  this.dist = dist;\n};\nEdgeIntersection.prototype.getSegmentIndex = function getSegmentIndex () {\n  return this.segmentIndex\n};\nEdgeIntersection.prototype.getCoordinate = function getCoordinate () {\n  return this.coord\n};\nEdgeIntersection.prototype.print = function print (out) {\n  out.print(this.coord);\n  out.print(' seg # = ' + this.segmentIndex);\n  out.println(' dist = ' + this.dist);\n};\nEdgeIntersection.prototype.compareTo = function compareTo (obj) {\n  var other = obj;\n  return this.compare(other.segmentIndex, other.dist)\n};\nEdgeIntersection.prototype.isEndPoint = function isEndPoint (maxSegmentIndex) {\n  if (this.segmentIndex === 0 && this.dist === 0.0) { return true }\n  if (this.segmentIndex === maxSegmentIndex) { return true }\n  return false\n};\nEdgeIntersection.prototype.toString = function toString () {\n  return this.coord + ' seg # = ' + this.segmentIndex + ' dist = ' + this.dist\n};\nEdgeIntersection.prototype.getDistance = function getDistance () {\n  return this.dist\n};\nEdgeIntersection.prototype.compare = function compare (segmentIndex, dist) {\n  if (this.segmentIndex < segmentIndex) { return -1 }\n  if (this.segmentIndex > segmentIndex) { return 1 }\n  if (this.dist < dist) { return -1 }\n  if (this.dist > dist) { return 1 }\n  return 0\n};\nEdgeIntersection.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nEdgeIntersection.prototype.getClass = function getClass () {\n  return EdgeIntersection\n};\n\nvar EdgeIntersectionList = function EdgeIntersectionList () {\n  this._nodeMap = new TreeMap();\n  this.edge = null;\n  var edge = arguments[0];\n  this.edge = edge;\n};\nEdgeIntersectionList.prototype.print = function print (out) {\n  out.println('Intersections:');\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    ei.print(out);\n  }\n};\nEdgeIntersectionList.prototype.iterator = function iterator () {\n  return this._nodeMap.values().iterator()\n};\nEdgeIntersectionList.prototype.addSplitEdges = function addSplitEdges (edgeList) {\n    var this$1 = this;\n\n  this.addEndpoints();\n  var it = this.iterator();\n  var eiPrev = it.next();\n  while (it.hasNext()) {\n    var ei = it.next();\n    var newEdge = this$1.createSplitEdge(eiPrev, ei);\n    edgeList.add(newEdge);\n    eiPrev = ei;\n  }\n};\nEdgeIntersectionList.prototype.addEndpoints = function addEndpoints () {\n  var maxSegIndex = this.edge.pts.length - 1;\n  this.add(this.edge.pts[0], 0, 0.0);\n  this.add(this.edge.pts[maxSegIndex], maxSegIndex, 0.0);\n};\nEdgeIntersectionList.prototype.createSplitEdge = function createSplitEdge (ei0, ei1) {\n    var this$1 = this;\n\n  var npts = ei1.segmentIndex - ei0.segmentIndex + 2;\n  var lastSegStartPt = this.edge.pts[ei1.segmentIndex];\n  var useIntPt1 = ei1.dist > 0.0 || !ei1.coord.equals2D(lastSegStartPt);\n  if (!useIntPt1) {\n    npts--;\n  }\n  var pts = new Array(npts).fill(null);\n  var ipt = 0;\n  pts[ipt++] = new Coordinate(ei0.coord);\n  for (var i = ei0.segmentIndex + 1; i <= ei1.segmentIndex; i++) {\n    pts[ipt++] = this$1.edge.pts[i];\n  }\n  if (useIntPt1) { pts[ipt] = ei1.coord; }\n  return new Edge(pts, new Label(this.edge._label))\n};\nEdgeIntersectionList.prototype.add = function add (intPt, segmentIndex, dist) {\n  var eiNew = new EdgeIntersection(intPt, segmentIndex, dist);\n  var ei = this._nodeMap.get(eiNew);\n  if (ei !== null) {\n    return ei\n  }\n  this._nodeMap.put(eiNew, eiNew);\n  return eiNew\n};\nEdgeIntersectionList.prototype.isIntersection = function isIntersection (pt) {\n  for (var it = this.iterator(); it.hasNext();) {\n    var ei = it.next();\n    if (ei.coord.equals(pt)) { return true }\n  }\n  return false\n};\nEdgeIntersectionList.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeIntersectionList.prototype.getClass = function getClass () {\n  return EdgeIntersectionList\n};\n\nvar MonotoneChainIndexer = function MonotoneChainIndexer () {};\n\nMonotoneChainIndexer.prototype.getChainStartIndices = function getChainStartIndices (pts) {\n    var this$1 = this;\n\n  var start = 0;\n  var startIndexList = new ArrayList();\n  startIndexList.add(new Integer(start));\n  do {\n    var last = this$1.findChainEnd(pts, start);\n    startIndexList.add(new Integer(last));\n    start = last;\n  } while (start < pts.length - 1)\n  var startIndex = MonotoneChainIndexer.toIntArray(startIndexList);\n  return startIndex\n};\nMonotoneChainIndexer.prototype.findChainEnd = function findChainEnd (pts, start) {\n  var chainQuad = Quadrant.quadrant(pts[start], pts[start + 1]);\n  var last = start + 1;\n  while (last < pts.length) {\n    var quad = Quadrant.quadrant(pts[last - 1], pts[last]);\n    if (quad !== chainQuad) { break }\n    last++;\n  }\n  return last - 1\n};\nMonotoneChainIndexer.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainIndexer.prototype.getClass = function getClass () {\n  return MonotoneChainIndexer\n};\nMonotoneChainIndexer.toIntArray = function toIntArray (list) {\n  var array = new Array(list.size()).fill(null);\n  for (var i = 0; i < array.length; i++) {\n    array[i] = list.get(i).intValue();\n  }\n  return array\n};\n\nvar MonotoneChainEdge = function MonotoneChainEdge () {\n  this.e = null;\n  this.pts = null;\n  this.startIndex = null;\n  this.env1 = new Envelope();\n  this.env2 = new Envelope();\n  var e = arguments[0];\n  this.e = e;\n  this.pts = e.getCoordinates();\n  var mcb = new MonotoneChainIndexer();\n  this.startIndex = mcb.getChainStartIndices(this.pts);\n};\nMonotoneChainEdge.prototype.getCoordinates = function getCoordinates () {\n  return this.pts\n};\nMonotoneChainEdge.prototype.getMaxX = function getMaxX (chainIndex) {\n  var x1 = this.pts[this.startIndex[chainIndex]].x;\n  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  return x1 > x2 ? x1 : x2\n};\nMonotoneChainEdge.prototype.getMinX = function getMinX (chainIndex) {\n  var x1 = this.pts[this.startIndex[chainIndex]].x;\n  var x2 = this.pts[this.startIndex[chainIndex + 1]].x;\n  return x1 < x2 ? x1 : x2\n};\nMonotoneChainEdge.prototype.computeIntersectsForChain = function computeIntersectsForChain () {\n  if (arguments.length === 4) {\n    var chainIndex0 = arguments[0];\n    var mce = arguments[1];\n    var chainIndex1 = arguments[2];\n    var si = arguments[3];\n    this.computeIntersectsForChain(this.startIndex[chainIndex0], this.startIndex[chainIndex0 + 1], mce, mce.startIndex[chainIndex1], mce.startIndex[chainIndex1 + 1], si);\n  } else if (arguments.length === 6) {\n    var start0 = arguments[0];\n    var end0 = arguments[1];\n    var mce$1 = arguments[2];\n    var start1 = arguments[3];\n    var end1 = arguments[4];\n    var ei = arguments[5];\n    var p00 = this.pts[start0];\n    var p01 = this.pts[end0];\n    var p10 = mce$1.pts[start1];\n    var p11 = mce$1.pts[end1];\n    if (end0 - start0 === 1 && end1 - start1 === 1) {\n      ei.addIntersections(this.e, start0, mce$1.e, start1);\n      return null\n    }\n    this.env1.init(p00, p01);\n    this.env2.init(p10, p11);\n    if (!this.env1.intersects(this.env2)) { return null }\n    var mid0 = Math.trunc((start0 + end0) / 2);\n    var mid1 = Math.trunc((start1 + end1) / 2);\n    if (start0 < mid0) {\n      if (start1 < mid1) { this.computeIntersectsForChain(start0, mid0, mce$1, start1, mid1, ei); }\n      if (mid1 < end1) { this.computeIntersectsForChain(start0, mid0, mce$1, mid1, end1, ei); }\n    }\n    if (mid0 < end0) {\n      if (start1 < mid1) { this.computeIntersectsForChain(mid0, end0, mce$1, start1, mid1, ei); }\n      if (mid1 < end1) { this.computeIntersectsForChain(mid0, end0, mce$1, mid1, end1, ei); }\n    }\n  }\n};\nMonotoneChainEdge.prototype.getStartIndexes = function getStartIndexes () {\n  return this.startIndex\n};\nMonotoneChainEdge.prototype.computeIntersects = function computeIntersects (mce, si) {\n    var this$1 = this;\n\n  for (var i = 0; i < this.startIndex.length - 1; i++) {\n    for (var j = 0; j < mce.startIndex.length - 1; j++) {\n      this$1.computeIntersectsForChain(i, mce, j, si);\n    }\n  }\n};\nMonotoneChainEdge.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainEdge.prototype.getClass = function getClass () {\n  return MonotoneChainEdge\n};\n\nvar Depth = function Depth () {\n  var this$1 = this;\n\n  this._depth = Array(2).fill().map(function () { return Array(3); });\n  for (var i = 0; i < 2; i++) {\n    for (var j = 0; j < 3; j++) {\n      this$1._depth[i][j] = Depth.NULL_VALUE;\n    }\n  }\n};\n\nvar staticAccessors$31 = { NULL_VALUE: { configurable: true } };\nDepth.prototype.getDepth = function getDepth (geomIndex, posIndex) {\n  return this._depth[geomIndex][posIndex]\n};\nDepth.prototype.setDepth = function setDepth (geomIndex, posIndex, depthValue) {\n  this._depth[geomIndex][posIndex] = depthValue;\n};\nDepth.prototype.isNull = function isNull () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = 0; i < 2; i++) {\n      for (var j = 0; j < 3; j++) {\n        if (this$1._depth[i][j] !== Depth.NULL_VALUE) { return false }\n      }\n    }\n    return true\n  } else if (arguments.length === 1) {\n    var geomIndex = arguments[0];\n    return this._depth[geomIndex][1] === Depth.NULL_VALUE\n  } else if (arguments.length === 2) {\n    var geomIndex$1 = arguments[0];\n    var posIndex = arguments[1];\n    return this._depth[geomIndex$1][posIndex] === Depth.NULL_VALUE\n  }\n};\nDepth.prototype.normalize = function normalize () {\n    var this$1 = this;\n\n  for (var i = 0; i < 2; i++) {\n    if (!this$1.isNull(i)) {\n      var minDepth = this$1._depth[i][1];\n      if (this$1._depth[i][2] < minDepth) { minDepth = this$1._depth[i][2]; }\n      if (minDepth < 0) { minDepth = 0; }\n      for (var j = 1; j < 3; j++) {\n        var newValue = 0;\n        if (this$1._depth[i][j] > minDepth) { newValue = 1; }\n        this$1._depth[i][j] = newValue;\n      }\n    }\n  }\n};\nDepth.prototype.getDelta = function getDelta (geomIndex) {\n  return this._depth[geomIndex][Position.RIGHT] - this._depth[geomIndex][Position.LEFT]\n};\nDepth.prototype.getLocation = function getLocation (geomIndex, posIndex) {\n  if (this._depth[geomIndex][posIndex] <= 0) { return Location.EXTERIOR }\n  return Location.INTERIOR\n};\nDepth.prototype.toString = function toString () {\n  return 'A: ' + this._depth[0][1] + ',' + this._depth[0][2] + ' B: ' + this._depth[1][1] + ',' + this._depth[1][2]\n};\nDepth.prototype.add = function add () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var lbl = arguments[0];\n    for (var i = 0; i < 2; i++) {\n      for (var j = 1; j < 3; j++) {\n        var loc = lbl.getLocation(i, j);\n        if (loc === Location.EXTERIOR || loc === Location.INTERIOR) {\n          if (this$1.isNull(i, j)) {\n            this$1._depth[i][j] = Depth.depthAtLocation(loc);\n          } else { this$1._depth[i][j] += Depth.depthAtLocation(loc); }\n        }\n      }\n    }\n  } else if (arguments.length === 3) {\n    var geomIndex = arguments[0];\n    var posIndex = arguments[1];\n    var location = arguments[2];\n    if (location === Location.INTERIOR) { this._depth[geomIndex][posIndex]++; }\n  }\n};\nDepth.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDepth.prototype.getClass = function getClass () {\n  return Depth\n};\nDepth.depthAtLocation = function depthAtLocation (location) {\n  if (location === Location.EXTERIOR) { return 0 }\n  if (location === Location.INTERIOR) { return 1 }\n  return Depth.NULL_VALUE\n};\nstaticAccessors$31.NULL_VALUE.get = function () { return -1 };\n\nObject.defineProperties( Depth, staticAccessors$31 );\n\nvar Edge = (function (GraphComponent$$1) {\n  function Edge () {\n    GraphComponent$$1.call(this);\n    this.pts = null;\n    this._env = null;\n    this.eiList = new EdgeIntersectionList(this);\n    this._name = null;\n    this._mce = null;\n    this._isIsolated = true;\n    this._depth = new Depth();\n    this._depthDelta = 0;\n    if (arguments.length === 1) {\n      var pts = arguments[0];\n      Edge.call(this, pts, null);\n    } else if (arguments.length === 2) {\n      var pts$1 = arguments[0];\n      var label = arguments[1];\n      this.pts = pts$1;\n      this._label = label;\n    }\n  }\n\n  if ( GraphComponent$$1 ) Edge.__proto__ = GraphComponent$$1;\n  Edge.prototype = Object.create( GraphComponent$$1 && GraphComponent$$1.prototype );\n  Edge.prototype.constructor = Edge;\n  Edge.prototype.getDepth = function getDepth () {\n    return this._depth\n  };\n  Edge.prototype.getCollapsedEdge = function getCollapsedEdge () {\n    var newPts = new Array(2).fill(null);\n    newPts[0] = this.pts[0];\n    newPts[1] = this.pts[1];\n    var newe = new Edge(newPts, Label.toLineLabel(this._label));\n    return newe\n  };\n  Edge.prototype.isIsolated = function isIsolated () {\n    return this._isIsolated\n  };\n  Edge.prototype.getCoordinates = function getCoordinates () {\n    return this.pts\n  };\n  Edge.prototype.setIsolated = function setIsolated (isIsolated) {\n    this._isIsolated = isIsolated;\n  };\n  Edge.prototype.setName = function setName (name) {\n    this._name = name;\n  };\n  Edge.prototype.equals = function equals (o) {\n    var this$1 = this;\n\n    if (!(o instanceof Edge)) { return false }\n    var e = o;\n    if (this.pts.length !== e.pts.length) { return false }\n    var isEqualForward = true;\n    var isEqualReverse = true;\n    var iRev = this.pts.length;\n    for (var i = 0; i < this.pts.length; i++) {\n      if (!this$1.pts[i].equals2D(e.pts[i])) {\n        isEqualForward = false;\n      }\n      if (!this$1.pts[i].equals2D(e.pts[--iRev])) {\n        isEqualReverse = false;\n      }\n      if (!isEqualForward && !isEqualReverse) { return false }\n    }\n    return true\n  };\n  Edge.prototype.getCoordinate = function getCoordinate () {\n    if (arguments.length === 0) {\n      if (this.pts.length > 0) { return this.pts[0] }\n      return null\n    } else if (arguments.length === 1) {\n      var i = arguments[0];\n      return this.pts[i]\n    }\n  };\n  Edge.prototype.print = function print (out) {\n    var this$1 = this;\n\n    out.print('edge ' + this._name + ': ');\n    out.print('LINESTRING (');\n    for (var i = 0; i < this.pts.length; i++) {\n      if (i > 0) { out.print(','); }\n      out.print(this$1.pts[i].x + ' ' + this$1.pts[i].y);\n    }\n    out.print(')  ' + this._label + ' ' + this._depthDelta);\n  };\n  Edge.prototype.computeIM = function computeIM (im) {\n    Edge.updateIM(this._label, im);\n  };\n  Edge.prototype.isCollapsed = function isCollapsed () {\n    if (!this._label.isArea()) { return false }\n    if (this.pts.length !== 3) { return false }\n    if (this.pts[0].equals(this.pts[2])) { return true }\n    return false\n  };\n  Edge.prototype.isClosed = function isClosed () {\n    return this.pts[0].equals(this.pts[this.pts.length - 1])\n  };\n  Edge.prototype.getMaximumSegmentIndex = function getMaximumSegmentIndex () {\n    return this.pts.length - 1\n  };\n  Edge.prototype.getDepthDelta = function getDepthDelta () {\n    return this._depthDelta\n  };\n  Edge.prototype.getNumPoints = function getNumPoints () {\n    return this.pts.length\n  };\n  Edge.prototype.printReverse = function printReverse (out) {\n    var this$1 = this;\n\n    out.print('edge ' + this._name + ': ');\n    for (var i = this.pts.length - 1; i >= 0; i--) {\n      out.print(this$1.pts[i] + ' ');\n    }\n    out.println('');\n  };\n  Edge.prototype.getMonotoneChainEdge = function getMonotoneChainEdge () {\n    if (this._mce === null) { this._mce = new MonotoneChainEdge(this); }\n    return this._mce\n  };\n  Edge.prototype.getEnvelope = function getEnvelope () {\n    var this$1 = this;\n\n    if (this._env === null) {\n      this._env = new Envelope();\n      for (var i = 0; i < this.pts.length; i++) {\n        this$1._env.expandToInclude(this$1.pts[i]);\n      }\n    }\n    return this._env\n  };\n  Edge.prototype.addIntersection = function addIntersection (li, segmentIndex, geomIndex, intIndex) {\n    var intPt = new Coordinate(li.getIntersection(intIndex));\n    var normalizedSegmentIndex = segmentIndex;\n    var dist = li.getEdgeDistance(geomIndex, intIndex);\n    var nextSegIndex = normalizedSegmentIndex + 1;\n    if (nextSegIndex < this.pts.length) {\n      var nextPt = this.pts[nextSegIndex];\n      if (intPt.equals2D(nextPt)) {\n        normalizedSegmentIndex = nextSegIndex;\n        dist = 0.0;\n      }\n    }\n    this.eiList.add(intPt, normalizedSegmentIndex, dist);\n  };\n  Edge.prototype.toString = function toString () {\n    var this$1 = this;\n\n    var buf = new StringBuffer();\n    buf.append('edge ' + this._name + ': ');\n    buf.append('LINESTRING (');\n    for (var i = 0; i < this.pts.length; i++) {\n      if (i > 0) { buf.append(','); }\n      buf.append(this$1.pts[i].x + ' ' + this$1.pts[i].y);\n    }\n    buf.append(')  ' + this._label + ' ' + this._depthDelta);\n    return buf.toString()\n  };\n  Edge.prototype.isPointwiseEqual = function isPointwiseEqual (e) {\n    var this$1 = this;\n\n    if (this.pts.length !== e.pts.length) { return false }\n    for (var i = 0; i < this.pts.length; i++) {\n      if (!this$1.pts[i].equals2D(e.pts[i])) {\n        return false\n      }\n    }\n    return true\n  };\n  Edge.prototype.setDepthDelta = function setDepthDelta (depthDelta) {\n    this._depthDelta = depthDelta;\n  };\n  Edge.prototype.getEdgeIntersectionList = function getEdgeIntersectionList () {\n    return this.eiList\n  };\n  Edge.prototype.addIntersections = function addIntersections (li, segmentIndex, geomIndex) {\n    var this$1 = this;\n\n    for (var i = 0; i < li.getIntersectionNum(); i++) {\n      this$1.addIntersection(li, segmentIndex, geomIndex, i);\n    }\n  };\n  Edge.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  Edge.prototype.getClass = function getClass () {\n    return Edge\n  };\n  Edge.updateIM = function updateIM () {\n    if (arguments.length === 2) {\n      var label = arguments[0];\n      var im = arguments[1];\n      im.setAtLeastIfValid(label.getLocation(0, Position.ON), label.getLocation(1, Position.ON), 1);\n      if (label.isArea()) {\n        im.setAtLeastIfValid(label.getLocation(0, Position.LEFT), label.getLocation(1, Position.LEFT), 2);\n        im.setAtLeastIfValid(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), 2);\n      }\n    } else { return GraphComponent$$1.prototype.updateIM.apply(this, arguments) }\n  };\n\n  return Edge;\n}(GraphComponent));\n\nvar BufferBuilder = function BufferBuilder (bufParams) {\n  this._workingPrecisionModel = null;\n  this._workingNoder = null;\n  this._geomFact = null;\n  this._graph = null;\n  this._edgeList = new EdgeList();\n  this._bufParams = bufParams || null;\n};\nBufferBuilder.prototype.setWorkingPrecisionModel = function setWorkingPrecisionModel (pm) {\n  this._workingPrecisionModel = pm;\n};\nBufferBuilder.prototype.insertUniqueEdge = function insertUniqueEdge (e) {\n  var existingEdge = this._edgeList.findEqualEdge(e);\n  if (existingEdge !== null) {\n    var existingLabel = existingEdge.getLabel();\n    var labelToMerge = e.getLabel();\n    if (!existingEdge.isPointwiseEqual(e)) {\n      labelToMerge = new Label(e.getLabel());\n      labelToMerge.flip();\n    }\n    existingLabel.merge(labelToMerge);\n    var mergeDelta = BufferBuilder.depthDelta(labelToMerge);\n    var existingDelta = existingEdge.getDepthDelta();\n    var newDelta = existingDelta + mergeDelta;\n    existingEdge.setDepthDelta(newDelta);\n  } else {\n    this._edgeList.add(e);\n    e.setDepthDelta(BufferBuilder.depthDelta(e.getLabel()));\n  }\n};\nBufferBuilder.prototype.buildSubgraphs = function buildSubgraphs (subgraphList, polyBuilder) {\n  var processedGraphs = new ArrayList();\n  for (var i = subgraphList.iterator(); i.hasNext();) {\n    var subgraph = i.next();\n    var p = subgraph.getRightmostCoordinate();\n    var locater = new SubgraphDepthLocater(processedGraphs);\n    var outsideDepth = locater.getDepth(p);\n    subgraph.computeDepth(outsideDepth);\n    subgraph.findResultEdges();\n    processedGraphs.add(subgraph);\n    polyBuilder.add(subgraph.getDirectedEdges(), subgraph.getNodes());\n  }\n};\nBufferBuilder.prototype.createSubgraphs = function createSubgraphs (graph) {\n  var subgraphList = new ArrayList();\n  for (var i = graph.getNodes().iterator(); i.hasNext();) {\n    var node = i.next();\n    if (!node.isVisited()) {\n      var subgraph = new BufferSubgraph();\n      subgraph.create(node);\n      subgraphList.add(subgraph);\n    }\n  }\n  Collections.sort(subgraphList, Collections.reverseOrder());\n  return subgraphList\n};\nBufferBuilder.prototype.createEmptyResultGeometry = function createEmptyResultGeometry () {\n  var emptyGeom = this._geomFact.createPolygon();\n  return emptyGeom\n};\nBufferBuilder.prototype.getNoder = function getNoder (precisionModel) {\n  if (this._workingNoder !== null) { return this._workingNoder }\n  var noder = new MCIndexNoder();\n  var li = new RobustLineIntersector();\n  li.setPrecisionModel(precisionModel);\n  noder.setSegmentIntersector(new IntersectionAdder(li));\n  return noder\n};\nBufferBuilder.prototype.buffer = function buffer (g, distance) {\n  var precisionModel = this._workingPrecisionModel;\n  if (precisionModel === null) { precisionModel = g.getPrecisionModel(); }\n  this._geomFact = g.getFactory();\n  var curveBuilder = new OffsetCurveBuilder(precisionModel, this._bufParams);\n  var curveSetBuilder = new OffsetCurveSetBuilder(g, distance, curveBuilder);\n  var bufferSegStrList = curveSetBuilder.getCurves();\n  if (bufferSegStrList.size() <= 0) {\n    return this.createEmptyResultGeometry()\n  }\n  this.computeNodedEdges(bufferSegStrList, precisionModel);\n  this._graph = new PlanarGraph(new OverlayNodeFactory());\n  this._graph.addEdges(this._edgeList.getEdges());\n  var subgraphList = this.createSubgraphs(this._graph);\n  var polyBuilder = new PolygonBuilder(this._geomFact);\n  this.buildSubgraphs(subgraphList, polyBuilder);\n  var resultPolyList = polyBuilder.getPolygons();\n  if (resultPolyList.size() <= 0) {\n    return this.createEmptyResultGeometry()\n  }\n  var resultGeom = this._geomFact.buildGeometry(resultPolyList);\n  return resultGeom\n};\nBufferBuilder.prototype.computeNodedEdges = function computeNodedEdges (bufferSegStrList, precisionModel) {\n    var this$1 = this;\n\n  var noder = this.getNoder(precisionModel);\n  noder.computeNodes(bufferSegStrList);\n  var nodedSegStrings = noder.getNodedSubstrings();\n  for (var i = nodedSegStrings.iterator(); i.hasNext();) {\n    var segStr = i.next();\n    var pts = segStr.getCoordinates();\n    if (pts.length === 2 && pts[0].equals2D(pts[1])) { continue }\n    var oldLabel = segStr.getData();\n    var edge = new Edge(segStr.getCoordinates(), new Label(oldLabel));\n    this$1.insertUniqueEdge(edge);\n  }\n};\nBufferBuilder.prototype.setNoder = function setNoder (noder) {\n  this._workingNoder = noder;\n};\nBufferBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferBuilder.prototype.getClass = function getClass () {\n  return BufferBuilder\n};\nBufferBuilder.depthDelta = function depthDelta (label) {\n  var lLoc = label.getLocation(0, Position.LEFT);\n  var rLoc = label.getLocation(0, Position.RIGHT);\n  if (lLoc === Location.INTERIOR && rLoc === Location.EXTERIOR) { return 1; } else if (lLoc === Location.EXTERIOR && rLoc === Location.INTERIOR) { return -1 }\n  return 0\n};\nBufferBuilder.convertSegStrings = function convertSegStrings (it) {\n  var fact = new GeometryFactory();\n  var lines = new ArrayList();\n  while (it.hasNext()) {\n    var ss = it.next();\n    var line = fact.createLineString(ss.getCoordinates());\n    lines.add(line);\n  }\n  return fact.buildGeometry(lines)\n};\n\nvar ScaledNoder = function ScaledNoder () {\n  this._noder = null;\n  this._scaleFactor = null;\n  this._offsetX = null;\n  this._offsetY = null;\n  this._isScaled = false;\n  if (arguments.length === 2) {\n    var noder = arguments[0];\n    var scaleFactor = arguments[1];\n    this._noder = noder;\n    this._scaleFactor = scaleFactor;\n    this._offsetX = 0.0;\n    this._offsetY = 0.0;\n    this._isScaled = !this.isIntegerPrecision();\n  } else if (arguments.length === 4) {\n    var noder$1 = arguments[0];\n    var scaleFactor$1 = arguments[1];\n    var offsetX = arguments[2];\n    var offsetY = arguments[3];\n    this._noder = noder$1;\n    this._scaleFactor = scaleFactor$1;\n    this._offsetX = offsetX;\n    this._offsetY = offsetY;\n    this._isScaled = !this.isIntegerPrecision();\n  }\n};\nScaledNoder.prototype.rescale = function rescale () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var segStrings = arguments[0];\n    for (var i = segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      this$1.rescale(ss.getCoordinates());\n    }\n  } else if (arguments[0] instanceof Array) {\n    var pts = arguments[0];\n    // let p0 = null\n    // let p1 = null\n    // if (pts.length === 2) {\n    // p0 = new Coordinate(pts[0])\n    // p1 = new Coordinate(pts[1])\n    // }\n    for (var i$1 = 0; i$1 < pts.length; i$1++) {\n      pts[i$1].x = pts[i$1].x / this$1._scaleFactor + this$1._offsetX;\n      pts[i$1].y = pts[i$1].y / this$1._scaleFactor + this$1._offsetY;\n    }\n    if (pts.length === 2 && pts[0].equals2D(pts[1])) {\n      System.out.println(pts);\n    }\n  }\n};\nScaledNoder.prototype.scale = function scale () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var segStrings = arguments[0];\n    var nodedSegmentStrings = new ArrayList();\n    for (var i = segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      nodedSegmentStrings.add(new NodedSegmentString(this$1.scale(ss.getCoordinates()), ss.getData()));\n    }\n    return nodedSegmentStrings\n  } else if (arguments[0] instanceof Array) {\n    var pts = arguments[0];\n    var roundPts = new Array(pts.length).fill(null);\n    for (var i$1 = 0; i$1 < pts.length; i$1++) {\n      roundPts[i$1] = new Coordinate(Math.round((pts[i$1].x - this$1._offsetX) * this$1._scaleFactor), Math.round((pts[i$1].y - this$1._offsetY) * this$1._scaleFactor), pts[i$1].z);\n    }\n    var roundPtsNoDup = CoordinateArrays.removeRepeatedPoints(roundPts);\n    return roundPtsNoDup\n  }\n};\nScaledNoder.prototype.isIntegerPrecision = function isIntegerPrecision () {\n  return this._scaleFactor === 1.0\n};\nScaledNoder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n  var splitSS = this._noder.getNodedSubstrings();\n  if (this._isScaled) { this.rescale(splitSS); }\n  return splitSS\n};\nScaledNoder.prototype.computeNodes = function computeNodes (inputSegStrings) {\n  var intSegStrings = inputSegStrings;\n  if (this._isScaled) { intSegStrings = this.scale(inputSegStrings); }\n  this._noder.computeNodes(intSegStrings);\n};\nScaledNoder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nScaledNoder.prototype.getClass = function getClass () {\n  return ScaledNoder\n};\n\nvar NodingValidator = function NodingValidator () {\n  this._li = new RobustLineIntersector();\n  this._segStrings = null;\n  var segStrings = arguments[0];\n  this._segStrings = segStrings;\n};\n\nvar staticAccessors$33 = { fact: { configurable: true } };\nNodingValidator.prototype.checkEndPtVertexIntersections = function checkEndPtVertexIntersections () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      var pts = ss.getCoordinates();\n      this$1.checkEndPtVertexIntersections(pts[0], this$1._segStrings);\n      this$1.checkEndPtVertexIntersections(pts[pts.length - 1], this$1._segStrings);\n    }\n  } else if (arguments.length === 2) {\n    var testPt = arguments[0];\n    var segStrings = arguments[1];\n    for (var i$1 = segStrings.iterator(); i$1.hasNext();) {\n      var ss$1 = i$1.next();\n      var pts$1 = ss$1.getCoordinates();\n      for (var j = 1; j < pts$1.length - 1; j++) {\n        if (pts$1[j].equals(testPt)) { throw new RuntimeException('found endpt/interior pt intersection at index ' + j + ' :pt ' + testPt) }\n      }\n    }\n  }\n};\nNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss0 = i.next();\n      for (var j = this._segStrings.iterator(); j.hasNext();) {\n        var ss1 = j.next();\n        this$1.checkInteriorIntersections(ss0, ss1);\n      }\n    }\n  } else if (arguments.length === 2) {\n    var ss0$1 = arguments[0];\n    var ss1$1 = arguments[1];\n    var pts0 = ss0$1.getCoordinates();\n    var pts1 = ss1$1.getCoordinates();\n    for (var i0 = 0; i0 < pts0.length - 1; i0++) {\n      for (var i1 = 0; i1 < pts1.length - 1; i1++) {\n        this$1.checkInteriorIntersections(ss0$1, i0, ss1$1, i1);\n      }\n    }\n  } else if (arguments.length === 4) {\n    var e0 = arguments[0];\n    var segIndex0 = arguments[1];\n    var e1 = arguments[2];\n    var segIndex1 = arguments[3];\n    if (e0 === e1 && segIndex0 === segIndex1) { return null }\n    var p00 = e0.getCoordinates()[segIndex0];\n    var p01 = e0.getCoordinates()[segIndex0 + 1];\n    var p10 = e1.getCoordinates()[segIndex1];\n    var p11 = e1.getCoordinates()[segIndex1 + 1];\n    this._li.computeIntersection(p00, p01, p10, p11);\n    if (this._li.hasIntersection()) {\n      if (this._li.isProper() || this.hasInteriorIntersection(this._li, p00, p01) || this.hasInteriorIntersection(this._li, p10, p11)) {\n        throw new RuntimeException('found non-noded intersection at ' + p00 + '-' + p01 + ' and ' + p10 + '-' + p11)\n      }\n    }\n  }\n};\nNodingValidator.prototype.checkValid = function checkValid () {\n  this.checkEndPtVertexIntersections();\n  this.checkInteriorIntersections();\n  this.checkCollapses();\n};\nNodingValidator.prototype.checkCollapses = function checkCollapses () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var i = this._segStrings.iterator(); i.hasNext();) {\n      var ss = i.next();\n      this$1.checkCollapses(ss);\n    }\n  } else if (arguments.length === 1) {\n    var ss$1 = arguments[0];\n    var pts = ss$1.getCoordinates();\n    for (var i$1 = 0; i$1 < pts.length - 2; i$1++) {\n      this$1.checkCollapse(pts[i$1], pts[i$1 + 1], pts[i$1 + 2]);\n    }\n  }\n};\nNodingValidator.prototype.hasInteriorIntersection = function hasInteriorIntersection (li, p0, p1) {\n  for (var i = 0; i < li.getIntersectionNum(); i++) {\n    var intPt = li.getIntersection(i);\n    if (!(intPt.equals(p0) || intPt.equals(p1))) { return true }\n  }\n  return false\n};\nNodingValidator.prototype.checkCollapse = function checkCollapse (p0, p1, p2) {\n  if (p0.equals(p2)) { throw new RuntimeException('found non-noded collapse at ' + NodingValidator.fact.createLineString([p0, p1, p2])) }\n};\nNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nNodingValidator.prototype.getClass = function getClass () {\n  return NodingValidator\n};\nstaticAccessors$33.fact.get = function () { return new GeometryFactory() };\n\nObject.defineProperties( NodingValidator, staticAccessors$33 );\n\nvar HotPixel = function HotPixel () {\n  this._li = null;\n  this._pt = null;\n  this._originalPt = null;\n  this._ptScaled = null;\n  this._p0Scaled = null;\n  this._p1Scaled = null;\n  this._scaleFactor = null;\n  this._minx = null;\n  this._maxx = null;\n  this._miny = null;\n  this._maxy = null;\n  this._corner = new Array(4).fill(null);\n  this._safeEnv = null;\n  var pt = arguments[0];\n  var scaleFactor = arguments[1];\n  var li = arguments[2];\n  this._originalPt = pt;\n  this._pt = pt;\n  this._scaleFactor = scaleFactor;\n  this._li = li;\n  if (scaleFactor <= 0) { throw new IllegalArgumentException('Scale factor must be non-zero') }\n  if (scaleFactor !== 1.0) {\n    this._pt = new Coordinate(this.scale(pt.x), this.scale(pt.y));\n    this._p0Scaled = new Coordinate();\n    this._p1Scaled = new Coordinate();\n  }\n  this.initCorners(this._pt);\n};\n\nvar staticAccessors$34 = { SAFE_ENV_EXPANSION_FACTOR: { configurable: true } };\nHotPixel.prototype.intersectsScaled = function intersectsScaled (p0, p1) {\n  var segMinx = Math.min(p0.x, p1.x);\n  var segMaxx = Math.max(p0.x, p1.x);\n  var segMiny = Math.min(p0.y, p1.y);\n  var segMaxy = Math.max(p0.y, p1.y);\n  var isOutsidePixelEnv = this._maxx < segMinx || this._minx > segMaxx || this._maxy < segMiny || this._miny > segMaxy;\n  if (isOutsidePixelEnv) { return false }\n  var intersects = this.intersectsToleranceSquare(p0, p1);\n  Assert.isTrue(!(isOutsidePixelEnv && intersects), 'Found bad envelope test');\n  return intersects\n};\nHotPixel.prototype.initCorners = function initCorners (pt) {\n  var tolerance = 0.5;\n  this._minx = pt.x - tolerance;\n  this._maxx = pt.x + tolerance;\n  this._miny = pt.y - tolerance;\n  this._maxy = pt.y + tolerance;\n  this._corner[0] = new Coordinate(this._maxx, this._maxy);\n  this._corner[1] = new Coordinate(this._minx, this._maxy);\n  this._corner[2] = new Coordinate(this._minx, this._miny);\n  this._corner[3] = new Coordinate(this._maxx, this._miny);\n};\nHotPixel.prototype.intersects = function intersects (p0, p1) {\n  if (this._scaleFactor === 1.0) { return this.intersectsScaled(p0, p1) }\n  this.copyScaled(p0, this._p0Scaled);\n  this.copyScaled(p1, this._p1Scaled);\n  return this.intersectsScaled(this._p0Scaled, this._p1Scaled)\n};\nHotPixel.prototype.scale = function scale (val) {\n  return Math.round(val * this._scaleFactor)\n};\nHotPixel.prototype.getCoordinate = function getCoordinate () {\n  return this._originalPt\n};\nHotPixel.prototype.copyScaled = function copyScaled (p, pScaled) {\n  pScaled.x = this.scale(p.x);\n  pScaled.y = this.scale(p.y);\n};\nHotPixel.prototype.getSafeEnvelope = function getSafeEnvelope () {\n  if (this._safeEnv === null) {\n    var safeTolerance = HotPixel.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;\n    this._safeEnv = new Envelope(this._originalPt.x - safeTolerance, this._originalPt.x + safeTolerance, this._originalPt.y - safeTolerance, this._originalPt.y + safeTolerance);\n  }\n  return this._safeEnv\n};\nHotPixel.prototype.intersectsPixelClosure = function intersectsPixelClosure (p0, p1) {\n  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  if (this._li.hasIntersection()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  if (this._li.hasIntersection()) { return true }\n  return false\n};\nHotPixel.prototype.intersectsToleranceSquare = function intersectsToleranceSquare (p0, p1) {\n  var intersectsLeft = false;\n  var intersectsBottom = false;\n  this._li.computeIntersection(p0, p1, this._corner[0], this._corner[1]);\n  if (this._li.isProper()) { return true }\n  this._li.computeIntersection(p0, p1, this._corner[1], this._corner[2]);\n  if (this._li.isProper()) { return true }\n  if (this._li.hasIntersection()) { intersectsLeft = true; }\n  this._li.computeIntersection(p0, p1, this._corner[2], this._corner[3]);\n  if (this._li.isProper()) { return true }\n  if (this._li.hasIntersection()) { intersectsBottom = true; }\n  this._li.computeIntersection(p0, p1, this._corner[3], this._corner[0]);\n  if (this._li.isProper()) { return true }\n  if (intersectsLeft && intersectsBottom) { return true }\n  if (p0.equals(this._pt)) { return true }\n  if (p1.equals(this._pt)) { return true }\n  return false\n};\nHotPixel.prototype.addSnappedNode = function addSnappedNode (segStr, segIndex) {\n  var p0 = segStr.getCoordinate(segIndex);\n  var p1 = segStr.getCoordinate(segIndex + 1);\n  if (this.intersects(p0, p1)) {\n    segStr.addIntersection(this.getCoordinate(), segIndex);\n    return true\n  }\n  return false\n};\nHotPixel.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nHotPixel.prototype.getClass = function getClass () {\n  return HotPixel\n};\nstaticAccessors$34.SAFE_ENV_EXPANSION_FACTOR.get = function () { return 0.75 };\n\nObject.defineProperties( HotPixel, staticAccessors$34 );\n\nvar MonotoneChainSelectAction = function MonotoneChainSelectAction () {\n  this.tempEnv1 = new Envelope();\n  this.selectedSegment = new LineSegment();\n};\nMonotoneChainSelectAction.prototype.select = function select () {\n  if (arguments.length === 1) {\n    // const seg = arguments[0]\n  } else if (arguments.length === 2) {\n    var mc = arguments[0];\n    var startIndex = arguments[1];\n    mc.getLineSegment(startIndex, this.selectedSegment);\n    this.select(this.selectedSegment);\n  }\n};\nMonotoneChainSelectAction.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChainSelectAction.prototype.getClass = function getClass () {\n  return MonotoneChainSelectAction\n};\n\nvar MCIndexPointSnapper = function MCIndexPointSnapper () {\n  this._index = null;\n  var index = arguments[0];\n  this._index = index;\n};\n\nvar staticAccessors$35 = { HotPixelSnapAction: { configurable: true } };\nMCIndexPointSnapper.prototype.snap = function snap () {\n  if (arguments.length === 1) {\n    var hotPixel = arguments[0];\n    return this.snap(hotPixel, null, -1)\n  } else if (arguments.length === 3) {\n    var hotPixel$1 = arguments[0];\n    var parentEdge = arguments[1];\n    var hotPixelVertexIndex = arguments[2];\n    var pixelEnv = hotPixel$1.getSafeEnvelope();\n    var hotPixelSnapAction = new HotPixelSnapAction(hotPixel$1, parentEdge, hotPixelVertexIndex);\n    this._index.query(pixelEnv, {\n      interfaces_: function () {\n        return [ItemVisitor]\n      },\n      visitItem: function (item) {\n        var testChain = item;\n        testChain.select(pixelEnv, hotPixelSnapAction);\n      }\n    });\n    return hotPixelSnapAction.isNodeAdded()\n  }\n};\nMCIndexPointSnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMCIndexPointSnapper.prototype.getClass = function getClass () {\n  return MCIndexPointSnapper\n};\nstaticAccessors$35.HotPixelSnapAction.get = function () { return HotPixelSnapAction };\n\nObject.defineProperties( MCIndexPointSnapper, staticAccessors$35 );\n\nvar HotPixelSnapAction = (function (MonotoneChainSelectAction$$1) {\n  function HotPixelSnapAction () {\n    MonotoneChainSelectAction$$1.call(this);\n    this._hotPixel = null;\n    this._parentEdge = null;\n    this._hotPixelVertexIndex = null;\n    this._isNodeAdded = false;\n    var hotPixel = arguments[0];\n    var parentEdge = arguments[1];\n    var hotPixelVertexIndex = arguments[2];\n    this._hotPixel = hotPixel;\n    this._parentEdge = parentEdge;\n    this._hotPixelVertexIndex = hotPixelVertexIndex;\n  }\n\n  if ( MonotoneChainSelectAction$$1 ) HotPixelSnapAction.__proto__ = MonotoneChainSelectAction$$1;\n  HotPixelSnapAction.prototype = Object.create( MonotoneChainSelectAction$$1 && MonotoneChainSelectAction$$1.prototype );\n  HotPixelSnapAction.prototype.constructor = HotPixelSnapAction;\n  HotPixelSnapAction.prototype.isNodeAdded = function isNodeAdded () {\n    return this._isNodeAdded\n  };\n  HotPixelSnapAction.prototype.select = function select () {\n    if (arguments.length === 2) {\n      var mc = arguments[0];\n      var startIndex = arguments[1];\n      var ss = mc.getContext();\n      if (this._parentEdge !== null) {\n        if (ss === this._parentEdge && startIndex === this._hotPixelVertexIndex) { return null }\n      }\n      this._isNodeAdded = this._hotPixel.addSnappedNode(ss, startIndex);\n    } else { return MonotoneChainSelectAction$$1.prototype.select.apply(this, arguments) }\n  };\n  HotPixelSnapAction.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  HotPixelSnapAction.prototype.getClass = function getClass () {\n    return HotPixelSnapAction\n  };\n\n  return HotPixelSnapAction;\n}(MonotoneChainSelectAction));\n\nvar InteriorIntersectionFinderAdder = function InteriorIntersectionFinderAdder () {\n  this._li = null;\n  this._interiorIntersections = null;\n  var li = arguments[0];\n  this._li = li;\n  this._interiorIntersections = new ArrayList();\n};\nInteriorIntersectionFinderAdder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n    var this$1 = this;\n\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._li.isInteriorIntersection()) {\n      for (var intIndex = 0; intIndex < this._li.getIntersectionNum(); intIndex++) {\n        this$1._interiorIntersections.add(this$1._li.getIntersection(intIndex));\n      }\n      e0.addIntersections(this._li, segIndex0, 0);\n      e1.addIntersections(this._li, segIndex1, 1);\n    }\n  }\n};\nInteriorIntersectionFinderAdder.prototype.isDone = function isDone () {\n  return false\n};\nInteriorIntersectionFinderAdder.prototype.getInteriorIntersections = function getInteriorIntersections () {\n  return this._interiorIntersections\n};\nInteriorIntersectionFinderAdder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nInteriorIntersectionFinderAdder.prototype.getClass = function getClass () {\n  return InteriorIntersectionFinderAdder\n};\n\nvar MCIndexSnapRounder = function MCIndexSnapRounder () {\n  this._pm = null;\n  this._li = null;\n  this._scaleFactor = null;\n  this._noder = null;\n  this._pointSnapper = null;\n  this._nodedSegStrings = null;\n  var pm = arguments[0];\n  this._pm = pm;\n  this._li = new RobustLineIntersector();\n  this._li.setPrecisionModel(pm);\n  this._scaleFactor = pm.getScale();\n};\nMCIndexSnapRounder.prototype.checkCorrectness = function checkCorrectness (inputSegmentStrings) {\n  var resultSegStrings = NodedSegmentString.getNodedSubstrings(inputSegmentStrings);\n  var nv = new NodingValidator(resultSegStrings);\n  try {\n    nv.checkValid();\n  } catch (ex) {\n    if (ex instanceof Exception) {\n      ex.printStackTrace();\n    } else { throw ex }\n  } finally {}\n};\nMCIndexSnapRounder.prototype.getNodedSubstrings = function getNodedSubstrings () {\n  return NodedSegmentString.getNodedSubstrings(this._nodedSegStrings)\n};\nMCIndexSnapRounder.prototype.snapRound = function snapRound (segStrings, li) {\n  var intersections = this.findInteriorIntersections(segStrings, li);\n  this.computeIntersectionSnaps(intersections);\n  this.computeVertexSnaps(segStrings);\n};\nMCIndexSnapRounder.prototype.findInteriorIntersections = function findInteriorIntersections (segStrings, li) {\n  var intFinderAdder = new InteriorIntersectionFinderAdder(li);\n  this._noder.setSegmentIntersector(intFinderAdder);\n  this._noder.computeNodes(segStrings);\n  return intFinderAdder.getInteriorIntersections()\n};\nMCIndexSnapRounder.prototype.computeVertexSnaps = function computeVertexSnaps () {\n    var this$1 = this;\n\n  if (hasInterface(arguments[0], Collection)) {\n    var edges = arguments[0];\n    for (var i0 = edges.iterator(); i0.hasNext();) {\n      var edge0 = i0.next();\n      this$1.computeVertexSnaps(edge0);\n    }\n  } else if (arguments[0] instanceof NodedSegmentString) {\n    var e = arguments[0];\n    var pts0 = e.getCoordinates();\n    for (var i = 0; i < pts0.length; i++) {\n      var hotPixel = new HotPixel(pts0[i], this$1._scaleFactor, this$1._li);\n      var isNodeAdded = this$1._pointSnapper.snap(hotPixel, e, i);\n      if (isNodeAdded) {\n        e.addIntersection(pts0[i], i);\n      }\n    }\n  }\n};\nMCIndexSnapRounder.prototype.computeNodes = function computeNodes (inputSegmentStrings) {\n  this._nodedSegStrings = inputSegmentStrings;\n  this._noder = new MCIndexNoder();\n  this._pointSnapper = new MCIndexPointSnapper(this._noder.getIndex());\n  this.snapRound(inputSegmentStrings, this._li);\n};\nMCIndexSnapRounder.prototype.computeIntersectionSnaps = function computeIntersectionSnaps (snapPts) {\n    var this$1 = this;\n\n  for (var it = snapPts.iterator(); it.hasNext();) {\n    var snapPt = it.next();\n    var hotPixel = new HotPixel(snapPt, this$1._scaleFactor, this$1._li);\n    this$1._pointSnapper.snap(hotPixel);\n  }\n};\nMCIndexSnapRounder.prototype.interfaces_ = function interfaces_ () {\n  return [Noder]\n};\nMCIndexSnapRounder.prototype.getClass = function getClass () {\n  return MCIndexSnapRounder\n};\n\nvar BufferOp = function BufferOp () {\n  this._argGeom = null;\n  this._distance = null;\n  this._bufParams = new BufferParameters();\n  this._resultGeometry = null;\n  this._saveException = null;\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    this._argGeom = g;\n  } else if (arguments.length === 2) {\n    var g$1 = arguments[0];\n    var bufParams = arguments[1];\n    this._argGeom = g$1;\n    this._bufParams = bufParams;\n  }\n};\n\nvar staticAccessors$32 = { CAP_ROUND: { configurable: true },CAP_BUTT: { configurable: true },CAP_FLAT: { configurable: true },CAP_SQUARE: { configurable: true },MAX_PRECISION_DIGITS: { configurable: true } };\nBufferOp.prototype.bufferFixedPrecision = function bufferFixedPrecision (fixedPM) {\n  var noder = new ScaledNoder(new MCIndexSnapRounder(new PrecisionModel(1.0)), fixedPM.getScale());\n  var bufBuilder = new BufferBuilder(this._bufParams);\n  bufBuilder.setWorkingPrecisionModel(fixedPM);\n  bufBuilder.setNoder(noder);\n  this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n};\nBufferOp.prototype.bufferReducedPrecision = function bufferReducedPrecision () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    for (var precDigits = BufferOp.MAX_PRECISION_DIGITS; precDigits >= 0; precDigits--) {\n      try {\n        this$1.bufferReducedPrecision(precDigits);\n      } catch (ex) {\n        if (ex instanceof TopologyException) {\n          this$1._saveException = ex;\n        } else { throw ex }\n      } finally {}\n      if (this$1._resultGeometry !== null) { return null }\n    }\n    throw this._saveException\n  } else if (arguments.length === 1) {\n    var precisionDigits = arguments[0];\n    var sizeBasedScaleFactor = BufferOp.precisionScaleFactor(this._argGeom, this._distance, precisionDigits);\n    var fixedPM = new PrecisionModel(sizeBasedScaleFactor);\n    this.bufferFixedPrecision(fixedPM);\n  }\n};\nBufferOp.prototype.computeGeometry = function computeGeometry () {\n  this.bufferOriginalPrecision();\n  if (this._resultGeometry !== null) { return null }\n  var argPM = this._argGeom.getFactory().getPrecisionModel();\n  if (argPM.getType() === PrecisionModel.FIXED) { this.bufferFixedPrecision(argPM); } else { this.bufferReducedPrecision(); }\n};\nBufferOp.prototype.setQuadrantSegments = function setQuadrantSegments (quadrantSegments) {\n  this._bufParams.setQuadrantSegments(quadrantSegments);\n};\nBufferOp.prototype.bufferOriginalPrecision = function bufferOriginalPrecision () {\n  try {\n    var bufBuilder = new BufferBuilder(this._bufParams);\n    this._resultGeometry = bufBuilder.buffer(this._argGeom, this._distance);\n  } catch (ex) {\n    if (ex instanceof RuntimeException) {\n      this._saveException = ex;\n    } else { throw ex }\n  } finally {}\n};\nBufferOp.prototype.getResultGeometry = function getResultGeometry (distance) {\n  this._distance = distance;\n  this.computeGeometry();\n  return this._resultGeometry\n};\nBufferOp.prototype.setEndCapStyle = function setEndCapStyle (endCapStyle) {\n  this._bufParams.setEndCapStyle(endCapStyle);\n};\nBufferOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferOp.prototype.getClass = function getClass () {\n  return BufferOp\n};\nBufferOp.bufferOp = function bufferOp () {\n  if (arguments.length === 2) {\n    var g = arguments[0];\n    var distance = arguments[1];\n    var gBuf = new BufferOp(g);\n    var geomBuf = gBuf.getResultGeometry(distance);\n    return geomBuf\n  } else if (arguments.length === 3) {\n    if (Number.isInteger(arguments[2]) && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n      var g$1 = arguments[0];\n      var distance$1 = arguments[1];\n      var quadrantSegments = arguments[2];\n      var bufOp = new BufferOp(g$1);\n      bufOp.setQuadrantSegments(quadrantSegments);\n      var geomBuf$1 = bufOp.getResultGeometry(distance$1);\n      return geomBuf$1\n    } else if (arguments[2] instanceof BufferParameters && (arguments[0] instanceof Geometry && typeof arguments[1] === 'number')) {\n      var g$2 = arguments[0];\n      var distance$2 = arguments[1];\n      var params = arguments[2];\n      var bufOp$1 = new BufferOp(g$2, params);\n      var geomBuf$2 = bufOp$1.getResultGeometry(distance$2);\n      return geomBuf$2\n    }\n  } else if (arguments.length === 4) {\n    var g$3 = arguments[0];\n    var distance$3 = arguments[1];\n    var quadrantSegments$1 = arguments[2];\n    var endCapStyle = arguments[3];\n    var bufOp$2 = new BufferOp(g$3);\n    bufOp$2.setQuadrantSegments(quadrantSegments$1);\n    bufOp$2.setEndCapStyle(endCapStyle);\n    var geomBuf$3 = bufOp$2.getResultGeometry(distance$3);\n    return geomBuf$3\n  }\n};\nBufferOp.precisionScaleFactor = function precisionScaleFactor (g, distance, maxPrecisionDigits) {\n  var env = g.getEnvelopeInternal();\n  var envMax = MathUtil.max(Math.abs(env.getMaxX()), Math.abs(env.getMaxY()), Math.abs(env.getMinX()), Math.abs(env.getMinY()));\n  var expandByDistance = distance > 0.0 ? distance : 0.0;\n  var bufEnvMax = envMax + 2 * expandByDistance;\n  var bufEnvPrecisionDigits = Math.trunc(Math.log(bufEnvMax) / Math.log(10) + 1.0);\n  var minUnitLog10 = maxPrecisionDigits - bufEnvPrecisionDigits;\n  var scaleFactor = Math.pow(10.0, minUnitLog10);\n  return scaleFactor\n};\nstaticAccessors$32.CAP_ROUND.get = function () { return BufferParameters.CAP_ROUND };\nstaticAccessors$32.CAP_BUTT.get = function () { return BufferParameters.CAP_FLAT };\nstaticAccessors$32.CAP_FLAT.get = function () { return BufferParameters.CAP_FLAT };\nstaticAccessors$32.CAP_SQUARE.get = function () { return BufferParameters.CAP_SQUARE };\nstaticAccessors$32.MAX_PRECISION_DIGITS.get = function () { return 12 };\n\nObject.defineProperties( BufferOp, staticAccessors$32 );\n\nvar PointPairDistance = function PointPairDistance () {\n  this._pt = [new Coordinate(), new Coordinate()];\n  this._distance = Double.NaN;\n  this._isNull = true;\n};\nPointPairDistance.prototype.getCoordinates = function getCoordinates () {\n  return this._pt\n};\nPointPairDistance.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pt[i]\n};\nPointPairDistance.prototype.setMinimum = function setMinimum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist < this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance.prototype.initialize = function initialize () {\n  if (arguments.length === 0) {\n    this._isNull = true;\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this._pt[0].setCoordinate(p0);\n    this._pt[1].setCoordinate(p1);\n    this._distance = p0.distance(p1);\n    this._isNull = false;\n  } else if (arguments.length === 3) {\n    var p0$1 = arguments[0];\n    var p1$1 = arguments[1];\n    var distance = arguments[2];\n    this._pt[0].setCoordinate(p0$1);\n    this._pt[1].setCoordinate(p1$1);\n    this._distance = distance;\n    this._isNull = false;\n  }\n};\nPointPairDistance.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nPointPairDistance.prototype.setMaximum = function setMaximum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist > this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointPairDistance.prototype.getClass = function getClass () {\n  return PointPairDistance\n};\n\nvar DistanceToPointFinder = function DistanceToPointFinder () {};\n\nDistanceToPointFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceToPointFinder.prototype.getClass = function getClass () {\n  return DistanceToPointFinder\n};\nDistanceToPointFinder.computeDistance = function computeDistance () {\n  if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {\n    var line = arguments[0];\n    var pt = arguments[1];\n    var ptDist = arguments[2];\n    var coords = line.getCoordinates();\n    var tempSegment = new LineSegment();\n    for (var i = 0; i < coords.length - 1; i++) {\n      tempSegment.setCoordinates(coords[i], coords[i + 1]);\n      var closestPt = tempSegment.closestPoint(pt);\n      ptDist.setMinimum(closestPt, pt);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {\n    var poly = arguments[0];\n    var pt$1 = arguments[1];\n    var ptDist$1 = arguments[2];\n    DistanceToPointFinder.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);\n    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {\n      DistanceToPointFinder.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {\n    var geom = arguments[0];\n    var pt$2 = arguments[1];\n    var ptDist$2 = arguments[2];\n    if (geom instanceof LineString) {\n      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof Polygon) {\n      DistanceToPointFinder.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof GeometryCollection) {\n      var gc = geom;\n      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {\n        var g = gc.getGeometryN(i$2);\n        DistanceToPointFinder.computeDistance(g, pt$2, ptDist$2);\n      }\n    } else {\n      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);\n    }\n  } else if (arguments[2] instanceof PointPairDistance && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {\n    var segment = arguments[0];\n    var pt$3 = arguments[1];\n    var ptDist$3 = arguments[2];\n    var closestPt$1 = segment.closestPoint(pt$3);\n    ptDist$3.setMinimum(closestPt$1, pt$3);\n  }\n};\n\nvar BufferCurveMaximumDistanceFinder = function BufferCurveMaximumDistanceFinder (inputGeom) {\n  this._maxPtDist = new PointPairDistance();\n  this._inputGeom = inputGeom || null;\n};\n\nvar staticAccessors$36 = { MaxPointDistanceFilter: { configurable: true },MaxMidpointDistanceFilter: { configurable: true } };\nBufferCurveMaximumDistanceFinder.prototype.computeMaxMidpointDistance = function computeMaxMidpointDistance (curve) {\n  var distFilter = new MaxMidpointDistanceFilter(this._inputGeom);\n  curve.apply(distFilter);\n  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());\n};\nBufferCurveMaximumDistanceFinder.prototype.computeMaxVertexDistance = function computeMaxVertexDistance (curve) {\n  var distFilter = new MaxPointDistanceFilter(this._inputGeom);\n  curve.apply(distFilter);\n  this._maxPtDist.setMaximum(distFilter.getMaxPointDistance());\n};\nBufferCurveMaximumDistanceFinder.prototype.findDistance = function findDistance (bufferCurve) {\n  this.computeMaxVertexDistance(bufferCurve);\n  this.computeMaxMidpointDistance(bufferCurve);\n  return this._maxPtDist.getDistance()\n};\nBufferCurveMaximumDistanceFinder.prototype.getDistancePoints = function getDistancePoints () {\n  return this._maxPtDist\n};\nBufferCurveMaximumDistanceFinder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferCurveMaximumDistanceFinder.prototype.getClass = function getClass () {\n  return BufferCurveMaximumDistanceFinder\n};\nstaticAccessors$36.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter };\nstaticAccessors$36.MaxMidpointDistanceFilter.get = function () { return MaxMidpointDistanceFilter };\n\nObject.defineProperties( BufferCurveMaximumDistanceFinder, staticAccessors$36 );\n\nvar MaxPointDistanceFilter = function MaxPointDistanceFilter (geom) {\n  this._maxPtDist = new PointPairDistance();\n  this._minPtDist = new PointPairDistance();\n  this._geom = geom || null;\n};\nMaxPointDistanceFilter.prototype.filter = function filter (pt) {\n  this._minPtDist.initialize();\n  DistanceToPointFinder.computeDistance(this._geom, pt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxPointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxPointDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nMaxPointDistanceFilter.prototype.getClass = function getClass () {\n  return MaxPointDistanceFilter\n};\n\nvar MaxMidpointDistanceFilter = function MaxMidpointDistanceFilter (geom) {\n  this._maxPtDist = new PointPairDistance();\n  this._minPtDist = new PointPairDistance();\n  this._geom = geom || null;\n};\nMaxMidpointDistanceFilter.prototype.filter = function filter (seq, index) {\n  if (index === 0) { return null }\n  var p0 = seq.getCoordinate(index - 1);\n  var p1 = seq.getCoordinate(index);\n  var midPt = new Coordinate((p0.x + p1.x) / 2, (p0.y + p1.y) / 2);\n  this._minPtDist.initialize();\n  DistanceToPointFinder.computeDistance(this._geom, midPt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxMidpointDistanceFilter.prototype.isDone = function isDone () {\n  return false\n};\nMaxMidpointDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged () {\n  return false\n};\nMaxMidpointDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxMidpointDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nMaxMidpointDistanceFilter.prototype.getClass = function getClass () {\n  return MaxMidpointDistanceFilter\n};\n\nvar PolygonExtracter = function PolygonExtracter (comps) {\n  this._comps = comps || null;\n};\nPolygonExtracter.prototype.filter = function filter (geom) {\n  if (geom instanceof Polygon) { this._comps.add(geom); }\n};\nPolygonExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPolygonExtracter.prototype.getClass = function getClass () {\n  return PolygonExtracter\n};\nPolygonExtracter.getPolygons = function getPolygons () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return PolygonExtracter.getPolygons(geom, new ArrayList())\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var list = arguments[1];\n    if (geom$1 instanceof Polygon) {\n      list.add(geom$1);\n    } else if (geom$1 instanceof GeometryCollection) {\n      geom$1.apply(new PolygonExtracter(list));\n    }\n    return list\n  }\n};\n\nvar LinearComponentExtracter = function LinearComponentExtracter () {\n  this._lines = null;\n  this._isForcedToLineString = false;\n  if (arguments.length === 1) {\n    var lines = arguments[0];\n    this._lines = lines;\n  } else if (arguments.length === 2) {\n    var lines$1 = arguments[0];\n    var isForcedToLineString = arguments[1];\n    this._lines = lines$1;\n    this._isForcedToLineString = isForcedToLineString;\n  }\n};\nLinearComponentExtracter.prototype.filter = function filter (geom) {\n  if (this._isForcedToLineString && geom instanceof LinearRing) {\n    var line = geom.getFactory().createLineString(geom.getCoordinateSequence());\n    this._lines.add(line);\n    return null\n  }\n  if (geom instanceof LineString) { this._lines.add(geom); }\n};\nLinearComponentExtracter.prototype.setForceToLineString = function setForceToLineString (isForcedToLineString) {\n  this._isForcedToLineString = isForcedToLineString;\n};\nLinearComponentExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryComponentFilter]\n};\nLinearComponentExtracter.prototype.getClass = function getClass () {\n  return LinearComponentExtracter\n};\nLinearComponentExtracter.getGeometry = function getGeometry () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return geom.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom))\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var forceToLineString = arguments[1];\n    return geom$1.getFactory().buildGeometry(LinearComponentExtracter.getLines(geom$1, forceToLineString))\n  }\n};\nLinearComponentExtracter.getLines = function getLines () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    return LinearComponentExtracter.getLines(geom, false)\n  } else if (arguments.length === 2) {\n    if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection)) {\n      var geoms = arguments[0];\n      var lines$1 = arguments[1];\n      for (var i = geoms.iterator(); i.hasNext();) {\n        var g = i.next();\n        LinearComponentExtracter.getLines(g, lines$1);\n      }\n      return lines$1\n    } else if (arguments[0] instanceof Geometry && typeof arguments[1] === 'boolean') {\n      var geom$1 = arguments[0];\n      var forceToLineString = arguments[1];\n      var lines = new ArrayList();\n      geom$1.apply(new LinearComponentExtracter(lines, forceToLineString));\n      return lines\n    } else if (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection)) {\n      var geom$2 = arguments[0];\n      var lines$2 = arguments[1];\n      if (geom$2 instanceof LineString) {\n        lines$2.add(geom$2);\n      } else {\n        geom$2.apply(new LinearComponentExtracter(lines$2));\n      }\n      return lines$2\n    }\n  } else if (arguments.length === 3) {\n    if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], Collection))) {\n      var geoms$1 = arguments[0];\n      var lines$3 = arguments[1];\n      var forceToLineString$1 = arguments[2];\n      for (var i$1 = geoms$1.iterator(); i$1.hasNext();) {\n        var g$1 = i$1.next();\n        LinearComponentExtracter.getLines(g$1, lines$3, forceToLineString$1);\n      }\n      return lines$3\n    } else if (typeof arguments[2] === 'boolean' && (arguments[0] instanceof Geometry && hasInterface(arguments[1], Collection))) {\n      var geom$3 = arguments[0];\n      var lines$4 = arguments[1];\n      var forceToLineString$2 = arguments[2];\n      geom$3.apply(new LinearComponentExtracter(lines$4, forceToLineString$2));\n      return lines$4\n    }\n  }\n};\n\nvar PointLocator = function PointLocator () {\n  this._boundaryRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n  this._isIn = null;\n  this._numBoundaries = null;\n  if (arguments.length === 0) {} else if (arguments.length === 1) {\n    var boundaryRule = arguments[0];\n    if (boundaryRule === null) { throw new IllegalArgumentException('Rule must be non-null') }\n    this._boundaryRule = boundaryRule;\n  }\n};\nPointLocator.prototype.locateInternal = function locateInternal () {\n    var this$1 = this;\n\n  if (arguments[0] instanceof Coordinate && arguments[1] instanceof Polygon) {\n    var p = arguments[0];\n    var poly = arguments[1];\n    if (poly.isEmpty()) { return Location.EXTERIOR }\n    var shell = poly.getExteriorRing();\n    var shellLoc = this.locateInPolygonRing(p, shell);\n    if (shellLoc === Location.EXTERIOR) { return Location.EXTERIOR }\n    if (shellLoc === Location.BOUNDARY) { return Location.BOUNDARY }\n    for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n      var hole = poly.getInteriorRingN(i);\n      var holeLoc = this$1.locateInPolygonRing(p, hole);\n      if (holeLoc === Location.INTERIOR) { return Location.EXTERIOR }\n      if (holeLoc === Location.BOUNDARY) { return Location.BOUNDARY }\n    }\n    return Location.INTERIOR\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof LineString) {\n    var p$1 = arguments[0];\n    var l = arguments[1];\n    if (!l.getEnvelopeInternal().intersects(p$1)) { return Location.EXTERIOR }\n    var pt = l.getCoordinates();\n    if (!l.isClosed()) {\n      if (p$1.equals(pt[0]) || p$1.equals(pt[pt.length - 1])) {\n        return Location.BOUNDARY\n      }\n    }\n    if (CGAlgorithms.isOnLine(p$1, pt)) { return Location.INTERIOR }\n    return Location.EXTERIOR\n  } else if (arguments[0] instanceof Coordinate && arguments[1] instanceof Point) {\n    var p$2 = arguments[0];\n    var pt$1 = arguments[1];\n    var ptCoord = pt$1.getCoordinate();\n    if (ptCoord.equals2D(p$2)) { return Location.INTERIOR }\n    return Location.EXTERIOR\n  }\n};\nPointLocator.prototype.locateInPolygonRing = function locateInPolygonRing (p, ring) {\n  if (!ring.getEnvelopeInternal().intersects(p)) { return Location.EXTERIOR }\n  return CGAlgorithms.locatePointInRing(p, ring.getCoordinates())\n};\nPointLocator.prototype.intersects = function intersects (p, geom) {\n  return this.locate(p, geom) !== Location.EXTERIOR\n};\nPointLocator.prototype.updateLocationInfo = function updateLocationInfo (loc) {\n  if (loc === Location.INTERIOR) { this._isIn = true; }\n  if (loc === Location.BOUNDARY) { this._numBoundaries++; }\n};\nPointLocator.prototype.computeLocation = function computeLocation (p, geom) {\n    var this$1 = this;\n\n  if (geom instanceof Point) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  }\n  if (geom instanceof LineString) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  } else if (geom instanceof Polygon) {\n    this.updateLocationInfo(this.locateInternal(p, geom));\n  } else if (geom instanceof MultiLineString) {\n    var ml = geom;\n    for (var i = 0; i < ml.getNumGeometries(); i++) {\n      var l = ml.getGeometryN(i);\n      this$1.updateLocationInfo(this$1.locateInternal(p, l));\n    }\n  } else if (geom instanceof MultiPolygon) {\n    var mpoly = geom;\n    for (var i$1 = 0; i$1 < mpoly.getNumGeometries(); i$1++) {\n      var poly = mpoly.getGeometryN(i$1);\n      this$1.updateLocationInfo(this$1.locateInternal(p, poly));\n    }\n  } else if (geom instanceof GeometryCollection) {\n    var geomi = new GeometryCollectionIterator(geom);\n    while (geomi.hasNext()) {\n      var g2 = geomi.next();\n      if (g2 !== geom) { this$1.computeLocation(p, g2); }\n    }\n  }\n};\nPointLocator.prototype.locate = function locate (p, geom) {\n  if (geom.isEmpty()) { return Location.EXTERIOR }\n  if (geom instanceof LineString) {\n    return this.locateInternal(p, geom)\n  } else if (geom instanceof Polygon) {\n    return this.locateInternal(p, geom)\n  }\n  this._isIn = false;\n  this._numBoundaries = 0;\n  this.computeLocation(p, geom);\n  if (this._boundaryRule.isInBoundary(this._numBoundaries)) { return Location.BOUNDARY }\n  if (this._numBoundaries > 0 || this._isIn) { return Location.INTERIOR }\n  return Location.EXTERIOR\n};\nPointLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointLocator.prototype.getClass = function getClass () {\n  return PointLocator\n};\n\nvar GeometryLocation = function GeometryLocation () {\n  this._component = null;\n  this._segIndex = null;\n  this._pt = null;\n  if (arguments.length === 2) {\n    var component = arguments[0];\n    var pt = arguments[1];\n    GeometryLocation.call(this, component, GeometryLocation.INSIDE_AREA, pt);\n  } else if (arguments.length === 3) {\n    var component$1 = arguments[0];\n    var segIndex = arguments[1];\n    var pt$1 = arguments[2];\n    this._component = component$1;\n    this._segIndex = segIndex;\n    this._pt = pt$1;\n  }\n};\n\nvar staticAccessors$38 = { INSIDE_AREA: { configurable: true } };\nGeometryLocation.prototype.isInsideArea = function isInsideArea () {\n  return this._segIndex === GeometryLocation.INSIDE_AREA\n};\nGeometryLocation.prototype.getCoordinate = function getCoordinate () {\n  return this._pt\n};\nGeometryLocation.prototype.getGeometryComponent = function getGeometryComponent () {\n  return this._component\n};\nGeometryLocation.prototype.getSegmentIndex = function getSegmentIndex () {\n  return this._segIndex\n};\nGeometryLocation.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryLocation.prototype.getClass = function getClass () {\n  return GeometryLocation\n};\nstaticAccessors$38.INSIDE_AREA.get = function () { return -1 };\n\nObject.defineProperties( GeometryLocation, staticAccessors$38 );\n\nvar PointExtracter = function PointExtracter (pts) {\n  this._pts = pts || null;\n};\nPointExtracter.prototype.filter = function filter (geom) {\n  if (geom instanceof Point) { this._pts.add(geom); }\n};\nPointExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPointExtracter.prototype.getClass = function getClass () {\n  return PointExtracter\n};\nPointExtracter.getPoints = function getPoints () {\n  if (arguments.length === 1) {\n    var geom = arguments[0];\n    if (geom instanceof Point) {\n      return Collections.singletonList(geom)\n    }\n    return PointExtracter.getPoints(geom, new ArrayList())\n  } else if (arguments.length === 2) {\n    var geom$1 = arguments[0];\n    var list = arguments[1];\n    if (geom$1 instanceof Point) {\n      list.add(geom$1);\n    } else if (geom$1 instanceof GeometryCollection) {\n      geom$1.apply(new PointExtracter(list));\n    }\n    return list\n  }\n};\n\nvar ConnectedElementLocationFilter = function ConnectedElementLocationFilter () {\n  this._locations = null;\n  var locations = arguments[0];\n  this._locations = locations;\n};\nConnectedElementLocationFilter.prototype.filter = function filter (geom) {\n  if (geom instanceof Point || geom instanceof LineString || geom instanceof Polygon) { this._locations.add(new GeometryLocation(geom, 0, geom.getCoordinate())); }\n};\nConnectedElementLocationFilter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nConnectedElementLocationFilter.prototype.getClass = function getClass () {\n  return ConnectedElementLocationFilter\n};\nConnectedElementLocationFilter.getLocations = function getLocations (geom) {\n  var locations = new ArrayList();\n  geom.apply(new ConnectedElementLocationFilter(locations));\n  return locations\n};\n\nvar DistanceOp = function DistanceOp () {\n  this._geom = null;\n  this._terminateDistance = 0.0;\n  this._ptLocator = new PointLocator();\n  this._minDistanceLocation = null;\n  this._minDistance = Double.MAX_VALUE;\n  if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    this._geom = [g0, g1];\n    this._terminateDistance = 0.0;\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var terminateDistance = arguments[2];\n    this._geom = new Array(2).fill(null);\n    this._geom[0] = g0$1;\n    this._geom[1] = g1$1;\n    this._terminateDistance = terminateDistance;\n  }\n};\nDistanceOp.prototype.computeContainmentDistance = function computeContainmentDistance () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    var locPtPoly = new Array(2).fill(null);\n    this.computeContainmentDistance(0, locPtPoly);\n    if (this._minDistance <= this._terminateDistance) { return null }\n    this.computeContainmentDistance(1, locPtPoly);\n  } else if (arguments.length === 2) {\n    var polyGeomIndex = arguments[0];\n    var locPtPoly$1 = arguments[1];\n    var locationsIndex = 1 - polyGeomIndex;\n    var polys = PolygonExtracter.getPolygons(this._geom[polyGeomIndex]);\n    if (polys.size() > 0) {\n      var insideLocs = ConnectedElementLocationFilter.getLocations(this._geom[locationsIndex]);\n      this.computeContainmentDistance(insideLocs, polys, locPtPoly$1);\n      if (this._minDistance <= this._terminateDistance) {\n        this._minDistanceLocation[locationsIndex] = locPtPoly$1[0];\n        this._minDistanceLocation[polyGeomIndex] = locPtPoly$1[1];\n        return null\n      }\n    }\n  } else if (arguments.length === 3) {\n    if (arguments[2] instanceof Array && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n      var locs = arguments[0];\n      var polys$1 = arguments[1];\n      var locPtPoly$2 = arguments[2];\n      for (var i = 0; i < locs.size(); i++) {\n        var loc = locs.get(i);\n        for (var j = 0; j < polys$1.size(); j++) {\n          this$1.computeContainmentDistance(loc, polys$1.get(j), locPtPoly$2);\n          if (this$1._minDistance <= this$1._terminateDistance) { return null }\n        }\n      }\n    } else if (arguments[2] instanceof Array && (arguments[0] instanceof GeometryLocation && arguments[1] instanceof Polygon)) {\n      var ptLoc = arguments[0];\n      var poly = arguments[1];\n      var locPtPoly$3 = arguments[2];\n      var pt = ptLoc.getCoordinate();\n      if (Location.EXTERIOR !== this._ptLocator.locate(pt, poly)) {\n        this._minDistance = 0.0;\n        locPtPoly$3[0] = ptLoc;\n        locPtPoly$3[1] = new GeometryLocation(poly, pt);\n\n        return null\n      }\n    }\n  }\n};\nDistanceOp.prototype.computeMinDistanceLinesPoints = function computeMinDistanceLinesPoints (lines, points, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < lines.size(); i++) {\n    var line = lines.get(i);\n    for (var j = 0; j < points.size(); j++) {\n      var pt = points.get(j);\n      this$1.computeMinDistance(line, pt, locGeom);\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.computeFacetDistance = function computeFacetDistance () {\n  var locGeom = new Array(2).fill(null);\n  var lines0 = LinearComponentExtracter.getLines(this._geom[0]);\n  var lines1 = LinearComponentExtracter.getLines(this._geom[1]);\n  var pts0 = PointExtracter.getPoints(this._geom[0]);\n  var pts1 = PointExtracter.getPoints(this._geom[1]);\n  this.computeMinDistanceLines(lines0, lines1, locGeom);\n  this.updateMinDistance(locGeom, false);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistanceLinesPoints(lines0, pts1, locGeom);\n  this.updateMinDistance(locGeom, false);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistanceLinesPoints(lines1, pts0, locGeom);\n  this.updateMinDistance(locGeom, true);\n  if (this._minDistance <= this._terminateDistance) { return null }\n  locGeom[0] = null;\n  locGeom[1] = null;\n  this.computeMinDistancePoints(pts0, pts1, locGeom);\n  this.updateMinDistance(locGeom, false);\n};\nDistanceOp.prototype.nearestLocations = function nearestLocations () {\n  this.computeMinDistance();\n  return this._minDistanceLocation\n};\nDistanceOp.prototype.updateMinDistance = function updateMinDistance (locGeom, flip) {\n  if (locGeom[0] === null) { return null }\n  if (flip) {\n    this._minDistanceLocation[0] = locGeom[1];\n    this._minDistanceLocation[1] = locGeom[0];\n  } else {\n    this._minDistanceLocation[0] = locGeom[0];\n    this._minDistanceLocation[1] = locGeom[1];\n  }\n};\nDistanceOp.prototype.nearestPoints = function nearestPoints () {\n  this.computeMinDistance();\n  var nearestPts = [this._minDistanceLocation[0].getCoordinate(), this._minDistanceLocation[1].getCoordinate()];\n  return nearestPts\n};\nDistanceOp.prototype.computeMinDistance = function computeMinDistance () {\n    var this$1 = this;\n\n  if (arguments.length === 0) {\n    if (this._minDistanceLocation !== null) { return null }\n    this._minDistanceLocation = new Array(2).fill(null);\n    this.computeContainmentDistance();\n    if (this._minDistance <= this._terminateDistance) { return null }\n    this.computeFacetDistance();\n  } else if (arguments.length === 3) {\n    if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof Point)) {\n      var line = arguments[0];\n      var pt = arguments[1];\n      var locGeom = arguments[2];\n      if (line.getEnvelopeInternal().distance(pt.getEnvelopeInternal()) > this._minDistance) { return null }\n      var coord0 = line.getCoordinates();\n      var coord = pt.getCoordinate();\n      for (var i = 0; i < coord0.length - 1; i++) {\n        var dist = CGAlgorithms.distancePointLine(coord, coord0[i], coord0[i + 1]);\n        if (dist < this$1._minDistance) {\n          this$1._minDistance = dist;\n          var seg = new LineSegment(coord0[i], coord0[i + 1]);\n          var segClosestPoint = seg.closestPoint(coord);\n          locGeom[0] = new GeometryLocation(line, i, segClosestPoint);\n          locGeom[1] = new GeometryLocation(pt, 0, coord);\n        }\n        if (this$1._minDistance <= this$1._terminateDistance) { return null }\n      }\n    } else if (arguments[2] instanceof Array && (arguments[0] instanceof LineString && arguments[1] instanceof LineString)) {\n      var line0 = arguments[0];\n      var line1 = arguments[1];\n      var locGeom$1 = arguments[2];\n      if (line0.getEnvelopeInternal().distance(line1.getEnvelopeInternal()) > this._minDistance) { return null }\n      var coord0$1 = line0.getCoordinates();\n      var coord1 = line1.getCoordinates();\n      for (var i$1 = 0; i$1 < coord0$1.length - 1; i$1++) {\n        for (var j = 0; j < coord1.length - 1; j++) {\n          var dist$1 = CGAlgorithms.distanceLineLine(coord0$1[i$1], coord0$1[i$1 + 1], coord1[j], coord1[j + 1]);\n          if (dist$1 < this$1._minDistance) {\n            this$1._minDistance = dist$1;\n            var seg0 = new LineSegment(coord0$1[i$1], coord0$1[i$1 + 1]);\n            var seg1 = new LineSegment(coord1[j], coord1[j + 1]);\n            var closestPt = seg0.closestPoints(seg1);\n            locGeom$1[0] = new GeometryLocation(line0, i$1, closestPt[0]);\n            locGeom$1[1] = new GeometryLocation(line1, j, closestPt[1]);\n          }\n          if (this$1._minDistance <= this$1._terminateDistance) { return null }\n        }\n      }\n    }\n  }\n};\nDistanceOp.prototype.computeMinDistancePoints = function computeMinDistancePoints (points0, points1, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < points0.size(); i++) {\n    var pt0 = points0.get(i);\n    for (var j = 0; j < points1.size(); j++) {\n      var pt1 = points1.get(j);\n      var dist = pt0.getCoordinate().distance(pt1.getCoordinate());\n      if (dist < this$1._minDistance) {\n        this$1._minDistance = dist;\n        locGeom[0] = new GeometryLocation(pt0, 0, pt0.getCoordinate());\n        locGeom[1] = new GeometryLocation(pt1, 0, pt1.getCoordinate());\n      }\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.distance = function distance () {\n  if (this._geom[0] === null || this._geom[1] === null) { throw new IllegalArgumentException('null geometries are not supported') }\n  if (this._geom[0].isEmpty() || this._geom[1].isEmpty()) { return 0.0 }\n  this.computeMinDistance();\n  return this._minDistance\n};\nDistanceOp.prototype.computeMinDistanceLines = function computeMinDistanceLines (lines0, lines1, locGeom) {\n    var this$1 = this;\n\n  for (var i = 0; i < lines0.size(); i++) {\n    var line0 = lines0.get(i);\n    for (var j = 0; j < lines1.size(); j++) {\n      var line1 = lines1.get(j);\n      this$1.computeMinDistance(line0, line1, locGeom);\n      if (this$1._minDistance <= this$1._terminateDistance) { return null }\n    }\n  }\n};\nDistanceOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceOp.prototype.getClass = function getClass () {\n  return DistanceOp\n};\nDistanceOp.distance = function distance (g0, g1) {\n  var distOp = new DistanceOp(g0, g1);\n  return distOp.distance()\n};\nDistanceOp.isWithinDistance = function isWithinDistance (g0, g1, distance) {\n  var distOp = new DistanceOp(g0, g1, distance);\n  return distOp.distance() <= distance\n};\nDistanceOp.nearestPoints = function nearestPoints (g0, g1) {\n  var distOp = new DistanceOp(g0, g1);\n  return distOp.nearestPoints()\n};\n\nvar PointPairDistance$2 = function PointPairDistance () {\n  this._pt = [new Coordinate(), new Coordinate()];\n  this._distance = Double.NaN;\n  this._isNull = true;\n};\nPointPairDistance$2.prototype.getCoordinates = function getCoordinates () {\n  return this._pt\n};\nPointPairDistance$2.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pt[i]\n};\nPointPairDistance$2.prototype.setMinimum = function setMinimum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMinimum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist < this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance$2.prototype.initialize = function initialize () {\n  if (arguments.length === 0) {\n    this._isNull = true;\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    this._pt[0].setCoordinate(p0);\n    this._pt[1].setCoordinate(p1);\n    this._distance = p0.distance(p1);\n    this._isNull = false;\n  } else if (arguments.length === 3) {\n    var p0$1 = arguments[0];\n    var p1$1 = arguments[1];\n    var distance = arguments[2];\n    this._pt[0].setCoordinate(p0$1);\n    this._pt[1].setCoordinate(p1$1);\n    this._distance = distance;\n    this._isNull = false;\n  }\n};\nPointPairDistance$2.prototype.toString = function toString () {\n  return WKTWriter.toLineString(this._pt[0], this._pt[1])\n};\nPointPairDistance$2.prototype.getDistance = function getDistance () {\n  return this._distance\n};\nPointPairDistance$2.prototype.setMaximum = function setMaximum () {\n  if (arguments.length === 1) {\n    var ptDist = arguments[0];\n    this.setMaximum(ptDist._pt[0], ptDist._pt[1]);\n  } else if (arguments.length === 2) {\n    var p0 = arguments[0];\n    var p1 = arguments[1];\n    if (this._isNull) {\n      this.initialize(p0, p1);\n      return null\n    }\n    var dist = p0.distance(p1);\n    if (dist > this._distance) { this.initialize(p0, p1, dist); }\n  }\n};\nPointPairDistance$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointPairDistance$2.prototype.getClass = function getClass () {\n  return PointPairDistance$2\n};\n\nvar DistanceToPoint = function DistanceToPoint () {};\n\nDistanceToPoint.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDistanceToPoint.prototype.getClass = function getClass () {\n  return DistanceToPoint\n};\nDistanceToPoint.computeDistance = function computeDistance () {\n  if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineString && arguments[1] instanceof Coordinate)) {\n    var line = arguments[0];\n    var pt = arguments[1];\n    var ptDist = arguments[2];\n    var tempSegment = new LineSegment();\n    var coords = line.getCoordinates();\n    for (var i = 0; i < coords.length - 1; i++) {\n      tempSegment.setCoordinates(coords[i], coords[i + 1]);\n      var closestPt = tempSegment.closestPoint(pt);\n      ptDist.setMinimum(closestPt, pt);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Polygon && arguments[1] instanceof Coordinate)) {\n    var poly = arguments[0];\n    var pt$1 = arguments[1];\n    var ptDist$1 = arguments[2];\n    DistanceToPoint.computeDistance(poly.getExteriorRing(), pt$1, ptDist$1);\n    for (var i$1 = 0; i$1 < poly.getNumInteriorRing(); i$1++) {\n      DistanceToPoint.computeDistance(poly.getInteriorRingN(i$1), pt$1, ptDist$1);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof Geometry && arguments[1] instanceof Coordinate)) {\n    var geom = arguments[0];\n    var pt$2 = arguments[1];\n    var ptDist$2 = arguments[2];\n    if (geom instanceof LineString) {\n      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof Polygon) {\n      DistanceToPoint.computeDistance(geom, pt$2, ptDist$2);\n    } else if (geom instanceof GeometryCollection) {\n      var gc = geom;\n      for (var i$2 = 0; i$2 < gc.getNumGeometries(); i$2++) {\n        var g = gc.getGeometryN(i$2);\n        DistanceToPoint.computeDistance(g, pt$2, ptDist$2);\n      }\n    } else {\n      ptDist$2.setMinimum(geom.getCoordinate(), pt$2);\n    }\n  } else if (arguments[2] instanceof PointPairDistance$2 && (arguments[0] instanceof LineSegment && arguments[1] instanceof Coordinate)) {\n    var segment = arguments[0];\n    var pt$3 = arguments[1];\n    var ptDist$3 = arguments[2];\n    var closestPt$1 = segment.closestPoint(pt$3);\n    ptDist$3.setMinimum(closestPt$1, pt$3);\n  }\n};\n\nvar DiscreteHausdorffDistance = function DiscreteHausdorffDistance () {\n  this._g0 = null;\n  this._g1 = null;\n  this._ptDist = new PointPairDistance$2();\n  this._densifyFrac = 0.0;\n  var g0 = arguments[0];\n  var g1 = arguments[1];\n  this._g0 = g0;\n  this._g1 = g1;\n};\n\nvar staticAccessors$39 = { MaxPointDistanceFilter: { configurable: true },MaxDensifiedByFractionDistanceFilter: { configurable: true } };\nDiscreteHausdorffDistance.prototype.getCoordinates = function getCoordinates () {\n  return this._ptDist.getCoordinates()\n};\nDiscreteHausdorffDistance.prototype.setDensifyFraction = function setDensifyFraction (densifyFrac) {\n  if (densifyFrac > 1.0 || densifyFrac <= 0.0) { throw new IllegalArgumentException('Fraction is not in range (0.0 - 1.0]') }\n  this._densifyFrac = densifyFrac;\n};\nDiscreteHausdorffDistance.prototype.compute = function compute (g0, g1) {\n  this.computeOrientedDistance(g0, g1, this._ptDist);\n  this.computeOrientedDistance(g1, g0, this._ptDist);\n};\nDiscreteHausdorffDistance.prototype.distance = function distance () {\n  this.compute(this._g0, this._g1);\n  return this._ptDist.getDistance()\n};\nDiscreteHausdorffDistance.prototype.computeOrientedDistance = function computeOrientedDistance (discreteGeom, geom, ptDist) {\n  var distFilter = new MaxPointDistanceFilter$1(geom);\n  discreteGeom.apply(distFilter);\n  ptDist.setMaximum(distFilter.getMaxPointDistance());\n  if (this._densifyFrac > 0) {\n    var fracFilter = new MaxDensifiedByFractionDistanceFilter(geom, this._densifyFrac);\n    discreteGeom.apply(fracFilter);\n    ptDist.setMaximum(fracFilter.getMaxPointDistance());\n  }\n};\nDiscreteHausdorffDistance.prototype.orientedDistance = function orientedDistance () {\n  this.computeOrientedDistance(this._g0, this._g1, this._ptDist);\n  return this._ptDist.getDistance()\n};\nDiscreteHausdorffDistance.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nDiscreteHausdorffDistance.prototype.getClass = function getClass () {\n  return DiscreteHausdorffDistance\n};\nDiscreteHausdorffDistance.distance = function distance () {\n  if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var dist = new DiscreteHausdorffDistance(g0, g1);\n    return dist.distance()\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var densifyFrac = arguments[2];\n    var dist$1 = new DiscreteHausdorffDistance(g0$1, g1$1);\n    dist$1.setDensifyFraction(densifyFrac);\n    return dist$1.distance()\n  }\n};\nstaticAccessors$39.MaxPointDistanceFilter.get = function () { return MaxPointDistanceFilter$1 };\nstaticAccessors$39.MaxDensifiedByFractionDistanceFilter.get = function () { return MaxDensifiedByFractionDistanceFilter };\n\nObject.defineProperties( DiscreteHausdorffDistance, staticAccessors$39 );\n\nvar MaxPointDistanceFilter$1 = function MaxPointDistanceFilter () {\n  this._maxPtDist = new PointPairDistance$2();\n  this._minPtDist = new PointPairDistance$2();\n  this._euclideanDist = new DistanceToPoint();\n  this._geom = null;\n  var geom = arguments[0];\n  this._geom = geom;\n};\nMaxPointDistanceFilter$1.prototype.filter = function filter (pt) {\n  this._minPtDist.initialize();\n  DistanceToPoint.computeDistance(this._geom, pt, this._minPtDist);\n  this._maxPtDist.setMaximum(this._minPtDist);\n};\nMaxPointDistanceFilter$1.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxPointDistanceFilter$1.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nMaxPointDistanceFilter$1.prototype.getClass = function getClass () {\n  return MaxPointDistanceFilter$1\n};\n\nvar MaxDensifiedByFractionDistanceFilter = function MaxDensifiedByFractionDistanceFilter () {\n  this._maxPtDist = new PointPairDistance$2();\n  this._minPtDist = new PointPairDistance$2();\n  this._geom = null;\n  this._numSubSegs = 0;\n  var geom = arguments[0];\n  var fraction = arguments[1];\n  this._geom = geom;\n  this._numSubSegs = Math.trunc(Math.round(1.0 / fraction));\n};\nMaxDensifiedByFractionDistanceFilter.prototype.filter = function filter (seq, index) {\n    var this$1 = this;\n\n  if (index === 0) { return null }\n  var p0 = seq.getCoordinate(index - 1);\n  var p1 = seq.getCoordinate(index);\n  var delx = (p1.x - p0.x) / this._numSubSegs;\n  var dely = (p1.y - p0.y) / this._numSubSegs;\n  for (var i = 0; i < this._numSubSegs; i++) {\n    var x = p0.x + i * delx;\n    var y = p0.y + i * dely;\n    var pt = new Coordinate(x, y);\n    this$1._minPtDist.initialize();\n    DistanceToPoint.computeDistance(this$1._geom, pt, this$1._minPtDist);\n    this$1._maxPtDist.setMaximum(this$1._minPtDist);\n  }\n};\nMaxDensifiedByFractionDistanceFilter.prototype.isDone = function isDone () {\n  return false\n};\nMaxDensifiedByFractionDistanceFilter.prototype.isGeometryChanged = function isGeometryChanged () {\n  return false\n};\nMaxDensifiedByFractionDistanceFilter.prototype.getMaxPointDistance = function getMaxPointDistance () {\n  return this._maxPtDist\n};\nMaxDensifiedByFractionDistanceFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nMaxDensifiedByFractionDistanceFilter.prototype.getClass = function getClass () {\n  return MaxDensifiedByFractionDistanceFilter\n};\n\nvar BufferDistanceValidator = function BufferDistanceValidator (input, bufDistance, result) {\n  this._minValidDistance = null;\n  this._maxValidDistance = null;\n  this._minDistanceFound = null;\n  this._maxDistanceFound = null;\n  this._isValid = true;\n  this._errMsg = null;\n  this._errorLocation = null;\n  this._errorIndicator = null;\n  this._input = input || null;\n  this._bufDistance = bufDistance || null;\n  this._result = result || null;\n};\n\nvar staticAccessors$37 = { VERBOSE: { configurable: true },MAX_DISTANCE_DIFF_FRAC: { configurable: true } };\nBufferDistanceValidator.prototype.checkMaximumDistance = function checkMaximumDistance (input, bufCurve, maxDist) {\n  var haus = new DiscreteHausdorffDistance(bufCurve, input);\n  haus.setDensifyFraction(0.25);\n  this._maxDistanceFound = haus.orientedDistance();\n  if (this._maxDistanceFound > maxDist) {\n    this._isValid = false;\n    var pts = haus.getCoordinates();\n    this._errorLocation = pts[1];\n    this._errorIndicator = input.getFactory().createLineString(pts);\n    this._errMsg = 'Distance between buffer curve and input is too large (' + this._maxDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ')';\n  }\n};\nBufferDistanceValidator.prototype.isValid = function isValid () {\n  var posDistance = Math.abs(this._bufDistance);\n  var distDelta = BufferDistanceValidator.MAX_DISTANCE_DIFF_FRAC * posDistance;\n  this._minValidDistance = posDistance - distDelta;\n  this._maxValidDistance = posDistance + distDelta;\n  if (this._input.isEmpty() || this._result.isEmpty()) { return true }\n  if (this._bufDistance > 0.0) {\n    this.checkPositiveValid();\n  } else {\n    this.checkNegativeValid();\n  }\n  if (BufferDistanceValidator.VERBOSE) {\n    System.out.println('Min Dist= ' + this._minDistanceFound + '  err= ' + (1.0 - this._minDistanceFound / this._bufDistance) + '  Max Dist= ' + this._maxDistanceFound + '  err= ' + (this._maxDistanceFound / this._bufDistance - 1.0));\n  }\n  return this._isValid\n};\nBufferDistanceValidator.prototype.checkNegativeValid = function checkNegativeValid () {\n  if (!(this._input instanceof Polygon || this._input instanceof MultiPolygon || this._input instanceof GeometryCollection)) {\n    return null\n  }\n  var inputCurve = this.getPolygonLines(this._input);\n  this.checkMinimumDistance(inputCurve, this._result, this._minValidDistance);\n  if (!this._isValid) { return null }\n  this.checkMaximumDistance(inputCurve, this._result, this._maxValidDistance);\n};\nBufferDistanceValidator.prototype.getErrorIndicator = function getErrorIndicator () {\n  return this._errorIndicator\n};\nBufferDistanceValidator.prototype.checkMinimumDistance = function checkMinimumDistance (g1, g2, minDist) {\n  var distOp = new DistanceOp(g1, g2, minDist);\n  this._minDistanceFound = distOp.distance();\n  if (this._minDistanceFound < minDist) {\n    this._isValid = false;\n    var pts = distOp.nearestPoints();\n    this._errorLocation = distOp.nearestPoints()[1];\n    this._errorIndicator = g1.getFactory().createLineString(pts);\n    this._errMsg = 'Distance between buffer curve and input is too small (' + this._minDistanceFound + ' at ' + WKTWriter.toLineString(pts[0], pts[1]) + ' )';\n  }\n};\nBufferDistanceValidator.prototype.checkPositiveValid = function checkPositiveValid () {\n  var bufCurve = this._result.getBoundary();\n  this.checkMinimumDistance(this._input, bufCurve, this._minValidDistance);\n  if (!this._isValid) { return null }\n  this.checkMaximumDistance(this._input, bufCurve, this._maxValidDistance);\n};\nBufferDistanceValidator.prototype.getErrorLocation = function getErrorLocation () {\n  return this._errorLocation\n};\nBufferDistanceValidator.prototype.getPolygonLines = function getPolygonLines (g) {\n  var lines = new ArrayList();\n  var lineExtracter = new LinearComponentExtracter(lines);\n  var polys = PolygonExtracter.getPolygons(g);\n  for (var i = polys.iterator(); i.hasNext();) {\n    var poly = i.next();\n    poly.apply(lineExtracter);\n  }\n  return g.getFactory().buildGeometry(lines)\n};\nBufferDistanceValidator.prototype.getErrorMessage = function getErrorMessage () {\n  return this._errMsg\n};\nBufferDistanceValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferDistanceValidator.prototype.getClass = function getClass () {\n  return BufferDistanceValidator\n};\nstaticAccessors$37.VERBOSE.get = function () { return false };\nstaticAccessors$37.MAX_DISTANCE_DIFF_FRAC.get = function () { return 0.012 };\n\nObject.defineProperties( BufferDistanceValidator, staticAccessors$37 );\n\nvar BufferResultValidator = function BufferResultValidator (input, distance, result) {\n  this._isValid = true;\n  this._errorMsg = null;\n  this._errorLocation = null;\n  this._errorIndicator = null;\n  this._input = input || null;\n  this._distance = distance || null;\n  this._result = result || null;\n};\n\nvar staticAccessors$40 = { VERBOSE: { configurable: true },MAX_ENV_DIFF_FRAC: { configurable: true } };\nBufferResultValidator.prototype.isValid = function isValid () {\n  this.checkPolygonal();\n  if (!this._isValid) { return this._isValid }\n  this.checkExpectedEmpty();\n  if (!this._isValid) { return this._isValid }\n  this.checkEnvelope();\n  if (!this._isValid) { return this._isValid }\n  this.checkArea();\n  if (!this._isValid) { return this._isValid }\n  this.checkDistance();\n  return this._isValid\n};\nBufferResultValidator.prototype.checkEnvelope = function checkEnvelope () {\n  if (this._distance < 0.0) { return null }\n  var padding = this._distance * BufferResultValidator.MAX_ENV_DIFF_FRAC;\n  if (padding === 0.0) { padding = 0.001; }\n  var expectedEnv = new Envelope(this._input.getEnvelopeInternal());\n  expectedEnv.expandBy(this._distance);\n  var bufEnv = new Envelope(this._result.getEnvelopeInternal());\n  bufEnv.expandBy(padding);\n  if (!bufEnv.contains(expectedEnv)) {\n    this._isValid = false;\n    this._errorMsg = 'Buffer envelope is incorrect';\n    this._errorIndicator = this._input.getFactory().toGeometry(bufEnv);\n  }\n  this.report('Envelope');\n};\nBufferResultValidator.prototype.checkDistance = function checkDistance () {\n  var distValid = new BufferDistanceValidator(this._input, this._distance, this._result);\n  if (!distValid.isValid()) {\n    this._isValid = false;\n    this._errorMsg = distValid.getErrorMessage();\n    this._errorLocation = distValid.getErrorLocation();\n    this._errorIndicator = distValid.getErrorIndicator();\n  }\n  this.report('Distance');\n};\nBufferResultValidator.prototype.checkArea = function checkArea () {\n  var inputArea = this._input.getArea();\n  var resultArea = this._result.getArea();\n  if (this._distance > 0.0 && inputArea > resultArea) {\n    this._isValid = false;\n    this._errorMsg = 'Area of positive buffer is smaller than input';\n    this._errorIndicator = this._result;\n  }\n  if (this._distance < 0.0 && inputArea < resultArea) {\n    this._isValid = false;\n    this._errorMsg = 'Area of negative buffer is larger than input';\n    this._errorIndicator = this._result;\n  }\n  this.report('Area');\n};\nBufferResultValidator.prototype.checkPolygonal = function checkPolygonal () {\n  if (!(this._result instanceof Polygon || this._result instanceof MultiPolygon)) { this._isValid = false; }\n  this._errorMsg = 'Result is not polygonal';\n  this._errorIndicator = this._result;\n  this.report('Polygonal');\n};\nBufferResultValidator.prototype.getErrorIndicator = function getErrorIndicator () {\n  return this._errorIndicator\n};\nBufferResultValidator.prototype.getErrorLocation = function getErrorLocation () {\n  return this._errorLocation\n};\nBufferResultValidator.prototype.checkExpectedEmpty = function checkExpectedEmpty () {\n  if (this._input.getDimension() >= 2) { return null }\n  if (this._distance > 0.0) { return null }\n  if (!this._result.isEmpty()) {\n    this._isValid = false;\n    this._errorMsg = 'Result is non-empty';\n    this._errorIndicator = this._result;\n  }\n  this.report('ExpectedEmpty');\n};\nBufferResultValidator.prototype.report = function report (checkName) {\n  if (!BufferResultValidator.VERBOSE) { return null }\n  System.out.println('Check ' + checkName + ': ' + (this._isValid ? 'passed' : 'FAILED'));\n};\nBufferResultValidator.prototype.getErrorMessage = function getErrorMessage () {\n  return this._errorMsg\n};\nBufferResultValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nBufferResultValidator.prototype.getClass = function getClass () {\n  return BufferResultValidator\n};\nBufferResultValidator.isValidMsg = function isValidMsg (g, distance, result) {\n  var validator = new BufferResultValidator(g, distance, result);\n  if (!validator.isValid()) { return validator.getErrorMessage() }\n  return null\n};\nBufferResultValidator.isValid = function isValid (g, distance, result) {\n  var validator = new BufferResultValidator(g, distance, result);\n  if (validator.isValid()) { return true }\n  return false\n};\nstaticAccessors$40.VERBOSE.get = function () { return false };\nstaticAccessors$40.MAX_ENV_DIFF_FRAC.get = function () { return 0.012 };\n\nObject.defineProperties( BufferResultValidator, staticAccessors$40 );\n\n// operation.buffer\n\nvar BasicSegmentString = function BasicSegmentString () {\n  this._pts = null;\n  this._data = null;\n  var pts = arguments[0];\n  var data = arguments[1];\n  this._pts = pts;\n  this._data = data;\n};\nBasicSegmentString.prototype.getCoordinates = function getCoordinates () {\n  return this._pts\n};\nBasicSegmentString.prototype.size = function size () {\n  return this._pts.length\n};\nBasicSegmentString.prototype.getCoordinate = function getCoordinate (i) {\n  return this._pts[i]\n};\nBasicSegmentString.prototype.isClosed = function isClosed () {\n  return this._pts[0].equals(this._pts[this._pts.length - 1])\n};\nBasicSegmentString.prototype.getSegmentOctant = function getSegmentOctant (index) {\n  if (index === this._pts.length - 1) { return -1 }\n  return Octant.octant(this.getCoordinate(index), this.getCoordinate(index + 1))\n};\nBasicSegmentString.prototype.setData = function setData (data) {\n  this._data = data;\n};\nBasicSegmentString.prototype.getData = function getData () {\n  return this._data\n};\nBasicSegmentString.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new CoordinateArraySequence(this._pts))\n};\nBasicSegmentString.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentString]\n};\nBasicSegmentString.prototype.getClass = function getClass () {\n  return BasicSegmentString\n};\n\nvar InteriorIntersectionFinder = function InteriorIntersectionFinder () {\n  this._findAllIntersections = false;\n  this._isCheckEndSegmentsOnly = false;\n  this._li = null;\n  this._interiorIntersection = null;\n  this._intSegments = null;\n  this._intersections = new ArrayList();\n  this._intersectionCount = 0;\n  this._keepIntersections = true;\n  var li = arguments[0];\n  this._li = li;\n  this._interiorIntersection = null;\n};\nInteriorIntersectionFinder.prototype.getInteriorIntersection = function getInteriorIntersection () {\n  return this._interiorIntersection\n};\nInteriorIntersectionFinder.prototype.setCheckEndSegmentsOnly = function setCheckEndSegmentsOnly (isCheckEndSegmentsOnly) {\n  this._isCheckEndSegmentsOnly = isCheckEndSegmentsOnly;\n};\nInteriorIntersectionFinder.prototype.getIntersectionSegments = function getIntersectionSegments () {\n  return this._intSegments\n};\nInteriorIntersectionFinder.prototype.count = function count () {\n  return this._intersectionCount\n};\nInteriorIntersectionFinder.prototype.getIntersections = function getIntersections () {\n  return this._intersections\n};\nInteriorIntersectionFinder.prototype.setFindAllIntersections = function setFindAllIntersections (findAllIntersections) {\n  this._findAllIntersections = findAllIntersections;\n};\nInteriorIntersectionFinder.prototype.setKeepIntersections = function setKeepIntersections (keepIntersections) {\n  this._keepIntersections = keepIntersections;\n};\nInteriorIntersectionFinder.prototype.processIntersections = function processIntersections (e0, segIndex0, e1, segIndex1) {\n  if (!this._findAllIntersections && this.hasIntersection()) { return null }\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  if (this._isCheckEndSegmentsOnly) {\n    var isEndSegPresent = this.isEndSegment(e0, segIndex0) || this.isEndSegment(e1, segIndex1);\n    if (!isEndSegPresent) { return null }\n  }\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._li.isInteriorIntersection()) {\n      this._intSegments = new Array(4).fill(null);\n      this._intSegments[0] = p00;\n      this._intSegments[1] = p01;\n      this._intSegments[2] = p10;\n      this._intSegments[3] = p11;\n      this._interiorIntersection = this._li.getIntersection(0);\n      if (this._keepIntersections) { this._intersections.add(this._interiorIntersection); }\n      this._intersectionCount++;\n    }\n  }\n};\nInteriorIntersectionFinder.prototype.isEndSegment = function isEndSegment (segStr, index) {\n  if (index === 0) { return true }\n  if (index >= segStr.size() - 2) { return true }\n  return false\n};\nInteriorIntersectionFinder.prototype.hasIntersection = function hasIntersection () {\n  return this._interiorIntersection !== null\n};\nInteriorIntersectionFinder.prototype.isDone = function isDone () {\n  if (this._findAllIntersections) { return false }\n  return this._interiorIntersection !== null\n};\nInteriorIntersectionFinder.prototype.interfaces_ = function interfaces_ () {\n  return [SegmentIntersector]\n};\nInteriorIntersectionFinder.prototype.getClass = function getClass () {\n  return InteriorIntersectionFinder\n};\nInteriorIntersectionFinder.createAllIntersectionsFinder = function createAllIntersectionsFinder (li) {\n  var finder = new InteriorIntersectionFinder(li);\n  finder.setFindAllIntersections(true);\n  return finder\n};\nInteriorIntersectionFinder.createAnyIntersectionFinder = function createAnyIntersectionFinder (li) {\n  return new InteriorIntersectionFinder(li)\n};\nInteriorIntersectionFinder.createIntersectionCounter = function createIntersectionCounter (li) {\n  var finder = new InteriorIntersectionFinder(li);\n  finder.setFindAllIntersections(true);\n  finder.setKeepIntersections(false);\n  return finder\n};\n\nvar FastNodingValidator = function FastNodingValidator () {\n  this._li = new RobustLineIntersector();\n  this._segStrings = null;\n  this._findAllIntersections = false;\n  this._segInt = null;\n  this._isValid = true;\n  var segStrings = arguments[0];\n  this._segStrings = segStrings;\n};\nFastNodingValidator.prototype.execute = function execute () {\n  if (this._segInt !== null) { return null }\n  this.checkInteriorIntersections();\n};\nFastNodingValidator.prototype.getIntersections = function getIntersections () {\n  return this._segInt.getIntersections()\n};\nFastNodingValidator.prototype.isValid = function isValid () {\n  this.execute();\n  return this._isValid\n};\nFastNodingValidator.prototype.setFindAllIntersections = function setFindAllIntersections (findAllIntersections) {\n  this._findAllIntersections = findAllIntersections;\n};\nFastNodingValidator.prototype.checkInteriorIntersections = function checkInteriorIntersections () {\n  this._isValid = true;\n  this._segInt = new InteriorIntersectionFinder(this._li);\n  this._segInt.setFindAllIntersections(this._findAllIntersections);\n  var noder = new MCIndexNoder();\n  noder.setSegmentIntersector(this._segInt);\n  noder.computeNodes(this._segStrings);\n  if (this._segInt.hasIntersection()) {\n    this._isValid = false;\n    return null\n  }\n};\nFastNodingValidator.prototype.checkValid = function checkValid () {\n  this.execute();\n  if (!this._isValid) { throw new TopologyException(this.getErrorMessage(), this._segInt.getInteriorIntersection()) }\n};\nFastNodingValidator.prototype.getErrorMessage = function getErrorMessage () {\n  if (this._isValid) { return 'no intersections found' }\n  var intSegs = this._segInt.getIntersectionSegments();\n  return 'found non-noded intersection between ' + WKTWriter.toLineString(intSegs[0], intSegs[1]) + ' and ' + WKTWriter.toLineString(intSegs[2], intSegs[3])\n};\nFastNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nFastNodingValidator.prototype.getClass = function getClass () {\n  return FastNodingValidator\n};\nFastNodingValidator.computeIntersections = function computeIntersections (segStrings) {\n  var nv = new FastNodingValidator(segStrings);\n  nv.setFindAllIntersections(true);\n  nv.isValid();\n  return nv.getIntersections()\n};\n\nvar EdgeNodingValidator = function EdgeNodingValidator () {\n  this._nv = null;\n  var edges = arguments[0];\n  this._nv = new FastNodingValidator(EdgeNodingValidator.toSegmentStrings(edges));\n};\nEdgeNodingValidator.prototype.checkValid = function checkValid () {\n  this._nv.checkValid();\n};\nEdgeNodingValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeNodingValidator.prototype.getClass = function getClass () {\n  return EdgeNodingValidator\n};\nEdgeNodingValidator.toSegmentStrings = function toSegmentStrings (edges) {\n  var segStrings = new ArrayList();\n  for (var i = edges.iterator(); i.hasNext();) {\n    var e = i.next();\n    segStrings.add(new BasicSegmentString(e.getCoordinates(), e));\n  }\n  return segStrings\n};\nEdgeNodingValidator.checkValid = function checkValid (edges) {\n  var validator = new EdgeNodingValidator(edges);\n  validator.checkValid();\n};\n\nvar GeometryCollectionMapper = function GeometryCollectionMapper (mapOp) {\n  this._mapOp = mapOp;\n};\nGeometryCollectionMapper.prototype.map = function map (gc) {\n    var this$1 = this;\n\n  var mapped = new ArrayList();\n  for (var i = 0; i < gc.getNumGeometries(); i++) {\n    var g = this$1._mapOp.map(gc.getGeometryN(i));\n    if (!g.isEmpty()) { mapped.add(g); }\n  }\n  return gc.getFactory().createGeometryCollection(GeometryFactory.toGeometryArray(mapped))\n};\nGeometryCollectionMapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryCollectionMapper.prototype.getClass = function getClass () {\n  return GeometryCollectionMapper\n};\nGeometryCollectionMapper.map = function map (gc, op) {\n  var mapper = new GeometryCollectionMapper(op);\n  return mapper.map(gc)\n};\n\nvar LineBuilder = function LineBuilder () {\n  this._op = null;\n  this._geometryFactory = null;\n  this._ptLocator = null;\n  this._lineEdgesList = new ArrayList();\n  this._resultLineList = new ArrayList();\n  var op = arguments[0];\n  var geometryFactory = arguments[1];\n  var ptLocator = arguments[2];\n  this._op = op;\n  this._geometryFactory = geometryFactory;\n  this._ptLocator = ptLocator;\n};\nLineBuilder.prototype.collectLines = function collectLines (opCode) {\n    var this$1 = this;\n\n  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n    var de = it.next();\n    this$1.collectLineEdge(de, opCode, this$1._lineEdgesList);\n    this$1.collectBoundaryTouchEdge(de, opCode, this$1._lineEdgesList);\n  }\n};\nLineBuilder.prototype.labelIsolatedLine = function labelIsolatedLine (e, targetIndex) {\n  var loc = this._ptLocator.locate(e.getCoordinate(), this._op.getArgGeometry(targetIndex));\n  e.getLabel().setLocation(targetIndex, loc);\n};\nLineBuilder.prototype.build = function build (opCode) {\n  this.findCoveredLineEdges();\n  this.collectLines(opCode);\n  this.buildLines(opCode);\n  return this._resultLineList\n};\nLineBuilder.prototype.collectLineEdge = function collectLineEdge (de, opCode, edges) {\n  var label = de.getLabel();\n  var e = de.getEdge();\n  if (de.isLineEdge()) {\n    if (!de.isVisited() && OverlayOp.isResultOfOp(label, opCode) && !e.isCovered()) {\n      edges.add(e);\n      de.setVisitedEdge(true);\n    }\n  }\n};\nLineBuilder.prototype.findCoveredLineEdges = function findCoveredLineEdges () {\n    var this$1 = this;\n\n  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n    var node = nodeit.next();\n    node.getEdges().findCoveredLineEdges();\n  }\n  for (var it = this._op.getGraph().getEdgeEnds().iterator(); it.hasNext();) {\n    var de = it.next();\n    var e = de.getEdge();\n    if (de.isLineEdge() && !e.isCoveredSet()) {\n      var isCovered = this$1._op.isCoveredByA(de.getCoordinate());\n      e.setCovered(isCovered);\n    }\n  }\n};\nLineBuilder.prototype.labelIsolatedLines = function labelIsolatedLines (edgesList) {\n    var this$1 = this;\n\n  for (var it = edgesList.iterator(); it.hasNext();) {\n    var e = it.next();\n    var label = e.getLabel();\n    if (e.isIsolated()) {\n      if (label.isNull(0)) { this$1.labelIsolatedLine(e, 0); } else { this$1.labelIsolatedLine(e, 1); }\n    }\n  }\n};\nLineBuilder.prototype.buildLines = function buildLines (opCode) {\n    var this$1 = this;\n\n  for (var it = this._lineEdgesList.iterator(); it.hasNext();) {\n    var e = it.next();\n    // const label = e.getLabel()\n    var line = this$1._geometryFactory.createLineString(e.getCoordinates());\n    this$1._resultLineList.add(line);\n    e.setInResult(true);\n  }\n};\nLineBuilder.prototype.collectBoundaryTouchEdge = function collectBoundaryTouchEdge (de, opCode, edges) {\n  var label = de.getLabel();\n  if (de.isLineEdge()) { return null }\n  if (de.isVisited()) { return null }\n  if (de.isInteriorAreaEdge()) { return null }\n  if (de.getEdge().isInResult()) { return null }\n  Assert.isTrue(!(de.isInResult() || de.getSym().isInResult()) || !de.getEdge().isInResult());\n  if (OverlayOp.isResultOfOp(label, opCode) && opCode === OverlayOp.INTERSECTION) {\n    edges.add(de.getEdge());\n    de.setVisitedEdge(true);\n  }\n};\nLineBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineBuilder.prototype.getClass = function getClass () {\n  return LineBuilder\n};\n\nvar PointBuilder = function PointBuilder () {\n  this._op = null;\n  this._geometryFactory = null;\n  this._resultPointList = new ArrayList();\n  var op = arguments[0];\n  var geometryFactory = arguments[1];\n  // const ptLocator = arguments[2]\n  this._op = op;\n  this._geometryFactory = geometryFactory;\n};\nPointBuilder.prototype.filterCoveredNodeToPoint = function filterCoveredNodeToPoint (n) {\n  var coord = n.getCoordinate();\n  if (!this._op.isCoveredByLA(coord)) {\n    var pt = this._geometryFactory.createPoint(coord);\n    this._resultPointList.add(pt);\n  }\n};\nPointBuilder.prototype.extractNonCoveredResultNodes = function extractNonCoveredResultNodes (opCode) {\n    var this$1 = this;\n\n  for (var nodeit = this._op.getGraph().getNodes().iterator(); nodeit.hasNext();) {\n    var n = nodeit.next();\n    if (n.isInResult()) { continue }\n    if (n.isIncidentEdgeInResult()) { continue }\n    if (n.getEdges().getDegree() === 0 || opCode === OverlayOp.INTERSECTION) {\n      var label = n.getLabel();\n      if (OverlayOp.isResultOfOp(label, opCode)) {\n        this$1.filterCoveredNodeToPoint(n);\n      }\n    }\n  }\n};\nPointBuilder.prototype.build = function build (opCode) {\n  this.extractNonCoveredResultNodes(opCode);\n  return this._resultPointList\n};\nPointBuilder.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nPointBuilder.prototype.getClass = function getClass () {\n  return PointBuilder\n};\n\nvar GeometryTransformer = function GeometryTransformer () {\n  this._inputGeom = null;\n  this._factory = null;\n  this._pruneEmptyGeometry = true;\n  this._preserveGeometryCollectionType = true;\n  this._preserveCollections = false;\n  this._preserveType = false;\n};\nGeometryTransformer.prototype.transformPoint = function transformPoint (geom, parent) {\n  return this._factory.createPoint(this.transformCoordinates(geom.getCoordinateSequence(), geom))\n};\nGeometryTransformer.prototype.transformPolygon = function transformPolygon (geom, parent) {\n    var this$1 = this;\n\n  var isAllValidLinearRings = true;\n  var shell = this.transformLinearRing(geom.getExteriorRing(), geom);\n  if (shell === null || !(shell instanceof LinearRing) || shell.isEmpty()) { isAllValidLinearRings = false; }\n  var holes = new ArrayList();\n  for (var i = 0; i < geom.getNumInteriorRing(); i++) {\n    var hole = this$1.transformLinearRing(geom.getInteriorRingN(i), geom);\n    if (hole === null || hole.isEmpty()) {\n      continue\n    }\n    if (!(hole instanceof LinearRing)) { isAllValidLinearRings = false; }\n    holes.add(hole);\n  }\n  if (isAllValidLinearRings) { return this._factory.createPolygon(shell, holes.toArray([])); } else {\n    var components = new ArrayList();\n    if (shell !== null) { components.add(shell); }\n    components.addAll(holes);\n    return this._factory.buildGeometry(components)\n  }\n};\nGeometryTransformer.prototype.createCoordinateSequence = function createCoordinateSequence (coords) {\n  return this._factory.getCoordinateSequenceFactory().create(coords)\n};\nGeometryTransformer.prototype.getInputGeometry = function getInputGeometry () {\n  return this._inputGeom\n};\nGeometryTransformer.prototype.transformMultiLineString = function transformMultiLineString (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformLineString(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transformCoordinates = function transformCoordinates (coords, parent) {\n  return this.copy(coords)\n};\nGeometryTransformer.prototype.transformLineString = function transformLineString (geom, parent) {\n  return this._factory.createLineString(this.transformCoordinates(geom.getCoordinateSequence(), geom))\n};\nGeometryTransformer.prototype.transformMultiPoint = function transformMultiPoint (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformPoint(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transformMultiPolygon = function transformMultiPolygon (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transformPolygon(geom.getGeometryN(i), geom);\n    if (transformGeom === null) { continue }\n    if (transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.copy = function copy (seq) {\n  return seq.copy()\n};\nGeometryTransformer.prototype.transformGeometryCollection = function transformGeometryCollection (geom, parent) {\n    var this$1 = this;\n\n  var transGeomList = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var transformGeom = this$1.transform(geom.getGeometryN(i));\n    if (transformGeom === null) { continue }\n    if (this$1._pruneEmptyGeometry && transformGeom.isEmpty()) { continue }\n    transGeomList.add(transformGeom);\n  }\n  if (this._preserveGeometryCollectionType) { return this._factory.createGeometryCollection(GeometryFactory.toGeometryArray(transGeomList)) }\n  return this._factory.buildGeometry(transGeomList)\n};\nGeometryTransformer.prototype.transform = function transform (inputGeom) {\n  this._inputGeom = inputGeom;\n  this._factory = inputGeom.getFactory();\n  if (inputGeom instanceof Point) { return this.transformPoint(inputGeom, null) }\n  if (inputGeom instanceof MultiPoint) { return this.transformMultiPoint(inputGeom, null) }\n  if (inputGeom instanceof LinearRing) { return this.transformLinearRing(inputGeom, null) }\n  if (inputGeom instanceof LineString) { return this.transformLineString(inputGeom, null) }\n  if (inputGeom instanceof MultiLineString) { return this.transformMultiLineString(inputGeom, null) }\n  if (inputGeom instanceof Polygon) { return this.transformPolygon(inputGeom, null) }\n  if (inputGeom instanceof MultiPolygon) { return this.transformMultiPolygon(inputGeom, null) }\n  if (inputGeom instanceof GeometryCollection) { return this.transformGeometryCollection(inputGeom, null) }\n  throw new IllegalArgumentException('Unknown Geometry subtype: ' + inputGeom.getClass().getName())\n};\nGeometryTransformer.prototype.transformLinearRing = function transformLinearRing (geom, parent) {\n  var seq = this.transformCoordinates(geom.getCoordinateSequence(), geom);\n  if (seq === null) { return this._factory.createLinearRing(null) }\n  var seqSize = seq.size();\n  if (seqSize > 0 && seqSize < 4 && !this._preserveType) { return this._factory.createLineString(seq) }\n  return this._factory.createLinearRing(seq)\n};\nGeometryTransformer.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryTransformer.prototype.getClass = function getClass () {\n  return GeometryTransformer\n};\n\nvar LineStringSnapper = function LineStringSnapper () {\n  this._snapTolerance = 0.0;\n  this._srcPts = null;\n  this._seg = new LineSegment();\n  this._allowSnappingToSourceVertices = false;\n  this._isClosed = false;\n  if (arguments[0] instanceof LineString && typeof arguments[1] === 'number') {\n    var srcLine = arguments[0];\n    var snapTolerance = arguments[1];\n    LineStringSnapper.call(this, srcLine.getCoordinates(), snapTolerance);\n  } else if (arguments[0] instanceof Array && typeof arguments[1] === 'number') {\n    var srcPts = arguments[0];\n    var snapTolerance$1 = arguments[1];\n    this._srcPts = srcPts;\n    this._isClosed = LineStringSnapper.isClosed(srcPts);\n    this._snapTolerance = snapTolerance$1;\n  }\n};\nLineStringSnapper.prototype.snapVertices = function snapVertices (srcCoords, snapPts) {\n    var this$1 = this;\n\n  var end = this._isClosed ? srcCoords.size() - 1 : srcCoords.size();\n  for (var i = 0; i < end; i++) {\n    var srcPt = srcCoords.get(i);\n    var snapVert = this$1.findSnapForVertex(srcPt, snapPts);\n    if (snapVert !== null) {\n      srcCoords.set(i, new Coordinate(snapVert));\n      if (i === 0 && this$1._isClosed) { srcCoords.set(srcCoords.size() - 1, new Coordinate(snapVert)); }\n    }\n  }\n};\nLineStringSnapper.prototype.findSnapForVertex = function findSnapForVertex (pt, snapPts) {\n    var this$1 = this;\n\n  for (var i = 0; i < snapPts.length; i++) {\n    if (pt.equals2D(snapPts[i])) { return null }\n    if (pt.distance(snapPts[i]) < this$1._snapTolerance) { return snapPts[i] }\n  }\n  return null\n};\nLineStringSnapper.prototype.snapTo = function snapTo (snapPts) {\n  var coordList = new CoordinateList(this._srcPts);\n  this.snapVertices(coordList, snapPts);\n  this.snapSegments(coordList, snapPts);\n  var newPts = coordList.toCoordinateArray();\n  return newPts\n};\nLineStringSnapper.prototype.snapSegments = function snapSegments (srcCoords, snapPts) {\n    var this$1 = this;\n\n  if (snapPts.length === 0) { return null }\n  var distinctPtCount = snapPts.length;\n  if (snapPts[0].equals2D(snapPts[snapPts.length - 1])) { distinctPtCount = snapPts.length - 1; }\n  for (var i = 0; i < distinctPtCount; i++) {\n    var snapPt = snapPts[i];\n    var index = this$1.findSegmentIndexToSnap(snapPt, srcCoords);\n    if (index >= 0) {\n      srcCoords.add(index + 1, new Coordinate(snapPt), false);\n    }\n  }\n};\nLineStringSnapper.prototype.findSegmentIndexToSnap = function findSegmentIndexToSnap (snapPt, srcCoords) {\n    var this$1 = this;\n\n  var minDist = Double.MAX_VALUE;\n  var snapIndex = -1;\n  for (var i = 0; i < srcCoords.size() - 1; i++) {\n    this$1._seg.p0 = srcCoords.get(i);\n    this$1._seg.p1 = srcCoords.get(i + 1);\n    if (this$1._seg.p0.equals2D(snapPt) || this$1._seg.p1.equals2D(snapPt)) {\n      if (this$1._allowSnappingToSourceVertices) { continue; } else { return -1 }\n    }\n    var dist = this$1._seg.distance(snapPt);\n    if (dist < this$1._snapTolerance && dist < minDist) {\n      minDist = dist;\n      snapIndex = i;\n    }\n  }\n  return snapIndex\n};\nLineStringSnapper.prototype.setAllowSnappingToSourceVertices = function setAllowSnappingToSourceVertices (allowSnappingToSourceVertices) {\n  this._allowSnappingToSourceVertices = allowSnappingToSourceVertices;\n};\nLineStringSnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nLineStringSnapper.prototype.getClass = function getClass () {\n  return LineStringSnapper\n};\nLineStringSnapper.isClosed = function isClosed (pts) {\n  if (pts.length <= 1) { return false }\n  return pts[0].equals2D(pts[pts.length - 1])\n};\n\nvar GeometrySnapper = function GeometrySnapper (srcGeom) {\n  this._srcGeom = srcGeom || null;\n};\n\nvar staticAccessors$41 = { SNAP_PRECISION_FACTOR: { configurable: true } };\nGeometrySnapper.prototype.snapTo = function snapTo (snapGeom, snapTolerance) {\n  var snapPts = this.extractTargetCoordinates(snapGeom);\n  var snapTrans = new SnapTransformer(snapTolerance, snapPts);\n  return snapTrans.transform(this._srcGeom)\n};\nGeometrySnapper.prototype.snapToSelf = function snapToSelf (snapTolerance, cleanResult) {\n  var snapPts = this.extractTargetCoordinates(this._srcGeom);\n  var snapTrans = new SnapTransformer(snapTolerance, snapPts, true);\n  var snappedGeom = snapTrans.transform(this._srcGeom);\n  var result = snappedGeom;\n  if (cleanResult && hasInterface(result, Polygonal)) {\n    result = snappedGeom.buffer(0);\n  }\n  return result\n};\nGeometrySnapper.prototype.computeSnapTolerance = function computeSnapTolerance (ringPts) {\n  var minSegLen = this.computeMinimumSegmentLength(ringPts);\n  var snapTol = minSegLen / 10;\n  return snapTol\n};\nGeometrySnapper.prototype.extractTargetCoordinates = function extractTargetCoordinates (g) {\n  var ptSet = new TreeSet();\n  var pts = g.getCoordinates();\n  for (var i = 0; i < pts.length; i++) {\n    ptSet.add(pts[i]);\n  }\n  return ptSet.toArray(new Array(0).fill(null))\n};\nGeometrySnapper.prototype.computeMinimumSegmentLength = function computeMinimumSegmentLength (pts) {\n  var minSegLen = Double.MAX_VALUE;\n  for (var i = 0; i < pts.length - 1; i++) {\n    var segLen = pts[i].distance(pts[i + 1]);\n    if (segLen < minSegLen) { minSegLen = segLen; }\n  }\n  return minSegLen\n};\nGeometrySnapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometrySnapper.prototype.getClass = function getClass () {\n  return GeometrySnapper\n};\nGeometrySnapper.snap = function snap (g0, g1, snapTolerance) {\n  var snapGeom = new Array(2).fill(null);\n  var snapper0 = new GeometrySnapper(g0);\n  snapGeom[0] = snapper0.snapTo(g1, snapTolerance);\n  var snapper1 = new GeometrySnapper(g1);\n  snapGeom[1] = snapper1.snapTo(snapGeom[0], snapTolerance);\n  return snapGeom\n};\nGeometrySnapper.computeOverlaySnapTolerance = function computeOverlaySnapTolerance () {\n  if (arguments.length === 1) {\n    var g = arguments[0];\n    var snapTolerance = GeometrySnapper.computeSizeBasedSnapTolerance(g);\n    var pm = g.getPrecisionModel();\n    if (pm.getType() === PrecisionModel.FIXED) {\n      var fixedSnapTol = 1 / pm.getScale() * 2 / 1.415;\n      if (fixedSnapTol > snapTolerance) { snapTolerance = fixedSnapTol; }\n    }\n    return snapTolerance\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    return Math.min(GeometrySnapper.computeOverlaySnapTolerance(g0), GeometrySnapper.computeOverlaySnapTolerance(g1))\n  }\n};\nGeometrySnapper.computeSizeBasedSnapTolerance = function computeSizeBasedSnapTolerance (g) {\n  var env = g.getEnvelopeInternal();\n  var minDimension = Math.min(env.getHeight(), env.getWidth());\n  var snapTol = minDimension * GeometrySnapper.SNAP_PRECISION_FACTOR;\n  return snapTol\n};\nGeometrySnapper.snapToSelf = function snapToSelf (geom, snapTolerance, cleanResult) {\n  var snapper0 = new GeometrySnapper(geom);\n  return snapper0.snapToSelf(snapTolerance, cleanResult)\n};\nstaticAccessors$41.SNAP_PRECISION_FACTOR.get = function () { return 1e-9 };\n\nObject.defineProperties( GeometrySnapper, staticAccessors$41 );\n\nvar SnapTransformer = (function (GeometryTransformer$$1) {\n  function SnapTransformer (snapTolerance, snapPts, isSelfSnap) {\n    GeometryTransformer$$1.call(this);\n    this._snapTolerance = snapTolerance || null;\n    this._snapPts = snapPts || null;\n    this._isSelfSnap = (isSelfSnap !== undefined) ? isSelfSnap : false;\n  }\n\n  if ( GeometryTransformer$$1 ) SnapTransformer.__proto__ = GeometryTransformer$$1;\n  SnapTransformer.prototype = Object.create( GeometryTransformer$$1 && GeometryTransformer$$1.prototype );\n  SnapTransformer.prototype.constructor = SnapTransformer;\n  SnapTransformer.prototype.snapLine = function snapLine (srcPts, snapPts) {\n    var snapper = new LineStringSnapper(srcPts, this._snapTolerance);\n    snapper.setAllowSnappingToSourceVertices(this._isSelfSnap);\n    return snapper.snapTo(snapPts)\n  };\n  SnapTransformer.prototype.transformCoordinates = function transformCoordinates (coords, parent) {\n    var srcPts = coords.toCoordinateArray();\n    var newPts = this.snapLine(srcPts, this._snapPts);\n    return this._factory.getCoordinateSequenceFactory().create(newPts)\n  };\n  SnapTransformer.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SnapTransformer.prototype.getClass = function getClass () {\n    return SnapTransformer\n  };\n\n  return SnapTransformer;\n}(GeometryTransformer));\n\nvar CommonBits = function CommonBits () {\n  this._isFirst = true;\n  this._commonMantissaBitsCount = 53;\n  this._commonBits = 0;\n  this._commonSignExp = null;\n};\nCommonBits.prototype.getCommon = function getCommon () {\n  return Double.longBitsToDouble(this._commonBits)\n};\nCommonBits.prototype.add = function add (num) {\n  var numBits = Double.doubleToLongBits(num);\n  if (this._isFirst) {\n    this._commonBits = numBits;\n    this._commonSignExp = CommonBits.signExpBits(this._commonBits);\n    this._isFirst = false;\n    return null\n  }\n  var numSignExp = CommonBits.signExpBits(numBits);\n  if (numSignExp !== this._commonSignExp) {\n    this._commonBits = 0;\n    return null\n  }\n  this._commonMantissaBitsCount = CommonBits.numCommonMostSigMantissaBits(this._commonBits, numBits);\n  this._commonBits = CommonBits.zeroLowerBits(this._commonBits, 64 - (12 + this._commonMantissaBitsCount));\n};\nCommonBits.prototype.toString = function toString () {\n  if (arguments.length === 1) {\n    var bits = arguments[0];\n    var x = Double.longBitsToDouble(bits);\n    var numStr = Double.toBinaryString(bits);\n    var padStr = '0000000000000000000000000000000000000000000000000000000000000000' + numStr;\n    var bitStr = padStr.substring(padStr.length - 64);\n    var str = bitStr.substring(0, 1) + '  ' + bitStr.substring(1, 12) + '(exp) ' + bitStr.substring(12) + ' [ ' + x + ' ]';\n    return str\n  }\n};\nCommonBits.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCommonBits.prototype.getClass = function getClass () {\n  return CommonBits\n};\nCommonBits.getBit = function getBit (bits, i) {\n  var mask = 1 << i;\n  return (bits & mask) !== 0 ? 1 : 0\n};\nCommonBits.signExpBits = function signExpBits (num) {\n  return num >> 52\n};\nCommonBits.zeroLowerBits = function zeroLowerBits (bits, nBits) {\n  var invMask = (1 << nBits) - 1;\n  var mask = ~invMask;\n  var zeroed = bits & mask;\n  return zeroed\n};\nCommonBits.numCommonMostSigMantissaBits = function numCommonMostSigMantissaBits (num1, num2) {\n  var count = 0;\n  for (var i = 52; i >= 0; i--) {\n    if (CommonBits.getBit(num1, i) !== CommonBits.getBit(num2, i)) { return count }\n    count++;\n  }\n  return 52\n};\n\nvar CommonBitsRemover = function CommonBitsRemover () {\n  this._commonCoord = null;\n  this._ccFilter = new CommonCoordinateFilter();\n};\n\nvar staticAccessors$42 = { CommonCoordinateFilter: { configurable: true },Translater: { configurable: true } };\nCommonBitsRemover.prototype.addCommonBits = function addCommonBits (geom) {\n  var trans = new Translater(this._commonCoord);\n  geom.apply(trans);\n  geom.geometryChanged();\n};\nCommonBitsRemover.prototype.removeCommonBits = function removeCommonBits (geom) {\n  if (this._commonCoord.x === 0.0 && this._commonCoord.y === 0.0) { return geom }\n  var invCoord = new Coordinate(this._commonCoord);\n  invCoord.x = -invCoord.x;\n  invCoord.y = -invCoord.y;\n  var trans = new Translater(invCoord);\n  geom.apply(trans);\n  geom.geometryChanged();\n  return geom\n};\nCommonBitsRemover.prototype.getCommonCoordinate = function getCommonCoordinate () {\n  return this._commonCoord\n};\nCommonBitsRemover.prototype.add = function add (geom) {\n  geom.apply(this._ccFilter);\n  this._commonCoord = this._ccFilter.getCommonCoordinate();\n};\nCommonBitsRemover.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCommonBitsRemover.prototype.getClass = function getClass () {\n  return CommonBitsRemover\n};\nstaticAccessors$42.CommonCoordinateFilter.get = function () { return CommonCoordinateFilter };\nstaticAccessors$42.Translater.get = function () { return Translater };\n\nObject.defineProperties( CommonBitsRemover, staticAccessors$42 );\n\nvar CommonCoordinateFilter = function CommonCoordinateFilter () {\n  this._commonBitsX = new CommonBits();\n  this._commonBitsY = new CommonBits();\n};\nCommonCoordinateFilter.prototype.filter = function filter (coord) {\n  this._commonBitsX.add(coord.x);\n  this._commonBitsY.add(coord.y);\n};\nCommonCoordinateFilter.prototype.getCommonCoordinate = function getCommonCoordinate () {\n  return new Coordinate(this._commonBitsX.getCommon(), this._commonBitsY.getCommon())\n};\nCommonCoordinateFilter.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateFilter]\n};\nCommonCoordinateFilter.prototype.getClass = function getClass () {\n  return CommonCoordinateFilter\n};\n\nvar Translater = function Translater () {\n  this.trans = null;\n  var trans = arguments[0];\n  this.trans = trans;\n};\nTranslater.prototype.filter = function filter (seq, i) {\n  var xp = seq.getOrdinate(i, 0) + this.trans.x;\n  var yp = seq.getOrdinate(i, 1) + this.trans.y;\n  seq.setOrdinate(i, 0, xp);\n  seq.setOrdinate(i, 1, yp);\n};\nTranslater.prototype.isDone = function isDone () {\n  return false\n};\nTranslater.prototype.isGeometryChanged = function isGeometryChanged () {\n  return true\n};\nTranslater.prototype.interfaces_ = function interfaces_ () {\n  return [CoordinateSequenceFilter]\n};\nTranslater.prototype.getClass = function getClass () {\n  return Translater\n};\n\nvar SnapOverlayOp = function SnapOverlayOp (g1, g2) {\n  this._geom = new Array(2).fill(null);\n  this._snapTolerance = null;\n  this._cbr = null;\n  this._geom[0] = g1;\n  this._geom[1] = g2;\n  this.computeSnapTolerance();\n};\nSnapOverlayOp.prototype.selfSnap = function selfSnap (geom) {\n  var snapper0 = new GeometrySnapper(geom);\n  var snapGeom = snapper0.snapTo(geom, this._snapTolerance);\n  return snapGeom\n};\nSnapOverlayOp.prototype.removeCommonBits = function removeCommonBits (geom) {\n  this._cbr = new CommonBitsRemover();\n  this._cbr.add(geom[0]);\n  this._cbr.add(geom[1]);\n  var remGeom = new Array(2).fill(null);\n  remGeom[0] = this._cbr.removeCommonBits(geom[0].copy());\n  remGeom[1] = this._cbr.removeCommonBits(geom[1].copy());\n  return remGeom\n};\nSnapOverlayOp.prototype.prepareResult = function prepareResult (geom) {\n  this._cbr.addCommonBits(geom);\n  return geom\n};\nSnapOverlayOp.prototype.getResultGeometry = function getResultGeometry (opCode) {\n  var prepGeom = this.snap(this._geom);\n  var result = OverlayOp.overlayOp(prepGeom[0], prepGeom[1], opCode);\n  return this.prepareResult(result)\n};\nSnapOverlayOp.prototype.checkValid = function checkValid (g) {\n  if (!g.isValid()) {\n    System.out.println('Snapped geometry is invalid');\n  }\n};\nSnapOverlayOp.prototype.computeSnapTolerance = function computeSnapTolerance () {\n  this._snapTolerance = GeometrySnapper.computeOverlaySnapTolerance(this._geom[0], this._geom[1]);\n};\nSnapOverlayOp.prototype.snap = function snap (geom) {\n  var remGeom = this.removeCommonBits(geom);\n  var snapGeom = GeometrySnapper.snap(remGeom[0], remGeom[1], this._snapTolerance);\n  return snapGeom\n};\nSnapOverlayOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSnapOverlayOp.prototype.getClass = function getClass () {\n  return SnapOverlayOp\n};\nSnapOverlayOp.overlayOp = function overlayOp (g0, g1, opCode) {\n  var op = new SnapOverlayOp(g0, g1);\n  return op.getResultGeometry(opCode)\n};\nSnapOverlayOp.union = function union (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)\n};\nSnapOverlayOp.intersection = function intersection (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)\n};\nSnapOverlayOp.symDifference = function symDifference (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)\n};\nSnapOverlayOp.difference = function difference (g0, g1) {\n  return SnapOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)\n};\n\nvar SnapIfNeededOverlayOp = function SnapIfNeededOverlayOp (g1, g2) {\n  this._geom = new Array(2).fill(null);\n  this._geom[0] = g1;\n  this._geom[1] = g2;\n};\nSnapIfNeededOverlayOp.prototype.getResultGeometry = function getResultGeometry (opCode) {\n  var result = null;\n  var isSuccess = false;\n  var savedException = null;\n  try {\n    result = OverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n    var isValid = true;\n    if (isValid) { isSuccess = true; }\n  } catch (ex) {\n    if (ex instanceof RuntimeException) {\n      savedException = ex;\n    } else { throw ex }\n  } finally {}\n  if (!isSuccess) {\n    try {\n      result = SnapOverlayOp.overlayOp(this._geom[0], this._geom[1], opCode);\n    } catch (ex) {\n      if (ex instanceof RuntimeException) {\n        throw savedException\n      } else { throw ex }\n    } finally {}\n  }\n  return result\n};\nSnapIfNeededOverlayOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSnapIfNeededOverlayOp.prototype.getClass = function getClass () {\n  return SnapIfNeededOverlayOp\n};\nSnapIfNeededOverlayOp.overlayOp = function overlayOp (g0, g1, opCode) {\n  var op = new SnapIfNeededOverlayOp(g0, g1);\n  return op.getResultGeometry(opCode)\n};\nSnapIfNeededOverlayOp.union = function union (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.UNION)\n};\nSnapIfNeededOverlayOp.intersection = function intersection (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.INTERSECTION)\n};\nSnapIfNeededOverlayOp.symDifference = function symDifference (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.SYMDIFFERENCE)\n};\nSnapIfNeededOverlayOp.difference = function difference (g0, g1) {\n  return SnapIfNeededOverlayOp.overlayOp(g0, g1, OverlayOp.DIFFERENCE)\n};\n\nvar MonotoneChain$2 = function MonotoneChain () {\n  this.mce = null;\n  this.chainIndex = null;\n  var mce = arguments[0];\n  var chainIndex = arguments[1];\n  this.mce = mce;\n  this.chainIndex = chainIndex;\n};\nMonotoneChain$2.prototype.computeIntersections = function computeIntersections (mc, si) {\n  this.mce.computeIntersectsForChain(this.chainIndex, mc.mce, mc.chainIndex, si);\n};\nMonotoneChain$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nMonotoneChain$2.prototype.getClass = function getClass () {\n  return MonotoneChain$2\n};\n\nvar SweepLineEvent = function SweepLineEvent () {\n  this._label = null;\n  this._xValue = null;\n  this._eventType = null;\n  this._insertEvent = null;\n  this._deleteEventIndex = null;\n  this._obj = null;\n  if (arguments.length === 2) {\n    var x = arguments[0];\n    var insertEvent = arguments[1];\n    this._eventType = SweepLineEvent.DELETE;\n    this._xValue = x;\n    this._insertEvent = insertEvent;\n  } else if (arguments.length === 3) {\n    var label = arguments[0];\n    var x$1 = arguments[1];\n    var obj = arguments[2];\n    this._eventType = SweepLineEvent.INSERT;\n    this._label = label;\n    this._xValue = x$1;\n    this._obj = obj;\n  }\n};\n\nvar staticAccessors$43 = { INSERT: { configurable: true },DELETE: { configurable: true } };\nSweepLineEvent.prototype.isDelete = function isDelete () {\n  return this._eventType === SweepLineEvent.DELETE\n};\nSweepLineEvent.prototype.setDeleteEventIndex = function setDeleteEventIndex (deleteEventIndex) {\n  this._deleteEventIndex = deleteEventIndex;\n};\nSweepLineEvent.prototype.getObject = function getObject () {\n  return this._obj\n};\nSweepLineEvent.prototype.compareTo = function compareTo (o) {\n  var pe = o;\n  if (this._xValue < pe._xValue) { return -1 }\n  if (this._xValue > pe._xValue) { return 1 }\n  if (this._eventType < pe._eventType) { return -1 }\n  if (this._eventType > pe._eventType) { return 1 }\n  return 0\n};\nSweepLineEvent.prototype.getInsertEvent = function getInsertEvent () {\n  return this._insertEvent\n};\nSweepLineEvent.prototype.isInsert = function isInsert () {\n  return this._eventType === SweepLineEvent.INSERT\n};\nSweepLineEvent.prototype.isSameLabel = function isSameLabel (ev) {\n  if (this._label === null) { return false }\n  return this._label === ev._label\n};\nSweepLineEvent.prototype.getDeleteEventIndex = function getDeleteEventIndex () {\n  return this._deleteEventIndex\n};\nSweepLineEvent.prototype.interfaces_ = function interfaces_ () {\n  return [Comparable]\n};\nSweepLineEvent.prototype.getClass = function getClass () {\n  return SweepLineEvent\n};\nstaticAccessors$43.INSERT.get = function () { return 1 };\nstaticAccessors$43.DELETE.get = function () { return 2 };\n\nObject.defineProperties( SweepLineEvent, staticAccessors$43 );\n\nvar EdgeSetIntersector = function EdgeSetIntersector () {};\n\nEdgeSetIntersector.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nEdgeSetIntersector.prototype.getClass = function getClass () {\n  return EdgeSetIntersector\n};\n\nvar SegmentIntersector$2 = function SegmentIntersector () {\n  this._hasIntersection = false;\n  this._hasProper = false;\n  this._hasProperInterior = false;\n  this._properIntersectionPoint = null;\n  this._li = null;\n  this._includeProper = null;\n  this._recordIsolated = null;\n  this._isSelfIntersection = null;\n  this._numIntersections = 0;\n  this.numTests = 0;\n  this._bdyNodes = null;\n  this._isDone = false;\n  this._isDoneWhenProperInt = false;\n  var li = arguments[0];\n  var includeProper = arguments[1];\n  var recordIsolated = arguments[2];\n  this._li = li;\n  this._includeProper = includeProper;\n  this._recordIsolated = recordIsolated;\n};\nSegmentIntersector$2.prototype.isTrivialIntersection = function isTrivialIntersection (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1) {\n    if (this._li.getIntersectionNum() === 1) {\n      if (SegmentIntersector$2.isAdjacentSegments(segIndex0, segIndex1)) { return true }\n      if (e0.isClosed()) {\n        var maxSegIndex = e0.getNumPoints() - 1;\n        if ((segIndex0 === 0 && segIndex1 === maxSegIndex) ||\n            (segIndex1 === 0 && segIndex0 === maxSegIndex)) {\n          return true\n        }\n      }\n    }\n  }\n  return false\n};\nSegmentIntersector$2.prototype.getProperIntersectionPoint = function getProperIntersectionPoint () {\n  return this._properIntersectionPoint\n};\nSegmentIntersector$2.prototype.setIsDoneIfProperInt = function setIsDoneIfProperInt (isDoneWhenProperInt) {\n  this._isDoneWhenProperInt = isDoneWhenProperInt;\n};\nSegmentIntersector$2.prototype.hasProperInteriorIntersection = function hasProperInteriorIntersection () {\n  return this._hasProperInterior\n};\nSegmentIntersector$2.prototype.isBoundaryPointInternal = function isBoundaryPointInternal (li, bdyNodes) {\n  for (var i = bdyNodes.iterator(); i.hasNext();) {\n    var node = i.next();\n    var pt = node.getCoordinate();\n    if (li.isIntersection(pt)) { return true }\n  }\n  return false\n};\nSegmentIntersector$2.prototype.hasProperIntersection = function hasProperIntersection () {\n  return this._hasProper\n};\nSegmentIntersector$2.prototype.hasIntersection = function hasIntersection () {\n  return this._hasIntersection\n};\nSegmentIntersector$2.prototype.isDone = function isDone () {\n  return this._isDone\n};\nSegmentIntersector$2.prototype.isBoundaryPoint = function isBoundaryPoint (li, bdyNodes) {\n  if (bdyNodes === null) { return false }\n  if (this.isBoundaryPointInternal(li, bdyNodes[0])) { return true }\n  if (this.isBoundaryPointInternal(li, bdyNodes[1])) { return true }\n  return false\n};\nSegmentIntersector$2.prototype.setBoundaryNodes = function setBoundaryNodes (bdyNodes0, bdyNodes1) {\n  this._bdyNodes = new Array(2).fill(null);\n  this._bdyNodes[0] = bdyNodes0;\n  this._bdyNodes[1] = bdyNodes1;\n};\nSegmentIntersector$2.prototype.addIntersections = function addIntersections (e0, segIndex0, e1, segIndex1) {\n  if (e0 === e1 && segIndex0 === segIndex1) { return null }\n  this.numTests++;\n  var p00 = e0.getCoordinates()[segIndex0];\n  var p01 = e0.getCoordinates()[segIndex0 + 1];\n  var p10 = e1.getCoordinates()[segIndex1];\n  var p11 = e1.getCoordinates()[segIndex1 + 1];\n  this._li.computeIntersection(p00, p01, p10, p11);\n  if (this._li.hasIntersection()) {\n    if (this._recordIsolated) {\n      e0.setIsolated(false);\n      e1.setIsolated(false);\n    }\n    this._numIntersections++;\n    if (!this.isTrivialIntersection(e0, segIndex0, e1, segIndex1)) {\n      this._hasIntersection = true;\n      if (this._includeProper || !this._li.isProper()) {\n        e0.addIntersections(this._li, segIndex0, 0);\n        e1.addIntersections(this._li, segIndex1, 1);\n      }\n      if (this._li.isProper()) {\n        this._properIntersectionPoint = this._li.getIntersection(0).copy();\n        this._hasProper = true;\n        if (this._isDoneWhenProperInt) {\n          this._isDone = true;\n        }\n        if (!this.isBoundaryPoint(this._li, this._bdyNodes)) { this._hasProperInterior = true; }\n      }\n    }\n  }\n};\nSegmentIntersector$2.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSegmentIntersector$2.prototype.getClass = function getClass () {\n  return SegmentIntersector$2\n};\nSegmentIntersector$2.isAdjacentSegments = function isAdjacentSegments (i1, i2) {\n  return Math.abs(i1 - i2) === 1\n};\n\nvar SimpleMCSweepLineIntersector = (function (EdgeSetIntersector$$1) {\n  function SimpleMCSweepLineIntersector () {\n    EdgeSetIntersector$$1.call(this);\n    this.events = new ArrayList();\n    this.nOverlaps = null;\n  }\n\n  if ( EdgeSetIntersector$$1 ) SimpleMCSweepLineIntersector.__proto__ = EdgeSetIntersector$$1;\n  SimpleMCSweepLineIntersector.prototype = Object.create( EdgeSetIntersector$$1 && EdgeSetIntersector$$1.prototype );\n  SimpleMCSweepLineIntersector.prototype.constructor = SimpleMCSweepLineIntersector;\n  SimpleMCSweepLineIntersector.prototype.prepareEvents = function prepareEvents () {\n    var this$1 = this;\n\n    Collections.sort(this.events);\n    for (var i = 0; i < this.events.size(); i++) {\n      var ev = this$1.events.get(i);\n      if (ev.isDelete()) {\n        ev.getInsertEvent().setDeleteEventIndex(i);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.computeIntersections = function computeIntersections () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var si = arguments[0];\n      this.nOverlaps = 0;\n      this.prepareEvents();\n      for (var i = 0; i < this.events.size(); i++) {\n        var ev = this$1.events.get(i);\n        if (ev.isInsert()) {\n          this$1.processOverlaps(i, ev.getDeleteEventIndex(), ev, si);\n        }\n        if (si.isDone()) {\n          break\n        }\n      }\n    } else if (arguments.length === 3) {\n      if (arguments[2] instanceof SegmentIntersector$2 && (hasInterface(arguments[0], List) && hasInterface(arguments[1], List))) {\n        var edges0 = arguments[0];\n        var edges1 = arguments[1];\n        var si$1 = arguments[2];\n        this.addEdges(edges0, edges0);\n        this.addEdges(edges1, edges1);\n        this.computeIntersections(si$1);\n      } else if (typeof arguments[2] === 'boolean' && (hasInterface(arguments[0], List) && arguments[1] instanceof SegmentIntersector$2)) {\n        var edges = arguments[0];\n        var si$2 = arguments[1];\n        var testAllSegments = arguments[2];\n        if (testAllSegments) { this.addEdges(edges, null); } else { this.addEdges(edges); }\n        this.computeIntersections(si$2);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.addEdge = function addEdge (edge, edgeSet) {\n    var this$1 = this;\n\n    var mce = edge.getMonotoneChainEdge();\n    var startIndex = mce.getStartIndexes();\n    for (var i = 0; i < startIndex.length - 1; i++) {\n      var mc = new MonotoneChain$2(mce, i);\n      var insertEvent = new SweepLineEvent(edgeSet, mce.getMinX(i), mc);\n      this$1.events.add(insertEvent);\n      this$1.events.add(new SweepLineEvent(mce.getMaxX(i), insertEvent));\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.processOverlaps = function processOverlaps (start, end, ev0, si) {\n    var this$1 = this;\n\n    var mc0 = ev0.getObject();\n    for (var i = start; i < end; i++) {\n      var ev1 = this$1.events.get(i);\n      if (ev1.isInsert()) {\n        var mc1 = ev1.getObject();\n        if (!ev0.isSameLabel(ev1)) {\n          mc0.computeIntersections(mc1, si);\n          this$1.nOverlaps++;\n        }\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.addEdges = function addEdges () {\n    var this$1 = this;\n\n    if (arguments.length === 1) {\n      var edges = arguments[0];\n      for (var i = edges.iterator(); i.hasNext();) {\n        var edge = i.next();\n        this$1.addEdge(edge, edge);\n      }\n    } else if (arguments.length === 2) {\n      var edges$1 = arguments[0];\n      var edgeSet = arguments[1];\n      for (var i$1 = edges$1.iterator(); i$1.hasNext();) {\n        var edge$1 = i$1.next();\n        this$1.addEdge(edge$1, edgeSet);\n      }\n    }\n  };\n  SimpleMCSweepLineIntersector.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  SimpleMCSweepLineIntersector.prototype.getClass = function getClass () {\n    return SimpleMCSweepLineIntersector\n  };\n\n  return SimpleMCSweepLineIntersector;\n}(EdgeSetIntersector));\n\nvar IntervalRTreeNode = function IntervalRTreeNode () {\n  this._min = Double.POSITIVE_INFINITY;\n  this._max = Double.NEGATIVE_INFINITY;\n};\n\nvar staticAccessors$45 = { NodeComparator: { configurable: true } };\nIntervalRTreeNode.prototype.getMin = function getMin () {\n  return this._min\n};\nIntervalRTreeNode.prototype.intersects = function intersects (queryMin, queryMax) {\n  if (this._min > queryMax || this._max < queryMin) { return false }\n  return true\n};\nIntervalRTreeNode.prototype.getMax = function getMax () {\n  return this._max\n};\nIntervalRTreeNode.prototype.toString = function toString () {\n  return WKTWriter.toLineString(new Coordinate(this._min, 0), new Coordinate(this._max, 0))\n};\nIntervalRTreeNode.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nIntervalRTreeNode.prototype.getClass = function getClass () {\n  return IntervalRTreeNode\n};\nstaticAccessors$45.NodeComparator.get = function () { return NodeComparator };\n\nObject.defineProperties( IntervalRTreeNode, staticAccessors$45 );\n\nvar NodeComparator = function NodeComparator () {};\n\nNodeComparator.prototype.compare = function compare (o1, o2) {\n  var n1 = o1;\n  var n2 = o2;\n  var mid1 = (n1._min + n1._max) / 2;\n  var mid2 = (n2._min + n2._max) / 2;\n  if (mid1 < mid2) { return -1 }\n  if (mid1 > mid2) { return 1 }\n  return 0\n};\nNodeComparator.prototype.interfaces_ = function interfaces_ () {\n  return [Comparator]\n};\nNodeComparator.prototype.getClass = function getClass () {\n  return NodeComparator\n};\n\nvar IntervalRTreeLeafNode = (function (IntervalRTreeNode$$1) {\n  function IntervalRTreeLeafNode () {\n    IntervalRTreeNode$$1.call(this);\n    this._item = null;\n    var min = arguments[0];\n    var max = arguments[1];\n    var item = arguments[2];\n    this._min = min;\n    this._max = max;\n    this._item = item;\n  }\n\n  if ( IntervalRTreeNode$$1 ) IntervalRTreeLeafNode.__proto__ = IntervalRTreeNode$$1;\n  IntervalRTreeLeafNode.prototype = Object.create( IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype );\n  IntervalRTreeLeafNode.prototype.constructor = IntervalRTreeLeafNode;\n  IntervalRTreeLeafNode.prototype.query = function query (queryMin, queryMax, visitor) {\n    if (!this.intersects(queryMin, queryMax)) { return null }\n    visitor.visitItem(this._item);\n  };\n  IntervalRTreeLeafNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  IntervalRTreeLeafNode.prototype.getClass = function getClass () {\n    return IntervalRTreeLeafNode\n  };\n\n  return IntervalRTreeLeafNode;\n}(IntervalRTreeNode));\n\nvar IntervalRTreeBranchNode = (function (IntervalRTreeNode$$1) {\n  function IntervalRTreeBranchNode () {\n    IntervalRTreeNode$$1.call(this);\n    this._node1 = null;\n    this._node2 = null;\n    var n1 = arguments[0];\n    var n2 = arguments[1];\n    this._node1 = n1;\n    this._node2 = n2;\n    this.buildExtent(this._node1, this._node2);\n  }\n\n  if ( IntervalRTreeNode$$1 ) IntervalRTreeBranchNode.__proto__ = IntervalRTreeNode$$1;\n  IntervalRTreeBranchNode.prototype = Object.create( IntervalRTreeNode$$1 && IntervalRTreeNode$$1.prototype );\n  IntervalRTreeBranchNode.prototype.constructor = IntervalRTreeBranchNode;\n  IntervalRTreeBranchNode.prototype.buildExtent = function buildExtent (n1, n2) {\n    this._min = Math.min(n1._min, n2._min);\n    this._max = Math.max(n1._max, n2._max);\n  };\n  IntervalRTreeBranchNode.prototype.query = function query (queryMin, queryMax, visitor) {\n    if (!this.intersects(queryMin, queryMax)) {\n      return null\n    }\n    if (this._node1 !== null) { this._node1.query(queryMin, queryMax, visitor); }\n    if (this._node2 !== null) { this._node2.query(queryMin, queryMax, visitor); }\n  };\n  IntervalRTreeBranchNode.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  IntervalRTreeBranchNode.prototype.getClass = function getClass () {\n    return IntervalRTreeBranchNode\n  };\n\n  return IntervalRTreeBranchNode;\n}(IntervalRTreeNode));\n\nvar SortedPackedIntervalRTree = function SortedPackedIntervalRTree () {\n  this._leaves = new ArrayList();\n  this._root = null;\n  this._level = 0;\n};\nSortedPackedIntervalRTree.prototype.buildTree = function buildTree () {\n    var this$1 = this;\n\n  Collections.sort(this._leaves, new IntervalRTreeNode.NodeComparator());\n  var src = this._leaves;\n  var temp = null;\n  var dest = new ArrayList();\n  while (true) {\n    this$1.buildLevel(src, dest);\n    if (dest.size() === 1) { return dest.get(0) }\n    temp = src;\n    src = dest;\n    dest = temp;\n  }\n};\nSortedPackedIntervalRTree.prototype.insert = function insert (min, max, item) {\n  if (this._root !== null) { throw new Error('Index cannot be added to once it has been queried') }\n  this._leaves.add(new IntervalRTreeLeafNode(min, max, item));\n};\nSortedPackedIntervalRTree.prototype.query = function query (min, max, visitor) {\n  this.init();\n  this._root.query(min, max, visitor);\n};\nSortedPackedIntervalRTree.prototype.buildRoot = function buildRoot () {\n  if (this._root !== null) { return null }\n  this._root = this.buildTree();\n};\nSortedPackedIntervalRTree.prototype.printNode = function printNode (node) {\n  System.out.println(WKTWriter.toLineString(new Coordinate(node._min, this._level), new Coordinate(node._max, this._level)));\n};\nSortedPackedIntervalRTree.prototype.init = function init () {\n  if (this._root !== null) { return null }\n  this.buildRoot();\n};\nSortedPackedIntervalRTree.prototype.buildLevel = function buildLevel (src, dest) {\n  this._level++;\n  dest.clear();\n  for (var i = 0; i < src.size(); i += 2) {\n    var n1 = src.get(i);\n    var n2 = i + 1 < src.size() ? src.get(i) : null;\n    if (n2 === null) {\n      dest.add(n1);\n    } else {\n      var node = new IntervalRTreeBranchNode(src.get(i), src.get(i + 1));\n      dest.add(node);\n    }\n  }\n};\nSortedPackedIntervalRTree.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nSortedPackedIntervalRTree.prototype.getClass = function getClass () {\n  return SortedPackedIntervalRTree\n};\n\nvar ArrayListVisitor = function ArrayListVisitor () {\n  this._items = new ArrayList();\n};\nArrayListVisitor.prototype.visitItem = function visitItem (item) {\n  this._items.add(item);\n};\nArrayListVisitor.prototype.getItems = function getItems () {\n  return this._items\n};\nArrayListVisitor.prototype.interfaces_ = function interfaces_ () {\n  return [ItemVisitor]\n};\nArrayListVisitor.prototype.getClass = function getClass () {\n  return ArrayListVisitor\n};\n\nvar IndexedPointInAreaLocator = function IndexedPointInAreaLocator () {\n  this._index = null;\n  var g = arguments[0];\n  if (!hasInterface(g, Polygonal)) { throw new IllegalArgumentException('Argument must be Polygonal') }\n  this._index = new IntervalIndexedGeometry(g);\n};\n\nvar staticAccessors$44 = { SegmentVisitor: { configurable: true },IntervalIndexedGeometry: { configurable: true } };\nIndexedPointInAreaLocator.prototype.locate = function locate (p) {\n  var rcc = new RayCrossingCounter(p);\n  var visitor = new SegmentVisitor(rcc);\n  this._index.query(p.y, p.y, visitor);\n  return rcc.getLocation()\n};\nIndexedPointInAreaLocator.prototype.interfaces_ = function interfaces_ () {\n  return [PointOnGeometryLocator]\n};\nIndexedPointInAreaLocator.prototype.getClass = function getClass () {\n  return IndexedPointInAreaLocator\n};\nstaticAccessors$44.SegmentVisitor.get = function () { return SegmentVisitor };\nstaticAccessors$44.IntervalIndexedGeometry.get = function () { return IntervalIndexedGeometry };\n\nObject.defineProperties( IndexedPointInAreaLocator, staticAccessors$44 );\n\nvar SegmentVisitor = function SegmentVisitor () {\n  this._counter = null;\n  var counter = arguments[0];\n  this._counter = counter;\n};\nSegmentVisitor.prototype.visitItem = function visitItem (item) {\n  var seg = item;\n  this._counter.countSegment(seg.getCoordinate(0), seg.getCoordinate(1));\n};\nSegmentVisitor.prototype.interfaces_ = function interfaces_ () {\n  return [ItemVisitor]\n};\nSegmentVisitor.prototype.getClass = function getClass () {\n  return SegmentVisitor\n};\n\nvar IntervalIndexedGeometry = function IntervalIndexedGeometry () {\n  this._index = new SortedPackedIntervalRTree();\n  var geom = arguments[0];\n  this.init(geom);\n};\nIntervalIndexedGeometry.prototype.init = function init (geom) {\n    var this$1 = this;\n\n  var lines = LinearComponentExtracter.getLines(geom);\n  for (var i = lines.iterator(); i.hasNext();) {\n    var line = i.next();\n    var pts = line.getCoordinates();\n    this$1.addLine(pts);\n  }\n};\nIntervalIndexedGeometry.prototype.addLine = function addLine (pts) {\n    var this$1 = this;\n\n  for (var i = 1; i < pts.length; i++) {\n    var seg = new LineSegment(pts[i - 1], pts[i]);\n    var min = Math.min(seg.p0.y, seg.p1.y);\n    var max = Math.max(seg.p0.y, seg.p1.y);\n    this$1._index.insert(min, max, seg);\n  }\n};\nIntervalIndexedGeometry.prototype.query = function query () {\n  if (arguments.length === 2) {\n    var min = arguments[0];\n    var max = arguments[1];\n    var visitor = new ArrayListVisitor();\n    this._index.query(min, max, visitor);\n    return visitor.getItems()\n  } else if (arguments.length === 3) {\n    var min$1 = arguments[0];\n    var max$1 = arguments[1];\n    var visitor$1 = arguments[2];\n    this._index.query(min$1, max$1, visitor$1);\n  }\n};\nIntervalIndexedGeometry.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nIntervalIndexedGeometry.prototype.getClass = function getClass () {\n  return IntervalIndexedGeometry\n};\n\nvar GeometryGraph = (function (PlanarGraph$$1) {\n  function GeometryGraph () {\n    PlanarGraph$$1.call(this);\n    this._parentGeom = null;\n    this._lineEdgeMap = new HashMap();\n    this._boundaryNodeRule = null;\n    this._useBoundaryDeterminationRule = true;\n    this._argIndex = null;\n    this._boundaryNodes = null;\n    this._hasTooFewPoints = false;\n    this._invalidPoint = null;\n    this._areaPtLocator = null;\n    this._ptLocator = new PointLocator();\n    if (arguments.length === 2) {\n      var argIndex = arguments[0];\n      var parentGeom = arguments[1];\n      var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n      this._argIndex = argIndex;\n      this._parentGeom = parentGeom;\n      this._boundaryNodeRule = boundaryNodeRule;\n      if (parentGeom !== null) {\n        this.add(parentGeom);\n      }\n    } else if (arguments.length === 3) {\n      var argIndex$1 = arguments[0];\n      var parentGeom$1 = arguments[1];\n      var boundaryNodeRule$1 = arguments[2];\n      this._argIndex = argIndex$1;\n      this._parentGeom = parentGeom$1;\n      this._boundaryNodeRule = boundaryNodeRule$1;\n      if (parentGeom$1 !== null) {\n        this.add(parentGeom$1);\n      }\n    }\n  }\n\n  if ( PlanarGraph$$1 ) GeometryGraph.__proto__ = PlanarGraph$$1;\n  GeometryGraph.prototype = Object.create( PlanarGraph$$1 && PlanarGraph$$1.prototype );\n  GeometryGraph.prototype.constructor = GeometryGraph;\n  GeometryGraph.prototype.insertBoundaryPoint = function insertBoundaryPoint (argIndex, coord) {\n    var n = this._nodes.addNode(coord);\n    var lbl = n.getLabel();\n    var boundaryCount = 1;\n    var loc = Location.NONE;\n    loc = lbl.getLocation(argIndex, Position.ON);\n    if (loc === Location.BOUNDARY) { boundaryCount++; }\n    var newLoc = GeometryGraph.determineBoundary(this._boundaryNodeRule, boundaryCount);\n    lbl.setLocation(argIndex, newLoc);\n  };\n  GeometryGraph.prototype.computeSelfNodes = function computeSelfNodes () {\n    if (arguments.length === 2) {\n      var li = arguments[0];\n      var computeRingSelfNodes = arguments[1];\n      return this.computeSelfNodes(li, computeRingSelfNodes, false)\n    } else if (arguments.length === 3) {\n      var li$1 = arguments[0];\n      var computeRingSelfNodes$1 = arguments[1];\n      var isDoneIfProperInt = arguments[2];\n      var si = new SegmentIntersector$2(li$1, true, false);\n      si.setIsDoneIfProperInt(isDoneIfProperInt);\n      var esi = this.createEdgeSetIntersector();\n      var isRings = this._parentGeom instanceof LinearRing || this._parentGeom instanceof Polygon || this._parentGeom instanceof MultiPolygon;\n      var computeAllSegments = computeRingSelfNodes$1 || !isRings;\n      esi.computeIntersections(this._edges, si, computeAllSegments);\n      this.addSelfIntersectionNodes(this._argIndex);\n      return si\n    }\n  };\n  GeometryGraph.prototype.computeSplitEdges = function computeSplitEdges (edgelist) {\n    for (var i = this._edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      e.eiList.addSplitEdges(edgelist);\n    }\n  };\n  GeometryGraph.prototype.computeEdgeIntersections = function computeEdgeIntersections (g, li, includeProper) {\n    var si = new SegmentIntersector$2(li, includeProper, true);\n    si.setBoundaryNodes(this.getBoundaryNodes(), g.getBoundaryNodes());\n    var esi = this.createEdgeSetIntersector();\n    esi.computeIntersections(this._edges, g._edges, si);\n    return si\n  };\n  GeometryGraph.prototype.getGeometry = function getGeometry () {\n    return this._parentGeom\n  };\n  GeometryGraph.prototype.getBoundaryNodeRule = function getBoundaryNodeRule () {\n    return this._boundaryNodeRule\n  };\n  GeometryGraph.prototype.hasTooFewPoints = function hasTooFewPoints () {\n    return this._hasTooFewPoints\n  };\n  GeometryGraph.prototype.addPoint = function addPoint () {\n    if (arguments[0] instanceof Point) {\n      var p = arguments[0];\n      var coord = p.getCoordinate();\n      this.insertPoint(this._argIndex, coord, Location.INTERIOR);\n    } else if (arguments[0] instanceof Coordinate) {\n      var pt = arguments[0];\n      this.insertPoint(this._argIndex, pt, Location.INTERIOR);\n    }\n  };\n  GeometryGraph.prototype.addPolygon = function addPolygon (p) {\n    var this$1 = this;\n\n    this.addPolygonRing(p.getExteriorRing(), Location.EXTERIOR, Location.INTERIOR);\n    for (var i = 0; i < p.getNumInteriorRing(); i++) {\n      var hole = p.getInteriorRingN(i);\n      this$1.addPolygonRing(hole, Location.INTERIOR, Location.EXTERIOR);\n    }\n  };\n  GeometryGraph.prototype.addEdge = function addEdge (e) {\n    this.insertEdge(e);\n    var coord = e.getCoordinates();\n    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n    this.insertPoint(this._argIndex, coord[coord.length - 1], Location.BOUNDARY);\n  };\n  GeometryGraph.prototype.addLineString = function addLineString (line) {\n    var coord = CoordinateArrays.removeRepeatedPoints(line.getCoordinates());\n    if (coord.length < 2) {\n      this._hasTooFewPoints = true;\n      this._invalidPoint = coord[0];\n      return null\n    }\n    var e = new Edge(coord, new Label(this._argIndex, Location.INTERIOR));\n    this._lineEdgeMap.put(line, e);\n    this.insertEdge(e);\n    Assert.isTrue(coord.length >= 2, 'found LineString with single point');\n    this.insertBoundaryPoint(this._argIndex, coord[0]);\n    this.insertBoundaryPoint(this._argIndex, coord[coord.length - 1]);\n  };\n  GeometryGraph.prototype.getInvalidPoint = function getInvalidPoint () {\n    return this._invalidPoint\n  };\n  GeometryGraph.prototype.getBoundaryPoints = function getBoundaryPoints () {\n    var coll = this.getBoundaryNodes();\n    var pts = new Array(coll.size()).fill(null);\n    var i = 0;\n    for (var it = coll.iterator(); it.hasNext();) {\n      var node = it.next();\n      pts[i++] = node.getCoordinate().copy();\n    }\n    return pts\n  };\n  GeometryGraph.prototype.getBoundaryNodes = function getBoundaryNodes () {\n    if (this._boundaryNodes === null) { this._boundaryNodes = this._nodes.getBoundaryNodes(this._argIndex); }\n    return this._boundaryNodes\n  };\n  GeometryGraph.prototype.addSelfIntersectionNode = function addSelfIntersectionNode (argIndex, coord, loc) {\n    if (this.isBoundaryNode(argIndex, coord)) { return null }\n    if (loc === Location.BOUNDARY && this._useBoundaryDeterminationRule) { this.insertBoundaryPoint(argIndex, coord); } else { this.insertPoint(argIndex, coord, loc); }\n  };\n  GeometryGraph.prototype.addPolygonRing = function addPolygonRing (lr, cwLeft, cwRight) {\n    if (lr.isEmpty()) { return null }\n    var coord = CoordinateArrays.removeRepeatedPoints(lr.getCoordinates());\n    if (coord.length < 4) {\n      this._hasTooFewPoints = true;\n      this._invalidPoint = coord[0];\n      return null\n    }\n    var left = cwLeft;\n    var right = cwRight;\n    if (CGAlgorithms.isCCW(coord)) {\n      left = cwRight;\n      right = cwLeft;\n    }\n    var e = new Edge(coord, new Label(this._argIndex, Location.BOUNDARY, left, right));\n    this._lineEdgeMap.put(lr, e);\n    this.insertEdge(e);\n    this.insertPoint(this._argIndex, coord[0], Location.BOUNDARY);\n  };\n  GeometryGraph.prototype.insertPoint = function insertPoint (argIndex, coord, onLocation) {\n    var n = this._nodes.addNode(coord);\n    var lbl = n.getLabel();\n    if (lbl === null) {\n      n._label = new Label(argIndex, onLocation);\n    } else { lbl.setLocation(argIndex, onLocation); }\n  };\n  GeometryGraph.prototype.createEdgeSetIntersector = function createEdgeSetIntersector () {\n    return new SimpleMCSweepLineIntersector()\n  };\n  GeometryGraph.prototype.addSelfIntersectionNodes = function addSelfIntersectionNodes (argIndex) {\n    var this$1 = this;\n\n    for (var i = this._edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      var eLoc = e.getLabel().getLocation(argIndex);\n      for (var eiIt = e.eiList.iterator(); eiIt.hasNext();) {\n        var ei = eiIt.next();\n        this$1.addSelfIntersectionNode(argIndex, ei.coord, eLoc);\n      }\n    }\n  };\n  GeometryGraph.prototype.add = function add () {\n    if (arguments.length === 1) {\n      var g = arguments[0];\n      if (g.isEmpty()) { return null }\n      if (g instanceof MultiPolygon) { this._useBoundaryDeterminationRule = false; }\n      if (g instanceof Polygon) { this.addPolygon(g); }\n      else if (g instanceof LineString) { this.addLineString(g); }\n      else if (g instanceof Point) { this.addPoint(g); }\n      else if (g instanceof MultiPoint) { this.addCollection(g); }\n      else if (g instanceof MultiLineString) { this.addCollection(g); }\n      else if (g instanceof MultiPolygon) { this.addCollection(g); }\n      else if (g instanceof GeometryCollection) { this.addCollection(g); }\n      else { throw new Error(g.getClass().getName()) }\n    } else { return PlanarGraph$$1.prototype.add.apply(this, arguments) }\n  };\n  GeometryGraph.prototype.addCollection = function addCollection (gc) {\n    var this$1 = this;\n\n    for (var i = 0; i < gc.getNumGeometries(); i++) {\n      var g = gc.getGeometryN(i);\n      this$1.add(g);\n    }\n  };\n  GeometryGraph.prototype.locate = function locate (pt) {\n    if (hasInterface(this._parentGeom, Polygonal) && this._parentGeom.getNumGeometries() > 50) {\n      if (this._areaPtLocator === null) {\n        this._areaPtLocator = new IndexedPointInAreaLocator(this._parentGeom);\n      }\n      return this._areaPtLocator.locate(pt)\n    }\n    return this._ptLocator.locate(pt, this._parentGeom)\n  };\n  GeometryGraph.prototype.findEdge = function findEdge () {\n    if (arguments.length === 1) {\n      var line = arguments[0];\n      return this._lineEdgeMap.get(line)\n    } else { return PlanarGraph$$1.prototype.findEdge.apply(this, arguments) }\n  };\n  GeometryGraph.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  GeometryGraph.prototype.getClass = function getClass () {\n    return GeometryGraph\n  };\n  GeometryGraph.determineBoundary = function determineBoundary (boundaryNodeRule, boundaryCount) {\n    return boundaryNodeRule.isInBoundary(boundaryCount) ? Location.BOUNDARY : Location.INTERIOR\n  };\n\n  return GeometryGraph;\n}(PlanarGraph));\n\nvar GeometryGraphOp = function GeometryGraphOp () {\n  this._li = new RobustLineIntersector();\n  this._resultPrecisionModel = null;\n  this._arg = null;\n  if (arguments.length === 1) {\n    var g0 = arguments[0];\n    this.setComputationPrecision(g0.getPrecisionModel());\n    this._arg = new Array(1).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0);\n  } else if (arguments.length === 2) {\n    var g0$1 = arguments[0];\n    var g1 = arguments[1];\n    var boundaryNodeRule = BoundaryNodeRule.OGC_SFS_BOUNDARY_RULE;\n    if (g0$1.getPrecisionModel().compareTo(g1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$1.getPrecisionModel()); } else { this.setComputationPrecision(g1.getPrecisionModel()); }\n    this._arg = new Array(2).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0$1, boundaryNodeRule);\n    this._arg[1] = new GeometryGraph(1, g1, boundaryNodeRule);\n  } else if (arguments.length === 3) {\n    var g0$2 = arguments[0];\n    var g1$1 = arguments[1];\n    var boundaryNodeRule$1 = arguments[2];\n    if (g0$2.getPrecisionModel().compareTo(g1$1.getPrecisionModel()) >= 0) { this.setComputationPrecision(g0$2.getPrecisionModel()); } else { this.setComputationPrecision(g1$1.getPrecisionModel()); }\n    this._arg = new Array(2).fill(null);\n    this._arg[0] = new GeometryGraph(0, g0$2, boundaryNodeRule$1);\n    this._arg[1] = new GeometryGraph(1, g1$1, boundaryNodeRule$1);\n  }\n};\nGeometryGraphOp.prototype.getArgGeometry = function getArgGeometry (i) {\n  return this._arg[i].getGeometry()\n};\nGeometryGraphOp.prototype.setComputationPrecision = function setComputationPrecision (pm) {\n  this._resultPrecisionModel = pm;\n  this._li.setPrecisionModel(this._resultPrecisionModel);\n};\nGeometryGraphOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryGraphOp.prototype.getClass = function getClass () {\n  return GeometryGraphOp\n};\n\n// operation.geometrygraph\n\nvar GeometryMapper = function GeometryMapper () {};\n\nGeometryMapper.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryMapper.prototype.getClass = function getClass () {\n  return GeometryMapper\n};\nGeometryMapper.map = function map () {\n  if (arguments[0] instanceof Geometry && hasInterface(arguments[1], GeometryMapper.MapOp)) {\n    var geom = arguments[0];\n    var op = arguments[1];\n    var mapped = new ArrayList();\n    for (var i = 0; i < geom.getNumGeometries(); i++) {\n      var g = op.map(geom.getGeometryN(i));\n      if (g !== null) { mapped.add(g); }\n    }\n    return geom.getFactory().buildGeometry(mapped)\n  } else if (hasInterface(arguments[0], Collection) && hasInterface(arguments[1], GeometryMapper.MapOp)) {\n    var geoms = arguments[0];\n    var op$1 = arguments[1];\n    var mapped$1 = new ArrayList();\n    for (var i$1 = geoms.iterator(); i$1.hasNext();) {\n      var g$1 = i$1.next();\n      var gr = op$1.map(g$1);\n      if (gr !== null) { mapped$1.add(gr); }\n    }\n    return mapped$1\n  }\n};\nGeometryMapper.MapOp = function MapOp () {};\n\nvar OverlayOp = (function (GeometryGraphOp) {\n  function OverlayOp () {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    GeometryGraphOp.call(this, g0, g1);\n    this._ptLocator = new PointLocator();\n    this._geomFact = null;\n    this._resultGeom = null;\n    this._graph = null;\n    this._edgeList = new EdgeList();\n    this._resultPolyList = new ArrayList();\n    this._resultLineList = new ArrayList();\n    this._resultPointList = new ArrayList();\n    this._graph = new PlanarGraph(new OverlayNodeFactory());\n    this._geomFact = g0.getFactory();\n  }\n\n  if ( GeometryGraphOp ) OverlayOp.__proto__ = GeometryGraphOp;\n  OverlayOp.prototype = Object.create( GeometryGraphOp && GeometryGraphOp.prototype );\n  OverlayOp.prototype.constructor = OverlayOp;\n  OverlayOp.prototype.insertUniqueEdge = function insertUniqueEdge (e) {\n    var existingEdge = this._edgeList.findEqualEdge(e);\n    if (existingEdge !== null) {\n      var existingLabel = existingEdge.getLabel();\n      var labelToMerge = e.getLabel();\n      if (!existingEdge.isPointwiseEqual(e)) {\n        labelToMerge = new Label(e.getLabel());\n        labelToMerge.flip();\n      }\n      var depth = existingEdge.getDepth();\n      if (depth.isNull()) {\n        depth.add(existingLabel);\n      }\n      depth.add(labelToMerge);\n      existingLabel.merge(labelToMerge);\n    } else {\n      this._edgeList.add(e);\n    }\n  };\n  OverlayOp.prototype.getGraph = function getGraph () {\n    return this._graph\n  };\n  OverlayOp.prototype.cancelDuplicateResultEdges = function cancelDuplicateResultEdges () {\n    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n      var de = it.next();\n      var sym = de.getSym();\n      if (de.isInResult() && sym.isInResult()) {\n        de.setInResult(false);\n        sym.setInResult(false);\n      }\n    }\n  };\n  OverlayOp.prototype.isCoveredByLA = function isCoveredByLA (coord) {\n    if (this.isCovered(coord, this._resultLineList)) { return true }\n    if (this.isCovered(coord, this._resultPolyList)) { return true }\n    return false\n  };\n  OverlayOp.prototype.computeGeometry = function computeGeometry (resultPointList, resultLineList, resultPolyList, opcode) {\n    var geomList = new ArrayList();\n    geomList.addAll(resultPointList);\n    geomList.addAll(resultLineList);\n    geomList.addAll(resultPolyList);\n    if (geomList.isEmpty()) { return OverlayOp.createEmptyResult(opcode, this._arg[0].getGeometry(), this._arg[1].getGeometry(), this._geomFact) }\n    return this._geomFact.buildGeometry(geomList)\n  };\n  OverlayOp.prototype.mergeSymLabels = function mergeSymLabels () {\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      node.getEdges().mergeSymLabels();\n    }\n  };\n  OverlayOp.prototype.isCovered = function isCovered (coord, geomList) {\n    var this$1 = this;\n\n    for (var it = geomList.iterator(); it.hasNext();) {\n      var geom = it.next();\n      var loc = this$1._ptLocator.locate(coord, geom);\n      if (loc !== Location.EXTERIOR) { return true }\n    }\n    return false\n  };\n  OverlayOp.prototype.replaceCollapsedEdges = function replaceCollapsedEdges () {\n    var newEdges = new ArrayList();\n    for (var it = this._edgeList.iterator(); it.hasNext();) {\n      var e = it.next();\n      if (e.isCollapsed()) {\n        it.remove();\n        newEdges.add(e.getCollapsedEdge());\n      }\n    }\n    this._edgeList.addAll(newEdges);\n  };\n  OverlayOp.prototype.updateNodeLabelling = function updateNodeLabelling () {\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      var lbl = node.getEdges().getLabel();\n      node.getLabel().merge(lbl);\n    }\n  };\n  OverlayOp.prototype.getResultGeometry = function getResultGeometry (overlayOpCode) {\n    this.computeOverlay(overlayOpCode);\n    return this._resultGeom\n  };\n  OverlayOp.prototype.insertUniqueEdges = function insertUniqueEdges (edges) {\n    var this$1 = this;\n\n    for (var i = edges.iterator(); i.hasNext();) {\n      var e = i.next();\n      this$1.insertUniqueEdge(e);\n    }\n  };\n  OverlayOp.prototype.computeOverlay = function computeOverlay (opCode) {\n    this.copyPoints(0);\n    this.copyPoints(1);\n    this._arg[0].computeSelfNodes(this._li, false);\n    this._arg[1].computeSelfNodes(this._li, false);\n    this._arg[0].computeEdgeIntersections(this._arg[1], this._li, true);\n    var baseSplitEdges = new ArrayList();\n    this._arg[0].computeSplitEdges(baseSplitEdges);\n    this._arg[1].computeSplitEdges(baseSplitEdges);\n    // const splitEdges = baseSplitEdges\n    this.insertUniqueEdges(baseSplitEdges);\n    this.computeLabelsFromDepths();\n    this.replaceCollapsedEdges();\n    EdgeNodingValidator.checkValid(this._edgeList.getEdges());\n    this._graph.addEdges(this._edgeList.getEdges());\n    this.computeLabelling();\n    this.labelIncompleteNodes();\n    this.findResultAreaEdges(opCode);\n    this.cancelDuplicateResultEdges();\n    var polyBuilder = new PolygonBuilder(this._geomFact);\n    polyBuilder.add(this._graph);\n    this._resultPolyList = polyBuilder.getPolygons();\n    var lineBuilder = new LineBuilder(this, this._geomFact, this._ptLocator);\n    this._resultLineList = lineBuilder.build(opCode);\n    var pointBuilder = new PointBuilder(this, this._geomFact, this._ptLocator);\n    this._resultPointList = pointBuilder.build(opCode);\n    this._resultGeom = this.computeGeometry(this._resultPointList, this._resultLineList, this._resultPolyList, opCode);\n  };\n  OverlayOp.prototype.labelIncompleteNode = function labelIncompleteNode (n, targetIndex) {\n    var loc = this._ptLocator.locate(n.getCoordinate(), this._arg[targetIndex].getGeometry());\n    n.getLabel().setLocation(targetIndex, loc);\n  };\n  OverlayOp.prototype.copyPoints = function copyPoints (argIndex) {\n    var this$1 = this;\n\n    for (var i = this._arg[argIndex].getNodeIterator(); i.hasNext();) {\n      var graphNode = i.next();\n      var newNode = this$1._graph.addNode(graphNode.getCoordinate());\n      newNode.setLabel(argIndex, graphNode.getLabel().getLocation(argIndex));\n    }\n  };\n  OverlayOp.prototype.findResultAreaEdges = function findResultAreaEdges (opCode) {\n    for (var it = this._graph.getEdgeEnds().iterator(); it.hasNext();) {\n      var de = it.next();\n      var label = de.getLabel();\n      if (label.isArea() && !de.isInteriorAreaEdge() && OverlayOp.isResultOfOp(label.getLocation(0, Position.RIGHT), label.getLocation(1, Position.RIGHT), opCode)) {\n        de.setInResult(true);\n      }\n    }\n  };\n  OverlayOp.prototype.computeLabelsFromDepths = function computeLabelsFromDepths () {\n    for (var it = this._edgeList.iterator(); it.hasNext();) {\n      var e = it.next();\n      var lbl = e.getLabel();\n      var depth = e.getDepth();\n      if (!depth.isNull()) {\n        depth.normalize();\n        for (var i = 0; i < 2; i++) {\n          if (!lbl.isNull(i) && lbl.isArea() && !depth.isNull(i)) {\n            if (depth.getDelta(i) === 0) {\n              lbl.toLine(i);\n            } else {\n              Assert.isTrue(!depth.isNull(i, Position.LEFT), 'depth of LEFT side has not been initialized');\n              lbl.setLocation(i, Position.LEFT, depth.getLocation(i, Position.LEFT));\n              Assert.isTrue(!depth.isNull(i, Position.RIGHT), 'depth of RIGHT side has not been initialized');\n              lbl.setLocation(i, Position.RIGHT, depth.getLocation(i, Position.RIGHT));\n            }\n          }\n        }\n      }\n    }\n  };\n  OverlayOp.prototype.computeLabelling = function computeLabelling () {\n    var this$1 = this;\n\n    for (var nodeit = this._graph.getNodes().iterator(); nodeit.hasNext();) {\n      var node = nodeit.next();\n      node.getEdges().computeLabelling(this$1._arg);\n    }\n    this.mergeSymLabels();\n    this.updateNodeLabelling();\n  };\n  OverlayOp.prototype.labelIncompleteNodes = function labelIncompleteNodes () {\n    var this$1 = this;\n\n    // let nodeCount = 0\n    for (var ni = this._graph.getNodes().iterator(); ni.hasNext();) {\n      var n = ni.next();\n      var label = n.getLabel();\n      if (n.isIsolated()) {\n        // nodeCount++\n        if (label.isNull(0)) { this$1.labelIncompleteNode(n, 0); } else { this$1.labelIncompleteNode(n, 1); }\n      }\n      n.getEdges().updateLabelling(label);\n    }\n  };\n  OverlayOp.prototype.isCoveredByA = function isCoveredByA (coord) {\n    if (this.isCovered(coord, this._resultPolyList)) { return true }\n    return false\n  };\n  OverlayOp.prototype.interfaces_ = function interfaces_ () {\n    return []\n  };\n  OverlayOp.prototype.getClass = function getClass () {\n    return OverlayOp\n  };\n\n  return OverlayOp;\n}(GeometryGraphOp));\n\nOverlayOp.overlayOp = function (geom0, geom1, opCode) {\n  var gov = new OverlayOp(geom0, geom1);\n  var geomOv = gov.getResultGeometry(opCode);\n  return geomOv\n};\nOverlayOp.intersection = function (g, other) {\n  if (g.isEmpty() || other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.INTERSECTION, g, other, g.getFactory()) }\n  if (g.isGeometryCollection()) {\n    var g2 = other;\n    return GeometryCollectionMapper.map(g, {\n      interfaces_: function () {\n        return [GeometryMapper.MapOp]\n      },\n      map: function (g) {\n        return g.intersection(g2)\n      }\n    })\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.INTERSECTION)\n};\nOverlayOp.symDifference = function (g, other) {\n  if (g.isEmpty() || other.isEmpty()) {\n    if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.SYMDIFFERENCE, g, other, g.getFactory()) }\n    if (g.isEmpty()) { return other.copy() }\n    if (other.isEmpty()) { return g.copy() }\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.SYMDIFFERENCE)\n};\nOverlayOp.resultDimension = function (opCode, g0, g1) {\n  var dim0 = g0.getDimension();\n  var dim1 = g1.getDimension();\n  var resultDimension = -1;\n  switch (opCode) {\n    case OverlayOp.INTERSECTION:\n      resultDimension = Math.min(dim0, dim1);\n      break\n    case OverlayOp.UNION:\n      resultDimension = Math.max(dim0, dim1);\n      break\n    case OverlayOp.DIFFERENCE:\n      resultDimension = dim0;\n      break\n    case OverlayOp.SYMDIFFERENCE:\n      resultDimension = Math.max(dim0, dim1);\n      break\n    default:\n  }\n  return resultDimension\n};\nOverlayOp.createEmptyResult = function (overlayOpCode, a, b, geomFact) {\n  var result = null;\n  switch (OverlayOp.resultDimension(overlayOpCode, a, b)) {\n    case -1:\n      result = geomFact.createGeometryCollection(new Array(0).fill(null));\n      break\n    case 0:\n      result = geomFact.createPoint();\n      break\n    case 1:\n      result = geomFact.createLineString();\n      break\n    case 2:\n      result = geomFact.createPolygon();\n      break\n    default:\n  }\n  return result\n};\nOverlayOp.difference = function (g, other) {\n  if (g.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.DIFFERENCE, g, other, g.getFactory()) }\n  if (other.isEmpty()) { return g.copy() }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.DIFFERENCE)\n};\nOverlayOp.isResultOfOp = function () {\n  if (arguments.length === 2) {\n    var label = arguments[0];\n    var opCode = arguments[1];\n    var loc0 = label.getLocation(0);\n    var loc1 = label.getLocation(1);\n    return OverlayOp.isResultOfOp(loc0, loc1, opCode)\n  } else if (arguments.length === 3) {\n    var loc0$1 = arguments[0];\n    var loc1$1 = arguments[1];\n    var overlayOpCode = arguments[2];\n    if (loc0$1 === Location.BOUNDARY) { loc0$1 = Location.INTERIOR; }\n    if (loc1$1 === Location.BOUNDARY) { loc1$1 = Location.INTERIOR; }\n    switch (overlayOpCode) {\n      case OverlayOp.INTERSECTION:\n        return loc0$1 === Location.INTERIOR && loc1$1 === Location.INTERIOR\n      case OverlayOp.UNION:\n        return loc0$1 === Location.INTERIOR || loc1$1 === Location.INTERIOR\n      case OverlayOp.DIFFERENCE:\n        return loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR\n      case OverlayOp.SYMDIFFERENCE:\n        return (loc0$1 === Location.INTERIOR && loc1$1 !== Location.INTERIOR) || (loc0$1 !== Location.INTERIOR && loc1$1 === Location.INTERIOR)\n      default:\n    }\n    return false\n  }\n};\nOverlayOp.INTERSECTION = 1;\nOverlayOp.UNION = 2;\nOverlayOp.DIFFERENCE = 3;\nOverlayOp.SYMDIFFERENCE = 4;\n\nvar FuzzyPointLocator = function FuzzyPointLocator () {\n  this._g = null;\n  this._boundaryDistanceTolerance = null;\n  this._linework = null;\n  this._ptLocator = new PointLocator();\n  this._seg = new LineSegment();\n  var g = arguments[0];\n  var boundaryDistanceTolerance = arguments[1];\n  this._g = g;\n  this._boundaryDistanceTolerance = boundaryDistanceTolerance;\n  this._linework = this.extractLinework(g);\n};\nFuzzyPointLocator.prototype.isWithinToleranceOfBoundary = function isWithinToleranceOfBoundary (pt) {\n    var this$1 = this;\n\n  for (var i = 0; i < this._linework.getNumGeometries(); i++) {\n    var line = this$1._linework.getGeometryN(i);\n    var seq = line.getCoordinateSequence();\n    for (var j = 0; j < seq.size() - 1; j++) {\n      seq.getCoordinate(j, this$1._seg.p0);\n      seq.getCoordinate(j + 1, this$1._seg.p1);\n      var dist = this$1._seg.distance(pt);\n      if (dist <= this$1._boundaryDistanceTolerance) { return true }\n    }\n  }\n  return false\n};\nFuzzyPointLocator.prototype.getLocation = function getLocation (pt) {\n  if (this.isWithinToleranceOfBoundary(pt)) { return Location.BOUNDARY }\n  return this._ptLocator.locate(pt, this._g)\n};\nFuzzyPointLocator.prototype.extractLinework = function extractLinework (g) {\n  var extracter = new PolygonalLineworkExtracter();\n  g.apply(extracter);\n  var linework = extracter.getLinework();\n  var lines = GeometryFactory.toLineStringArray(linework);\n  return g.getFactory().createMultiLineString(lines)\n};\nFuzzyPointLocator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nFuzzyPointLocator.prototype.getClass = function getClass () {\n  return FuzzyPointLocator\n};\n\nvar PolygonalLineworkExtracter = function PolygonalLineworkExtracter () {\n  this._linework = null;\n  this._linework = new ArrayList();\n};\nPolygonalLineworkExtracter.prototype.getLinework = function getLinework () {\n  return this._linework\n};\nPolygonalLineworkExtracter.prototype.filter = function filter (g) {\n    var this$1 = this;\n\n  if (g instanceof Polygon) {\n    var poly = g;\n    this._linework.add(poly.getExteriorRing());\n    for (var i = 0; i < poly.getNumInteriorRing(); i++) {\n      this$1._linework.add(poly.getInteriorRingN(i));\n    }\n  }\n};\nPolygonalLineworkExtracter.prototype.interfaces_ = function interfaces_ () {\n  return [GeometryFilter]\n};\nPolygonalLineworkExtracter.prototype.getClass = function getClass () {\n  return PolygonalLineworkExtracter\n};\n\nvar OffsetPointGenerator = function OffsetPointGenerator () {\n  this._g = null;\n  this._doLeft = true;\n  this._doRight = true;\n  var g = arguments[0];\n  this._g = g;\n};\nOffsetPointGenerator.prototype.extractPoints = function extractPoints (line, offsetDistance, offsetPts) {\n    var this$1 = this;\n\n  var pts = line.getCoordinates();\n  for (var i = 0; i < pts.length - 1; i++) {\n    this$1.computeOffsetPoints(pts[i], pts[i + 1], offsetDistance, offsetPts);\n  }\n};\nOffsetPointGenerator.prototype.setSidesToGenerate = function setSidesToGenerate (doLeft, doRight) {\n  this._doLeft = doLeft;\n  this._doRight = doRight;\n};\nOffsetPointGenerator.prototype.getPoints = function getPoints (offsetDistance) {\n    var this$1 = this;\n\n  var offsetPts = new ArrayList();\n  var lines = LinearComponentExtracter.getLines(this._g);\n  for (var i = lines.iterator(); i.hasNext();) {\n    var line = i.next();\n    this$1.extractPoints(line, offsetDistance, offsetPts);\n  }\n  return offsetPts\n};\nOffsetPointGenerator.prototype.computeOffsetPoints = function computeOffsetPoints (p0, p1, offsetDistance, offsetPts) {\n  var dx = p1.x - p0.x;\n  var dy = p1.y - p0.y;\n  var len = Math.sqrt(dx * dx + dy * dy);\n  var ux = offsetDistance * dx / len;\n  var uy = offsetDistance * dy / len;\n  var midX = (p1.x + p0.x) / 2;\n  var midY = (p1.y + p0.y) / 2;\n  if (this._doLeft) {\n    var offsetLeft = new Coordinate(midX - uy, midY + ux);\n    offsetPts.add(offsetLeft);\n  }\n  if (this._doRight) {\n    var offsetRight = new Coordinate(midX + uy, midY - ux);\n    offsetPts.add(offsetRight);\n  }\n};\nOffsetPointGenerator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOffsetPointGenerator.prototype.getClass = function getClass () {\n  return OffsetPointGenerator\n};\n\nvar OverlayResultValidator = function OverlayResultValidator () {\n  this._geom = null;\n  this._locFinder = null;\n  this._location = new Array(3).fill(null);\n  this._invalidLocation = null;\n  this._boundaryDistanceTolerance = OverlayResultValidator.TOLERANCE;\n  this._testCoords = new ArrayList();\n  var a = arguments[0];\n  var b = arguments[1];\n  var result = arguments[2];\n  this._boundaryDistanceTolerance = OverlayResultValidator.computeBoundaryDistanceTolerance(a, b);\n  this._geom = [a, b, result];\n  this._locFinder = [new FuzzyPointLocator(this._geom[0], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[1], this._boundaryDistanceTolerance), new FuzzyPointLocator(this._geom[2], this._boundaryDistanceTolerance)];\n};\n\nvar staticAccessors$46 = { TOLERANCE: { configurable: true } };\nOverlayResultValidator.prototype.reportResult = function reportResult (overlayOp, location, expectedInterior) {\n  System.out.println('Overlay result invalid - A:' + Location.toLocationSymbol(location[0]) + ' B:' + Location.toLocationSymbol(location[1]) + ' expected:' + (expectedInterior ? 'i' : 'e') + ' actual:' + Location.toLocationSymbol(location[2]));\n};\nOverlayResultValidator.prototype.isValid = function isValid (overlayOp) {\n  this.addTestPts(this._geom[0]);\n  this.addTestPts(this._geom[1]);\n  var isValid = this.checkValid(overlayOp);\n  return isValid\n};\nOverlayResultValidator.prototype.checkValid = function checkValid () {\n    var this$1 = this;\n\n  if (arguments.length === 1) {\n    var overlayOp = arguments[0];\n    for (var i = 0; i < this._testCoords.size(); i++) {\n      var pt = this$1._testCoords.get(i);\n      if (!this$1.checkValid(overlayOp, pt)) {\n        this$1._invalidLocation = pt;\n        return false\n      }\n    }\n    return true\n  } else if (arguments.length === 2) {\n    var overlayOp$1 = arguments[0];\n    var pt$1 = arguments[1];\n    this._location[0] = this._locFinder[0].getLocation(pt$1);\n    this._location[1] = this._locFinder[1].getLocation(pt$1);\n    this._location[2] = this._locFinder[2].getLocation(pt$1);\n    if (OverlayResultValidator.hasLocation(this._location, Location.BOUNDARY)) { return true }\n    return this.isValidResult(overlayOp$1, this._location)\n  }\n};\nOverlayResultValidator.prototype.addTestPts = function addTestPts (g) {\n  var ptGen = new OffsetPointGenerator(g);\n  this._testCoords.addAll(ptGen.getPoints(5 * this._boundaryDistanceTolerance));\n};\nOverlayResultValidator.prototype.isValidResult = function isValidResult (overlayOp, location) {\n  var expectedInterior = OverlayOp.isResultOfOp(location[0], location[1], overlayOp);\n  var resultInInterior = location[2] === Location.INTERIOR;\n  var isValid = !(expectedInterior ^ resultInInterior);\n  if (!isValid) { this.reportResult(overlayOp, location, expectedInterior); }\n  return isValid\n};\nOverlayResultValidator.prototype.getInvalidLocation = function getInvalidLocation () {\n  return this._invalidLocation\n};\nOverlayResultValidator.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nOverlayResultValidator.prototype.getClass = function getClass () {\n  return OverlayResultValidator\n};\nOverlayResultValidator.hasLocation = function hasLocation (location, loc) {\n  for (var i = 0; i < 3; i++) {\n    if (location[i] === loc) { return true }\n  }\n  return false\n};\nOverlayResultValidator.computeBoundaryDistanceTolerance = function computeBoundaryDistanceTolerance (g0, g1) {\n  return Math.min(GeometrySnapper.computeSizeBasedSnapTolerance(g0), GeometrySnapper.computeSizeBasedSnapTolerance(g1))\n};\nOverlayResultValidator.isValid = function isValid (a, b, overlayOp, result) {\n  var validator = new OverlayResultValidator(a, b, result);\n  return validator.isValid(overlayOp)\n};\nstaticAccessors$46.TOLERANCE.get = function () { return 0.000001 };\n\nObject.defineProperties( OverlayResultValidator, staticAccessors$46 );\n\n// operation.overlay\n\nvar GeometryCombiner = function GeometryCombiner (geoms) {\n  this._geomFactory = null;\n  this._skipEmpty = false;\n  this._inputGeoms = null;\n  this._geomFactory = GeometryCombiner.extractFactory(geoms);\n  this._inputGeoms = geoms;\n};\nGeometryCombiner.prototype.extractElements = function extractElements (geom, elems) {\n    var this$1 = this;\n\n  if (geom === null) { return null }\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var elemGeom = geom.getGeometryN(i);\n    if (this$1._skipEmpty && elemGeom.isEmpty()) { continue }\n    elems.add(elemGeom);\n  }\n};\nGeometryCombiner.prototype.combine = function combine () {\n    var this$1 = this;\n\n  var elems = new ArrayList();\n  for (var i = this._inputGeoms.iterator(); i.hasNext();) {\n    var g = i.next();\n    this$1.extractElements(g, elems);\n  }\n  if (elems.size() === 0) {\n    if (this._geomFactory !== null) {\n      return this._geomFactory.createGeometryCollection(null)\n    }\n    return null\n  }\n  return this._geomFactory.buildGeometry(elems)\n};\nGeometryCombiner.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nGeometryCombiner.prototype.getClass = function getClass () {\n  return GeometryCombiner\n};\nGeometryCombiner.combine = function combine () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    var combiner = new GeometryCombiner(geoms);\n    return combiner.combine()\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var combiner$1 = new GeometryCombiner(GeometryCombiner.createList(g0, g1));\n    return combiner$1.combine()\n  } else if (arguments.length === 3) {\n    var g0$1 = arguments[0];\n    var g1$1 = arguments[1];\n    var g2 = arguments[2];\n    var combiner$2 = new GeometryCombiner(GeometryCombiner.createList(g0$1, g1$1, g2));\n    return combiner$2.combine()\n  }\n};\nGeometryCombiner.extractFactory = function extractFactory (geoms) {\n  if (geoms.isEmpty()) { return null }\n  return geoms.iterator().next().getFactory()\n};\nGeometryCombiner.createList = function createList () {\n  if (arguments.length === 2) {\n    var obj0 = arguments[0];\n    var obj1 = arguments[1];\n    var list = new ArrayList();\n    list.add(obj0);\n    list.add(obj1);\n    return list\n  } else if (arguments.length === 3) {\n    var obj0$1 = arguments[0];\n    var obj1$1 = arguments[1];\n    var obj2 = arguments[2];\n    var list$1 = new ArrayList();\n    list$1.add(obj0$1);\n    list$1.add(obj1$1);\n    list$1.add(obj2);\n    return list$1\n  }\n};\n\nvar CascadedPolygonUnion = function CascadedPolygonUnion () {\n  this._inputPolys = null;\n  this._geomFactory = null;\n  var polys = arguments[0];\n  this._inputPolys = polys;\n  if (this._inputPolys === null) { this._inputPolys = new ArrayList(); }\n};\n\nvar staticAccessors$47 = { STRTREE_NODE_CAPACITY: { configurable: true } };\nCascadedPolygonUnion.prototype.reduceToGeometries = function reduceToGeometries (geomTree) {\n    var this$1 = this;\n\n  var geoms = new ArrayList();\n  for (var i = geomTree.iterator(); i.hasNext();) {\n    var o = i.next();\n    var geom = null;\n    if (hasInterface(o, List)) {\n      geom = this$1.unionTree(o);\n    } else if (o instanceof Geometry) {\n      geom = o;\n    }\n    geoms.add(geom);\n  }\n  return geoms\n};\nCascadedPolygonUnion.prototype.extractByEnvelope = function extractByEnvelope (env, geom, disjointGeoms) {\n  var intersectingGeoms = new ArrayList();\n  for (var i = 0; i < geom.getNumGeometries(); i++) {\n    var elem = geom.getGeometryN(i);\n    if (elem.getEnvelopeInternal().intersects(env)) { intersectingGeoms.add(elem); } else { disjointGeoms.add(elem); }\n  }\n  return this._geomFactory.buildGeometry(intersectingGeoms)\n};\nCascadedPolygonUnion.prototype.unionOptimized = function unionOptimized (g0, g1) {\n  var g0Env = g0.getEnvelopeInternal();\n  var g1Env = g1.getEnvelopeInternal();\n  if (!g0Env.intersects(g1Env)) {\n    var combo = GeometryCombiner.combine(g0, g1);\n    return combo\n  }\n  if (g0.getNumGeometries() <= 1 && g1.getNumGeometries() <= 1) { return this.unionActual(g0, g1) }\n  var commonEnv = g0Env.intersection(g1Env);\n  return this.unionUsingEnvelopeIntersection(g0, g1, commonEnv)\n};\nCascadedPolygonUnion.prototype.union = function union () {\n  if (this._inputPolys === null) { throw new Error('union() method cannot be called twice') }\n  if (this._inputPolys.isEmpty()) { return null }\n  this._geomFactory = this._inputPolys.iterator().next().getFactory();\n  var index = new STRtree(CascadedPolygonUnion.STRTREE_NODE_CAPACITY);\n  for (var i = this._inputPolys.iterator(); i.hasNext();) {\n    var item = i.next();\n    index.insert(item.getEnvelopeInternal(), item);\n  }\n  this._inputPolys = null;\n  var itemTree = index.itemsTree();\n  var unionAll = this.unionTree(itemTree);\n  return unionAll\n};\nCascadedPolygonUnion.prototype.binaryUnion = function binaryUnion () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    return this.binaryUnion(geoms, 0, geoms.size())\n  } else if (arguments.length === 3) {\n    var geoms$1 = arguments[0];\n    var start = arguments[1];\n    var end = arguments[2];\n    if (end - start <= 1) {\n      var g0 = CascadedPolygonUnion.getGeometry(geoms$1, start);\n      return this.unionSafe(g0, null)\n    } else if (end - start === 2) {\n      return this.unionSafe(CascadedPolygonUnion.getGeometry(geoms$1, start), CascadedPolygonUnion.getGeometry(geoms$1, start + 1))\n    } else {\n      var mid = Math.trunc((end + start) / 2);\n      var g0$1 = this.binaryUnion(geoms$1, start, mid);\n      var g1 = this.binaryUnion(geoms$1, mid, end);\n      return this.unionSafe(g0$1, g1)\n    }\n  }\n};\nCascadedPolygonUnion.prototype.repeatedUnion = function repeatedUnion (geoms) {\n  var union = null;\n  for (var i = geoms.iterator(); i.hasNext();) {\n    var g = i.next();\n    if (union === null) { union = g.copy(); } else { union = union.union(g); }\n  }\n  return union\n};\nCascadedPolygonUnion.prototype.unionSafe = function unionSafe (g0, g1) {\n  if (g0 === null && g1 === null) { return null }\n  if (g0 === null) { return g1.copy() }\n  if (g1 === null) { return g0.copy() }\n  return this.unionOptimized(g0, g1)\n};\nCascadedPolygonUnion.prototype.unionActual = function unionActual (g0, g1) {\n  return CascadedPolygonUnion.restrictToPolygons(g0.union(g1))\n};\nCascadedPolygonUnion.prototype.unionTree = function unionTree (geomTree) {\n  var geoms = this.reduceToGeometries(geomTree);\n  var union = this.binaryUnion(geoms);\n  return union\n};\nCascadedPolygonUnion.prototype.unionUsingEnvelopeIntersection = function unionUsingEnvelopeIntersection (g0, g1, common) {\n  var disjointPolys = new ArrayList();\n  var g0Int = this.extractByEnvelope(common, g0, disjointPolys);\n  var g1Int = this.extractByEnvelope(common, g1, disjointPolys);\n  var union = this.unionActual(g0Int, g1Int);\n  disjointPolys.add(union);\n  var overallUnion = GeometryCombiner.combine(disjointPolys);\n  return overallUnion\n};\nCascadedPolygonUnion.prototype.bufferUnion = function bufferUnion () {\n  if (arguments.length === 1) {\n    var geoms = arguments[0];\n    var factory = geoms.get(0).getFactory();\n    var gColl = factory.buildGeometry(geoms);\n    var unionAll = gColl.buffer(0.0);\n    return unionAll\n  } else if (arguments.length === 2) {\n    var g0 = arguments[0];\n    var g1 = arguments[1];\n    var factory$1 = g0.getFactory();\n    var gColl$1 = factory$1.createGeometryCollection([g0, g1]);\n    var unionAll$1 = gColl$1.buffer(0.0);\n    return unionAll$1\n  }\n};\nCascadedPolygonUnion.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nCascadedPolygonUnion.prototype.getClass = function getClass () {\n  return CascadedPolygonUnion\n};\nCascadedPolygonUnion.restrictToPolygons = function restrictToPolygons (g) {\n  if (hasInterface(g, Polygonal)) {\n    return g\n  }\n  var polygons = PolygonExtracter.getPolygons(g);\n  if (polygons.size() === 1) { return polygons.get(0) }\n  return g.getFactory().createMultiPolygon(GeometryFactory.toPolygonArray(polygons))\n};\nCascadedPolygonUnion.getGeometry = function getGeometry (list, index) {\n  if (index >= list.size()) { return null }\n  return list.get(index)\n};\nCascadedPolygonUnion.union = function union (polys) {\n  var op = new CascadedPolygonUnion(polys);\n  return op.union()\n};\nstaticAccessors$47.STRTREE_NODE_CAPACITY.get = function () { return 4 };\n\nObject.defineProperties( CascadedPolygonUnion, staticAccessors$47 );\n\nvar UnionOp = function UnionOp () {};\n\nUnionOp.prototype.interfaces_ = function interfaces_ () {\n  return []\n};\nUnionOp.prototype.getClass = function getClass () {\n  return UnionOp\n};\nUnionOp.union = function union (g, other) {\n  if (g.isEmpty() || other.isEmpty()) {\n    if (g.isEmpty() && other.isEmpty()) { return OverlayOp.createEmptyResult(OverlayOp.UNION, g, other, g.getFactory()) }\n    if (g.isEmpty()) { return other.copy() }\n    if (other.isEmpty()) { return g.copy() }\n  }\n  g.checkNotGeometryCollection(g);\n  g.checkNotGeometryCollection(other);\n  return SnapIfNeededOverlayOp.overlayOp(g, other, OverlayOp.UNION)\n};\n\n// operation.union\n\n// operation\n\n/**\n * Polyfill for IE support\n */\n\nexports.GeoJSONReader = GeoJSONReader;\nexports.GeoJSONWriter = GeoJSONWriter;\nexports.OverlayOp = OverlayOp;\nexports.UnionOp = UnionOp;\nexports.BufferOp = BufferOp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdHVyZi1qc3RzQDEuMi4zL25vZGVfbW9kdWxlcy90dXJmLWpzdHMvanN0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBLDBCQUEwQixhQUFhOztBQUV2QyxvQ0FBb0M7QUFDcEMsMERBQTBEO0FBQzFELDBEQUEwRDtBQUMxRCw4Q0FBOEM7QUFDOUMsZ0RBQWdEOztBQUVoRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qix5QkFBeUIsb0JBQW9CLHFCQUFxQixvQkFBb0Isa0JBQWtCLG9CQUFvQixNQUFNLG9CQUFvQixNQUFNLG9CQUFvQixNQUFNO0FBQzlNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGFBQWE7QUFDYixXQUFXLFdBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsYUFBYTtBQUN0RTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxPQUFPO0FBQ2YsTUFBTSxPQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkJBQTJCLE1BQU0sb0JBQW9CLE9BQU8sb0JBQW9CLE9BQU8sb0JBQW9CLE9BQU87O0FBRWxIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLHVCQUF1QixzQkFBc0IsT0FBTztBQUNwRCxNQUFNO0FBQ04sdUJBQXVCLHNCQUFzQixPQUFPO0FBQ3BEO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSwwQkFBMEIsc0JBQXNCLE9BQU87QUFDdkQsTUFBTTtBQUNOLDBCQUEwQixzQkFBc0IsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQywwQ0FBMEM7O0FBRTFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRCxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLDBDQUEwQztBQUMxQywwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTSxPQUFPO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsa0RBQWtEO0FBQ2xELDREQUE0RDs7QUFFNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQixxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLDBCQUEwQixvQkFBb0IsZUFBZTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELGtEQUFrRDs7QUFFbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNLE9BQU87QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFVBQVUsb0JBQW9CLFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxtQ0FBbUM7QUFDbkMseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7O0FBRTlDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQ7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQix1REFBdUQ7QUFDdkQsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdCQUF3QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4QkFBOEIsT0FBTztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFlBQVk7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7O0FBRXREOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQSw0Q0FBNEMsWUFBWTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0EsMEJBQTBCLG9CQUFvQixPQUFPO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEOztBQUU3RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHVCQUF1QjtBQUN2QiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsZUFBZTtBQUNmLGdCQUFnQiIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vdHVyZi1qc3RzQDEuMi4zL25vZGVfbW9kdWxlcy90dXJmLWpzdHMvanN0cy5qcz80OTNkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLyogUG9seWZpbGwgc2VydmljZSB2My4xMy4wXG4gKiBGb3IgZGV0YWlsZWQgY3JlZGl0cyBhbmQgbGljZW5jZSBpbmZvcm1hdGlvbiBzZWUgaHR0cDovL2dpdGh1Yi5jb20vZmluYW5jaWFsLXRpbWVzL3BvbHlmaWxsLXNlcnZpY2VcbiAqXG4gKiAtIEFycmF5LnByb3RvdHlwZS5maWxsLCBMaWNlbnNlOiBDQzAgKi9cblxuaWYgKCEoJ2ZpbGwnIGluIEFycmF5LnByb3RvdHlwZSkpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFycmF5LnByb3RvdHlwZSwgJ2ZpbGwnLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaWxsICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IHVuZGVmaW5lZCB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IodGhpcyArICcgaXMgbm90IGFuIG9iamVjdCcpXG4gICAgICB9XG5cbiAgICAgIHZhciBhcnJheUxpa2UgPSBPYmplY3QodGhpcyk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLm1pbihhcnJheUxpa2UubGVuZ3RoLCA5MDA3MTk5MjU0NzQwOTkxKSwgMCkgfHwgMDtcblxuICAgICAgdmFyIHJlbGF0aXZlU3RhcnQgPSAxIGluIGFyZ3VtZW50cyA/IHBhcnNlSW50KE51bWJlcihhcmd1bWVudHNbMV0pLCAxMCkgfHwgMCA6IDA7XG5cbiAgICAgIHJlbGF0aXZlU3RhcnQgPSByZWxhdGl2ZVN0YXJ0IDwgMCA/IE1hdGgubWF4KGxlbmd0aCArIHJlbGF0aXZlU3RhcnQsIDApIDogTWF0aC5taW4ocmVsYXRpdmVTdGFydCwgbGVuZ3RoKTtcblxuICAgICAgdmFyIHJlbGF0aXZlRW5kID0gMiBpbiBhcmd1bWVudHMgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBwYXJzZUludChOdW1iZXIoYXJndW1lbnRzWzJdKSwgMTApIHx8IDAgOiBsZW5ndGg7XG5cbiAgICAgIHJlbGF0aXZlRW5kID0gcmVsYXRpdmVFbmQgPCAwID8gTWF0aC5tYXgobGVuZ3RoICsgYXJndW1lbnRzWzJdLCAwKSA6IE1hdGgubWluKHJlbGF0aXZlRW5kLCBsZW5ndGgpO1xuXG4gICAgICB3aGlsZSAocmVsYXRpdmVTdGFydCA8IHJlbGF0aXZlRW5kKSB7XG4gICAgICAgIGFycmF5TGlrZVtyZWxhdGl2ZVN0YXJ0XSA9IHZhbHVlO1xuXG4gICAgICAgICsrcmVsYXRpdmVTdGFydDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFycmF5TGlrZVxuICAgIH0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIElFIHN1cHBvcnRcbiAqL1xuTnVtYmVyLmlzRmluaXRlID0gTnVtYmVyLmlzRmluaXRlIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSlcbn07XG5cbk51bWJlci5pc0ludGVnZXIgPSBOdW1iZXIuaXNJbnRlZ2VyIHx8IGZ1bmN0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmXG4gIGlzRmluaXRlKHZhbCkgJiZcbiAgTWF0aC5mbG9vcih2YWwpID09PSB2YWxcbn07XG5cbk51bWJlci5wYXJzZUZsb2F0ID0gTnVtYmVyLnBhcnNlRmxvYXQgfHwgcGFyc2VGbG9hdDtcblxuTnVtYmVyLmlzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn07XG5cbi8qKlxuICogUG9seWZpbGwgZm9yIElFIHN1cHBvcnRcbiAqL1xuTWF0aC50cnVuYyA9IE1hdGgudHJ1bmMgfHwgZnVuY3Rpb24gKHgpIHtcbiAgcmV0dXJuIHggPCAwID8gTWF0aC5jZWlsKHgpIDogTWF0aC5mbG9vcih4KVxufTtcblxudmFyIE51bWJlclV0aWwgPSBmdW5jdGlvbiBOdW1iZXJVdGlsICgpIHt9O1xuXG5OdW1iZXJVdGlsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTnVtYmVyVXRpbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOdW1iZXJVdGlsXG59O1xuTnVtYmVyVXRpbC5wcm90b3R5cGUuZXF1YWxzV2l0aFRvbGVyYW5jZSA9IGZ1bmN0aW9uIGVxdWFsc1dpdGhUb2xlcmFuY2UgKHgxLCB4MiwgdG9sZXJhbmNlKSB7XG4gIHJldHVybiBNYXRoLmFicyh4MSAtIHgyKSA8PSB0b2xlcmFuY2Vcbn07XG5cbnZhciBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24gPSAoZnVuY3Rpb24gKEVycm9yKSB7XG5cdGZ1bmN0aW9uIElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbiAobWVzc2FnZSkge1xuXHRcdEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gJ0lsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbic7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHR0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcblx0fVxuXG5cdGlmICggRXJyb3IgKSBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24uX19wcm90b19fID0gRXJyb3I7XG5cdElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFcnJvciAmJiBFcnJvci5wcm90b3R5cGUgKTtcblx0SWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbjtcblxuXHRyZXR1cm4gSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uO1xufShFcnJvcikpO1xuXG52YXIgRG91YmxlID0gZnVuY3Rpb24gRG91YmxlICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDEgPSB7IE1BWF9WQUxVRTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5Eb3VibGUuaXNOYU4gPSBmdW5jdGlvbiBpc05hTiAobikgeyByZXR1cm4gTnVtYmVyLmlzTmFOKG4pIH07XG5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyA9IGZ1bmN0aW9uIGRvdWJsZVRvTG9uZ0JpdHMgKG4pIHsgcmV0dXJuIG4gfTtcbkRvdWJsZS5sb25nQml0c1RvRG91YmxlID0gZnVuY3Rpb24gbG9uZ0JpdHNUb0RvdWJsZSAobikgeyByZXR1cm4gbiB9O1xuRG91YmxlLmlzSW5maW5pdGUgPSBmdW5jdGlvbiBpc0luZmluaXRlIChuKSB7IHJldHVybiAhTnVtYmVyLmlzRmluaXRlKG4pIH07XG5zdGF0aWNBY2Nlc3NvcnMkMS5NQVhfVkFMVUUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTnVtYmVyLk1BWF9WQUxVRSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRG91YmxlLCBzdGF0aWNBY2Nlc3NvcnMkMSApO1xuXG52YXIgQ29tcGFyYWJsZSA9IGZ1bmN0aW9uIENvbXBhcmFibGUgKCkge307XG5cbnZhciBDbG9uYWJsZSA9IGZ1bmN0aW9uIENsb25hYmxlICgpIHt9O1xuXG52YXIgQ29tcGFyYXRvciA9IGZ1bmN0aW9uIENvbXBhcmF0b3IgKCkge307XG5cbmZ1bmN0aW9uIFNlcmlhbGl6YWJsZSAoKSB7fVxuXG4vLyBpbXBvcnQgQXNzZXJ0IGZyb20gJy4uL3V0aWwvQXNzZXJ0J1xuXG52YXIgQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIENvb3JkaW5hdGUgKCkge1xuICB0aGlzLnggPSBudWxsO1xuICB0aGlzLnkgPSBudWxsO1xuICB0aGlzLnogPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMueCA9IDAuMDtcbiAgICB0aGlzLnkgPSAwLjA7XG4gICAgdGhpcy56ID0gQ29vcmRpbmF0ZS5OVUxMX09SRElOQVRFO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnggPSBjLng7XG4gICAgdGhpcy55ID0gYy55O1xuICAgIHRoaXMueiA9IGMuejtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdGhpcy54ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMueSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLnogPSBDb29yZGluYXRlLk5VTExfT1JESU5BVEU7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHRoaXMueCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnkgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy56ID0gYXJndW1lbnRzWzJdO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzID0geyBEaW1lbnNpb25hbENvbXBhcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSxOVUxMX09SRElOQVRFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFg6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sWTogeyBjb25maWd1cmFibGU6IHRydWUgfSxaOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5Db29yZGluYXRlLnByb3RvdHlwZS5zZXRPcmRpbmF0ZSA9IGZ1bmN0aW9uIHNldE9yZGluYXRlIChvcmRpbmF0ZUluZGV4LCB2YWx1ZSkge1xuICBzd2l0Y2ggKG9yZGluYXRlSW5kZXgpIHtcbiAgICBjYXNlIENvb3JkaW5hdGUuWDpcbiAgICAgIHRoaXMueCA9IHZhbHVlO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIENvb3JkaW5hdGUuWTpcbiAgICAgIHRoaXMueSA9IHZhbHVlO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIENvb3JkaW5hdGUuWjpcbiAgICAgIHRoaXMueiA9IHZhbHVlO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogJyArIG9yZGluYXRlSW5kZXgpXG4gIH1cbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5lcXVhbHMyRCA9IGZ1bmN0aW9uIGVxdWFsczJEICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHRoaXMueCAhPT0gb3RoZXIueCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGlmICh0aGlzLnkgIT09IG90aGVyLnkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICghTnVtYmVyVXRpbC5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueCwgYy54LCB0b2xlcmFuY2UpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKCFOdW1iZXJVdGlsLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy55LCBjLnksIHRvbGVyYW5jZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZ2V0T3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRPcmRpbmF0ZSAob3JkaW5hdGVJbmRleCkge1xuICBzd2l0Y2ggKG9yZGluYXRlSW5kZXgpIHtcbiAgICBjYXNlIENvb3JkaW5hdGUuWDpcbiAgICAgIHJldHVybiB0aGlzLnhcbiAgICBjYXNlIENvb3JkaW5hdGUuWTpcbiAgICAgIHJldHVybiB0aGlzLnlcbiAgICBjYXNlIENvb3JkaW5hdGUuWjpcbiAgICAgIHJldHVybiB0aGlzLnpcbiAgICBkZWZhdWx0OlxuICB9XG4gIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0ludmFsaWQgb3JkaW5hdGUgaW5kZXg6ICcgKyBvcmRpbmF0ZUluZGV4KVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmVxdWFsczNEID0gZnVuY3Rpb24gZXF1YWxzM0QgKG90aGVyKSB7XG4gIHJldHVybiB0aGlzLnggPT09IG90aGVyLnggJiZcbiAgICAgICAgIHRoaXMueSA9PT0gb3RoZXIueSAmJlxuICAgICAgICAgKCh0aGlzLnogPT09IG90aGVyLnogfHwgRG91YmxlLmlzTmFOKHRoaXMueikpICYmXG4gICAgICAgICBEb3VibGUuaXNOYU4ob3RoZXIueikpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvdGhlcikge1xuICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRoaXMuZXF1YWxzMkQob3RoZXIpXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZXF1YWxJblogPSBmdW5jdGlvbiBlcXVhbEluWiAoYywgdG9sZXJhbmNlKSB7XG4gIHJldHVybiBOdW1iZXJVdGlsLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy56LCBjLnosIHRvbGVyYW5jZSlcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIG90aGVyID0gbztcbiAgaWYgKHRoaXMueCA8IG90aGVyLngpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMueCA+IG90aGVyLngpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy55IDwgb3RoZXIueSkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy55ID4gb3RoZXIueSkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gIC8vIHRyeSB7XG4gIC8vIHZhciBjb29yZCA9IG51bGxcbiAgLy8gcmV0dXJuIGNvb3JkXG4gIC8vIH0gY2F0Y2ggKGUpIHtcbiAgLy8gaWYgKGUgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbikge1xuICAvLyAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZShcInRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoaXMgY2xhc3MgaXMgQ2xvbmVhYmxlXCIpXG4gIC8vICAgcmV0dXJuIG51bGxcbiAgLy8gfSBlbHNlIHRocm93IGVcbiAgLy8gfSBmaW5hbGx5IHt9XG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUodGhpcylcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuICcoJyArIHRoaXMueCArICcsICcgKyB0aGlzLnkgKyAnLCAnICsgdGhpcy56ICsgJyknXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZGlzdGFuY2UzRCA9IGZ1bmN0aW9uIGRpc3RhbmNlM0QgKGMpIHtcbiAgdmFyIGR4ID0gdGhpcy54IC0gYy54O1xuICB2YXIgZHkgPSB0aGlzLnkgLSBjLnk7XG4gIHZhciBkeiA9IHRoaXMueiAtIGMuejtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHopXG59O1xuQ29vcmRpbmF0ZS5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoYykge1xuICB2YXIgZHggPSB0aGlzLnggLSBjLng7XG4gIHZhciBkeSA9IHRoaXMueSAtIGMueTtcbiAgcmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSlcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgdmFyIHJlc3VsdCA9IDE3O1xuICByZXN1bHQgPSAzNyAqIHJlc3VsdCArIENvb3JkaW5hdGUuaGFzaENvZGUodGhpcy54KTtcbiAgcmVzdWx0ID0gMzcgKiByZXN1bHQgKyBDb29yZGluYXRlLmhhc2hDb2RlKHRoaXMueSk7XG4gIHJldHVybiByZXN1bHRcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5zZXRDb29yZGluYXRlID0gZnVuY3Rpb24gc2V0Q29vcmRpbmF0ZSAob3RoZXIpIHtcbiAgdGhpcy54ID0gb3RoZXIueDtcbiAgdGhpcy55ID0gb3RoZXIueTtcbiAgdGhpcy56ID0gb3RoZXIuejtcbn07XG5Db29yZGluYXRlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlLCBDbG9uYWJsZSwgU2VyaWFsaXphYmxlXVxufTtcbkNvb3JkaW5hdGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZVxufTtcbkNvb3JkaW5hdGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGYgPSBEb3VibGUuZG91YmxlVG9Mb25nQml0cyh4KTtcbiAgICByZXR1cm4gTWF0aC50cnVuYygoZiBeIGYpID4+PiAzMilcbiAgfVxufTtcbnN0YXRpY0FjY2Vzc29ycy5EaW1lbnNpb25hbENvbXBhcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRGltZW5zaW9uYWxDb21wYXJhdG9yIH07XG5zdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA2NjgzMTA4OTAyNDI4MzY2OTEwIH07XG5zdGF0aWNBY2Nlc3NvcnMuTlVMTF9PUkRJTkFURS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBEb3VibGUuTmFOIH07XG5zdGF0aWNBY2Nlc3NvcnMuWC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMuWS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMuWi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxudmFyIERpbWVuc2lvbmFsQ29tcGFyYXRvciA9IGZ1bmN0aW9uIERpbWVuc2lvbmFsQ29tcGFyYXRvciAoZGltZW5zaW9uc1RvVGVzdCkge1xuICB0aGlzLl9kaW1lbnNpb25zVG9UZXN0ID0gMjtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHt9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZGltZW5zaW9uc1RvVGVzdCQxID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChkaW1lbnNpb25zVG9UZXN0JDEgIT09IDIgJiYgZGltZW5zaW9uc1RvVGVzdCQxICE9PSAzKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ29ubHkgMiBvciAzIGRpbWVuc2lvbnMgbWF5IGJlIHNwZWNpZmllZCcpIH1cbiAgICB0aGlzLl9kaW1lbnNpb25zVG9UZXN0ID0gZGltZW5zaW9uc1RvVGVzdCQxO1xuICB9XG59O1xuRGltZW5zaW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAobzEsIG8yKSB7XG4gIHZhciBjMSA9IG8xO1xuICB2YXIgYzIgPSBvMjtcbiAgdmFyIGNvbXBYID0gRGltZW5zaW9uYWxDb21wYXJhdG9yLmNvbXBhcmUoYzEueCwgYzIueCk7XG4gIGlmIChjb21wWCAhPT0gMCkgeyByZXR1cm4gY29tcFggfVxuICB2YXIgY29tcFkgPSBEaW1lbnNpb25hbENvbXBhcmF0b3IuY29tcGFyZShjMS55LCBjMi55KTtcbiAgaWYgKGNvbXBZICE9PSAwKSB7IHJldHVybiBjb21wWSB9XG4gIGlmICh0aGlzLl9kaW1lbnNpb25zVG9UZXN0IDw9IDIpIHsgcmV0dXJuIDAgfVxuICB2YXIgY29tcFogPSBEaW1lbnNpb25hbENvbXBhcmF0b3IuY29tcGFyZShjMS56LCBjMi56KTtcbiAgcmV0dXJuIGNvbXBaXG59O1xuRGltZW5zaW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhdG9yXVxufTtcbkRpbWVuc2lvbmFsQ29tcGFyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEaW1lbnNpb25hbENvbXBhcmF0b3Jcbn07XG5EaW1lbnNpb25hbENvbXBhcmF0b3IuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7IHJldHVybiAtMSB9XG4gIGlmIChhID4gYikgeyByZXR1cm4gMSB9XG4gIGlmIChEb3VibGUuaXNOYU4oYSkpIHtcbiAgICBpZiAoRG91YmxlLmlzTmFOKGIpKSB7IHJldHVybiAwIH1cbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoRG91YmxlLmlzTmFOKGIpKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5cbi8vIGltcG9ydCBoYXNJbnRlcmZhY2UgZnJvbSAnLi4vLi4vLi4vLi4vaGFzSW50ZXJmYWNlJ1xuLy8gaW1wb3J0IENvb3JkaW5hdGVTZXF1ZW5jZSBmcm9tICcuL0Nvb3JkaW5hdGVTZXF1ZW5jZSdcblxudmFyIENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgPSBmdW5jdGlvbiBDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ICgpIHt9O1xuXG5Db29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKCkge1xuICAvLyBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAvLyBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgLy8gICBsZXQgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF1cbiAgLy8gfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gIC8vICAgbGV0IGNvb3JkU2VxID0gYXJndW1lbnRzWzBdXG4gIC8vIH1cbiAgLy8gfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gIC8vIGxldCBzaXplID0gYXJndW1lbnRzWzBdXG4gIC8vIGxldCBkaW1lbnNpb24gPSBhcmd1bWVudHNbMV1cbiAgLy8gfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnlcbn07XG5cbnZhciBMb2NhdGlvbiA9IGZ1bmN0aW9uIExvY2F0aW9uICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQgPSB7IElOVEVSSU9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEJPVU5EQVJZOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEVYVEVSSU9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5PTkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuTG9jYXRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Mb2NhdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMb2NhdGlvblxufTtcbkxvY2F0aW9uLnRvTG9jYXRpb25TeW1ib2wgPSBmdW5jdGlvbiB0b0xvY2F0aW9uU3ltYm9sIChsb2NhdGlvblZhbHVlKSB7XG4gIHN3aXRjaCAobG9jYXRpb25WYWx1ZSkge1xuICAgIGNhc2UgTG9jYXRpb24uRVhURVJJT1I6XG4gICAgICByZXR1cm4gJ2UnXG4gICAgY2FzZSBMb2NhdGlvbi5CT1VOREFSWTpcbiAgICAgIHJldHVybiAnYidcbiAgICBjYXNlIExvY2F0aW9uLklOVEVSSU9SOlxuICAgICAgcmV0dXJuICdpJ1xuICAgIGNhc2UgTG9jYXRpb24uTk9ORTpcbiAgICAgIHJldHVybiAnLSdcbiAgICBkZWZhdWx0OlxuICB9XG4gIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1Vua25vd24gbG9jYXRpb24gdmFsdWU6ICcgKyBsb2NhdGlvblZhbHVlKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0LklOVEVSSU9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0LkJPVU5EQVJZLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0LkVYVEVSSU9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0Lk5PTkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTEgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExvY2F0aW9uLCBzdGF0aWNBY2Nlc3NvcnMkNCApO1xuXG52YXIgaGFzSW50ZXJmYWNlID0gZnVuY3Rpb24gKG8sIGkpIHtcbiAgcmV0dXJuIG8uaW50ZXJmYWNlc18gJiYgby5pbnRlcmZhY2VzXygpLmluZGV4T2YoaSkgPiAtMVxufTtcblxudmFyIE1hdGhVdGlsID0gZnVuY3Rpb24gTWF0aFV0aWwgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNSA9IHsgTE9HXzEwOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbk1hdGhVdGlsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTWF0aFV0aWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTWF0aFV0aWxcbn07XG5NYXRoVXRpbC5sb2cxMCA9IGZ1bmN0aW9uIGxvZzEwICh4KSB7XG4gIHZhciBsbiA9IE1hdGgubG9nKHgpO1xuICBpZiAoRG91YmxlLmlzSW5maW5pdGUobG4pKSB7IHJldHVybiBsbiB9XG4gIGlmIChEb3VibGUuaXNOYU4obG4pKSB7IHJldHVybiBsbiB9XG4gIHJldHVybiBsbiAvIE1hdGhVdGlsLkxPR18xMFxufTtcbk1hdGhVdGlsLm1pbiA9IGZ1bmN0aW9uIG1pbiAodjEsIHYyLCB2MywgdjQpIHtcbiAgdmFyIG1pbiA9IHYxO1xuICBpZiAodjIgPCBtaW4pIHsgbWluID0gdjI7IH1cbiAgaWYgKHYzIDwgbWluKSB7IG1pbiA9IHYzOyB9XG4gIGlmICh2NCA8IG1pbikgeyBtaW4gPSB2NDsgfVxuICByZXR1cm4gbWluXG59O1xuTWF0aFV0aWwuY2xhbXAgPSBmdW5jdGlvbiBjbGFtcCAoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnbnVtYmVyJyAmJiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1pbiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWF4ID0gYXJndW1lbnRzWzJdO1xuICAgIGlmICh4IDwgbWluKSB7IHJldHVybiBtaW4gfVxuICAgIGlmICh4ID4gbWF4KSB7IHJldHVybiBtYXggfVxuICAgIHJldHVybiB4XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pICYmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkgJiYgTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKSkge1xuICAgIHZhciB4JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1pbiQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXgkMSA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoeCQxIDwgbWluJDEpIHsgcmV0dXJuIG1pbiQxIH1cbiAgICBpZiAoeCQxID4gbWF4JDEpIHsgcmV0dXJuIG1heCQxIH1cbiAgICByZXR1cm4geCQxXG4gIH1cbn07XG5NYXRoVXRpbC53cmFwID0gZnVuY3Rpb24gd3JhcCAoaW5kZXgsIG1heCkge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIG1heCAtIC1pbmRleCAlIG1heFxuICB9XG4gIHJldHVybiBpbmRleCAlIG1heFxufTtcbk1hdGhVdGlsLm1heCA9IGZ1bmN0aW9uIG1heCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIHYxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB2MiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdjMgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIG1heCA9IHYxO1xuICAgIGlmICh2MiA+IG1heCkgeyBtYXggPSB2MjsgfVxuICAgIGlmICh2MyA+IG1heCkgeyBtYXggPSB2MzsgfVxuICAgIHJldHVybiBtYXhcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHYxJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHYyJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHYzJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHY0ID0gYXJndW1lbnRzWzNdO1xuICAgIHZhciBtYXgkMSA9IHYxJDE7XG4gICAgaWYgKHYyJDEgPiBtYXgkMSkgeyBtYXgkMSA9IHYyJDE7IH1cbiAgICBpZiAodjMkMSA+IG1heCQxKSB7IG1heCQxID0gdjMkMTsgfVxuICAgIGlmICh2NCA+IG1heCQxKSB7IG1heCQxID0gdjQ7IH1cbiAgICByZXR1cm4gbWF4JDFcbiAgfVxufTtcbk1hdGhVdGlsLmF2ZXJhZ2UgPSBmdW5jdGlvbiBhdmVyYWdlICh4MSwgeDIpIHtcbiAgcmV0dXJuICh4MSArIHgyKSAvIDIuMFxufTtcbnN0YXRpY0FjY2Vzc29ycyQ1LkxPR18xMC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXRoLmxvZygxMCkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE1hdGhVdGlsLCBzdGF0aWNBY2Nlc3NvcnMkNSApO1xuXG52YXIgU3RyaW5nQnVmZmVyID0gZnVuY3Rpb24gU3RyaW5nQnVmZmVyIChzdHIpIHtcbiAgdGhpcy5zdHIgPSBzdHI7XG59O1xuU3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQgKGUpIHtcbiAgdGhpcy5zdHIgKz0gZTtcbn07XG5cblN0cmluZ0J1ZmZlci5wcm90b3R5cGUuc2V0Q2hhckF0ID0gZnVuY3Rpb24gc2V0Q2hhckF0IChpLCBjKSB7XG4gIHRoaXMuc3RyID0gdGhpcy5zdHIuc3Vic3RyKDAsIGkpICsgYyArIHRoaXMuc3RyLnN1YnN0cihpICsgMSk7XG59O1xuXG5TdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGUpIHtcbiAgcmV0dXJuIHRoaXMuc3RyXG59O1xuXG52YXIgSW50ZWdlciA9IGZ1bmN0aW9uIEludGVnZXIgKHZhbHVlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZTtcbn07XG5JbnRlZ2VyLnByb3RvdHlwZS5pbnRWYWx1ZSA9IGZ1bmN0aW9uIGludFZhbHVlICgpIHtcbiAgcmV0dXJuIHRoaXMudmFsdWVcbn07XG5JbnRlZ2VyLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgaWYgKHRoaXMudmFsdWUgPCBvKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLnZhbHVlID4gbykgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuSW50ZWdlci5pc05hTiA9IGZ1bmN0aW9uIGlzTmFOIChuKSB7IHJldHVybiBOdW1iZXIuaXNOYU4obikgfTtcblxudmFyIENoYXJhY3RlciA9IGZ1bmN0aW9uIENoYXJhY3RlciAoKSB7fTtcblxuQ2hhcmFjdGVyLmlzV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAoYykgeyByZXR1cm4gKChjIDw9IDMyICYmIGMgPj0gMCkgfHwgYyA9PT0gMTI3KSB9O1xuQ2hhcmFjdGVyLnRvVXBwZXJDYXNlID0gZnVuY3Rpb24gdG9VcHBlckNhc2UgKGMpIHsgcmV0dXJuIGMudG9VcHBlckNhc2UoKSB9O1xuXG52YXIgREQgPSBmdW5jdGlvbiBERCAoKSB7XG4gIHRoaXMuX2hpID0gMC4wO1xuICB0aGlzLl9sbyA9IDAuMDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmluaXQoMC4wKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdCh4KTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgICB2YXIgZGQgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQoZGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBzdHIgPSBhcmd1bWVudHNbMF07XG4gICAgICBERC5jYWxsKHRoaXMsIERELnBhcnNlKHN0cikpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGhpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsbyA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmluaXQoaGksIGxvKTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ3ID0geyBQSTogeyBjb25maWd1cmFibGU6IHRydWUgfSxUV09fUEk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sUElfMjogeyBjb25maWd1cmFibGU6IHRydWUgfSxFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5hTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxFUFM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1BMSVQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTUFYX1BSSU5UX0RJR0lUUzogeyBjb25maWd1cmFibGU6IHRydWUgfSxURU46IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sT05FOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNDSV9OT1RfRVhQT05FTlRfQ0hBUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxTQ0lfTk9UX1pFUk86IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkRELnByb3RvdHlwZS5sZSA9IGZ1bmN0aW9uIGxlICh5KSB7XG4gIHJldHVybiAodGhpcy5faGkgPCB5Ll9oaSB8fCB0aGlzLl9oaSA9PT0geS5faGkpICYmIHRoaXMuX2xvIDw9IHkuX2xvXG59O1xuREQucHJvdG90eXBlLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyA9IGZ1bmN0aW9uIGV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyAoaW5zZXJ0RGVjaW1hbFBvaW50LCBtYWduaXR1ZGUpIHtcbiAgdmFyIHkgPSB0aGlzLmFicygpO1xuICB2YXIgbWFnID0gREQubWFnbml0dWRlKHkuX2hpKTtcbiAgdmFyIHNjYWxlID0gREQuVEVOLnBvdyhtYWcpO1xuICB5ID0geS5kaXZpZGUoc2NhbGUpO1xuICBpZiAoeS5ndChERC5URU4pKSB7XG4gICAgeSA9IHkuZGl2aWRlKERELlRFTik7XG4gICAgbWFnICs9IDE7XG4gIH0gZWxzZSBpZiAoeS5sdChERC5PTkUpKSB7XG4gICAgeSA9IHkubXVsdGlwbHkoREQuVEVOKTtcbiAgICBtYWcgLT0gMTtcbiAgfVxuICB2YXIgZGVjaW1hbFBvaW50UG9zID0gbWFnICsgMTtcbiAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgdmFyIG51bURpZ2l0cyA9IERELk1BWF9QUklOVF9ESUdJVFMgLSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBudW1EaWdpdHM7IGkrKykge1xuICAgIGlmIChpbnNlcnREZWNpbWFsUG9pbnQgJiYgaSA9PT0gZGVjaW1hbFBvaW50UG9zKSB7XG4gICAgICBidWYuYXBwZW5kKCcuJyk7XG4gICAgfVxuICAgIHZhciBkaWdpdCA9IE1hdGgudHJ1bmMoeS5faGkpO1xuICAgIGlmIChkaWdpdCA8IDApIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIHZhciByZWJpYXNCeTEwID0gZmFsc2U7XG4gICAgdmFyIGRpZ2l0Q2hhciA9IDA7XG4gICAgaWYgKGRpZ2l0ID4gOSkge1xuICAgICAgcmViaWFzQnkxMCA9IHRydWU7XG4gICAgICBkaWdpdENoYXIgPSAnOSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZ2l0Q2hhciA9ICcwJyArIGRpZ2l0O1xuICAgIH1cbiAgICBidWYuYXBwZW5kKGRpZ2l0Q2hhcik7XG4gICAgeSA9IHkuc3VidHJhY3QoREQudmFsdWVPZihkaWdpdCkpLm11bHRpcGx5KERELlRFTik7XG4gICAgaWYgKHJlYmlhc0J5MTApIHsgeS5zZWxmQWRkKERELlRFTik7IH1cbiAgICB2YXIgY29udGludWVFeHRyYWN0aW5nRGlnaXRzID0gdHJ1ZTtcbiAgICB2YXIgcmVtTWFnID0gREQubWFnbml0dWRlKHkuX2hpKTtcbiAgICBpZiAocmVtTWFnIDwgMCAmJiBNYXRoLmFicyhyZW1NYWcpID49IG51bURpZ2l0cyAtIGkpIHsgY29udGludWVFeHRyYWN0aW5nRGlnaXRzID0gZmFsc2U7IH1cbiAgICBpZiAoIWNvbnRpbnVlRXh0cmFjdGluZ0RpZ2l0cykgeyBicmVhayB9XG4gIH1cbiAgbWFnbml0dWRlWzBdID0gbWFnO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKClcbn07XG5ERC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyICgpIHtcbiAgcmV0dXJuIHRoaXMubXVsdGlwbHkodGhpcylcbn07XG5ERC5wcm90b3R5cGUuZG91YmxlVmFsdWUgPSBmdW5jdGlvbiBkb3VibGVWYWx1ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9oaSArIHRoaXMuX2xvXG59O1xuREQucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gc3VidHJhY3QgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5hZGQoeS5uZWdhdGUoKSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuYWRkKC15JDEpXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5faGkgPT09IHkuX2hpICYmIHRoaXMuX2xvID09PSB5Ll9sb1xuICB9XG59O1xuREQucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gIHJldHVybiB0aGlzLl9oaSA9PT0gMC4wICYmIHRoaXMuX2xvID09PSAwLjBcbn07XG5ERC5wcm90b3R5cGUuc2VsZlN1YnRyYWN0ID0gZnVuY3Rpb24gc2VsZlN1YnRyYWN0ICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIHRoaXMuc2VsZkFkZCgteS5faGksIC15Ll9sbylcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gdGhpcyB9XG4gICAgcmV0dXJuIHRoaXMuc2VsZkFkZCgteSQxLCAwLjApXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuZ2V0U3BlY2lhbE51bWJlclN0cmluZyA9IGZ1bmN0aW9uIGdldFNwZWNpYWxOdW1iZXJTdHJpbmcgKCkge1xuICBpZiAodGhpcy5pc1plcm8oKSkgeyByZXR1cm4gJzAuMCcgfVxuICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiAnTmFOICcgfVxuICByZXR1cm4gbnVsbFxufTtcbkRELnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiBtaW4gKHgpIHtcbiAgaWYgKHRoaXMubGUoeCkpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4XG4gIH1cbn07XG5ERC5wcm90b3R5cGUuc2VsZkRpdmlkZSA9IGZ1bmN0aW9uIHNlbGZEaXZpZGUgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgICAgdmFyIHkgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHkuX2hpLCB5Ll9sbylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh5JDEsIDAuMClcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB5aGkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHlsbyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaGMgPSBudWxsO1xuICAgIHZhciB0YyA9IG51bGw7XG4gICAgdmFyIGh5ID0gbnVsbDtcbiAgICB2YXIgdHkgPSBudWxsO1xuICAgIHZhciBDID0gbnVsbDtcbiAgICB2YXIgYyA9IG51bGw7XG4gICAgdmFyIFUgPSBudWxsO1xuICAgIHZhciB1ID0gbnVsbDtcbiAgICBDID0gdGhpcy5faGkgLyB5aGk7XG4gICAgYyA9IERELlNQTElUICogQztcbiAgICBoYyA9IGMgLSBDO1xuICAgIHUgPSBERC5TUExJVCAqIHloaTtcbiAgICBoYyA9IGMgLSBoYztcbiAgICB0YyA9IEMgLSBoYztcbiAgICBoeSA9IHUgLSB5aGk7XG4gICAgVSA9IEMgKiB5aGk7XG4gICAgaHkgPSB1IC0gaHk7XG4gICAgdHkgPSB5aGkgLSBoeTtcbiAgICB1ID0gaGMgKiBoeSAtIFUgKyBoYyAqIHR5ICsgdGMgKiBoeSArIHRjICogdHk7XG4gICAgYyA9ICh0aGlzLl9oaSAtIFUgLSB1ICsgdGhpcy5fbG8gLSBDICogeWxvKSAvIHloaTtcbiAgICB1ID0gQyArIGM7XG4gICAgdGhpcy5faGkgPSB1O1xuICAgIHRoaXMuX2xvID0gQyAtIHUgKyBjO1xuICAgIHJldHVybiB0aGlzXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuZHVtcCA9IGZ1bmN0aW9uIGR1bXAgKCkge1xuICByZXR1cm4gJ0REPCcgKyB0aGlzLl9oaSArICcsICcgKyB0aGlzLl9sbyArICc+J1xufTtcbkRELnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiBkaXZpZGUgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgREQpIHtcbiAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgaGMgPSBudWxsO1xuICAgIHZhciB0YyA9IG51bGw7XG4gICAgdmFyIGh5ID0gbnVsbDtcbiAgICB2YXIgdHkgPSBudWxsO1xuICAgIHZhciBDID0gbnVsbDtcbiAgICB2YXIgYyA9IG51bGw7XG4gICAgdmFyIFUgPSBudWxsO1xuICAgIHZhciB1ID0gbnVsbDtcbiAgICBDID0gdGhpcy5faGkgLyB5Ll9oaTtcbiAgICBjID0gREQuU1BMSVQgKiBDO1xuICAgIGhjID0gYyAtIEM7XG4gICAgdSA9IERELlNQTElUICogeS5faGk7XG4gICAgaGMgPSBjIC0gaGM7XG4gICAgdGMgPSBDIC0gaGM7XG4gICAgaHkgPSB1IC0geS5faGk7XG4gICAgVSA9IEMgKiB5Ll9oaTtcbiAgICBoeSA9IHUgLSBoeTtcbiAgICB0eSA9IHkuX2hpIC0gaHk7XG4gICAgdSA9IGhjICogaHkgLSBVICsgaGMgKiB0eSArIHRjICogaHkgKyB0YyAqIHR5O1xuICAgIGMgPSAodGhpcy5faGkgLSBVIC0gdSArIHRoaXMuX2xvIC0gQyAqIHkuX2xvKSAvIHkuX2hpO1xuICAgIHUgPSBDICsgYztcbiAgICB2YXIgemhpID0gdTtcbiAgICB2YXIgemxvID0gQyAtIHUgKyBjO1xuICAgIHJldHVybiBuZXcgREQoemhpLCB6bG8pXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeSQxID0gYXJndW1lbnRzWzBdO1xuICAgIGlmIChEb3VibGUuaXNOYU4oeSQxKSkgeyByZXR1cm4gREQuY3JlYXRlTmFOKCkgfVxuICAgIHJldHVybiBERC5jb3B5KHRoaXMpLnNlbGZEaXZpZGUoeSQxLCAwLjApXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuZ2UgPSBmdW5jdGlvbiBnZSAoeSkge1xuICByZXR1cm4gKHRoaXMuX2hpID4geS5faGkgfHwgdGhpcy5faGkgPT09IHkuX2hpKSAmJiB0aGlzLl9sbyA+PSB5Ll9sb1xufTtcbkRELnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGV4cCkge1xuICBpZiAoZXhwID09PSAwLjApIHsgcmV0dXJuIERELnZhbHVlT2YoMS4wKSB9XG4gIHZhciByID0gbmV3IEREKHRoaXMpO1xuICB2YXIgcyA9IERELnZhbHVlT2YoMS4wKTtcbiAgdmFyIG4gPSBNYXRoLmFicyhleHApO1xuICBpZiAobiA+IDEpIHtcbiAgICB3aGlsZSAobiA+IDApIHtcbiAgICAgIGlmIChuICUgMiA9PT0gMSkge1xuICAgICAgICBzLnNlbGZNdWx0aXBseShyKTtcbiAgICAgIH1cbiAgICAgIG4gLz0gMjtcbiAgICAgIGlmIChuID4gMCkgeyByID0gci5zcXIoKTsgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzID0gcjtcbiAgfVxuICBpZiAoZXhwIDwgMCkgeyByZXR1cm4gcy5yZWNpcHJvY2FsKCkgfVxuICByZXR1cm4gc1xufTtcbkRELnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24gY2VpbCAoKSB7XG4gIGlmICh0aGlzLmlzTmFOKCkpIHsgcmV0dXJuIERELk5hTiB9XG4gIHZhciBmaGkgPSBNYXRoLmNlaWwodGhpcy5faGkpO1xuICB2YXIgZmxvID0gMC4wO1xuICBpZiAoZmhpID09PSB0aGlzLl9oaSkge1xuICAgIGZsbyA9IE1hdGguY2VpbCh0aGlzLl9sbyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBERChmaGksIGZsbylcbn07XG5ERC5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBvdGhlciA9IG87XG4gIGlmICh0aGlzLl9oaSA8IG90aGVyLl9oaSkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5faGkgPiBvdGhlci5faGkpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fbG8gPCBvdGhlci5fbG8pIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX2xvID4gb3RoZXIuX2xvKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5ERC5wcm90b3R5cGUucmludCA9IGZ1bmN0aW9uIHJpbnQgKCkge1xuICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiB0aGlzIH1cbiAgdmFyIHBsdXM1ID0gdGhpcy5hZGQoMC41KTtcbiAgcmV0dXJuIHBsdXM1LmZsb29yKClcbn07XG5ERC5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLmluaXQodmFsdWUpO1xuICAgIHJldHVybiB0aGlzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgdmFsdWUkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLmluaXQodmFsdWUkMSk7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufTtcbkRELnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiBtYXggKHgpIHtcbiAgaWYgKHRoaXMuZ2UoeCkpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB4XG4gIH1cbn07XG5ERC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKCkge1xuICBpZiAodGhpcy5pc1plcm8oKSkgeyByZXR1cm4gREQudmFsdWVPZigwLjApIH1cbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7XG4gICAgcmV0dXJuIERELk5hTlxuICB9XG4gIHZhciB4ID0gMS4wIC8gTWF0aC5zcXJ0KHRoaXMuX2hpKTtcbiAgdmFyIGF4ID0gdGhpcy5faGkgKiB4O1xuICB2YXIgYXhkZCA9IERELnZhbHVlT2YoYXgpO1xuICB2YXIgZGlmZlNxID0gdGhpcy5zdWJ0cmFjdChheGRkLnNxcigpKTtcbiAgdmFyIGQyID0gZGlmZlNxLl9oaSAqICh4ICogMC41KTtcbiAgcmV0dXJuIGF4ZGQuYWRkKGQyKVxufTtcbkRELnByb3RvdHlwZS5zZWxmQWRkID0gZnVuY3Rpb24gc2VsZkFkZCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLnNlbGZBZGQoeS5faGksIHkuX2xvKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgSCA9IG51bGw7XG4gICAgICB2YXIgaCA9IG51bGw7XG4gICAgICB2YXIgUyA9IG51bGw7XG4gICAgICB2YXIgcyA9IG51bGw7XG4gICAgICB2YXIgZSA9IG51bGw7XG4gICAgICB2YXIgZiA9IG51bGw7XG4gICAgICBTID0gdGhpcy5faGkgKyB5JDE7XG4gICAgICBlID0gUyAtIHRoaXMuX2hpO1xuICAgICAgcyA9IFMgLSBlO1xuICAgICAgcyA9IHkkMSAtIGUgKyAodGhpcy5faGkgLSBzKTtcbiAgICAgIGYgPSBzICsgdGhpcy5fbG87XG4gICAgICBIID0gUyArIGY7XG4gICAgICBoID0gZiArIChTIC0gSCk7XG4gICAgICB0aGlzLl9oaSA9IEggKyBoO1xuICAgICAgdGhpcy5fbG8gPSBoICsgKEggLSB0aGlzLl9oaSk7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHloaSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeWxvID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBIJDEgPSBudWxsO1xuICAgIHZhciBoJDEgPSBudWxsO1xuICAgIHZhciBUID0gbnVsbDtcbiAgICB2YXIgdCA9IG51bGw7XG4gICAgdmFyIFMkMSA9IG51bGw7XG4gICAgdmFyIHMkMSA9IG51bGw7XG4gICAgdmFyIGUkMSA9IG51bGw7XG4gICAgdmFyIGYkMSA9IG51bGw7XG4gICAgUyQxID0gdGhpcy5faGkgKyB5aGk7XG4gICAgVCA9IHRoaXMuX2xvICsgeWxvO1xuICAgIGUkMSA9IFMkMSAtIHRoaXMuX2hpO1xuICAgIGYkMSA9IFQgLSB0aGlzLl9sbztcbiAgICBzJDEgPSBTJDEgLSBlJDE7XG4gICAgdCA9IFQgLSBmJDE7XG4gICAgcyQxID0geWhpIC0gZSQxICsgKHRoaXMuX2hpIC0gcyQxKTtcbiAgICB0ID0geWxvIC0gZiQxICsgKHRoaXMuX2xvIC0gdCk7XG4gICAgZSQxID0gcyQxICsgVDtcbiAgICBIJDEgPSBTJDEgKyBlJDE7XG4gICAgaCQxID0gZSQxICsgKFMkMSAtIEgkMSk7XG4gICAgZSQxID0gdCArIGgkMTtcbiAgICB2YXIgemhpID0gSCQxICsgZSQxO1xuICAgIHZhciB6bG8gPSBlJDEgKyAoSCQxIC0gemhpKTtcbiAgICB0aGlzLl9oaSA9IHpoaTtcbiAgICB0aGlzLl9sbyA9IHpsbztcbiAgICByZXR1cm4gdGhpc1xuICB9XG59O1xuREQucHJvdG90eXBlLnNlbGZNdWx0aXBseSA9IGZ1bmN0aW9uIHNlbGZNdWx0aXBseSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgICB2YXIgeSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLnNlbGZNdWx0aXBseSh5Ll9oaSwgeS5fbG8pXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHkkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLnNlbGZNdWx0aXBseSh5JDEsIDAuMClcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB5aGkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHlsbyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaHggPSBudWxsO1xuICAgIHZhciB0eCA9IG51bGw7XG4gICAgdmFyIGh5ID0gbnVsbDtcbiAgICB2YXIgdHkgPSBudWxsO1xuICAgIHZhciBDID0gbnVsbDtcbiAgICB2YXIgYyA9IG51bGw7XG4gICAgQyA9IERELlNQTElUICogdGhpcy5faGk7XG4gICAgaHggPSBDIC0gdGhpcy5faGk7XG4gICAgYyA9IERELlNQTElUICogeWhpO1xuICAgIGh4ID0gQyAtIGh4O1xuICAgIHR4ID0gdGhpcy5faGkgLSBoeDtcbiAgICBoeSA9IGMgLSB5aGk7XG4gICAgQyA9IHRoaXMuX2hpICogeWhpO1xuICAgIGh5ID0gYyAtIGh5O1xuICAgIHR5ID0geWhpIC0gaHk7XG4gICAgYyA9IGh4ICogaHkgLSBDICsgaHggKiB0eSArIHR4ICogaHkgKyB0eCAqIHR5ICsgKHRoaXMuX2hpICogeWxvICsgdGhpcy5fbG8gKiB5aGkpO1xuICAgIHZhciB6aGkgPSBDICsgYztcbiAgICBoeCA9IEMgLSB6aGk7XG4gICAgdmFyIHpsbyA9IGMgKyBoeDtcbiAgICB0aGlzLl9oaSA9IHpoaTtcbiAgICB0aGlzLl9sbyA9IHpsbztcbiAgICByZXR1cm4gdGhpc1xuICB9XG59O1xuREQucHJvdG90eXBlLnNlbGZTcXIgPSBmdW5jdGlvbiBzZWxmU3FyICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHRoaXMpXG59O1xuREQucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gZmxvb3IgKCkge1xuICBpZiAodGhpcy5pc05hTigpKSB7IHJldHVybiBERC5OYU4gfVxuICB2YXIgZmhpID0gTWF0aC5mbG9vcih0aGlzLl9oaSk7XG4gIHZhciBmbG8gPSAwLjA7XG4gIGlmIChmaGkgPT09IHRoaXMuX2hpKSB7XG4gICAgZmxvID0gTWF0aC5mbG9vcih0aGlzLl9sbyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBERChmaGksIGZsbylcbn07XG5ERC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gbmVnYXRlICgpIHtcbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gdGhpcyB9XG4gIHJldHVybiBuZXcgREQoLXRoaXMuX2hpLCAtdGhpcy5fbG8pXG59O1xuREQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAvLyB0cnkge1xuICAvLyByZXR1cm4gbnVsbFxuICAvLyB9IGNhdGNoIChleCkge1xuICAvLyBpZiAoZXggaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbikge1xuICAvLyAgIHJldHVybiBudWxsXG4gIC8vIH0gZWxzZSB0aHJvdyBleFxuICAvLyB9IGZpbmFsbHkge31cbn07XG5ERC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiBtdWx0aXBseSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICh5LmlzTmFOKCkpIHsgcmV0dXJuIERELmNyZWF0ZU5hTigpIH1cbiAgICByZXR1cm4gREQuY29weSh0aGlzKS5zZWxmTXVsdGlwbHkoeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKERvdWJsZS5pc05hTih5JDEpKSB7IHJldHVybiBERC5jcmVhdGVOYU4oKSB9XG4gICAgcmV0dXJuIERELmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHkkMSwgMC4wKVxuICB9XG59O1xuREQucHJvdG90eXBlLmlzTmFOID0gZnVuY3Rpb24gaXNOYU4gKCkge1xuICByZXR1cm4gRG91YmxlLmlzTmFOKHRoaXMuX2hpKVxufTtcbkRELnByb3RvdHlwZS5pbnRWYWx1ZSA9IGZ1bmN0aW9uIGludFZhbHVlICgpIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmModGhpcy5faGkpXG59O1xuREQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbWFnID0gREQubWFnbml0dWRlKHRoaXMuX2hpKTtcbiAgaWYgKG1hZyA+PSAtMyAmJiBtYWcgPD0gMjApIHsgcmV0dXJuIHRoaXMudG9TdGFuZGFyZE5vdGF0aW9uKCkgfVxuICByZXR1cm4gdGhpcy50b1NjaU5vdGF0aW9uKClcbn07XG5ERC5wcm90b3R5cGUudG9TdGFuZGFyZE5vdGF0aW9uID0gZnVuY3Rpb24gdG9TdGFuZGFyZE5vdGF0aW9uICgpIHtcbiAgdmFyIHNwZWNpYWxTdHIgPSB0aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtcbiAgaWYgKHNwZWNpYWxTdHIgIT09IG51bGwpIHsgcmV0dXJuIHNwZWNpYWxTdHIgfVxuICB2YXIgbWFnbml0dWRlID0gbmV3IEFycmF5KDEpLmZpbGwobnVsbCk7XG4gIHZhciBzaWdEaWdpdHMgPSB0aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyh0cnVlLCBtYWduaXR1ZGUpO1xuICB2YXIgZGVjaW1hbFBvaW50UG9zID0gbWFnbml0dWRlWzBdICsgMTtcbiAgdmFyIG51bSA9IHNpZ0RpZ2l0cztcbiAgaWYgKHNpZ0RpZ2l0cy5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgIG51bSA9ICcwJyArIHNpZ0RpZ2l0cztcbiAgfSBlbHNlIGlmIChkZWNpbWFsUG9pbnRQb3MgPCAwKSB7XG4gICAgbnVtID0gJzAuJyArIERELnN0cmluZ09mQ2hhcignMCcsIC1kZWNpbWFsUG9pbnRQb3MpICsgc2lnRGlnaXRzO1xuICB9IGVsc2UgaWYgKHNpZ0RpZ2l0cy5pbmRleE9mKCcuJykgPT09IC0xKSB7XG4gICAgdmFyIG51bVplcm9lcyA9IGRlY2ltYWxQb2ludFBvcyAtIHNpZ0RpZ2l0cy5sZW5ndGg7XG4gICAgdmFyIHplcm9lcyA9IERELnN0cmluZ09mQ2hhcignMCcsIG51bVplcm9lcyk7XG4gICAgbnVtID0gc2lnRGlnaXRzICsgemVyb2VzICsgJy4wJztcbiAgfVxuICBpZiAodGhpcy5pc05lZ2F0aXZlKCkpIHsgcmV0dXJuICctJyArIG51bSB9XG4gIHJldHVybiBudW1cbn07XG5ERC5wcm90b3R5cGUucmVjaXByb2NhbCA9IGZ1bmN0aW9uIHJlY2lwcm9jYWwgKCkge1xuICB2YXIgaGMgPSBudWxsO1xuICB2YXIgdGMgPSBudWxsO1xuICB2YXIgaHkgPSBudWxsO1xuICB2YXIgdHkgPSBudWxsO1xuICB2YXIgQyA9IG51bGw7XG4gIHZhciBjID0gbnVsbDtcbiAgdmFyIFUgPSBudWxsO1xuICB2YXIgdSA9IG51bGw7XG4gIEMgPSAxLjAgLyB0aGlzLl9oaTtcbiAgYyA9IERELlNQTElUICogQztcbiAgaGMgPSBjIC0gQztcbiAgdSA9IERELlNQTElUICogdGhpcy5faGk7XG4gIGhjID0gYyAtIGhjO1xuICB0YyA9IEMgLSBoYztcbiAgaHkgPSB1IC0gdGhpcy5faGk7XG4gIFUgPSBDICogdGhpcy5faGk7XG4gIGh5ID0gdSAtIGh5O1xuICB0eSA9IHRoaXMuX2hpIC0gaHk7XG4gIHUgPSBoYyAqIGh5IC0gVSArIGhjICogdHkgKyB0YyAqIGh5ICsgdGMgKiB0eTtcbiAgYyA9ICgxLjAgLSBVIC0gdSAtIEMgKiB0aGlzLl9sbykgLyB0aGlzLl9oaTtcbiAgdmFyIHpoaSA9IEMgKyBjO1xuICB2YXIgemxvID0gQyAtIHpoaSArIGM7XG4gIHJldHVybiBuZXcgREQoemhpLCB6bG8pXG59O1xuREQucHJvdG90eXBlLnRvU2NpTm90YXRpb24gPSBmdW5jdGlvbiB0b1NjaU5vdGF0aW9uICgpIHtcbiAgaWYgKHRoaXMuaXNaZXJvKCkpIHsgcmV0dXJuIERELlNDSV9OT1RfWkVSTyB9XG4gIHZhciBzcGVjaWFsU3RyID0gdGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7XG4gIGlmIChzcGVjaWFsU3RyICE9PSBudWxsKSB7IHJldHVybiBzcGVjaWFsU3RyIH1cbiAgdmFyIG1hZ25pdHVkZSA9IG5ldyBBcnJheSgxKS5maWxsKG51bGwpO1xuICB2YXIgZGlnaXRzID0gdGhpcy5leHRyYWN0U2lnbmlmaWNhbnREaWdpdHMoZmFsc2UsIG1hZ25pdHVkZSk7XG4gIHZhciBleHBTdHIgPSBERC5TQ0lfTk9UX0VYUE9ORU5UX0NIQVIgKyBtYWduaXR1ZGVbMF07XG4gIGlmIChkaWdpdHMuY2hhckF0KDApID09PSAnMCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIGxlYWRpbmcgemVybzogJyArIGRpZ2l0cylcbiAgfVxuICB2YXIgdHJhaWxpbmdEaWdpdHMgPSAnJztcbiAgaWYgKGRpZ2l0cy5sZW5ndGggPiAxKSB7IHRyYWlsaW5nRGlnaXRzID0gZGlnaXRzLnN1YnN0cmluZygxKTsgfVxuICB2YXIgZGlnaXRzV2l0aERlY2ltYWwgPSBkaWdpdHMuY2hhckF0KDApICsgJy4nICsgdHJhaWxpbmdEaWdpdHM7XG4gIGlmICh0aGlzLmlzTmVnYXRpdmUoKSkgeyByZXR1cm4gJy0nICsgZGlnaXRzV2l0aERlY2ltYWwgKyBleHBTdHIgfVxuICByZXR1cm4gZGlnaXRzV2l0aERlY2ltYWwgKyBleHBTdHJcbn07XG5ERC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gREQuTmFOIH1cbiAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpKSB7IHJldHVybiB0aGlzLm5lZ2F0ZSgpIH1cbiAgcmV0dXJuIG5ldyBERCh0aGlzKVxufTtcbkRELnByb3RvdHlwZS5pc1Bvc2l0aXZlID0gZnVuY3Rpb24gaXNQb3NpdGl2ZSAoKSB7XG4gIHJldHVybiAodGhpcy5faGkgPiAwLjAgfHwgdGhpcy5faGkgPT09IDAuMCkgJiYgdGhpcy5fbG8gPiAwLjBcbn07XG5ERC5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAoeSkge1xuICByZXR1cm4gKHRoaXMuX2hpIDwgeS5faGkgfHwgdGhpcy5faGkgPT09IHkuX2hpKSAmJiB0aGlzLl9sbyA8IHkuX2xvXG59O1xuREQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBERCkge1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBERC5jb3B5KHRoaXMpLnNlbGZBZGQoeSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIHZhciB5JDEgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIERELmNvcHkodGhpcykuc2VsZkFkZCh5JDEpXG4gIH1cbn07XG5ERC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9oaSA9IHg7XG4gICAgICB0aGlzLl9sbyA9IDAuMDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEREKSB7XG4gICAgICB2YXIgZGQgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9oaSA9IGRkLl9oaTtcbiAgICAgIHRoaXMuX2xvID0gZGQuX2xvO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGhpID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsbyA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9oaSA9IGhpO1xuICAgIHRoaXMuX2xvID0gbG87XG4gIH1cbn07XG5ERC5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiBndCAoeSkge1xuICByZXR1cm4gKHRoaXMuX2hpID4geS5faGkgfHwgdGhpcy5faGkgPT09IHkuX2hpKSAmJiB0aGlzLl9sbyA+IHkuX2xvXG59O1xuREQucHJvdG90eXBlLmlzTmVnYXRpdmUgPSBmdW5jdGlvbiBpc05lZ2F0aXZlICgpIHtcbiAgcmV0dXJuICh0aGlzLl9oaSA8IDAuMCB8fCB0aGlzLl9oaSA9PT0gMC4wKSAmJiB0aGlzLl9sbyA8IDAuMFxufTtcbkRELnByb3RvdHlwZS50cnVuYyA9IGZ1bmN0aW9uIHRydW5jICgpIHtcbiAgaWYgKHRoaXMuaXNOYU4oKSkgeyByZXR1cm4gREQuTmFOIH1cbiAgaWYgKHRoaXMuaXNQb3NpdGl2ZSgpKSB7IHJldHVybiB0aGlzLmZsb29yKCk7IH0gZWxzZSB7IHJldHVybiB0aGlzLmNlaWwoKSB9XG59O1xuREQucHJvdG90eXBlLnNpZ251bSA9IGZ1bmN0aW9uIHNpZ251bSAoKSB7XG4gIGlmICh0aGlzLl9oaSA+IDApIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5faGkgPCAwKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9sbyA+IDApIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fbG8gPCAwKSB7IHJldHVybiAtMSB9XG4gIHJldHVybiAwXG59O1xuREQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlcmlhbGl6YWJsZSwgQ29tcGFyYWJsZSwgQ2xvbmFibGVdXG59O1xuREQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRERcbn07XG5ERC5zcXIgPSBmdW5jdGlvbiBzcXIgKHgpIHtcbiAgcmV0dXJuIERELnZhbHVlT2YoeCkuc2VsZk11bHRpcGx5KHgpXG59O1xuREQudmFsdWVPZiA9IGZ1bmN0aW9uIHZhbHVlT2YgKCkge1xuICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc3RyID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBERC5wYXJzZShzdHIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgeCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gbmV3IEREKHgpXG4gIH1cbn07XG5ERC5zcXJ0ID0gZnVuY3Rpb24gc3FydCAoeCkge1xuICByZXR1cm4gREQudmFsdWVPZih4KS5zcXJ0KClcbn07XG5ERC5wYXJzZSA9IGZ1bmN0aW9uIHBhcnNlIChzdHIpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgc3RybGVuID0gc3RyLmxlbmd0aDtcbiAgd2hpbGUgKENoYXJhY3Rlci5pc1doaXRlc3BhY2Uoc3RyLmNoYXJBdChpKSkpIHsgaSsrOyB9XG4gIHZhciBpc05lZ2F0aXZlID0gZmFsc2U7XG4gIGlmIChpIDwgc3RybGVuKSB7XG4gICAgdmFyIHNpZ25DaCA9IHN0ci5jaGFyQXQoaSk7XG4gICAgaWYgKHNpZ25DaCA9PT0gJy0nIHx8IHNpZ25DaCA9PT0gJysnKSB7XG4gICAgICBpKys7XG4gICAgICBpZiAoc2lnbkNoID09PSAnLScpIHsgaXNOZWdhdGl2ZSA9IHRydWU7IH1cbiAgICB9XG4gIH1cbiAgdmFyIHZhbCA9IG5ldyBERCgpO1xuICB2YXIgbnVtRGlnaXRzID0gMDtcbiAgdmFyIG51bUJlZm9yZURlYyA9IDA7XG4gIHZhciBleHAgPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChpID49IHN0cmxlbikgeyBicmVhayB9XG4gICAgdmFyIGNoID0gc3RyLmNoYXJBdChpKTtcbiAgICBpKys7XG4gICAgaWYgKENoYXJhY3Rlci5pc0RpZ2l0KGNoKSkge1xuICAgICAgdmFyIGQgPSBjaCAtICcwJztcbiAgICAgIHZhbC5zZWxmTXVsdGlwbHkoREQuVEVOKTtcbiAgICAgIHZhbC5zZWxmQWRkKGQpO1xuICAgICAgbnVtRGlnaXRzKys7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY2ggPT09ICcuJykge1xuICAgICAgbnVtQmVmb3JlRGVjID0gbnVtRGlnaXRzO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgdmFyIGV4cFN0ciA9IHN0ci5zdWJzdHJpbmcoaSk7XG4gICAgICB0cnkge1xuICAgICAgICBleHAgPSBJbnRlZ2VyLnBhcnNlSW50KGV4cFN0cik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBleHBvbmVudCAnICsgZXhwU3RyICsgJyBpbiBzdHJpbmcgJyArIHN0cilcbiAgICAgICAgfSBlbHNlIHsgdGhyb3cgZXggfVxuICAgICAgfSBmaW5hbGx5IHt9XG4gICAgICBicmVha1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIgKyBjaCArIFwiJyBhdCBwb3NpdGlvbiBcIiArIGkgKyAnIGluIHN0cmluZyAnICsgc3RyKVxuICB9XG4gIHZhciB2YWwyID0gdmFsO1xuICB2YXIgbnVtRGVjUGxhY2VzID0gbnVtRGlnaXRzIC0gbnVtQmVmb3JlRGVjIC0gZXhwO1xuICBpZiAobnVtRGVjUGxhY2VzID09PSAwKSB7XG4gICAgdmFsMiA9IHZhbDtcbiAgfSBlbHNlIGlmIChudW1EZWNQbGFjZXMgPiAwKSB7XG4gICAgdmFyIHNjYWxlID0gREQuVEVOLnBvdyhudW1EZWNQbGFjZXMpO1xuICAgIHZhbDIgPSB2YWwuZGl2aWRlKHNjYWxlKTtcbiAgfSBlbHNlIGlmIChudW1EZWNQbGFjZXMgPCAwKSB7XG4gICAgdmFyIHNjYWxlJDEgPSBERC5URU4ucG93KC1udW1EZWNQbGFjZXMpO1xuICAgIHZhbDIgPSB2YWwubXVsdGlwbHkoc2NhbGUkMSk7XG4gIH1cbiAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICByZXR1cm4gdmFsMi5uZWdhdGUoKVxuICB9XG4gIHJldHVybiB2YWwyXG59O1xuREQuY3JlYXRlTmFOID0gZnVuY3Rpb24gY3JlYXRlTmFOICgpIHtcbiAgcmV0dXJuIG5ldyBERChEb3VibGUuTmFOLCBEb3VibGUuTmFOKVxufTtcbkRELmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZCkge1xuICByZXR1cm4gbmV3IEREKGRkKVxufTtcbkRELm1hZ25pdHVkZSA9IGZ1bmN0aW9uIG1hZ25pdHVkZSAoeCkge1xuICB2YXIgeEFicyA9IE1hdGguYWJzKHgpO1xuICB2YXIgeExvZzEwID0gTWF0aC5sb2coeEFicykgLyBNYXRoLmxvZygxMCk7XG4gIHZhciB4TWFnID0gTWF0aC50cnVuYyhNYXRoLmZsb29yKHhMb2cxMCkpO1xuICB2YXIgeEFwcHJveCA9IE1hdGgucG93KDEwLCB4TWFnKTtcbiAgaWYgKHhBcHByb3ggKiAxMCA8PSB4QWJzKSB7IHhNYWcgKz0gMTsgfVxuICByZXR1cm4geE1hZ1xufTtcbkRELnN0cmluZ09mQ2hhciA9IGZ1bmN0aW9uIHN0cmluZ09mQ2hhciAoY2gsIGxlbikge1xuICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYnVmLmFwcGVuZChjaCk7XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG59O1xuc3RhdGljQWNjZXNzb3JzJDcuUEkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEREKDMuMTQxNTkyNjUzNTg5NzkzMTE2ZSswMCwgMS4yMjQ2NDY3OTkxNDczNTMyMDdlLTE2KSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuVFdPX1BJLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBERCg2LjI4MzE4NTMwNzE3OTU4NjIzMmUrMDAsIDIuNDQ5MjkzNTk4Mjk0NzA2NDE0ZS0xNikgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlBJXzIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEREKDEuNTcwNzk2MzI2Nzk0ODk2NTU4ZSswMCwgNi4xMjMyMzM5OTU3MzY3NjYwMzZlLTE3KSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgREQoMi43MTgyODE4Mjg0NTkwNDUwOTFlKzAwLCAxLjQ0NTY0Njg5MTcyOTI1MDE1OGUtMTYpIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5OYU4uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEREKERvdWJsZS5OYU4sIERvdWJsZS5OYU4pIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5FUFMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMS4yMzI1OTUxNjQ0MDc4M2UtMzIgfTtcbnN0YXRpY0FjY2Vzc29ycyQ3LlNQTElULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEzNDIxNzcyOS4wIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5NQVhfUFJJTlRfRElHSVRTLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMyIH07XG5zdGF0aWNBY2Nlc3NvcnMkNy5URU4uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gREQudmFsdWVPZigxMC4wKSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuT05FLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIERELnZhbHVlT2YoMS4wKSB9O1xuc3RhdGljQWNjZXNzb3JzJDcuU0NJX05PVF9FWFBPTkVOVF9DSEFSLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICdFJyB9O1xuc3RhdGljQWNjZXNzb3JzJDcuU0NJX05PVF9aRVJPLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcwLjBFMCcgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERELCBzdGF0aWNBY2Nlc3NvcnMkNyApO1xuXG52YXIgQ0dBbGdvcml0aG1zREQgPSBmdW5jdGlvbiBDR0FsZ29yaXRobXNERCAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ2ID0geyBEUF9TQUZFX0VQU0lMT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuQ0dBbGdvcml0aG1zREQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5DR0FsZ29yaXRobXNERC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDR0FsZ29yaXRobXNERFxufTtcbkNHQWxnb3JpdGhtc0RELm9yaWVudGF0aW9uSW5kZXggPSBmdW5jdGlvbiBvcmllbnRhdGlvbkluZGV4IChwMSwgcDIsIHEpIHtcbiAgdmFyIGluZGV4ID0gQ0dBbGdvcml0aG1zREQub3JpZW50YXRpb25JbmRleEZpbHRlcihwMSwgcDIsIHEpO1xuICBpZiAoaW5kZXggPD0gMSkgeyByZXR1cm4gaW5kZXggfVxuICB2YXIgZHgxID0gREQudmFsdWVPZihwMi54KS5zZWxmQWRkKC1wMS54KTtcbiAgdmFyIGR5MSA9IERELnZhbHVlT2YocDIueSkuc2VsZkFkZCgtcDEueSk7XG4gIHZhciBkeDIgPSBERC52YWx1ZU9mKHEueCkuc2VsZkFkZCgtcDIueCk7XG4gIHZhciBkeTIgPSBERC52YWx1ZU9mKHEueSkuc2VsZkFkZCgtcDIueSk7XG4gIHJldHVybiBkeDEuc2VsZk11bHRpcGx5KGR5Mikuc2VsZlN1YnRyYWN0KGR5MS5zZWxmTXVsdGlwbHkoZHgyKSkuc2lnbnVtKClcbn07XG5DR0FsZ29yaXRobXNERC5zaWduT2ZEZXQyeDIgPSBmdW5jdGlvbiBzaWduT2ZEZXQyeDIgKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBkZXQgPSB4MS5tdWx0aXBseSh5Mikuc2VsZlN1YnRyYWN0KHkxLm11bHRpcGx5KHgyKSk7XG4gIHJldHVybiBkZXQuc2lnbnVtKClcbn07XG5DR0FsZ29yaXRobXNERC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKHAxLCBwMiwgcTEsIHEyKSB7XG4gIHZhciBkZW5vbTEgPSBERC52YWx1ZU9mKHEyLnkpLnNlbGZTdWJ0cmFjdChxMS55KS5zZWxmTXVsdGlwbHkoREQudmFsdWVPZihwMi54KS5zZWxmU3VidHJhY3QocDEueCkpO1xuICB2YXIgZGVub20yID0gREQudmFsdWVPZihxMi54KS5zZWxmU3VidHJhY3QocTEueCkuc2VsZk11bHRpcGx5KERELnZhbHVlT2YocDIueSkuc2VsZlN1YnRyYWN0KHAxLnkpKTtcbiAgdmFyIGRlbm9tID0gZGVub20xLnN1YnRyYWN0KGRlbm9tMik7XG4gIHZhciBudW14MSA9IERELnZhbHVlT2YocTIueCkuc2VsZlN1YnRyYWN0KHExLngpLnNlbGZNdWx0aXBseShERC52YWx1ZU9mKHAxLnkpLnNlbGZTdWJ0cmFjdChxMS55KSk7XG4gIHZhciBudW14MiA9IERELnZhbHVlT2YocTIueSkuc2VsZlN1YnRyYWN0KHExLnkpLnNlbGZNdWx0aXBseShERC52YWx1ZU9mKHAxLngpLnNlbGZTdWJ0cmFjdChxMS54KSk7XG4gIHZhciBudW14ID0gbnVteDEuc3VidHJhY3QobnVteDIpO1xuICB2YXIgZnJhY1AgPSBudW14LnNlbGZEaXZpZGUoZGVub20pLmRvdWJsZVZhbHVlKCk7XG4gIHZhciB4ID0gREQudmFsdWVPZihwMS54KS5zZWxmQWRkKERELnZhbHVlT2YocDIueCkuc2VsZlN1YnRyYWN0KHAxLngpLnNlbGZNdWx0aXBseShmcmFjUCkpLmRvdWJsZVZhbHVlKCk7XG4gIHZhciBudW15MSA9IERELnZhbHVlT2YocDIueCkuc2VsZlN1YnRyYWN0KHAxLngpLnNlbGZNdWx0aXBseShERC52YWx1ZU9mKHAxLnkpLnNlbGZTdWJ0cmFjdChxMS55KSk7XG4gIHZhciBudW15MiA9IERELnZhbHVlT2YocDIueSkuc2VsZlN1YnRyYWN0KHAxLnkpLnNlbGZNdWx0aXBseShERC52YWx1ZU9mKHAxLngpLnNlbGZTdWJ0cmFjdChxMS54KSk7XG4gIHZhciBudW15ID0gbnVteTEuc3VidHJhY3QobnVteTIpO1xuICB2YXIgZnJhY1EgPSBudW15LnNlbGZEaXZpZGUoZGVub20pLmRvdWJsZVZhbHVlKCk7XG4gIHZhciB5ID0gREQudmFsdWVPZihxMS55KS5zZWxmQWRkKERELnZhbHVlT2YocTIueSkuc2VsZlN1YnRyYWN0KHExLnkpLnNlbGZNdWx0aXBseShmcmFjUSkpLmRvdWJsZVZhbHVlKCk7XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSh4LCB5KVxufTtcbkNHQWxnb3JpdGhtc0RELm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIgPSBmdW5jdGlvbiBvcmllbnRhdGlvbkluZGV4RmlsdGVyIChwYSwgcGIsIHBjKSB7XG4gIHZhciBkZXRzdW0gPSBudWxsO1xuICB2YXIgZGV0bGVmdCA9IChwYS54IC0gcGMueCkgKiAocGIueSAtIHBjLnkpO1xuICB2YXIgZGV0cmlnaHQgPSAocGEueSAtIHBjLnkpICogKHBiLnggLSBwYy54KTtcbiAgdmFyIGRldCA9IGRldGxlZnQgLSBkZXRyaWdodDtcbiAgaWYgKGRldGxlZnQgPiAwLjApIHtcbiAgICBpZiAoZGV0cmlnaHQgPD0gMC4wKSB7XG4gICAgICByZXR1cm4gQ0dBbGdvcml0aG1zREQuc2lnbnVtKGRldClcbiAgICB9IGVsc2Uge1xuICAgICAgZGV0c3VtID0gZGV0bGVmdCArIGRldHJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChkZXRsZWZ0IDwgMC4wKSB7XG4gICAgaWYgKGRldHJpZ2h0ID49IDAuMCkge1xuICAgICAgcmV0dXJuIENHQWxnb3JpdGhtc0RELnNpZ251bShkZXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRldHN1bSA9IC1kZXRsZWZ0IC0gZGV0cmlnaHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBDR0FsZ29yaXRobXNERC5zaWdudW0oZGV0KVxuICB9XG4gIHZhciBlcnJib3VuZCA9IENHQWxnb3JpdGhtc0RELkRQX1NBRkVfRVBTSUxPTiAqIGRldHN1bTtcbiAgaWYgKGRldCA+PSBlcnJib3VuZCB8fCAtZGV0ID49IGVycmJvdW5kKSB7XG4gICAgcmV0dXJuIENHQWxnb3JpdGhtc0RELnNpZ251bShkZXQpXG4gIH1cbiAgcmV0dXJuIDJcbn07XG5DR0FsZ29yaXRobXNERC5zaWdudW0gPSBmdW5jdGlvbiBzaWdudW0gKHgpIHtcbiAgaWYgKHggPiAwKSB7IHJldHVybiAxIH1cbiAgaWYgKHggPCAwKSB7IHJldHVybiAtMSB9XG4gIHJldHVybiAwXG59O1xuc3RhdGljQWNjZXNzb3JzJDYuRFBfU0FGRV9FUFNJTE9OLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDFlLTE1IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDR0FsZ29yaXRobXNERCwgc3RhdGljQWNjZXNzb3JzJDYgKTtcblxudmFyIENvb3JkaW5hdGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIENvb3JkaW5hdGVTZXF1ZW5jZSAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ4ID0geyBYOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sWjogeyBjb25maWd1cmFibGU6IHRydWUgfSxNOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnN0YXRpY0FjY2Vzc29ycyQ4LlguZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDguWS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkOC5aLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQ4Lk0uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMyB9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5zZXRPcmRpbmF0ZSA9IGZ1bmN0aW9uIHNldE9yZGluYXRlIChpbmRleCwgb3JkaW5hdGVJbmRleCwgdmFsdWUpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0T3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRPcmRpbmF0ZSAoaW5kZXgsIG9yZGluYXRlSW5kZXgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZUNvcHkgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlQ29weSAoaSkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFggKGluZGV4KSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZXhwYW5kRW52ZWxvcGUgPSBmdW5jdGlvbiBleHBhbmRFbnZlbG9wZSAoZW52KSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZIChpbmRleCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLnRvQ29vcmRpbmF0ZUFycmF5ID0gZnVuY3Rpb24gdG9Db29yZGluYXRlQXJyYXkgKCkge307XG5Db29yZGluYXRlU2VxdWVuY2UucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nsb25hYmxlXVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2Vcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlU2VxdWVuY2UsIHN0YXRpY0FjY2Vzc29ycyQ4ICk7XG5cbnZhciBFeGNlcHRpb24gPSBmdW5jdGlvbiBFeGNlcHRpb24gKCkge307XG5cbnZhciBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChFeGNlcHRpb24kJDEpIHtcbiAgZnVuY3Rpb24gTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbiAoKSB7XG4gICAgRXhjZXB0aW9uJCQxLmNhbGwodGhpcywgJ1Byb2plY3RpdmUgcG9pbnQgbm90IHJlcHJlc2VudGFibGUgb24gdGhlIENhcnRlc2lhbiBwbGFuZS4nKTtcbiAgfVxuXG4gIGlmICggRXhjZXB0aW9uJCQxICkgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbi5fX3Byb3RvX18gPSBFeGNlcHRpb24kJDE7XG4gIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRXhjZXB0aW9uJCQxICYmIEV4Y2VwdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uO1xuICBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb25cbiAgfTtcblxuICByZXR1cm4gTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbjtcbn0oRXhjZXB0aW9uKSk7XG5cbnZhciBTeXN0ZW0gPSBmdW5jdGlvbiBTeXN0ZW0gKCkge307XG5cblN5c3RlbS5hcnJheWNvcHkgPSBmdW5jdGlvbiBhcnJheWNvcHkgKHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW4pIHtcbiAgdmFyIGMgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUG9zOyBpIDwgc3JjUG9zICsgbGVuOyBpKyspIHtcbiAgICBkZXN0W2Rlc3RQb3MgKyBjXSA9IHNyY1tpXTtcbiAgICBjKys7XG4gIH1cbn07XG5cblN5c3RlbS5nZXRQcm9wZXJ0eSA9IGZ1bmN0aW9uIGdldFByb3BlcnR5IChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgJ2xpbmUuc2VwYXJhdG9yJzogJ1xcbidcbiAgfVtuYW1lXVxufTtcblxudmFyIEhDb29yZGluYXRlID0gZnVuY3Rpb24gSENvb3JkaW5hdGUgKCkge1xuICB0aGlzLnggPSBudWxsO1xuICB0aGlzLnkgPSBudWxsO1xuICB0aGlzLncgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMueCA9IDAuMDtcbiAgICB0aGlzLnkgPSAwLjA7XG4gICAgdGhpcy53ID0gMS4wO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnggPSBwLng7XG4gICAgdGhpcy55ID0gcC55O1xuICAgIHRoaXMudyA9IDEuMDtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgX3ggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgX3kgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnggPSBfeDtcbiAgICAgIHRoaXMueSA9IF95O1xuICAgICAgdGhpcy53ID0gMS4wO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgSENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgSENvb3JkaW5hdGUpIHtcbiAgICAgIHZhciBwMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwMiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMueCA9IHAxLnkgKiBwMi53IC0gcDIueSAqIHAxLnc7XG4gICAgICB0aGlzLnkgPSBwMi54ICogcDEudyAtIHAxLnggKiBwMi53O1xuICAgICAgdGhpcy53ID0gcDEueCAqIHAyLnkgLSBwMi54ICogcDEueTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAxJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcDIkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMueCA9IHAxJDEueSAtIHAyJDEueTtcbiAgICAgIHRoaXMueSA9IHAyJDEueCAtIHAxJDEueDtcbiAgICAgIHRoaXMudyA9IHAxJDEueCAqIHAyJDEueSAtIHAyJDEueCAqIHAxJDEueTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBfeCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBfeSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBfdyA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLnggPSBfeCQxO1xuICAgIHRoaXMueSA9IF95JDE7XG4gICAgdGhpcy53ID0gX3c7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBwMSQyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMiQyID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBxMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgcTIgPSBhcmd1bWVudHNbM107XG4gICAgdmFyIHB4ID0gcDEkMi55IC0gcDIkMi55O1xuICAgIHZhciBweSA9IHAyJDIueCAtIHAxJDIueDtcbiAgICB2YXIgcHcgPSBwMSQyLnggKiBwMiQyLnkgLSBwMiQyLnggKiBwMSQyLnk7XG4gICAgdmFyIHF4ID0gcTEueSAtIHEyLnk7XG4gICAgdmFyIHF5ID0gcTIueCAtIHExLng7XG4gICAgdmFyIHF3ID0gcTEueCAqIHEyLnkgLSBxMi54ICogcTEueTtcbiAgICB0aGlzLnggPSBweSAqIHF3IC0gcXkgKiBwdztcbiAgICB0aGlzLnkgPSBxeCAqIHB3IC0gcHggKiBxdztcbiAgICB0aGlzLncgPSBweCAqIHF5IC0gcXggKiBweTtcbiAgfVxufTtcbkhDb29yZGluYXRlLnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSAoKSB7XG4gIHZhciBhID0gdGhpcy55IC8gdGhpcy53O1xuICBpZiAoRG91YmxlLmlzTmFOKGEpIHx8IERvdWJsZS5pc0luZmluaXRlKGEpKSB7XG4gICAgdGhyb3cgbmV3IE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24oKVxuICB9XG4gIHJldHVybiBhXG59O1xuSENvb3JkaW5hdGUucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYICgpIHtcbiAgdmFyIGEgPSB0aGlzLnggLyB0aGlzLnc7XG4gIGlmIChEb3VibGUuaXNOYU4oYSkgfHwgRG91YmxlLmlzSW5maW5pdGUoYSkpIHtcbiAgICB0aHJvdyBuZXcgTm90UmVwcmVzZW50YWJsZUV4Y2VwdGlvbigpXG4gIH1cbiAgcmV0dXJuIGFcbn07XG5IQ29vcmRpbmF0ZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICB2YXIgcCA9IG5ldyBDb29yZGluYXRlKCk7XG4gIHAueCA9IHRoaXMuZ2V0WCgpO1xuICBwLnkgPSB0aGlzLmdldFkoKTtcbiAgcmV0dXJuIHBcbn07XG5IQ29vcmRpbmF0ZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkhDb29yZGluYXRlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEhDb29yZGluYXRlXG59O1xuSENvb3JkaW5hdGUuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChwMSwgcDIsIHExLCBxMikge1xuICB2YXIgcHggPSBwMS55IC0gcDIueTtcbiAgdmFyIHB5ID0gcDIueCAtIHAxLng7XG4gIHZhciBwdyA9IHAxLnggKiBwMi55IC0gcDIueCAqIHAxLnk7XG4gIHZhciBxeCA9IHExLnkgLSBxMi55O1xuICB2YXIgcXkgPSBxMi54IC0gcTEueDtcbiAgdmFyIHF3ID0gcTEueCAqIHEyLnkgLSBxMi54ICogcTEueTtcbiAgdmFyIHggPSBweSAqIHF3IC0gcXkgKiBwdztcbiAgdmFyIHkgPSBxeCAqIHB3IC0gcHggKiBxdztcbiAgdmFyIHcgPSBweCAqIHF5IC0gcXggKiBweTtcbiAgdmFyIHhJbnQgPSB4IC8gdztcbiAgdmFyIHlJbnQgPSB5IC8gdztcbiAgaWYgKERvdWJsZS5pc05hTih4SW50KSB8fCAoRG91YmxlLmlzSW5maW5pdGUoeEludCkgfHwgRG91YmxlLmlzTmFOKHlJbnQpKSB8fCBEb3VibGUuaXNJbmZpbml0ZSh5SW50KSkge1xuICAgIHRocm93IG5ldyBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKClcbiAgfVxuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoeEludCwgeUludClcbn07XG5cbnZhciBFbnZlbG9wZSA9IGZ1bmN0aW9uIEVudmVsb3BlICgpIHtcbiAgdGhpcy5fbWlueCA9IG51bGw7XG4gIHRoaXMuX21heHggPSBudWxsO1xuICB0aGlzLl9taW55ID0gbnVsbDtcbiAgdGhpcy5fbWF4eSA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdChwLngsIHAueCwgcC55LCBwLnkpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRW52ZWxvcGUpIHtcbiAgICAgIHZhciBlbnYgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQoZW52KTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDIgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5pbml0KHAxLngsIHAyLngsIHAxLnksIHAyLnkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgeDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHgyID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB5MSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgeTIgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5pbml0KHgxLCB4MiwgeTEsIHkyKTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ5ID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5FbnZlbG9wZS5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uIGdldEFyZWEgKCkge1xuICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpICogdGhpcy5nZXRIZWlnaHQoKVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKG90aGVyKSB7XG4gIGlmICghKG90aGVyIGluc3RhbmNlb2YgRW52ZWxvcGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdmFyIG90aGVyRW52ZWxvcGUgPSBvdGhlcjtcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICByZXR1cm4gb3RoZXJFbnZlbG9wZS5pc051bGwoKVxuICB9XG4gIHJldHVybiB0aGlzLl9tYXh4ID09PSBvdGhlckVudmVsb3BlLmdldE1heFgoKSAmJiB0aGlzLl9tYXh5ID09PSBvdGhlckVudmVsb3BlLmdldE1heFkoKSAmJiB0aGlzLl9taW54ID09PSBvdGhlckVudmVsb3BlLmdldE1pblgoKSAmJiB0aGlzLl9taW55ID09PSBvdGhlckVudmVsb3BlLmdldE1pblkoKVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKGVudikge1xuICBpZiAodGhpcy5pc051bGwoKSB8fCBlbnYuaXNOdWxsKCkgfHwgIXRoaXMuaW50ZXJzZWN0cyhlbnYpKSB7IHJldHVybiBuZXcgRW52ZWxvcGUoKSB9XG4gIHZhciBpbnRNaW5YID0gdGhpcy5fbWlueCA+IGVudi5fbWlueCA/IHRoaXMuX21pbnggOiBlbnYuX21pbng7XG4gIHZhciBpbnRNaW5ZID0gdGhpcy5fbWlueSA+IGVudi5fbWlueSA/IHRoaXMuX21pbnkgOiBlbnYuX21pbnk7XG4gIHZhciBpbnRNYXhYID0gdGhpcy5fbWF4eCA8IGVudi5fbWF4eCA/IHRoaXMuX21heHggOiBlbnYuX21heHg7XG4gIHZhciBpbnRNYXhZID0gdGhpcy5fbWF4eSA8IGVudi5fbWF4eSA/IHRoaXMuX21heHkgOiBlbnYuX21heHk7XG4gIHJldHVybiBuZXcgRW52ZWxvcGUoaW50TWluWCwgaW50TWF4WCwgaW50TWluWSwgaW50TWF4WSlcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuaXNOdWxsID0gZnVuY3Rpb24gaXNOdWxsICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heHggPCB0aGlzLl9taW54XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldE1heFggPSBmdW5jdGlvbiBnZXRNYXhYICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heHhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuY292ZXJzID0gZnVuY3Rpb24gY292ZXJzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jb3ZlcnMocC54LCBwLnkpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbnZlbG9wZSkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKHRoaXMuaXNOdWxsKCkgfHwgb3RoZXIuaXNOdWxsKCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gb3RoZXIuZ2V0TWluWCgpID49IHRoaXMuX21pbnggJiYgb3RoZXIuZ2V0TWF4WCgpIDw9IHRoaXMuX21heHggJiYgb3RoZXIuZ2V0TWluWSgpID49IHRoaXMuX21pbnkgJiYgb3RoZXIuZ2V0TWF4WSgpIDw9IHRoaXMuX21heHlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciB4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciB5ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIHggPj0gdGhpcy5fbWlueCAmJiB4IDw9IHRoaXMuX21heHggJiYgeSA+PSB0aGlzLl9taW55ICYmIHkgPD0gdGhpcy5fbWF4eVxuICB9XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiBpbnRlcnNlY3RzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgRW52ZWxvcGUpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLmlzTnVsbCgpIHx8IG90aGVyLmlzTnVsbCgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuICEob3RoZXIuX21pbnggPiB0aGlzLl9tYXh4IHx8IG90aGVyLl9tYXh4IDwgdGhpcy5fbWlueCB8fCBvdGhlci5fbWlueSA+IHRoaXMuX21heHkgfHwgb3RoZXIuX21heHkgPCB0aGlzLl9taW55KVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHAueCwgcC55KVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuaXNOdWxsKCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gISh4ID4gdGhpcy5fbWF4eCB8fCB4IDwgdGhpcy5fbWlueCB8fCB5ID4gdGhpcy5fbWF4eSB8fCB5IDwgdGhpcy5fbWlueSlcbiAgfVxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRNaW5ZID0gZnVuY3Rpb24gZ2V0TWluWSAoKSB7XG4gIHJldHVybiB0aGlzLl9taW55XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldE1pblggPSBmdW5jdGlvbiBnZXRNaW5YICgpIHtcbiAgcmV0dXJuIHRoaXMuX21pbnhcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZXhwYW5kVG9JbmNsdWRlID0gZnVuY3Rpb24gZXhwYW5kVG9JbmNsdWRlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmV4cGFuZFRvSW5jbHVkZShwLngsIHAueSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBFbnZlbG9wZSkge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKG90aGVyLmlzTnVsbCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgICAgICB0aGlzLl9taW54ID0gb3RoZXIuZ2V0TWluWCgpO1xuICAgICAgICB0aGlzLl9tYXh4ID0gb3RoZXIuZ2V0TWF4WCgpO1xuICAgICAgICB0aGlzLl9taW55ID0gb3RoZXIuZ2V0TWluWSgpO1xuICAgICAgICB0aGlzLl9tYXh5ID0gb3RoZXIuZ2V0TWF4WSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG90aGVyLl9taW54IDwgdGhpcy5fbWlueCkge1xuICAgICAgICAgIHRoaXMuX21pbnggPSBvdGhlci5fbWlueDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIuX21heHggPiB0aGlzLl9tYXh4KSB7XG4gICAgICAgICAgdGhpcy5fbWF4eCA9IG90aGVyLl9tYXh4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvdGhlci5fbWlueSA8IHRoaXMuX21pbnkpIHtcbiAgICAgICAgICB0aGlzLl9taW55ID0gb3RoZXIuX21pbnk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG90aGVyLl9tYXh5ID4gdGhpcy5fbWF4eSkge1xuICAgICAgICAgIHRoaXMuX21heHkgPSBvdGhlci5fbWF4eTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICAgIHRoaXMuX21pbnggPSB4O1xuICAgICAgdGhpcy5fbWF4eCA9IHg7XG4gICAgICB0aGlzLl9taW55ID0geTtcbiAgICAgIHRoaXMuX21heHkgPSB5O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeCA8IHRoaXMuX21pbngpIHtcbiAgICAgICAgdGhpcy5fbWlueCA9IHg7XG4gICAgICB9XG4gICAgICBpZiAoeCA+IHRoaXMuX21heHgpIHtcbiAgICAgICAgdGhpcy5fbWF4eCA9IHg7XG4gICAgICB9XG4gICAgICBpZiAoeSA8IHRoaXMuX21pbnkpIHtcbiAgICAgICAgdGhpcy5fbWlueSA9IHk7XG4gICAgICB9XG4gICAgICBpZiAoeSA+IHRoaXMuX21heHkpIHtcbiAgICAgICAgdGhpcy5fbWF4eSA9IHk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLm1pbkV4dGVudCA9IGZ1bmN0aW9uIG1pbkV4dGVudCAoKSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiAwLjAgfVxuICB2YXIgdyA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgdmFyIGggPSB0aGlzLmdldEhlaWdodCgpO1xuICBpZiAodyA8IGgpIHsgcmV0dXJuIHcgfVxuICByZXR1cm4gaFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIGdldFdpZHRoICgpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIHJldHVybiB0aGlzLl9tYXh4IC0gdGhpcy5fbWlueFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8pIHtcbiAgdmFyIGVudiA9IG87XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgaWYgKGVudi5pc051bGwoKSkgeyByZXR1cm4gMCB9XG4gICAgcmV0dXJuIC0xXG4gIH0gZWxzZSB7XG4gICAgaWYgKGVudi5pc051bGwoKSkgeyByZXR1cm4gMSB9XG4gIH1cbiAgaWYgKHRoaXMuX21pbnggPCBlbnYuX21pbngpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX21pbnggPiBlbnYuX21pbngpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5fbWlueSA8IGVudi5fbWlueSkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fbWlueSA+IGVudi5fbWlueSkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9tYXh4IDwgZW52Ll9tYXh4KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl9tYXh4ID4gZW52Ll9tYXh4KSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX21heHkgPCBlbnYuX21heHkpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX21heHkgPiBlbnYuX21heHkpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUgKHRyYW5zWCwgdHJhbnNZKSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB0aGlzLmluaXQodGhpcy5nZXRNaW5YKCkgKyB0cmFuc1gsIHRoaXMuZ2V0TWF4WCgpICsgdHJhbnNYLCB0aGlzLmdldE1pblkoKSArIHRyYW5zWSwgdGhpcy5nZXRNYXhZKCkgKyB0cmFuc1kpO1xufTtcbkVudmVsb3BlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuICdFbnZbJyArIHRoaXMuX21pbnggKyAnIDogJyArIHRoaXMuX21heHggKyAnLCAnICsgdGhpcy5fbWlueSArICcgOiAnICsgdGhpcy5fbWF4eSArICddJ1xufTtcbkVudmVsb3BlLnByb3RvdHlwZS5zZXRUb051bGwgPSBmdW5jdGlvbiBzZXRUb051bGwgKCkge1xuICB0aGlzLl9taW54ID0gMDtcbiAgdGhpcy5fbWF4eCA9IC0xO1xuICB0aGlzLl9taW55ID0gMDtcbiAgdGhpcy5fbWF4eSA9IC0xO1xufTtcbkVudmVsb3BlLnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbiBnZXRIZWlnaHQgKCkge1xuICBpZiAodGhpcy5pc051bGwoKSkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgcmV0dXJuIHRoaXMuX21heHkgLSB0aGlzLl9taW55XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLm1heEV4dGVudCA9IGZ1bmN0aW9uIG1heEV4dGVudCAoKSB7XG4gIGlmICh0aGlzLmlzTnVsbCgpKSB7IHJldHVybiAwLjAgfVxuICB2YXIgdyA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgdmFyIGggPSB0aGlzLmdldEhlaWdodCgpO1xuICBpZiAodyA+IGgpIHsgcmV0dXJuIHcgfVxuICByZXR1cm4gaFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5leHBhbmRCeSA9IGZ1bmN0aW9uIGV4cGFuZEJ5ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZGlzdGFuY2UgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5leHBhbmRCeShkaXN0YW5jZSwgZGlzdGFuY2UpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZGVsdGFYID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkZWx0YVkgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuaXNOdWxsKCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHRoaXMuX21pbnggLT0gZGVsdGFYO1xuICAgIHRoaXMuX21heHggKz0gZGVsdGFYO1xuICAgIHRoaXMuX21pbnkgLT0gZGVsdGFZO1xuICAgIHRoaXMuX21heHkgKz0gZGVsdGFZO1xuICAgIGlmICh0aGlzLl9taW54ID4gdGhpcy5fbWF4eCB8fCB0aGlzLl9taW55ID4gdGhpcy5fbWF4eSkgeyB0aGlzLnNldFRvTnVsbCgpOyB9XG4gIH1cbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVudmVsb3BlKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jb3ZlcnMob3RoZXIpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNvdmVycyhwKVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHkgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIHRoaXMuY292ZXJzKHgsIHkpXG4gIH1cbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuY2VudHJlID0gZnVuY3Rpb24gY2VudHJlICgpIHtcbiAgaWYgKHRoaXMuaXNOdWxsKCkpIHsgcmV0dXJuIG51bGwgfVxuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoKHRoaXMuZ2V0TWluWCgpICsgdGhpcy5nZXRNYXhYKCkpIC8gMi4wLCAodGhpcy5nZXRNaW5ZKCkgKyB0aGlzLmdldE1heFkoKSkgLyAyLjApXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiBpbml0ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLnNldFRvTnVsbCgpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQocC54LCBwLngsIHAueSwgcC55KTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEVudmVsb3BlKSB7XG4gICAgICB2YXIgZW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5fbWlueCA9IGVudi5fbWlueDtcbiAgICAgIHRoaXMuX21heHggPSBlbnYuX21heHg7XG4gICAgICB0aGlzLl9taW55ID0gZW52Ll9taW55O1xuICAgICAgdGhpcy5fbWF4eSA9IGVudi5fbWF4eTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDIgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5pbml0KHAxLngsIHAyLngsIHAxLnksIHAyLnkpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgeDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHgyID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB5MSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgeTIgPSBhcmd1bWVudHNbM107XG4gICAgaWYgKHgxIDwgeDIpIHtcbiAgICAgIHRoaXMuX21pbnggPSB4MTtcbiAgICAgIHRoaXMuX21heHggPSB4MjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWlueCA9IHgyO1xuICAgICAgdGhpcy5fbWF4eCA9IHgxO1xuICAgIH1cbiAgICBpZiAoeTEgPCB5Mikge1xuICAgICAgdGhpcy5fbWlueSA9IHkxO1xuICAgICAgdGhpcy5fbWF4eSA9IHkyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9taW55ID0geTI7XG4gICAgICB0aGlzLl9tYXh5ID0geTE7XG4gICAgfVxuICB9XG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldE1heFkgPSBmdW5jdGlvbiBnZXRNYXhZICgpIHtcbiAgcmV0dXJuIHRoaXMuX21heHlcbn07XG5FbnZlbG9wZS5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoZW52KSB7XG4gIGlmICh0aGlzLmludGVyc2VjdHMoZW52KSkgeyByZXR1cm4gMCB9XG4gIHZhciBkeCA9IDAuMDtcbiAgaWYgKHRoaXMuX21heHggPCBlbnYuX21pbngpIHsgZHggPSBlbnYuX21pbnggLSB0aGlzLl9tYXh4OyB9IGVsc2UgaWYgKHRoaXMuX21pbnggPiBlbnYuX21heHgpIHsgZHggPSB0aGlzLl9taW54IC0gZW52Ll9tYXh4OyB9XG4gIHZhciBkeSA9IDAuMDtcbiAgaWYgKHRoaXMuX21heHkgPCBlbnYuX21pbnkpIHsgZHkgPSBlbnYuX21pbnkgLSB0aGlzLl9tYXh5OyB9IGVsc2UgaWYgKHRoaXMuX21pbnkgPiBlbnYuX21heHkpIHsgZHkgPSB0aGlzLl9taW55IC0gZW52Ll9tYXh5OyB9XG4gIGlmIChkeCA9PT0gMC4wKSB7IHJldHVybiBkeSB9XG4gIGlmIChkeSA9PT0gMC4wKSB7IHJldHVybiBkeCB9XG4gIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmhhc2hDb2RlID0gZnVuY3Rpb24gaGFzaENvZGUgKCkge1xuICB2YXIgcmVzdWx0ID0gMTc7XG4gIHJlc3VsdCA9IDM3ICogcmVzdWx0ICsgQ29vcmRpbmF0ZS5oYXNoQ29kZSh0aGlzLl9taW54KTtcbiAgcmVzdWx0ID0gMzcgKiByZXN1bHQgKyBDb29yZGluYXRlLmhhc2hDb2RlKHRoaXMuX21heHgpO1xuICByZXN1bHQgPSAzNyAqIHJlc3VsdCArIENvb3JkaW5hdGUuaGFzaENvZGUodGhpcy5fbWlueSk7XG4gIHJlc3VsdCA9IDM3ICogcmVzdWx0ICsgQ29vcmRpbmF0ZS5oYXNoQ29kZSh0aGlzLl9tYXh5KTtcbiAgcmV0dXJuIHJlc3VsdFxufTtcbkVudmVsb3BlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlLCBTZXJpYWxpemFibGVdXG59O1xuRW52ZWxvcGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRW52ZWxvcGVcbn07XG5FbnZlbG9wZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcSA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAocS54ID49IChwMS54IDwgcDIueCA/IHAxLnggOiBwMi54KSAmJiBxLnggPD0gKHAxLnggPiBwMi54ID8gcDEueCA6IHAyLngpICYmIChxLnkgPj0gKHAxLnkgPCBwMi55ID8gcDEueSA6IHAyLnkpICYmIHEueSA8PSAocDEueSA+IHAyLnkgPyBwMS55IDogcDIueSkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIHAxJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAyJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHExID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBxMiA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgbWlucSA9IE1hdGgubWluKHExLngsIHEyLngpO1xuICAgIHZhciBtYXhxID0gTWF0aC5tYXgocTEueCwgcTIueCk7XG4gICAgdmFyIG1pbnAgPSBNYXRoLm1pbihwMSQxLngsIHAyJDEueCk7XG4gICAgdmFyIG1heHAgPSBNYXRoLm1heChwMSQxLngsIHAyJDEueCk7XG4gICAgaWYgKG1pbnAgPiBtYXhxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKG1heHAgPCBtaW5xKSB7IHJldHVybiBmYWxzZSB9XG4gICAgbWlucSA9IE1hdGgubWluKHExLnksIHEyLnkpO1xuICAgIG1heHEgPSBNYXRoLm1heChxMS55LCBxMi55KTtcbiAgICBtaW5wID0gTWF0aC5taW4ocDEkMS55LCBwMiQxLnkpO1xuICAgIG1heHAgPSBNYXRoLm1heChwMSQxLnksIHAyJDEueSk7XG4gICAgaWYgKG1pbnAgPiBtYXhxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKG1heHAgPCBtaW5xKSB7IHJldHVybiBmYWxzZSB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ5LnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNTg3MzkyMTg4NTI3MzEwMjQyMCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggRW52ZWxvcGUsIHN0YXRpY0FjY2Vzc29ycyQ5ICk7XG5cbnZhciByZWdFeGVzID0ge1xuICAndHlwZVN0cic6IC9eXFxzKihcXHcrKVxccypcXChcXHMqKC4qKVxccypcXClcXHMqJC8sXG4gICdlbXB0eVR5cGVTdHInOiAvXlxccyooXFx3KylcXHMqRU1QVFlcXHMqJC8sXG4gICdzcGFjZXMnOiAvXFxzKy8sXG4gICdwYXJlbkNvbW1hJzogL1xcKVxccyosXFxzKlxcKC8sXG4gICdkb3VibGVQYXJlbkNvbW1hJzogL1xcKVxccypcXClcXHMqLFxccypcXChcXHMqXFwoLywgLy8gY2FuJ3QgdXNlIHsyfSBoZXJlXG4gICd0cmltUGFyZW5zJzogL15cXHMqXFwoPyguKj8pXFwpP1xccyokL1xufTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVhZGluZyBhbmQgd3JpdGluZyBXZWxsLUtub3duIFRleHQuXG4gKlxuICogTk9URTogQWRhcHRlZCBmcm9tIE9wZW5MYXllcnMgMi4xMSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuXG4vKiogQ3JlYXRlIGEgbmV3IHBhcnNlciBmb3IgV0tUXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeUZhY3Rvcnl9IGdlb21ldHJ5RmFjdG9yeVxuICogQHJldHVybiBBbiBpbnN0YW5jZSBvZiBXS1RQYXJzZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBXS1RQYXJzZXIgPSBmdW5jdGlvbiBXS1RQYXJzZXIgKGdlb21ldHJ5RmFjdG9yeSkge1xuICB0aGlzLmdlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeSB8fCBuZXcgR2VvbWV0cnlGYWN0b3J5KCk7XG59O1xuLyoqXG4gKiBEZXNlcmlhbGl6ZSBhIFdLVCBzdHJpbmcgYW5kIHJldHVybiBhIGdlb21ldHJ5LiBTdXBwb3J0cyBXS1QgZm9yIFBPSU5ULFxuICogTVVMVElQT0lOVCwgTElORVNUUklORywgTElORUFSUklORywgTVVMVElMSU5FU1RSSU5HLCBQT0xZR09OLCBNVUxUSVBPTFlHT04sXG4gKiBhbmQgR0VPTUVUUllDT0xMRUNUSU9OLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB3a3QgQSBXS1Qgc3RyaW5nLlxuICogQHJldHVybiB7R2VvbWV0cnl9IEEgZ2VvbWV0cnkgaW5zdGFuY2UuXG4gKiBAcHJpdmF0ZVxuICovXG5XS1RQYXJzZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiByZWFkICh3a3QpIHtcbiAgdmFyIGdlb21ldHJ5LCB0eXBlLCBzdHI7XG4gIHdrdCA9IHdrdC5yZXBsYWNlKC9bXFxuXFxyXS9nLCAnICcpO1xuICB2YXIgbWF0Y2hlcyA9IHJlZ0V4ZXMudHlwZVN0ci5leGVjKHdrdCk7XG4gIGlmICh3a3Quc2VhcmNoKCdFTVBUWScpICE9PSAtMSkge1xuICAgIG1hdGNoZXMgPSByZWdFeGVzLmVtcHR5VHlwZVN0ci5leGVjKHdrdCk7XG4gICAgbWF0Y2hlc1syXSA9IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAobWF0Y2hlcykge1xuICAgIHR5cGUgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgc3RyID0gbWF0Y2hlc1syXTtcbiAgICBpZiAocGFyc2UkMVt0eXBlXSkge1xuICAgICAgZ2VvbWV0cnkgPSBwYXJzZSQxW3R5cGVdLmFwcGx5KHRoaXMsIFtzdHJdKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZ2VvbWV0cnkgPT09IHVuZGVmaW5lZCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBwYXJzZSBXS1QgJyArIHdrdCkgfVxuXG4gIHJldHVybiBnZW9tZXRyeVxufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYSBnZW9tZXRyeSBpbnRvIGEgV0tUIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeSBBIGZlYXR1cmUgb3IgYXJyYXkgb2YgZmVhdHVyZXMuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSBXS1Qgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dCBnZW9tZXRyaWVzLlxuICogQHByaXZhdGVcbiAqL1xuV0tUUGFyc2VyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChnZW9tZXRyeSkge1xuICByZXR1cm4gdGhpcy5leHRyYWN0R2VvbWV0cnkoZ2VvbWV0cnkpXG59O1xuXG4vKipcbiAqIEVudHJ5IHBvaW50IHRvIGNvbnN0cnVjdCB0aGUgV0tUIGZvciBhIHNpbmdsZSBHZW9tZXRyeSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnlcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBXS1Qgc3RyaW5nIG9mIHJlcHJlc2VudGluZyB0aGUgZ2VvbWV0cnkuXG4gKiBAcHJpdmF0ZVxuICovXG5XS1RQYXJzZXIucHJvdG90eXBlLmV4dHJhY3RHZW9tZXRyeSA9IGZ1bmN0aW9uIGV4dHJhY3RHZW9tZXRyeSAoZ2VvbWV0cnkpIHtcbiAgdmFyIHR5cGUgPSBnZW9tZXRyeS5nZXRHZW9tZXRyeVR5cGUoKS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIWV4dHJhY3QkMVt0eXBlXSkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIHdrdFR5cGUgPSB0eXBlLnRvVXBwZXJDYXNlKCk7XG4gIHZhciBkYXRhO1xuICBpZiAoZ2VvbWV0cnkuaXNFbXB0eSgpKSB7XG4gICAgZGF0YSA9IHdrdFR5cGUgKyAnIEVNUFRZJztcbiAgfSBlbHNlIHtcbiAgICBkYXRhID0gd2t0VHlwZSArICcoJyArIGV4dHJhY3QkMVt0eXBlXS5hcHBseSh0aGlzLCBbZ2VvbWV0cnldKSArICcpJztcbiAgfVxuICByZXR1cm4gZGF0YVxufTtcblxuLyoqXG4gKiBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdlb21ldHJ5IHR5cGVzLiBQcm9wZXJ0eSB2YWx1ZXNcbiAqIGFyZSBmdW5jdGlvbnMgdGhhdCBkbyB0aGUgYWN0dWFsIGRhdGEgZXh0cmFjdGlvbi5cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBleHRyYWN0JDEgPSB7XG4gIGNvb3JkaW5hdGU6IGZ1bmN0aW9uIGNvb3JkaW5hdGUgKGNvb3JkaW5hdGUkMSkge1xuICAgIHJldHVybiBjb29yZGluYXRlJDEueCArICcgJyArIGNvb3JkaW5hdGUkMS55XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIHNwYWNlIGRlbGltaXRlZCBzdHJpbmcgb2YgcG9pbnQgY29vcmRpbmF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9pbnR9XG4gICAqICAgICAgICAgIHBvaW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgb2YgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIHRoZSBwb2ludC5cbiAgICovXG4gIHBvaW50OiBmdW5jdGlvbiBwb2ludCAocG9pbnQkMSkge1xuICAgIHJldHVybiBleHRyYWN0JDEuY29vcmRpbmF0ZS5jYWxsKHRoaXMsIHBvaW50JDEuX2Nvb3JkaW5hdGVzLl9jb29yZGluYXRlc1swXSlcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZyBvZiBwb2ludCBjb29yZGluYXRlcyBmcm9tIGEgbXVsdGlwb2ludC5cbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aVBvaW50fVxuICAgKiAgICAgICAgICBtdWx0aXBvaW50XG4gICAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgb2YgcG9pbnQgY29vcmRpbmF0ZSBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGVcbiAgICogICAgICAgICBtdWx0aXBvaW50LlxuICAgKi9cbiAgbXVsdGlwb2ludDogZnVuY3Rpb24gbXVsdGlwb2ludCAobXVsdGlwb2ludCQxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbXVsdGlwb2ludCQxLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBhcnJheS5wdXNoKCcoJyArIGV4dHJhY3QkMS5wb2ludC5hcHBseSh0aGlzJDEsIFttdWx0aXBvaW50JDEuX2dlb21ldHJpZXNbaV1dKSArICcpJyk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgY29tbWEgZGVsaW1pdGVkIHN0cmluZyBvZiBwb2ludCBjb29yZGluYXRlcyBmcm9tIGEgbGluZS5cbiAgICpcbiAgICogQHBhcmFtIHtMaW5lU3RyaW5nfSBsaW5lc3RyaW5nXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgb2YgcG9pbnQgY29vcmRpbmF0ZSBzdHJpbmdzIHJlcHJlc2VudGluZyB0aGUgbGluZXN0cmluZy5cbiAgICovXG4gIGxpbmVzdHJpbmc6IGZ1bmN0aW9uIGxpbmVzdHJpbmcgKGxpbmVzdHJpbmckMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzdHJpbmckMS5fcG9pbnRzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXJyYXkucHVzaChleHRyYWN0JDEuY29vcmRpbmF0ZS5hcHBseSh0aGlzJDEsIFtsaW5lc3RyaW5nJDEuX3BvaW50cy5fY29vcmRpbmF0ZXNbaV1dKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfSxcblxuICBsaW5lYXJyaW5nOiBmdW5jdGlvbiBsaW5lYXJyaW5nIChsaW5lYXJyaW5nJDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBsaW5lYXJyaW5nJDEuX3BvaW50cy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2goZXh0cmFjdCQxLmNvb3JkaW5hdGUuYXBwbHkodGhpcyQxLCBbbGluZWFycmluZyQxLl9wb2ludHMuX2Nvb3JkaW5hdGVzW2ldXSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGNvbW1hIGRlbGltaXRlZCBzdHJpbmcgb2YgbGluZXN0cmluZyBzdHJpbmdzIGZyb20gYVxuICAgKiBtdWx0aWxpbmVzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlMaW5lU3RyaW5nfSBtdWx0aWxpbmVzdHJpbmdcbiAgICogQHJldHVybiB7U3RyaW5nfSBBIHN0cmluZyBvZiBvZiBsaW5lc3RyaW5nIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBtdWx0aWxpbmVzdHJpbmcuXG4gICAqL1xuICBtdWx0aWxpbmVzdHJpbmc6IGZ1bmN0aW9uIG11bHRpbGluZXN0cmluZyAobXVsdGlsaW5lc3RyaW5nJDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtdWx0aWxpbmVzdHJpbmckMS5fZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXJyYXkucHVzaCgnKCcgK1xuICAgICAgICBleHRyYWN0JDEubGluZXN0cmluZy5hcHBseSh0aGlzJDEsIFttdWx0aWxpbmVzdHJpbmckMS5fZ2VvbWV0cmllc1tpXV0pICtcbiAgICAgICAgJyknKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBjb21tYSBkZWxpbWl0ZWQgc3RyaW5nIG9mIGxpbmVhciByaW5nIGFycmF5cyBmcm9tIGEgcG9seWdvbi5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5Z29ufSBwb2x5Z29uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQW4gYXJyYXkgb2YgbGluZWFyIHJpbmcgYXJyYXlzIHJlcHJlc2VudGluZyB0aGUgcG9seWdvbi5cbiAgICovXG4gIHBvbHlnb246IGZ1bmN0aW9uIHBvbHlnb24gKHBvbHlnb24kMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgYXJyYXkucHVzaCgnKCcgKyBleHRyYWN0JDEubGluZXN0cmluZy5hcHBseSh0aGlzLCBbcG9seWdvbiQxLl9zaGVsbF0pICsgJyknKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9seWdvbiQxLl9ob2xlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXJyYXkucHVzaCgnKCcgKyBleHRyYWN0JDEubGluZXN0cmluZy5hcHBseSh0aGlzJDEsIFtwb2x5Z29uJDEuX2hvbGVzW2ldXSkgKyAnKScpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXkuam9pbignLCcpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBhcnJheSBvZiBwb2x5Z29uIGFycmF5cyBmcm9tIGEgbXVsdGlwb2x5Z29uLlxuICAgKlxuICAgKiBAcGFyYW0ge011bHRpUG9seWdvbn0gbXVsdGlwb2x5Z29uXG4gICAqIEByZXR1cm4ge1N0cmluZ30gQW4gYXJyYXkgb2YgcG9seWdvbiBhcnJheXMgcmVwcmVzZW50aW5nIHRoZSBtdWx0aXBvbHlnb24uXG4gICAqL1xuICBtdWx0aXBvbHlnb246IGZ1bmN0aW9uIG11bHRpcG9seWdvbiAobXVsdGlwb2x5Z29uJDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBtdWx0aXBvbHlnb24kMS5fZ2VvbWV0cmllcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgYXJyYXkucHVzaCgnKCcgKyBleHRyYWN0JDEucG9seWdvbi5hcHBseSh0aGlzJDEsIFttdWx0aXBvbHlnb24kMS5fZ2VvbWV0cmllc1tpXV0pICsgJyknKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5LmpvaW4oJywnKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIFdLVCBwb3J0aW9uIGJldHdlZW4gJ0dFT01FVFJZQ09MTEVDVElPTignIGFuZCAnKScgZm9yIGFuXG4gICAqIGdlb21ldHJ5Y29sbGVjdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtHZW9tZXRyeUNvbGxlY3Rpb259IGNvbGxlY3Rpb25cbiAgICogQHJldHVybiB7U3RyaW5nfSBpbnRlcm5hbCBXS1QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqL1xuICBnZW9tZXRyeWNvbGxlY3Rpb246IGZ1bmN0aW9uIGdlb21ldHJ5Y29sbGVjdGlvbiAoY29sbGVjdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbGxlY3Rpb24uX2dlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGFycmF5LnB1c2godGhpcyQxLmV4dHJhY3RHZW9tZXRyeShjb2xsZWN0aW9uLl9nZW9tZXRyaWVzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBhcnJheS5qb2luKCcsJylcbiAgfVxufTtcblxuLyoqXG4gKiBPYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdlb21ldHJ5IHR5cGVzLiBQcm9wZXJ0eSB2YWx1ZXNcbiAqIGFyZSBmdW5jdGlvbnMgdGhhdCBkbyB0aGUgYWN0dWFsIHBhcnNpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgcGFyc2UkMSA9IHtcbiAgLyoqXG4gICAqIFJldHVybiBwb2ludCBnZW9tZXRyeSBnaXZlbiBhIHBvaW50IFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIHBvaW50LlxuICAgKiBAcmV0dXJuIHtQb2ludH0gQSBwb2ludCBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHBvaW50OiBmdW5jdGlvbiBwb2ludCAoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoKVxuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBzdHIudHJpbSgpLnNwbGl0KHJlZ0V4ZXMuc3BhY2VzKTtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQobmV3IENvb3JkaW5hdGUoTnVtYmVyLnBhcnNlRmxvYXQoY29vcmRzWzBdKSxcbiAgICAgIE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1sxXSkpKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtdWx0aXBvaW50IGdlb21ldHJ5IGdpdmVuIGEgbXVsdGlwb2ludCBXS1QgZnJhZ21lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgQSBXS1QgZnJhZ21lbnQgcmVwcmVzZW50aW5nIHRoZSBtdWx0aXBvaW50LlxuICAgKiBAcmV0dXJuIHtQb2ludH0gQSBtdWx0aXBvaW50IGZlYXR1cmUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtdWx0aXBvaW50OiBmdW5jdGlvbiBtdWx0aXBvaW50IChzdHIpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoKVxuICAgIH1cblxuICAgIHZhciBwb2ludDtcbiAgICB2YXIgcG9pbnRzID0gc3RyLnRyaW0oKS5zcGxpdCgnLCcpO1xuICAgIHZhciBjb21wb25lbnRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgcG9pbnQgPSBwb2ludHNbaV0ucmVwbGFjZShyZWdFeGVzLnRyaW1QYXJlbnMsICckMScpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKHBhcnNlJDEucG9pbnQuYXBwbHkodGhpcyQxLCBbcG9pbnRdKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGNvbXBvbmVudHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiBhIGxpbmVzdHJpbmcgZ2VvbWV0cnkgZ2l2ZW4gYSBsaW5lc3RyaW5nIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIGxpbmVzdHJpbmcuXG4gICAqIEByZXR1cm4ge0xpbmVTdHJpbmd9IEEgbGluZXN0cmluZyBnZW9tZXRyeS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGxpbmVzdHJpbmc6IGZ1bmN0aW9uIGxpbmVzdHJpbmcgKHN0cikge1xuICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoKVxuICAgIH1cblxuICAgIHZhciBwb2ludHMgPSBzdHIudHJpbSgpLnNwbGl0KCcsJyk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICB2YXIgY29vcmRzO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNvb3JkcyA9IHBvaW50c1tpXS50cmltKCkuc3BsaXQocmVnRXhlcy5zcGFjZXMpO1xuICAgICAgY29tcG9uZW50cy5wdXNoKG5ldyBDb29yZGluYXRlKE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1swXSksIE51bWJlci5wYXJzZUZsb2F0KGNvb3Jkc1sxXSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoY29tcG9uZW50cylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgbGluZWFycmluZyBnZW9tZXRyeSBnaXZlbiBhIGxpbmVhcnJpbmcgV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgbGluZWFycmluZy5cbiAgICogQHJldHVybiB7TGluZWFyUmluZ30gQSBsaW5lYXJyaW5nIGdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbGluZWFycmluZzogZnVuY3Rpb24gbGluZWFycmluZyAoc3RyKSB7XG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZygpXG4gICAgfVxuXG4gICAgdmFyIHBvaW50cyA9IHN0ci50cmltKCkuc3BsaXQoJywnKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIHZhciBjb29yZHM7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29vcmRzID0gcG9pbnRzW2ldLnRyaW0oKS5zcGxpdChyZWdFeGVzLnNwYWNlcyk7XG4gICAgICBjb21wb25lbnRzLnB1c2gobmV3IENvb3JkaW5hdGUoTnVtYmVyLnBhcnNlRmxvYXQoY29vcmRzWzBdKSwgTnVtYmVyLnBhcnNlRmxvYXQoY29vcmRzWzFdKSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhjb21wb25lbnRzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtdWx0aWxpbmVzdHJpbmcgZ2VvbWV0cnkgZ2l2ZW4gYSBtdWx0aWxpbmVzdHJpbmcgV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgbXVsdGlsaW5lc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtNdWx0aUxpbmVTdHJpbmd9IEEgbXVsdGlsaW5lc3RyaW5nIGdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbXVsdGlsaW5lc3RyaW5nOiBmdW5jdGlvbiBtdWx0aWxpbmVzdHJpbmcgKHN0cikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKClcbiAgICB9XG5cbiAgICB2YXIgbGluZTtcbiAgICB2YXIgbGluZXMgPSBzdHIudHJpbSgpLnNwbGl0KHJlZ0V4ZXMucGFyZW5Db21tYSk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGxpbmUgPSBsaW5lc1tpXS5yZXBsYWNlKHJlZ0V4ZXMudHJpbVBhcmVucywgJyQxJyk7XG4gICAgICBjb21wb25lbnRzLnB1c2gocGFyc2UkMS5saW5lc3RyaW5nLmFwcGx5KHRoaXMkMSwgW2xpbmVdKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoY29tcG9uZW50cylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgcG9seWdvbiBnZW9tZXRyeSBnaXZlbiBhIHBvbHlnb24gV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgcG9seWdvbi5cbiAgICogQHJldHVybiB7UG9seWdvbn0gQSBwb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcG9seWdvbjogZnVuY3Rpb24gcG9seWdvbiAoc3RyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKClcbiAgICB9XG5cbiAgICB2YXIgcmluZywgbGluZXN0cmluZywgbGluZWFycmluZztcbiAgICB2YXIgcmluZ3MgPSBzdHIudHJpbSgpLnNwbGl0KHJlZ0V4ZXMucGFyZW5Db21tYSk7XG4gICAgdmFyIHNoZWxsO1xuICAgIHZhciBob2xlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSByaW5ncy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgcmluZyA9IHJpbmdzW2ldLnJlcGxhY2UocmVnRXhlcy50cmltUGFyZW5zLCAnJDEnKTtcbiAgICAgIGxpbmVzdHJpbmcgPSBwYXJzZSQxLmxpbmVzdHJpbmcuYXBwbHkodGhpcyQxLCBbcmluZ10pO1xuICAgICAgbGluZWFycmluZyA9IHRoaXMkMS5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhsaW5lc3RyaW5nLl9wb2ludHMpO1xuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgc2hlbGwgPSBsaW5lYXJyaW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9sZXMucHVzaChsaW5lYXJyaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24oc2hlbGwsIGhvbGVzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYSBtdWx0aXBvbHlnb24gZ2VvbWV0cnkgZ2l2ZW4gYSBtdWx0aXBvbHlnb24gV0tUIGZyYWdtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyIEEgV0tUIGZyYWdtZW50IHJlcHJlc2VudGluZyB0aGUgbXVsdGlwb2x5Z29uLlxuICAgKiBAcmV0dXJuIHtNdWx0aVBvbHlnb259IEEgbXVsdGlwb2x5Z29uIGdlb21ldHJ5LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbXVsdGlwb2x5Z29uOiBmdW5jdGlvbiBtdWx0aXBvbHlnb24gKHN0cikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKClcbiAgICB9XG5cbiAgICB2YXIgcG9seWdvbjtcbiAgICB2YXIgcG9seWdvbnMgPSBzdHIudHJpbSgpLnNwbGl0KHJlZ0V4ZXMuZG91YmxlUGFyZW5Db21tYSk7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcG9seWdvbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHBvbHlnb24gPSBwb2x5Z29uc1tpXS5yZXBsYWNlKHJlZ0V4ZXMudHJpbVBhcmVucywgJyQxJyk7XG4gICAgICBjb21wb25lbnRzLnB1c2gocGFyc2UkMS5wb2x5Z29uLmFwcGx5KHRoaXMkMSwgW3BvbHlnb25dKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oY29tcG9uZW50cylcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJuIGEgZ2VvbWV0cnljb2xsZWN0aW9uIGdpdmVuIGEgZ2VvbWV0cnljb2xsZWN0aW9uIFdLVCBmcmFnbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0ciBBIFdLVCBmcmFnbWVudCByZXByZXNlbnRpbmcgdGhlIGdlb21ldHJ5Y29sbGVjdGlvbi5cbiAgICogQHJldHVybiB7R2VvbWV0cnlDb2xsZWN0aW9ufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2VvbWV0cnljb2xsZWN0aW9uOiBmdW5jdGlvbiBnZW9tZXRyeWNvbGxlY3Rpb24gKHN0cikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKClcbiAgICB9XG5cbiAgICAvLyBzZXBhcmF0ZSBjb21wb25lbnRzIG9mIHRoZSBjb2xsZWN0aW9uIHdpdGggfFxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8sXFxzKihbQS1aYS16XSkvZywgJ3wkMScpO1xuICAgIHZhciB3a3RBcnJheSA9IHN0ci50cmltKCkuc3BsaXQoJ3wnKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB3a3RBcnJheS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY29tcG9uZW50cy5wdXNoKHRoaXMkMS5yZWFkKHdrdEFycmF5W2ldKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oY29tcG9uZW50cylcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgdGhlIFdlbGwtS25vd24gVGV4dCByZXByZXNlbnRhdGlvbiBvZiBhIHtAbGluayBHZW9tZXRyeX0uIFRoZVxuICogV2VsbC1Lbm93biBUZXh0IGZvcm1hdCBpcyBkZWZpbmVkIGluIHRoZSA8QVxuICogSFJFRj1cImh0dHA6Ly93d3cub3Blbmdpcy5vcmcvdGVjaG5vL3NwZWNzLmh0bVwiPiBPR0MgU2ltcGxlIEZlYXR1cmVzXG4gKiBTcGVjaWZpY2F0aW9uIGZvciBTUUw8L0E+LlxuICogPHA+XG4gKiBUaGUgPGNvZGU+V0tUV3JpdGVyPC9jb2RlPiBvdXRwdXRzIGNvb3JkaW5hdGVzIHJvdW5kZWQgdG8gdGhlIHByZWNpc2lvblxuICogbW9kZWwuIE9ubHkgdGhlIG1heGltdW0gbnVtYmVyIG9mIGRlY2ltYWwgcGxhY2VzIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlXG4gKiBvcmRpbmF0ZXMgdG8gdGhlIHJlcXVpcmVkIHByZWNpc2lvbiB3aWxsIGJlIG91dHB1dC5cbiAqIDxwPlxuICogVGhlIFNGUyBXS1Qgc3BlYyBkb2VzIG5vdCBkZWZpbmUgYSBzcGVjaWFsIHRhZyBmb3Ige0BsaW5rIExpbmVhclJpbmd9cy5cbiAqIFVuZGVyIHRoZSBzcGVjLCByaW5ncyBhcmUgb3V0cHV0IGFzIDxjb2RlPkxJTkVTVFJJTkc8L2NvZGU+cy5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7R2VvbWV0cnlGYWN0b3J5fSBnZW9tZXRyeUZhY3RvcnlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgV0tUV3JpdGVyID0gZnVuY3Rpb24gV0tUV3JpdGVyIChnZW9tZXRyeUZhY3RvcnkpIHtcbiAgdGhpcy5wYXJzZXIgPSBuZXcgV0tUUGFyc2VyKGdlb21ldHJ5RmFjdG9yeSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgPGNvZGU+R2VvbWV0cnk8L2NvZGU+IHRvIGl0cyBXZWxsLWtub3duIFRleHQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgYSA8Y29kZT5HZW9tZXRyeTwvY29kZT4gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm4ge3N0cmluZ30gYSA8R2VvbWV0cnkgVGFnZ2VkIFRleHQ+IHN0cmluZyAoc2VlIHRoZSBPcGVuR0lTIFNpbXBsZVxuICogICAgICAgRmVhdHVyZXMgU3BlY2lmaWNhdGlvbikuXG4gKiBAbWVtYmVyb2YgV0tUV3JpdGVyXG4gKi9cbldLVFdyaXRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoZ2VvbWV0cnkpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKGdlb21ldHJ5KVxufTtcbi8qKlxuICogR2VuZXJhdGVzIHRoZSBXS1QgZm9yIGEgPHR0PkxJTkVTVFJJTkc8L3R0PiBzcGVjaWZpZWQgYnkgdHdvXG4gKiB7QGxpbmsgQ29vcmRpbmF0ZX1zLlxuICpcbiAqIEBwYXJhbSBwMCB0aGUgZmlyc3QgY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSBwMSB0aGUgc2Vjb25kIGNvb3JkaW5hdGUuXG4gKlxuICogQHJldHVybiB0aGUgV0tULlxuICogQHByaXZhdGVcbiAqL1xuV0tUV3JpdGVyLnRvTGluZVN0cmluZyA9IGZ1bmN0aW9uIHRvTGluZVN0cmluZyAocDAsIHAxKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoICE9PSAyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKVxuICB9XG4gIHJldHVybiAnTElORVNUUklORyAoICcgKyBwMC54ICsgJyAnICsgcDAueSArICcsICcgKyBwMS54ICsgJyAnICsgcDEueSArICcgKSdcbn07XG5cbnZhciBSdW50aW1lRXhjZXB0aW9uID0gKGZ1bmN0aW9uIChFcnJvcikge1xuICBmdW5jdGlvbiBSdW50aW1lRXhjZXB0aW9uIChtZXNzYWdlKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnUnVudGltZUV4Y2VwdGlvbic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFjaztcbiAgfVxuXG4gIGlmICggRXJyb3IgKSBSdW50aW1lRXhjZXB0aW9uLl9fcHJvdG9fXyA9IEVycm9yO1xuICBSdW50aW1lRXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEVycm9yICYmIEVycm9yLnByb3RvdHlwZSApO1xuICBSdW50aW1lRXhjZXB0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJ1bnRpbWVFeGNlcHRpb247XG5cbiAgcmV0dXJuIFJ1bnRpbWVFeGNlcHRpb247XG59KEVycm9yKSk7XG5cbnZhciBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24gPSAoZnVuY3Rpb24gKFJ1bnRpbWVFeGNlcHRpb24kJDEpIHtcbiAgZnVuY3Rpb24gQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uICgpIHtcbiAgICBSdW50aW1lRXhjZXB0aW9uJCQxLmNhbGwodGhpcyk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIFJ1bnRpbWVFeGNlcHRpb24kJDEuY2FsbCh0aGlzKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gYXJndW1lbnRzWzBdO1xuICAgICAgUnVudGltZUV4Y2VwdGlvbiQkMS5jYWxsKHRoaXMsIG1lc3NhZ2UpO1xuICAgIH1cbiAgfVxuXG4gIGlmICggUnVudGltZUV4Y2VwdGlvbiQkMSApIEFzc2VydGlvbkZhaWxlZEV4Y2VwdGlvbi5fX3Byb3RvX18gPSBSdW50aW1lRXhjZXB0aW9uJCQxO1xuICBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUnVudGltZUV4Y2VwdGlvbiQkMSAmJiBSdW50aW1lRXhjZXB0aW9uJCQxLnByb3RvdHlwZSApO1xuICBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uO1xuICBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb25cbiAgfTtcblxuICByZXR1cm4gQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uO1xufShSdW50aW1lRXhjZXB0aW9uKSk7XG5cbnZhciBBc3NlcnQgPSBmdW5jdGlvbiBBc3NlcnQgKCkge307XG5cbkFzc2VydC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkFzc2VydC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBBc3NlcnRcbn07XG5Bc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUgPSBmdW5jdGlvbiBzaG91bGROZXZlclJlYWNoSGVyZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKG51bGwpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbWVzc2FnZSA9IGFyZ3VtZW50c1swXTtcbiAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uKCdTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZScgKyAobWVzc2FnZSAhPT0gbnVsbCA/ICc6ICcgKyBtZXNzYWdlIDogJycpKVxuICB9XG59O1xuQXNzZXJ0LmlzVHJ1ZSA9IGZ1bmN0aW9uIGlzVHJ1ZSAoKSB7XG4gIHZhciBhc3NlcnRpb247XG4gIHZhciBtZXNzYWdlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGFzc2VydGlvbiA9IGFyZ3VtZW50c1swXTtcbiAgICBBc3NlcnQuaXNUcnVlKGFzc2VydGlvbiwgbnVsbCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIGFzc2VydGlvbiA9IGFyZ3VtZW50c1swXTtcbiAgICBtZXNzYWdlID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICghYXNzZXJ0aW9uKSB7XG4gICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBBc3NlcnRpb25GYWlsZWRFeGNlcHRpb24obWVzc2FnZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5Bc3NlcnQuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzICgpIHtcbiAgdmFyIGV4cGVjdGVkVmFsdWU7XG4gIHZhciBhY3R1YWxWYWx1ZTtcbiAgdmFyIG1lc3NhZ2U7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgZXhwZWN0ZWRWYWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICBhY3R1YWxWYWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBBc3NlcnQuZXF1YWxzKGV4cGVjdGVkVmFsdWUsIGFjdHVhbFZhbHVlLCBudWxsKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgZXhwZWN0ZWRWYWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICBhY3R1YWxWYWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBtZXNzYWdlID0gYXJndW1lbnRzWzJdO1xuICAgIGlmICghYWN0dWFsVmFsdWUuZXF1YWxzKGV4cGVjdGVkVmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgQXNzZXJ0aW9uRmFpbGVkRXhjZXB0aW9uKCdFeHBlY3RlZCAnICsgZXhwZWN0ZWRWYWx1ZSArICcgYnV0IGVuY291bnRlcmVkICcgKyBhY3R1YWxWYWx1ZSArIChtZXNzYWdlICE9PSBudWxsID8gJzogJyArIG1lc3NhZ2UgOiAnJykpXG4gICAgfVxuICB9XG59O1xuXG52YXIgTGluZUludGVyc2VjdG9yID0gZnVuY3Rpb24gTGluZUludGVyc2VjdG9yICgpIHtcbiAgdGhpcy5fcmVzdWx0ID0gbnVsbDtcbiAgdGhpcy5faW5wdXRMaW5lcyA9IEFycmF5KDIpLmZpbGwoKS5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkoMik7IH0pO1xuICB0aGlzLl9pbnRQdCA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICB0aGlzLl9pbnRMaW5lSW5kZXggPSBudWxsO1xuICB0aGlzLl9pc1Byb3BlciA9IG51bGw7XG4gIHRoaXMuX3BhID0gbnVsbDtcbiAgdGhpcy5fcGIgPSBudWxsO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX2ludFB0WzBdID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgdGhpcy5faW50UHRbMV0gPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICB0aGlzLl9wYSA9IHRoaXMuX2ludFB0WzBdO1xuICB0aGlzLl9wYiA9IHRoaXMuX2ludFB0WzFdO1xuICB0aGlzLl9yZXN1bHQgPSAwO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxMCA9IHsgRE9OVF9JTlRFUlNFQ1Q6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRE9fSU5URVJTRUNUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENPTExJTkVBUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxOT19JTlRFUlNFQ1RJT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sUE9JTlRfSU5URVJTRUNUSU9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENPTExJTkVBUl9JTlRFUlNFQ1RJT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0SW5kZXhBbG9uZ1NlZ21lbnQgPSBmdW5jdGlvbiBnZXRJbmRleEFsb25nU2VnbWVudCAoc2VnbWVudEluZGV4LCBpbnRJbmRleCkge1xuICB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKTtcbiAgcmV0dXJuIHRoaXMuX2ludExpbmVJbmRleFtzZWdtZW50SW5kZXhdW2ludEluZGV4XVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0VG9wb2xvZ3lTdW1tYXJ5ID0gZnVuY3Rpb24gZ2V0VG9wb2xvZ3lTdW1tYXJ5ICgpIHtcbiAgdmFyIGNhdEJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgaWYgKHRoaXMuaXNFbmRQb2ludCgpKSB7IGNhdEJ1Zi5hcHBlbmQoJyBlbmRwb2ludCcpOyB9XG4gIGlmICh0aGlzLl9pc1Byb3BlcikgeyBjYXRCdWYuYXBwZW5kKCcgcHJvcGVyJyk7IH1cbiAgaWYgKHRoaXMuaXNDb2xsaW5lYXIoKSkgeyBjYXRCdWYuYXBwZW5kKCcgY29sbGluZWFyJyk7IH1cbiAgcmV0dXJuIGNhdEJ1Zi50b1N0cmluZygpXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdGlvbiAocDEsIHAyLCBwMywgcDQpIHtcbiAgdGhpcy5faW5wdXRMaW5lc1swXVswXSA9IHAxO1xuICB0aGlzLl9pbnB1dExpbmVzWzBdWzFdID0gcDI7XG4gIHRoaXMuX2lucHV0TGluZXNbMV1bMF0gPSBwMztcbiAgdGhpcy5faW5wdXRMaW5lc1sxXVsxXSA9IHA0O1xuICB0aGlzLl9yZXN1bHQgPSB0aGlzLmNvbXB1dGVJbnRlcnNlY3QocDEsIHAyLCBwMywgcDQpO1xufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9uTnVtID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uTnVtICgpIHtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdFxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUludExpbmVJbmRleCA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRMaW5lSW5kZXggKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmICh0aGlzLl9pbnRMaW5lSW5kZXggPT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2ludExpbmVJbmRleCA9IEFycmF5KDIpLmZpbGwoKS5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkoMik7IH0pO1xuICAgICAgdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDApO1xuICAgICAgdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDEpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHNlZ21lbnRJbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZGlzdDAgPSB0aGlzLmdldEVkZ2VEaXN0YW5jZShzZWdtZW50SW5kZXgsIDApO1xuICAgIHZhciBkaXN0MSA9IHRoaXMuZ2V0RWRnZURpc3RhbmNlKHNlZ21lbnRJbmRleCwgMSk7XG4gICAgaWYgKGRpc3QwID4gZGlzdDEpIHtcbiAgICAgIHRoaXMuX2ludExpbmVJbmRleFtzZWdtZW50SW5kZXhdWzBdID0gMDtcbiAgICAgIHRoaXMuX2ludExpbmVJbmRleFtzZWdtZW50SW5kZXhdWzFdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW50TGluZUluZGV4W3NlZ21lbnRJbmRleF1bMF0gPSAxO1xuICAgICAgdGhpcy5faW50TGluZUluZGV4W3NlZ21lbnRJbmRleF1bMV0gPSAwO1xuICAgIH1cbiAgfVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaXNQcm9wZXIgPSBmdW5jdGlvbiBpc1Byb3BlciAoKSB7XG4gIHJldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpICYmIHRoaXMuX2lzUHJvcGVyXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5zZXRQcmVjaXNpb25Nb2RlbCA9IGZ1bmN0aW9uIHNldFByZWNpc2lvbk1vZGVsIChwcmVjaXNpb25Nb2RlbCkge1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IHByZWNpc2lvbk1vZGVsO1xufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaXNJbnRlcmlvckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGlzSW50ZXJpb3JJbnRlcnNlY3Rpb24gKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigwKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigxKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBpbnB1dExpbmVJbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3Jlc3VsdDsgaSsrKSB7XG4gICAgICBpZiAoISh0aGlzJDEuX2ludFB0W2ldLmVxdWFsczJEKHRoaXMkMS5faW5wdXRMaW5lc1tpbnB1dExpbmVJbmRleF1bMF0pIHx8IHRoaXMkMS5faW50UHRbaV0uZXF1YWxzMkQodGhpcyQxLl9pbnB1dExpbmVzW2lucHV0TGluZUluZGV4XVsxXSkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb24gKGludEluZGV4KSB7XG4gIHJldHVybiB0aGlzLl9pbnRQdFtpbnRJbmRleF1cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmlzRW5kUG9pbnQgPSBmdW5jdGlvbiBpc0VuZFBvaW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uKCkgJiYgIXRoaXMuX2lzUHJvcGVyXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5oYXNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVzdWx0ICE9PSBMaW5lSW50ZXJzZWN0b3IuTk9fSU5URVJTRUNUSU9OXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRFZGdlRGlzdGFuY2UgPSBmdW5jdGlvbiBnZXRFZGdlRGlzdGFuY2UgKHNlZ21lbnRJbmRleCwgaW50SW5kZXgpIHtcbiAgdmFyIGRpc3QgPSBMaW5lSW50ZXJzZWN0b3IuY29tcHV0ZUVkZ2VEaXN0YW5jZSh0aGlzLl9pbnRQdFtpbnRJbmRleF0sIHRoaXMuX2lucHV0TGluZXNbc2VnbWVudEluZGV4XVswXSwgdGhpcy5faW5wdXRMaW5lc1tzZWdtZW50SW5kZXhdWzFdKTtcbiAgcmV0dXJuIGRpc3Rcbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmlzQ29sbGluZWFyID0gZnVuY3Rpb24gaXNDb2xsaW5lYXIgKCkge1xuICByZXR1cm4gdGhpcy5fcmVzdWx0ID09PSBMaW5lSW50ZXJzZWN0b3IuQ09MTElORUFSX0lOVEVSU0VDVElPTlxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMF1bMF0sIHRoaXMuX2lucHV0TGluZXNbMF1bMV0pICsgJyAtICcgKyBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKHRoaXMuX2lucHV0TGluZXNbMV1bMF0sIHRoaXMuX2lucHV0TGluZXNbMV1bMV0pICsgdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKVxufTtcbkxpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0RW5kcG9pbnQgPSBmdW5jdGlvbiBnZXRFbmRwb2ludCAoc2VnbWVudEluZGV4LCBwdEluZGV4KSB7XG4gIHJldHVybiB0aGlzLl9pbnB1dExpbmVzW3NlZ21lbnRJbmRleF1bcHRJbmRleF1cbn07XG5MaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmlzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaXNJbnRlcnNlY3Rpb24gKHB0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yZXN1bHQ7IGkrKykge1xuICAgIGlmICh0aGlzJDEuX2ludFB0W2ldLmVxdWFsczJEKHB0KSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQgPSBmdW5jdGlvbiBnZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQgKHNlZ21lbnRJbmRleCwgaW50SW5kZXgpIHtcbiAgdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCk7XG4gIHJldHVybiB0aGlzLl9pbnRQdFt0aGlzLl9pbnRMaW5lSW5kZXhbc2VnbWVudEluZGV4XVtpbnRJbmRleF1dXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExpbmVJbnRlcnNlY3RvclxufTtcbkxpbmVJbnRlcnNlY3Rvci5jb21wdXRlRWRnZURpc3RhbmNlID0gZnVuY3Rpb24gY29tcHV0ZUVkZ2VEaXN0YW5jZSAocCwgcDAsIHAxKSB7XG4gIHZhciBkeCA9IE1hdGguYWJzKHAxLnggLSBwMC54KTtcbiAgdmFyIGR5ID0gTWF0aC5hYnMocDEueSAtIHAwLnkpO1xuICB2YXIgZGlzdCA9IC0xLjA7XG4gIGlmIChwLmVxdWFscyhwMCkpIHtcbiAgICBkaXN0ID0gMC4wO1xuICB9IGVsc2UgaWYgKHAuZXF1YWxzKHAxKSkge1xuICAgIGlmIChkeCA+IGR5KSB7IGRpc3QgPSBkeDsgfSBlbHNlIHsgZGlzdCA9IGR5OyB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBkeCA9IE1hdGguYWJzKHAueCAtIHAwLngpO1xuICAgIHZhciBwZHkgPSBNYXRoLmFicyhwLnkgLSBwMC55KTtcbiAgICBpZiAoZHggPiBkeSkgeyBkaXN0ID0gcGR4OyB9IGVsc2UgeyBkaXN0ID0gcGR5OyB9XG4gICAgaWYgKGRpc3QgPT09IDAuMCAmJiAhcC5lcXVhbHMocDApKSB7XG4gICAgICBkaXN0ID0gTWF0aC5tYXgocGR4LCBwZHkpO1xuICAgIH1cbiAgfVxuICBBc3NlcnQuaXNUcnVlKCEoZGlzdCA9PT0gMC4wICYmICFwLmVxdWFscyhwMCkpLCAnQmFkIGRpc3RhbmNlIGNhbGN1bGF0aW9uJyk7XG4gIHJldHVybiBkaXN0XG59O1xuTGluZUludGVyc2VjdG9yLm5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2UgPSBmdW5jdGlvbiBub25Sb2J1c3RDb21wdXRlRWRnZURpc3RhbmNlIChwLCBwMSwgcDIpIHtcbiAgdmFyIGR4ID0gcC54IC0gcDEueDtcbiAgdmFyIGR5ID0gcC55IC0gcDEueTtcbiAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBBc3NlcnQuaXNUcnVlKCEoZGlzdCA9PT0gMC4wICYmICFwLmVxdWFscyhwMSkpLCAnSW52YWxpZCBkaXN0YW5jZSBjYWxjdWxhdGlvbicpO1xuICByZXR1cm4gZGlzdFxufTtcbnN0YXRpY0FjY2Vzc29ycyQxMC5ET05UX0lOVEVSU0VDVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuRE9fSU5URVJTRUNULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMC5DT0xMSU5FQVIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuc3RhdGljQWNjZXNzb3JzJDEwLk5PX0lOVEVSU0VDVElPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTAuUE9JTlRfSU5URVJTRUNUSU9OLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMC5DT0xMSU5FQVJfSU5URVJTRUNUSU9OLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExpbmVJbnRlcnNlY3Rvciwgc3RhdGljQWNjZXNzb3JzJDEwICk7XG5cbnZhciBSb2J1c3RMaW5lSW50ZXJzZWN0b3IgPSAoZnVuY3Rpb24gKExpbmVJbnRlcnNlY3RvciQkMSkge1xuICBmdW5jdGlvbiBSb2J1c3RMaW5lSW50ZXJzZWN0b3IgKCkge1xuICAgIExpbmVJbnRlcnNlY3RvciQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBMaW5lSW50ZXJzZWN0b3IkJDEgKSBSb2J1c3RMaW5lSW50ZXJzZWN0b3IuX19wcm90b19fID0gTGluZUludGVyc2VjdG9yJCQxO1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTGluZUludGVyc2VjdG9yJCQxICYmIExpbmVJbnRlcnNlY3RvciQkMS5wcm90b3R5cGUgKTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJvYnVzdExpbmVJbnRlcnNlY3RvcjtcblxuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmlzSW5TZWdtZW50RW52ZWxvcGVzID0gZnVuY3Rpb24gaXNJblNlZ21lbnRFbnZlbG9wZXMgKGludFB0KSB7XG4gICAgdmFyIGVudjAgPSBuZXcgRW52ZWxvcGUodGhpcy5faW5wdXRMaW5lc1swXVswXSwgdGhpcy5faW5wdXRMaW5lc1swXVsxXSk7XG4gICAgdmFyIGVudjEgPSBuZXcgRW52ZWxvcGUodGhpcy5faW5wdXRMaW5lc1sxXVswXSwgdGhpcy5faW5wdXRMaW5lc1sxXVsxXSk7XG4gICAgcmV0dXJuIGVudjAuY29udGFpbnMoaW50UHQpICYmIGVudjEuY29udGFpbnMoaW50UHQpXG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb24gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBwMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHRoaXMuX2lzUHJvcGVyID0gZmFsc2U7XG4gICAgICBpZiAoRW52ZWxvcGUuaW50ZXJzZWN0cyhwMSwgcDIsIHApKSB7XG4gICAgICAgIGlmIChDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChwMSwgcDIsIHApID09PSAwICYmIENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHAyLCBwMSwgcCkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9pc1Byb3BlciA9IHRydWU7XG4gICAgICAgICAgaWYgKHAuZXF1YWxzKHAxKSB8fCBwLmVxdWFscyhwMikpIHtcbiAgICAgICAgICAgIHRoaXMuX2lzUHJvcGVyID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3Jlc3VsdCA9IExpbmVJbnRlcnNlY3RvciQkMS5QT0lOVF9JTlRFUlNFQ1RJT047XG4gICAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fcmVzdWx0ID0gTGluZUludGVyc2VjdG9yJCQxLk5PX0lOVEVSU0VDVElPTjtcbiAgICB9IGVsc2UgeyByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLm5vcm1hbGl6ZVRvTWluaW11bSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVRvTWluaW11bSAobjEsIG4yLCBuMywgbjQsIG5vcm1QdCkge1xuICAgIG5vcm1QdC54ID0gdGhpcy5zbWFsbGVzdEluQWJzVmFsdWUobjEueCwgbjIueCwgbjMueCwgbjQueCk7XG4gICAgbm9ybVB0LnkgPSB0aGlzLnNtYWxsZXN0SW5BYnNWYWx1ZShuMS55LCBuMi55LCBuMy55LCBuNC55KTtcbiAgICBuMS54IC09IG5vcm1QdC54O1xuICAgIG4xLnkgLT0gbm9ybVB0Lnk7XG4gICAgbjIueCAtPSBub3JtUHQueDtcbiAgICBuMi55IC09IG5vcm1QdC55O1xuICAgIG4zLnggLT0gbm9ybVB0Lng7XG4gICAgbjMueSAtPSBub3JtUHQueTtcbiAgICBuNC54IC09IG5vcm1QdC54O1xuICAgIG40LnkgLT0gbm9ybVB0Lnk7XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uIChwMSwgcDIsIHExLCBxMikge1xuICAgIHZhciBpbnRQdCA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgIGludFB0ID0gSENvb3JkaW5hdGUuaW50ZXJzZWN0aW9uKHAxLCBwMiwgcTEsIHEyKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24pIHtcbiAgICAgICAgaW50UHQgPSBSb2J1c3RMaW5lSW50ZXJzZWN0b3IubmVhcmVzdEVuZHBvaW50KHAxLCBwMiwgcTEsIHEyKTtcbiAgICAgIH0gZWxzZSB7IHRocm93IGUgfVxuICAgIH0gZmluYWxseSB7fVxuICAgIHJldHVybiBpbnRQdFxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGludGVyc2VjdGlvbiAocDEsIHAyLCBxMSwgcTIpIHtcbiAgICB2YXIgaW50UHQgPSB0aGlzLmludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uKHAxLCBwMiwgcTEsIHEyKTtcbiAgICBpZiAoIXRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMoaW50UHQpKSB7XG4gICAgICBpbnRQdCA9IG5ldyBDb29yZGluYXRlKFJvYnVzdExpbmVJbnRlcnNlY3Rvci5uZWFyZXN0RW5kcG9pbnQocDEsIHAyLCBxMSwgcTIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3ByZWNpc2lvbk1vZGVsICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShpbnRQdCk7XG4gICAgfVxuICAgIHJldHVybiBpbnRQdFxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLnNtYWxsZXN0SW5BYnNWYWx1ZSA9IGZ1bmN0aW9uIHNtYWxsZXN0SW5BYnNWYWx1ZSAoeDEsIHgyLCB4MywgeDQpIHtcbiAgICB2YXIgeCA9IHgxO1xuICAgIHZhciB4YWJzID0gTWF0aC5hYnMoeCk7XG4gICAgaWYgKE1hdGguYWJzKHgyKSA8IHhhYnMpIHtcbiAgICAgIHggPSB4MjtcbiAgICAgIHhhYnMgPSBNYXRoLmFicyh4Mik7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyh4MykgPCB4YWJzKSB7XG4gICAgICB4ID0geDM7XG4gICAgICB4YWJzID0gTWF0aC5hYnMoeDMpO1xuICAgIH1cbiAgICBpZiAoTWF0aC5hYnMoeDQpIDwgeGFicykge1xuICAgICAgeCA9IHg0O1xuICAgIH1cbiAgICByZXR1cm4geFxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNoZWNrREQgPSBmdW5jdGlvbiBjaGVja0REIChwMSwgcDIsIHExLCBxMiwgaW50UHQpIHtcbiAgICB2YXIgaW50UHRERCA9IENHQWxnb3JpdGhtc0RELmludGVyc2VjdGlvbihwMSwgcDIsIHExLCBxMik7XG4gICAgdmFyIGlzSW4gPSB0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKGludFB0REQpO1xuICAgIFN5c3RlbS5vdXQucHJpbnRsbignREQgaW4gZW52ID0gJyArIGlzSW4gKyAnICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gJyArIGludFB0REQpO1xuICAgIGlmIChpbnRQdC5kaXN0YW5jZShpbnRQdEREKSA+IDAuMDAwMSkge1xuICAgICAgU3lzdGVtLm91dC5wcmludGxuKCdEaXN0YW5jZSA9ICcgKyBpbnRQdC5kaXN0YW5jZShpbnRQdEREKSk7XG4gICAgfVxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uV2l0aE5vcm1hbGl6YXRpb24gKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgdmFyIG4xID0gbmV3IENvb3JkaW5hdGUocDEpO1xuICAgIHZhciBuMiA9IG5ldyBDb29yZGluYXRlKHAyKTtcbiAgICB2YXIgbjMgPSBuZXcgQ29vcmRpbmF0ZShxMSk7XG4gICAgdmFyIG40ID0gbmV3IENvb3JkaW5hdGUocTIpO1xuICAgIHZhciBub3JtUHQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHRoaXMubm9ybWFsaXplVG9FbnZDZW50cmUobjEsIG4yLCBuMywgbjQsIG5vcm1QdCk7XG4gICAgdmFyIGludFB0ID0gdGhpcy5zYWZlSENvb3JkaW5hdGVJbnRlcnNlY3Rpb24objEsIG4yLCBuMywgbjQpO1xuICAgIGludFB0LnggKz0gbm9ybVB0Lng7XG4gICAgaW50UHQueSArPSBub3JtUHQueTtcbiAgICByZXR1cm4gaW50UHRcbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbiAocDEsIHAyLCBxMSwgcTIpIHtcbiAgICB2YXIgcDFxMXAyID0gRW52ZWxvcGUuaW50ZXJzZWN0cyhwMSwgcDIsIHExKTtcbiAgICB2YXIgcDFxMnAyID0gRW52ZWxvcGUuaW50ZXJzZWN0cyhwMSwgcDIsIHEyKTtcbiAgICB2YXIgcTFwMXEyID0gRW52ZWxvcGUuaW50ZXJzZWN0cyhxMSwgcTIsIHAxKTtcbiAgICB2YXIgcTFwMnEyID0gRW52ZWxvcGUuaW50ZXJzZWN0cyhxMSwgcTIsIHAyKTtcbiAgICBpZiAocDFxMXAyICYmIHAxcTJwMikge1xuICAgICAgdGhpcy5faW50UHRbMF0gPSBxMTtcbiAgICAgIHRoaXMuX2ludFB0WzFdID0gcTI7XG4gICAgICByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgaWYgKHExcDFxMiAmJiBxMXAycTIpIHtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gcDE7XG4gICAgICB0aGlzLl9pbnRQdFsxXSA9IHAyO1xuICAgICAgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIGlmIChwMXExcDIgJiYgcTFwMXEyKSB7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHExO1xuICAgICAgdGhpcy5faW50UHRbMV0gPSBwMTtcbiAgICAgIHJldHVybiBxMS5lcXVhbHMocDEpICYmICFwMXEycDIgJiYgIXExcDJxMiA/IExpbmVJbnRlcnNlY3RvciQkMS5QT0lOVF9JTlRFUlNFQ1RJT04gOiBMaW5lSW50ZXJzZWN0b3IkJDEuQ09MTElORUFSX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICBpZiAocDFxMXAyICYmIHExcDJxMikge1xuICAgICAgdGhpcy5faW50UHRbMF0gPSBxMTtcbiAgICAgIHRoaXMuX2ludFB0WzFdID0gcDI7XG4gICAgICByZXR1cm4gcTEuZXF1YWxzKHAyKSAmJiAhcDFxMnAyICYmICFxMXAxcTIgPyBMaW5lSW50ZXJzZWN0b3IkJDEuUE9JTlRfSU5URVJTRUNUSU9OIDogTGluZUludGVyc2VjdG9yJCQxLkNPTExJTkVBUl9JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgaWYgKHAxcTJwMiAmJiBxMXAxcTIpIHtcbiAgICAgIHRoaXMuX2ludFB0WzBdID0gcTI7XG4gICAgICB0aGlzLl9pbnRQdFsxXSA9IHAxO1xuICAgICAgcmV0dXJuIHEyLmVxdWFscyhwMSkgJiYgIXAxcTFwMiAmJiAhcTFwMnEyID8gTGluZUludGVyc2VjdG9yJCQxLlBPSU5UX0lOVEVSU0VDVElPTiA6IExpbmVJbnRlcnNlY3RvciQkMS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIGlmIChwMXEycDIgJiYgcTFwMnEyKSB7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHEyO1xuICAgICAgdGhpcy5faW50UHRbMV0gPSBwMjtcbiAgICAgIHJldHVybiBxMi5lcXVhbHMocDIpICYmICFwMXExcDIgJiYgIXExcDFxMiA/IExpbmVJbnRlcnNlY3RvciQkMS5QT0lOVF9JTlRFUlNFQ1RJT04gOiBMaW5lSW50ZXJzZWN0b3IkJDEuQ09MTElORUFSX0lOVEVSU0VDVElPTlxuICAgIH1cbiAgICByZXR1cm4gTGluZUludGVyc2VjdG9yJCQxLk5PX0lOVEVSU0VDVElPTlxuICB9O1xuICBSb2J1c3RMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLm5vcm1hbGl6ZVRvRW52Q2VudHJlID0gZnVuY3Rpb24gbm9ybWFsaXplVG9FbnZDZW50cmUgKG4wMCwgbjAxLCBuMTAsIG4xMSwgbm9ybVB0KSB7XG4gICAgdmFyIG1pblgwID0gbjAwLnggPCBuMDEueCA/IG4wMC54IDogbjAxLng7XG4gICAgdmFyIG1pblkwID0gbjAwLnkgPCBuMDEueSA/IG4wMC55IDogbjAxLnk7XG4gICAgdmFyIG1heFgwID0gbjAwLnggPiBuMDEueCA/IG4wMC54IDogbjAxLng7XG4gICAgdmFyIG1heFkwID0gbjAwLnkgPiBuMDEueSA/IG4wMC55IDogbjAxLnk7XG4gICAgdmFyIG1pblgxID0gbjEwLnggPCBuMTEueCA/IG4xMC54IDogbjExLng7XG4gICAgdmFyIG1pblkxID0gbjEwLnkgPCBuMTEueSA/IG4xMC55IDogbjExLnk7XG4gICAgdmFyIG1heFgxID0gbjEwLnggPiBuMTEueCA/IG4xMC54IDogbjExLng7XG4gICAgdmFyIG1heFkxID0gbjEwLnkgPiBuMTEueSA/IG4xMC55IDogbjExLnk7XG4gICAgdmFyIGludE1pblggPSBtaW5YMCA+IG1pblgxID8gbWluWDAgOiBtaW5YMTtcbiAgICB2YXIgaW50TWF4WCA9IG1heFgwIDwgbWF4WDEgPyBtYXhYMCA6IG1heFgxO1xuICAgIHZhciBpbnRNaW5ZID0gbWluWTAgPiBtaW5ZMSA/IG1pblkwIDogbWluWTE7XG4gICAgdmFyIGludE1heFkgPSBtYXhZMCA8IG1heFkxID8gbWF4WTAgOiBtYXhZMTtcbiAgICB2YXIgaW50TWlkWCA9IChpbnRNaW5YICsgaW50TWF4WCkgLyAyLjA7XG4gICAgdmFyIGludE1pZFkgPSAoaW50TWluWSArIGludE1heFkpIC8gMi4wO1xuICAgIG5vcm1QdC54ID0gaW50TWlkWDtcbiAgICBub3JtUHQueSA9IGludE1pZFk7XG4gICAgbjAwLnggLT0gbm9ybVB0Lng7XG4gICAgbjAwLnkgLT0gbm9ybVB0Lnk7XG4gICAgbjAxLnggLT0gbm9ybVB0Lng7XG4gICAgbjAxLnkgLT0gbm9ybVB0Lnk7XG4gICAgbjEwLnggLT0gbm9ybVB0Lng7XG4gICAgbjEwLnkgLT0gbm9ybVB0Lnk7XG4gICAgbjExLnggLT0gbm9ybVB0Lng7XG4gICAgbjExLnkgLT0gbm9ybVB0Lnk7XG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdCA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3QgKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgdGhpcy5faXNQcm9wZXIgPSBmYWxzZTtcbiAgICBpZiAoIUVudmVsb3BlLmludGVyc2VjdHMocDEsIHAyLCBxMSwgcTIpKSB7IHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuTk9fSU5URVJTRUNUSU9OIH1cbiAgICB2YXIgUHExID0gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocDEsIHAyLCBxMSk7XG4gICAgdmFyIFBxMiA9IENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHAxLCBwMiwgcTIpO1xuICAgIGlmICgoUHExID4gMCAmJiBQcTIgPiAwKSB8fCAoUHExIDwgMCAmJiBQcTIgPCAwKSkge1xuICAgICAgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5OT19JTlRFUlNFQ1RJT05cbiAgICB9XG4gICAgdmFyIFFwMSA9IENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHExLCBxMiwgcDEpO1xuICAgIHZhciBRcDIgPSBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleChxMSwgcTIsIHAyKTtcbiAgICBpZiAoKFFwMSA+IDAgJiYgUXAyID4gMCkgfHwgKFFwMSA8IDAgJiYgUXAyIDwgMCkpIHtcbiAgICAgIHJldHVybiBMaW5lSW50ZXJzZWN0b3IkJDEuTk9fSU5URVJTRUNUSU9OXG4gICAgfVxuICAgIHZhciBjb2xsaW5lYXIgPSBQcTEgPT09IDAgJiYgUHEyID09PSAwICYmIFFwMSA9PT0gMCAmJiBRcDIgPT09IDA7XG4gICAgaWYgKGNvbGxpbmVhcikge1xuICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbihwMSwgcDIsIHExLCBxMilcbiAgICB9XG4gICAgaWYgKFBxMSA9PT0gMCB8fCBQcTIgPT09IDAgfHwgUXAxID09PSAwIHx8IFFwMiA9PT0gMCkge1xuICAgICAgdGhpcy5faXNQcm9wZXIgPSBmYWxzZTtcbiAgICAgIGlmIChwMS5lcXVhbHMyRChxMSkgfHwgcDEuZXF1YWxzMkQocTIpKSB7XG4gICAgICAgIHRoaXMuX2ludFB0WzBdID0gcDE7XG4gICAgICB9IGVsc2UgaWYgKHAyLmVxdWFsczJEKHExKSB8fCBwMi5lcXVhbHMyRChxMikpIHtcbiAgICAgICAgdGhpcy5faW50UHRbMF0gPSBwMjtcbiAgICAgIH0gZWxzZSBpZiAoUHExID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2ludFB0WzBdID0gbmV3IENvb3JkaW5hdGUocTEpO1xuICAgICAgfSBlbHNlIGlmIChQcTIgPT09IDApIHtcbiAgICAgICAgdGhpcy5faW50UHRbMF0gPSBuZXcgQ29vcmRpbmF0ZShxMik7XG4gICAgICB9IGVsc2UgaWYgKFFwMSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9pbnRQdFswXSA9IG5ldyBDb29yZGluYXRlKHAxKTtcbiAgICAgIH0gZWxzZSBpZiAoUXAyID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2ludFB0WzBdID0gbmV3IENvb3JkaW5hdGUocDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc1Byb3BlciA9IHRydWU7XG4gICAgICB0aGlzLl9pbnRQdFswXSA9IHRoaXMuaW50ZXJzZWN0aW9uKHAxLCBwMiwgcTEsIHEyKTtcbiAgICB9XG4gICAgcmV0dXJuIExpbmVJbnRlcnNlY3RvciQkMS5QT0lOVF9JTlRFUlNFQ1RJT05cbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgUm9idXN0TGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gUm9idXN0TGluZUludGVyc2VjdG9yXG4gIH07XG4gIFJvYnVzdExpbmVJbnRlcnNlY3Rvci5uZWFyZXN0RW5kcG9pbnQgPSBmdW5jdGlvbiBuZWFyZXN0RW5kcG9pbnQgKHAxLCBwMiwgcTEsIHEyKSB7XG4gICAgdmFyIG5lYXJlc3RQdCA9IHAxO1xuICAgIHZhciBtaW5EaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHAxLCBxMSwgcTIpO1xuICAgIHZhciBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHAyLCBxMSwgcTIpO1xuICAgIGlmIChkaXN0IDwgbWluRGlzdCkge1xuICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICBuZWFyZXN0UHQgPSBwMjtcbiAgICB9XG4gICAgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShxMSwgcDEsIHAyKTtcbiAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgbmVhcmVzdFB0ID0gcTE7XG4gICAgfVxuICAgIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUocTIsIHAxLCBwMik7XG4gICAgaWYgKGRpc3QgPCBtaW5EaXN0KSB7XG4gICAgICBtaW5EaXN0ID0gZGlzdDtcbiAgICAgIG5lYXJlc3RQdCA9IHEyO1xuICAgIH1cbiAgICByZXR1cm4gbmVhcmVzdFB0XG4gIH07XG5cbiAgcmV0dXJuIFJvYnVzdExpbmVJbnRlcnNlY3Rvcjtcbn0oTGluZUludGVyc2VjdG9yKSk7XG5cbnZhciBSb2J1c3REZXRlcm1pbmFudCA9IGZ1bmN0aW9uIFJvYnVzdERldGVybWluYW50ICgpIHt9O1xuXG5Sb2J1c3REZXRlcm1pbmFudC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblJvYnVzdERldGVybWluYW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFJvYnVzdERldGVybWluYW50XG59O1xuUm9idXN0RGV0ZXJtaW5hbnQub3JpZW50YXRpb25JbmRleCA9IGZ1bmN0aW9uIG9yaWVudGF0aW9uSW5kZXggKHAxLCBwMiwgcSkge1xuICB2YXIgZHgxID0gcDIueCAtIHAxLng7XG4gIHZhciBkeTEgPSBwMi55IC0gcDEueTtcbiAgdmFyIGR4MiA9IHEueCAtIHAyLng7XG4gIHZhciBkeTIgPSBxLnkgLSBwMi55O1xuICByZXR1cm4gUm9idXN0RGV0ZXJtaW5hbnQuc2lnbk9mRGV0MngyKGR4MSwgZHkxLCBkeDIsIGR5Milcbn07XG5Sb2J1c3REZXRlcm1pbmFudC5zaWduT2ZEZXQyeDIgPSBmdW5jdGlvbiBzaWduT2ZEZXQyeDIgKHgxLCB5MSwgeDIsIHkyKSB7XG4gIHZhciBzaWduID0gbnVsbDtcbiAgdmFyIHN3YXAgPSBudWxsO1xuICB2YXIgayA9IG51bGw7XG4gIHNpZ24gPSAxO1xuICBpZiAoeDEgPT09IDAuMCB8fCB5MiA9PT0gMC4wKSB7XG4gICAgaWYgKHkxID09PSAwLjAgfHwgeDIgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9IGVsc2UgaWYgKHkxID4gMCkge1xuICAgICAgaWYgKHgyID4gMCkge1xuICAgICAgICByZXR1cm4gLXNpZ25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4MiA+IDApIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoeTEgPT09IDAuMCB8fCB4MiA9PT0gMC4wKSB7XG4gICAgaWYgKHkyID4gMCkge1xuICAgICAgaWYgKHgxID4gMCkge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh4MSA+IDApIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnblxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoeTEgPiAwLjApIHtcbiAgICBpZiAoeTIgPiAwLjApIHtcbiAgICAgIGlmICh5MSA8PSB5Mikge1xuICAgICAgICBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgICAgc3dhcCA9IHgxO1xuICAgICAgICB4MSA9IHgyO1xuICAgICAgICB4MiA9IHN3YXA7XG4gICAgICAgIHN3YXAgPSB5MTtcbiAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgeTIgPSBzd2FwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeTEgPD0gLXkyKSB7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgICAgeDIgPSAteDI7XG4gICAgICAgIHkyID0gLXkyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3dhcCA9IHgxO1xuICAgICAgICB4MSA9IC14MjtcbiAgICAgICAgeDIgPSBzd2FwO1xuICAgICAgICBzd2FwID0geTE7XG4gICAgICAgIHkxID0gLXkyO1xuICAgICAgICB5MiA9IHN3YXA7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh5MiA+IDAuMCkge1xuICAgICAgaWYgKC15MSA8PSB5Mikge1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICAgIHgxID0gLXgxO1xuICAgICAgICB5MSA9IC15MTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3YXAgPSAteDE7XG4gICAgICAgIHgxID0geDI7XG4gICAgICAgIHgyID0gc3dhcDtcbiAgICAgICAgc3dhcCA9IC15MTtcbiAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgeTIgPSBzd2FwO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeTEgPj0geTIpIHtcbiAgICAgICAgeDEgPSAteDE7XG4gICAgICAgIHkxID0gLXkxO1xuICAgICAgICB4MiA9IC14MjtcbiAgICAgICAgeTIgPSAteTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduID0gLXNpZ247XG4gICAgICAgIHN3YXAgPSAteDE7XG4gICAgICAgIHgxID0gLXgyO1xuICAgICAgICB4MiA9IHN3YXA7XG4gICAgICAgIHN3YXAgPSAteTE7XG4gICAgICAgIHkxID0gLXkyO1xuICAgICAgICB5MiA9IHN3YXA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh4MSA+IDAuMCkge1xuICAgIGlmICh4MiA+IDAuMCkge1xuICAgICAgaWYgKHgxIDw9IHgyKSB7XG4gICAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNpZ25cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpZ25cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHgyID4gMC4wKSB7XG4gICAgICByZXR1cm4gLXNpZ25cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgIHNpZ24gPSAtc2lnbjtcbiAgICAgICAgeDEgPSAteDE7XG4gICAgICAgIHgyID0gLXgyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgayA9IE1hdGguZmxvb3IoeDIgLyB4MSk7XG4gICAgeDIgPSB4MiAtIGsgKiB4MTtcbiAgICB5MiA9IHkyIC0gayAqIHkxO1xuICAgIGlmICh5MiA8IDAuMCkge1xuICAgICAgcmV0dXJuIC1zaWduXG4gICAgfVxuICAgIGlmICh5MiA+IHkxKSB7XG4gICAgICByZXR1cm4gc2lnblxuICAgIH1cbiAgICBpZiAoeDEgPiB4MiArIHgyKSB7XG4gICAgICBpZiAoeTEgPCB5MiArIHkyKSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh5MSA+IHkyICsgeTIpIHtcbiAgICAgICAgcmV0dXJuIC1zaWduXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MiA9IHgxIC0geDI7XG4gICAgICAgIHkyID0geTEgLSB5MjtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoeTIgPT09IDAuMCkge1xuICAgICAgaWYgKHgyID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoeDIgPT09IDAuMCkge1xuICAgICAgcmV0dXJuIHNpZ25cbiAgICB9XG4gICAgayA9IE1hdGguZmxvb3IoeDEgLyB4Mik7XG4gICAgeDEgPSB4MSAtIGsgKiB4MjtcbiAgICB5MSA9IHkxIC0gayAqIHkyO1xuICAgIGlmICh5MSA8IDAuMCkge1xuICAgICAgcmV0dXJuIHNpZ25cbiAgICB9XG4gICAgaWYgKHkxID4geTIpIHtcbiAgICAgIHJldHVybiAtc2lnblxuICAgIH1cbiAgICBpZiAoeDIgPiB4MSArIHgxKSB7XG4gICAgICBpZiAoeTIgPCB5MSArIHkxKSB7XG4gICAgICAgIHJldHVybiAtc2lnblxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoeTIgPiB5MSArIHkxKSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4MSA9IHgyIC0geDE7XG4gICAgICAgIHkxID0geTIgLSB5MTtcbiAgICAgICAgc2lnbiA9IC1zaWduO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoeTEgPT09IDAuMCkge1xuICAgICAgaWYgKHgxID09PSAwLjApIHtcbiAgICAgICAgcmV0dXJuIDBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWduXG4gICAgICB9XG4gICAgfVxuICAgIGlmICh4MSA9PT0gMC4wKSB7XG4gICAgICByZXR1cm4gLXNpZ25cbiAgICB9XG4gIH1cbn07XG5cbnZhciBSYXlDcm9zc2luZ0NvdW50ZXIgPSBmdW5jdGlvbiBSYXlDcm9zc2luZ0NvdW50ZXIgKCkge1xuICB0aGlzLl9wID0gbnVsbDtcbiAgdGhpcy5fY3Jvc3NpbmdDb3VudCA9IDA7XG4gIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQgPSBmYWxzZTtcbiAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3AgPSBwO1xufTtcblJheUNyb3NzaW5nQ291bnRlci5wcm90b3R5cGUuY291bnRTZWdtZW50ID0gZnVuY3Rpb24gY291bnRTZWdtZW50IChwMSwgcDIpIHtcbiAgaWYgKHAxLnggPCB0aGlzLl9wLnggJiYgcDIueCA8IHRoaXMuX3AueCkgeyByZXR1cm4gbnVsbCB9XG4gIGlmICh0aGlzLl9wLnggPT09IHAyLnggJiYgdGhpcy5fcC55ID09PSBwMi55KSB7XG4gICAgdGhpcy5faXNQb2ludE9uU2VnbWVudCA9IHRydWU7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAocDEueSA9PT0gdGhpcy5fcC55ICYmIHAyLnkgPT09IHRoaXMuX3AueSkge1xuICAgIHZhciBtaW54ID0gcDEueDtcbiAgICB2YXIgbWF4eCA9IHAyLng7XG4gICAgaWYgKG1pbnggPiBtYXh4KSB7XG4gICAgICBtaW54ID0gcDIueDtcbiAgICAgIG1heHggPSBwMS54O1xuICAgIH1cbiAgICBpZiAodGhpcy5fcC54ID49IG1pbnggJiYgdGhpcy5fcC54IDw9IG1heHgpIHtcbiAgICAgIHRoaXMuX2lzUG9pbnRPblNlZ21lbnQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmICgocDEueSA+IHRoaXMuX3AueSAmJiBwMi55IDw9IHRoaXMuX3AueSkgfHwgKHAyLnkgPiB0aGlzLl9wLnkgJiYgcDEueSA8PSB0aGlzLl9wLnkpKSB7XG4gICAgdmFyIHgxID0gcDEueCAtIHRoaXMuX3AueDtcbiAgICB2YXIgeTEgPSBwMS55IC0gdGhpcy5fcC55O1xuICAgIHZhciB4MiA9IHAyLnggLSB0aGlzLl9wLng7XG4gICAgdmFyIHkyID0gcDIueSAtIHRoaXMuX3AueTtcbiAgICB2YXIgeEludFNpZ24gPSBSb2J1c3REZXRlcm1pbmFudC5zaWduT2ZEZXQyeDIoeDEsIHkxLCB4MiwgeTIpO1xuICAgIGlmICh4SW50U2lnbiA9PT0gMC4wKSB7XG4gICAgICB0aGlzLl9pc1BvaW50T25TZWdtZW50ID0gdHJ1ZTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGlmICh5MiA8IHkxKSB7IHhJbnRTaWduID0gLXhJbnRTaWduOyB9XG4gICAgaWYgKHhJbnRTaWduID4gMC4wKSB7XG4gICAgICB0aGlzLl9jcm9zc2luZ0NvdW50Kys7XG4gICAgfVxuICB9XG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLnByb3RvdHlwZS5pc1BvaW50SW5Qb2x5Z29uID0gZnVuY3Rpb24gaXNQb2ludEluUG9seWdvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldExvY2F0aW9uKCkgIT09IExvY2F0aW9uLkVYVEVSSU9SXG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uICgpIHtcbiAgaWYgKHRoaXMuX2lzUG9pbnRPblNlZ21lbnQpIHsgcmV0dXJuIExvY2F0aW9uLkJPVU5EQVJZIH1cbiAgaWYgKHRoaXMuX2Nyb3NzaW5nQ291bnQgJSAyID09PSAxKSB7XG4gICAgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SXG4gIH1cbiAgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SXG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLnByb3RvdHlwZS5pc09uU2VnbWVudCA9IGZ1bmN0aW9uIGlzT25TZWdtZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzUG9pbnRPblNlZ21lbnRcbn07XG5SYXlDcm9zc2luZ0NvdW50ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5SYXlDcm9zc2luZ0NvdW50ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUmF5Q3Jvc3NpbmdDb3VudGVyXG59O1xuUmF5Q3Jvc3NpbmdDb3VudGVyLmxvY2F0ZVBvaW50SW5SaW5nID0gZnVuY3Rpb24gbG9jYXRlUG9pbnRJblJpbmcgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHJpbmcgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGNvdW50ZXIgPSBuZXcgUmF5Q3Jvc3NpbmdDb3VudGVyKHApO1xuICAgIHZhciBwMSA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgdmFyIHAyID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJpbmcuc2l6ZSgpOyBpKyspIHtcbiAgICAgIHJpbmcuZ2V0Q29vcmRpbmF0ZShpLCBwMSk7XG4gICAgICByaW5nLmdldENvb3JkaW5hdGUoaSAtIDEsIHAyKTtcbiAgICAgIGNvdW50ZXIuY291bnRTZWdtZW50KHAxLCBwMik7XG4gICAgICBpZiAoY291bnRlci5pc09uU2VnbWVudCgpKSB7IHJldHVybiBjb3VudGVyLmdldExvY2F0aW9uKCkgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRlci5nZXRMb2NhdGlvbigpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHJpbmckMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgY291bnRlciQxID0gbmV3IFJheUNyb3NzaW5nQ291bnRlcihwJDEpO1xuICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHJpbmckMS5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICB2YXIgcDEkMSA9IHJpbmckMVtpJDFdO1xuICAgICAgdmFyIHAyJDEgPSByaW5nJDFbaSQxIC0gMV07XG4gICAgICBjb3VudGVyJDEuY291bnRTZWdtZW50KHAxJDEsIHAyJDEpO1xuICAgICAgaWYgKGNvdW50ZXIkMS5pc09uU2VnbWVudCgpKSB7IHJldHVybiBjb3VudGVyJDEuZ2V0TG9jYXRpb24oKSB9XG4gICAgfVxuICAgIHJldHVybiBjb3VudGVyJDEuZ2V0TG9jYXRpb24oKVxuICB9XG59O1xuXG52YXIgQ0dBbGdvcml0aG1zID0gZnVuY3Rpb24gQ0dBbGdvcml0aG1zICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDMgPSB7IENMT0NLV0lTRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxSSUdIVDogeyBjb25maWd1cmFibGU6IHRydWUgfSxDT1VOVEVSQ0xPQ0tXSVNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LExFRlQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ09MTElORUFSOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNUUkFJR0hUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkNHQWxnb3JpdGhtcy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNHQWxnb3JpdGhtcy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDR0FsZ29yaXRobXNcbn07XG5DR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleCA9IGZ1bmN0aW9uIG9yaWVudGF0aW9uSW5kZXggKHAxLCBwMiwgcSkge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zREQub3JpZW50YXRpb25JbmRleChwMSwgcDIsIHEpXG59O1xuQ0dBbGdvcml0aG1zLnNpZ25lZEFyZWEgPSBmdW5jdGlvbiBzaWduZWRBcmVhICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgdmFyIHJpbmcgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKHJpbmcubGVuZ3RoIDwgMykgeyByZXR1cm4gMC4wIH1cbiAgICB2YXIgc3VtID0gMC4wO1xuICAgIHZhciB4MCA9IHJpbmdbMF0ueDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJpbmcubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICB2YXIgeCA9IHJpbmdbaV0ueCAtIHgwO1xuICAgICAgdmFyIHkxID0gcmluZ1tpICsgMV0ueTtcbiAgICAgIHZhciB5MiA9IHJpbmdbaSAtIDFdLnk7XG4gICAgICBzdW0gKz0geCAqICh5MiAtIHkxKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1bSAvIDIuMFxuICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICB2YXIgcmluZyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBuID0gcmluZyQxLnNpemUoKTtcbiAgICBpZiAobiA8IDMpIHsgcmV0dXJuIDAuMCB9XG4gICAgdmFyIHAwID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgICB2YXIgcDEgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHZhciBwMiA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgcmluZyQxLmdldENvb3JkaW5hdGUoMCwgcDEpO1xuICAgIHJpbmckMS5nZXRDb29yZGluYXRlKDEsIHAyKTtcbiAgICB2YXIgeDAkMSA9IHAxLng7XG4gICAgcDIueCAtPSB4MCQxO1xuICAgIHZhciBzdW0kMSA9IDAuMDtcbiAgICBmb3IgKHZhciBpJDEgPSAxOyBpJDEgPCBuIC0gMTsgaSQxKyspIHtcbiAgICAgIHAwLnkgPSBwMS55O1xuICAgICAgcDEueCA9IHAyLng7XG4gICAgICBwMS55ID0gcDIueTtcbiAgICAgIHJpbmckMS5nZXRDb29yZGluYXRlKGkkMSArIDEsIHAyKTtcbiAgICAgIHAyLnggLT0geDAkMTtcbiAgICAgIHN1bSQxICs9IHAxLnggKiAocDAueSAtIHAyLnkpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtJDEgLyAyLjBcbiAgfVxufTtcbkNHQWxnb3JpdGhtcy5kaXN0YW5jZUxpbmVMaW5lID0gZnVuY3Rpb24gZGlzdGFuY2VMaW5lTGluZSAoQSwgQiwgQywgRCkge1xuICBpZiAoQS5lcXVhbHMoQikpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShBLCBDLCBEKSB9XG4gIGlmIChDLmVxdWFscyhEKSkgeyByZXR1cm4gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKEQsIEEsIEIpIH1cbiAgdmFyIG5vSW50ZXJzZWN0aW9uID0gZmFsc2U7XG4gIGlmICghRW52ZWxvcGUuaW50ZXJzZWN0cyhBLCBCLCBDLCBEKSkge1xuICAgIG5vSW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVub20gPSAoQi54IC0gQS54KSAqIChELnkgLSBDLnkpIC0gKEIueSAtIEEueSkgKiAoRC54IC0gQy54KTtcbiAgICBpZiAoZGVub20gPT09IDApIHtcbiAgICAgIG5vSW50ZXJzZWN0aW9uID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJOdW1iID0gKEEueSAtIEMueSkgKiAoRC54IC0gQy54KSAtIChBLnggLSBDLngpICogKEQueSAtIEMueSk7XG4gICAgICB2YXIgc051bSA9IChBLnkgLSBDLnkpICogKEIueCAtIEEueCkgLSAoQS54IC0gQy54KSAqIChCLnkgLSBBLnkpO1xuICAgICAgdmFyIHMgPSBzTnVtIC8gZGVub207XG4gICAgICB2YXIgciA9IHJOdW1iIC8gZGVub207XG4gICAgICBpZiAociA8IDAgfHwgciA+IDEgfHwgcyA8IDAgfHwgcyA+IDEpIHtcbiAgICAgICAgbm9JbnRlcnNlY3Rpb24gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobm9JbnRlcnNlY3Rpb24pIHtcbiAgICByZXR1cm4gTWF0aFV0aWwubWluKENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShBLCBDLCBEKSwgQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKEIsIEMsIEQpLCBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoQywgQSwgQiksIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShELCBBLCBCKSlcbiAgfVxuICByZXR1cm4gMC4wXG59O1xuQ0dBbGdvcml0aG1zLmlzUG9pbnRJblJpbmcgPSBmdW5jdGlvbiBpc1BvaW50SW5SaW5nIChwLCByaW5nKSB7XG4gIHJldHVybiBDR0FsZ29yaXRobXMubG9jYXRlUG9pbnRJblJpbmcocCwgcmluZykgIT09IExvY2F0aW9uLkVYVEVSSU9SXG59O1xuQ0dBbGdvcml0aG1zLmNvbXB1dGVMZW5ndGggPSBmdW5jdGlvbiBjb21wdXRlTGVuZ3RoIChwdHMpIHtcbiAgdmFyIG4gPSBwdHMuc2l6ZSgpO1xuICBpZiAobiA8PSAxKSB7IHJldHVybiAwLjAgfVxuICB2YXIgbGVuID0gMC4wO1xuICB2YXIgcCA9IG5ldyBDb29yZGluYXRlKCk7XG4gIHB0cy5nZXRDb29yZGluYXRlKDAsIHApO1xuICB2YXIgeDAgPSBwLng7XG4gIHZhciB5MCA9IHAueTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICBwdHMuZ2V0Q29vcmRpbmF0ZShpLCBwKTtcbiAgICB2YXIgeDEgPSBwLng7XG4gICAgdmFyIHkxID0gcC55O1xuICAgIHZhciBkeCA9IHgxIC0geDA7XG4gICAgdmFyIGR5ID0geTEgLSB5MDtcbiAgICBsZW4gKz0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICB4MCA9IHgxO1xuICAgIHkwID0geTE7XG4gIH1cbiAgcmV0dXJuIGxlblxufTtcbkNHQWxnb3JpdGhtcy5pc0NDVyA9IGZ1bmN0aW9uIGlzQ0NXIChyaW5nKSB7XG4gIHZhciBuUHRzID0gcmluZy5sZW5ndGggLSAxO1xuICBpZiAoblB0cyA8IDMpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignUmluZyBoYXMgZmV3ZXIgdGhhbiA0IHBvaW50cywgc28gb3JpZW50YXRpb24gY2Fubm90IGJlIGRldGVybWluZWQnKSB9XG4gIHZhciBoaVB0ID0gcmluZ1swXTtcbiAgdmFyIGhpSW5kZXggPSAwO1xuICBmb3IgKHZhciBpID0gMTsgaSA8PSBuUHRzOyBpKyspIHtcbiAgICB2YXIgcCA9IHJpbmdbaV07XG4gICAgaWYgKHAueSA+IGhpUHQueSkge1xuICAgICAgaGlQdCA9IHA7XG4gICAgICBoaUluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgdmFyIGlQcmV2ID0gaGlJbmRleDtcbiAgZG8ge1xuICAgIGlQcmV2ID0gaVByZXYgLSAxO1xuICAgIGlmIChpUHJldiA8IDApIHsgaVByZXYgPSBuUHRzOyB9XG4gIH0gd2hpbGUgKHJpbmdbaVByZXZdLmVxdWFsczJEKGhpUHQpICYmIGlQcmV2ICE9PSBoaUluZGV4KVxuICB2YXIgaU5leHQgPSBoaUluZGV4O1xuICBkbyB7XG4gICAgaU5leHQgPSAoaU5leHQgKyAxKSAlIG5QdHM7XG4gIH0gd2hpbGUgKHJpbmdbaU5leHRdLmVxdWFsczJEKGhpUHQpICYmIGlOZXh0ICE9PSBoaUluZGV4KVxuICB2YXIgcHJldiA9IHJpbmdbaVByZXZdO1xuICB2YXIgbmV4dCA9IHJpbmdbaU5leHRdO1xuICBpZiAocHJldi5lcXVhbHMyRChoaVB0KSB8fCBuZXh0LmVxdWFsczJEKGhpUHQpIHx8IHByZXYuZXF1YWxzMkQobmV4dCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGRpc2MgPSBDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHByZXYsIGhpUHQsIG5leHQpO1xuICB2YXIgaXNDQ1cgPSBmYWxzZTtcbiAgaWYgKGRpc2MgPT09IDApIHtcbiAgICBpc0NDVyA9IHByZXYueCA+IG5leHQueDtcbiAgfSBlbHNlIHtcbiAgICBpc0NDVyA9IGRpc2MgPiAwO1xuICB9XG4gIHJldHVybiBpc0NDV1xufTtcbkNHQWxnb3JpdGhtcy5sb2NhdGVQb2ludEluUmluZyA9IGZ1bmN0aW9uIGxvY2F0ZVBvaW50SW5SaW5nIChwLCByaW5nKSB7XG4gIHJldHVybiBSYXlDcm9zc2luZ0NvdW50ZXIubG9jYXRlUG9pbnRJblJpbmcocCwgcmluZylcbn07XG5DR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmVQZXJwZW5kaWN1bGFyID0gZnVuY3Rpb24gZGlzdGFuY2VQb2ludExpbmVQZXJwZW5kaWN1bGFyIChwLCBBLCBCKSB7XG4gIHZhciBsZW4yID0gKEIueCAtIEEueCkgKiAoQi54IC0gQS54KSArIChCLnkgLSBBLnkpICogKEIueSAtIEEueSk7XG4gIHZhciBzID0gKChBLnkgLSBwLnkpICogKEIueCAtIEEueCkgLSAoQS54IC0gcC54KSAqIChCLnkgLSBBLnkpKSAvIGxlbjI7XG4gIHJldHVybiBNYXRoLmFicyhzKSAqIE1hdGguc3FydChsZW4yKVxufTtcbkNHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24gPSBmdW5jdGlvbiBjb21wdXRlT3JpZW50YXRpb24gKHAxLCBwMiwgcSkge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgocDEsIHAyLCBxKVxufTtcbkNHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZSA9IGZ1bmN0aW9uIGRpc3RhbmNlUG9pbnRMaW5lICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGluZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAobGluZS5sZW5ndGggPT09IDApIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignTGluZSBhcnJheSBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIHZlcnRleCcpIH1cbiAgICB2YXIgbWluRGlzdGFuY2UgPSBwLmRpc3RhbmNlKGxpbmVbMF0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHAsIGxpbmVbaV0sIGxpbmVbaSArIDFdKTtcbiAgICAgIGlmIChkaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWluRGlzdGFuY2VcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIHAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgQSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgQiA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoQS54ID09PSBCLnggJiYgQS55ID09PSBCLnkpIHsgcmV0dXJuIHAkMS5kaXN0YW5jZShBKSB9XG4gICAgdmFyIGxlbjIgPSAoQi54IC0gQS54KSAqIChCLnggLSBBLngpICsgKEIueSAtIEEueSkgKiAoQi55IC0gQS55KTtcbiAgICB2YXIgciA9ICgocCQxLnggLSBBLngpICogKEIueCAtIEEueCkgKyAocCQxLnkgLSBBLnkpICogKEIueSAtIEEueSkpIC8gbGVuMjtcbiAgICBpZiAociA8PSAwLjApIHsgcmV0dXJuIHAkMS5kaXN0YW5jZShBKSB9XG4gICAgaWYgKHIgPj0gMS4wKSB7IHJldHVybiBwJDEuZGlzdGFuY2UoQikgfVxuICAgIHZhciBzID0gKChBLnkgLSBwJDEueSkgKiAoQi54IC0gQS54KSAtIChBLnggLSBwJDEueCkgKiAoQi55IC0gQS55KSkgLyBsZW4yO1xuICAgIHJldHVybiBNYXRoLmFicyhzKSAqIE1hdGguc3FydChsZW4yKVxuICB9XG59O1xuQ0dBbGdvcml0aG1zLmlzT25MaW5lID0gZnVuY3Rpb24gaXNPbkxpbmUgKHAsIHB0KSB7XG4gIHZhciBsaW5lSW50ZXJzZWN0b3IgPSBuZXcgUm9idXN0TGluZUludGVyc2VjdG9yKCk7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgcHQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcDAgPSBwdFtpIC0gMV07XG4gICAgdmFyIHAxID0gcHRbaV07XG4gICAgbGluZUludGVyc2VjdG9yLmNvbXB1dGVJbnRlcnNlY3Rpb24ocCwgcDAsIHAxKTtcbiAgICBpZiAobGluZUludGVyc2VjdG9yLmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMy5DTE9DS1dJU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTEgfTtcbnN0YXRpY0FjY2Vzc29ycyQzLlJJR0hULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5DTE9DS1dJU0UgfTtcbnN0YXRpY0FjY2Vzc29ycyQzLkNPVU5URVJDTE9DS1dJU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDMuTEVGVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDR0FsZ29yaXRobXMuQ09VTlRFUkNMT0NLV0lTRSB9O1xuc3RhdGljQWNjZXNzb3JzJDMuQ09MTElORUFSLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQzLlNUUkFJR0hULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5DT0xMSU5FQVIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENHQWxnb3JpdGhtcywgc3RhdGljQWNjZXNzb3JzJDMgKTtcblxudmFyIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyID0gZnVuY3Rpb24gR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIgKCkge307XG5cbkdlb21ldHJ5Q29tcG9uZW50RmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHt9O1xuR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeUNvbXBvbmVudEZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUNvbXBvbmVudEZpbHRlclxufTtcblxudmFyIEdlb21ldHJ5ID0gZnVuY3Rpb24gR2VvbWV0cnkgKCkge1xuICB2YXIgZmFjdG9yeSA9IGFyZ3VtZW50c1swXTtcblxuICB0aGlzLl9lbnZlbG9wZSA9IG51bGw7XG4gIHRoaXMuX2ZhY3RvcnkgPSBudWxsO1xuICB0aGlzLl9TUklEID0gbnVsbDtcbiAgdGhpcy5fdXNlckRhdGEgPSBudWxsO1xuICB0aGlzLl9mYWN0b3J5ID0gZmFjdG9yeTtcbiAgdGhpcy5fU1JJRCA9IGZhY3RvcnkuZ2V0U1JJRCgpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxMSA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfUE9JTlQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX01VTFRJUE9JTlQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX0xJTkVTVFJJTkc6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX0xJTkVBUlJJTkc6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU09SVElOREVYX01VTFRJTElORVNUUklORzogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfUE9MWUdPTjogeyBjb25maWd1cmFibGU6IHRydWUgfSxTT1JUSU5ERVhfTVVMVElQT0xZR09OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT046IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5HZW9tZXRyeS5wcm90b3R5cGUuaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiBpc0dlb21ldHJ5Q29sbGVjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmdldFNvcnRJbmRleCgpID09PSBHZW9tZXRyeS5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldEZhY3RvcnkgPSBmdW5jdGlvbiBnZXRGYWN0b3J5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ZhY3Rvcnlcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0R2VvbWV0cnlOID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlOIChuKSB7XG4gIHJldHVybiB0aGlzXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgcmV0dXJuIDAuMFxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5pc1JlY3RhbmdsZSA9IGZ1bmN0aW9uIGlzUmVjdGFuZ2xlICgpIHtcbiAgcmV0dXJuIGZhbHNlXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSkge1xuICAgIHZhciBnJDEgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGckMSA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiB0aGlzLmVxdWFsc1RvcG8oZyQxKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgIHZhciBvID0gYXJndW1lbnRzWzBdO1xuICAgIGlmICghKG8gaW5zdGFuY2VvZiBHZW9tZXRyeSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgZyA9IG87XG4gICAgcmV0dXJuIHRoaXMuZXF1YWxzRXhhY3QoZylcbiAgfVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0IChvdGhlcikge1xuICByZXR1cm4gdGhpcyA9PT0gb3RoZXIgfHwgdGhpcy5lcXVhbHNFeGFjdChvdGhlciwgMClcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2VvbWV0cnlDaGFuZ2VkID0gZnVuY3Rpb24gZ2VvbWV0cnlDaGFuZ2VkICgpIHtcbiAgdGhpcy5hcHBseShHZW9tZXRyeS5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIpO1xufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZW9tZXRyeUNoYW5nZWRBY3Rpb24gPSBmdW5jdGlvbiBnZW9tZXRyeUNoYW5nZWRBY3Rpb24gKCkge1xuICB0aGlzLl9lbnZlbG9wZSA9IG51bGw7XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmVxdWFsc05vcm0gPSBmdW5jdGlvbiBlcXVhbHNOb3JtIChnKSB7XG4gIGlmIChnID09PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0aGlzLm5vcm0oKS5lcXVhbHNFeGFjdChnLm5vcm0oKSlcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgcmV0dXJuIDAuMFxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXROdW1HZW9tZXRyaWVzID0gZnVuY3Rpb24gZ2V0TnVtR2VvbWV0cmllcyAoKSB7XG4gIHJldHVybiAxXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG8gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG90aGVyID0gbztcbiAgICBpZiAodGhpcy5nZXRTb3J0SW5kZXgoKSAhPT0gb3RoZXIuZ2V0U29ydEluZGV4KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFNvcnRJbmRleCgpIC0gb3RoZXIuZ2V0U29ydEluZGV4KClcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpICYmIG90aGVyLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgaWYgKG90aGVyLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIDFcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKG8pXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBvdGhlciQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb21wID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLmdldFNvcnRJbmRleCgpICE9PSBvdGhlciQxLmdldFNvcnRJbmRleCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSAtIG90aGVyJDEuZ2V0U29ydEluZGV4KClcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpICYmIG90aGVyJDEuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gMFxuICAgIH1cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICBpZiAob3RoZXIkMS5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAxXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyhvdGhlciQxLCBjb21wKVxuICB9XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmdldFVzZXJEYXRhID0gZnVuY3Rpb24gZ2V0VXNlckRhdGEgKCkge1xuICByZXR1cm4gdGhpcy5fdXNlckRhdGFcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0U1JJRCA9IGZ1bmN0aW9uIGdldFNSSUQgKCkge1xuICByZXR1cm4gdGhpcy5fU1JJRFxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRFbnZlbG9wZSA9IGZ1bmN0aW9uIGdldEVudmVsb3BlICgpIHtcbiAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkodGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkpXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uID0gZnVuY3Rpb24gY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24gKGcpIHtcbiAgaWYgKGcuZ2V0U29ydEluZGV4KCkgPT09IEdlb21ldHJ5LlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04pIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHMnKVxuICB9XG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gZXF1YWwgKGEsIGIsIHRvbGVyYW5jZSkge1xuICBpZiAodG9sZXJhbmNlID09PSAwKSB7XG4gICAgcmV0dXJuIGEuZXF1YWxzKGIpXG4gIH1cbiAgcmV0dXJuIGEuZGlzdGFuY2UoYikgPD0gdG9sZXJhbmNlXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLm5vcm0gPSBmdW5jdGlvbiBub3JtICgpIHtcbiAgdmFyIGNvcHkgPSB0aGlzLmNvcHkoKTtcbiAgY29weS5ub3JtYWxpemUoKTtcbiAgcmV0dXJuIGNvcHlcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0UHJlY2lzaW9uTW9kZWwgPSBmdW5jdGlvbiBnZXRQcmVjaXNpb25Nb2RlbCAoKSB7XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKClcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGdldEVudmVsb3BlSW50ZXJuYWwgKCkge1xuICBpZiAodGhpcy5fZW52ZWxvcGUgPT09IG51bGwpIHtcbiAgICB0aGlzLl9lbnZlbG9wZSA9IHRoaXMuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKTtcbiAgfVxuICByZXR1cm4gbmV3IEVudmVsb3BlKHRoaXMuX2VudmVsb3BlKVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5zZXRTUklEID0gZnVuY3Rpb24gc2V0U1JJRCAoU1JJRCkge1xuICB0aGlzLl9TUklEID0gU1JJRDtcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuc2V0VXNlckRhdGEgPSBmdW5jdGlvbiBzZXRVc2VyRGF0YSAodXNlckRhdGEpIHtcbiAgdGhpcy5fdXNlckRhdGEgPSB1c2VyRGF0YTtcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgdmFyIGkgPSBhLml0ZXJhdG9yKCk7XG4gIHZhciBqID0gYi5pdGVyYXRvcigpO1xuICB3aGlsZSAoaS5oYXNOZXh0KCkgJiYgai5oYXNOZXh0KCkpIHtcbiAgICB2YXIgYUVsZW1lbnQgPSBpLm5leHQoKTtcbiAgICB2YXIgYkVsZW1lbnQgPSBqLm5leHQoKTtcbiAgICB2YXIgY29tcGFyaXNvbiA9IGFFbGVtZW50LmNvbXBhcmVUbyhiRWxlbWVudCk7XG4gICAgaWYgKGNvbXBhcmlzb24gIT09IDApIHtcbiAgICAgIHJldHVybiBjb21wYXJpc29uXG4gICAgfVxuICB9XG4gIGlmIChpLmhhc05leHQoKSkge1xuICAgIHJldHVybiAxXG4gIH1cbiAgaWYgKGouaGFzTmV4dCgpKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgcmV0dXJuIDBcbn07XG5HZW9tZXRyeS5wcm90b3R5cGUuaGFzaENvZGUgPSBmdW5jdGlvbiBoYXNoQ29kZSAoKSB7XG4gIHJldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5oYXNoQ29kZSgpXG59O1xuR2VvbWV0cnkucHJvdG90eXBlLmlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkID0gZnVuY3Rpb24gaXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQgKCkge1xuICBpZiAodGhpcy5nZXRTb3J0SW5kZXgoKSA9PT0gR2VvbWV0cnkuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTiB8fCB0aGlzLmdldFNvcnRJbmRleCgpID09PSBHZW9tZXRyeS5TT1JUSU5ERVhfTVVMVElQT0lOVCB8fCB0aGlzLmdldFNvcnRJbmRleCgpID09PSBHZW9tZXRyeS5TT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HIHx8IHRoaXMuZ2V0U29ydEluZGV4KCkgPT09IEdlb21ldHJ5LlNPUlRJTkRFWF9NVUxUSVBPTFlHT04pIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDbG9uYWJsZSwgQ29tcGFyYWJsZSwgU2VyaWFsaXphYmxlXVxufTtcbkdlb21ldHJ5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5XG59O1xuR2VvbWV0cnkuaGFzTm9uRW1wdHlFbGVtZW50cyA9IGZ1bmN0aW9uIGhhc05vbkVtcHR5RWxlbWVudHMgKGdlb21ldHJpZXMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFnZW9tZXRyaWVzW2ldLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuR2VvbWV0cnkuaGFzTnVsbEVsZW1lbnRzID0gZnVuY3Rpb24gaGFzTnVsbEVsZW1lbnRzIChhcnJheSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycmF5W2ldID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA4NzYzNjIyNjc5MTg3Mzc2NzAyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX1BPSU5ULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfTVVMVElQT0lOVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX0xJTkVTVFJJTkcuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuc3RhdGljQWNjZXNzb3JzJDExLlNPUlRJTkRFWF9MSU5FQVJSSU5HLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMS5TT1JUSU5ERVhfUE9MWUdPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA1IH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX01VTFRJUE9MWUdPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA2IH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3IH07XG5zdGF0aWNBY2Nlc3NvcnMkMTEuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdlb21ldHJ5Q2hhbmdlZEZpbHRlciB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggR2VvbWV0cnksIHN0YXRpY0FjY2Vzc29ycyQxMSApO1xuXG52YXIgZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyID0gZnVuY3Rpb24gZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyICgpIHt9O1xuXG5nZW9tZXRyeUNoYW5nZWRGaWx0ZXIuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlDb21wb25lbnRGaWx0ZXJdXG59O1xuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZ2VvbSkge1xuICBnZW9tLmdlb21ldHJ5Q2hhbmdlZEFjdGlvbigpO1xufTtcblxudmFyIENvb3JkaW5hdGVGaWx0ZXIgPSBmdW5jdGlvbiBDb29yZGluYXRlRmlsdGVyICgpIHt9O1xuXG5Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGNvb3JkKSB7fTtcbkNvb3JkaW5hdGVGaWx0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVGaWx0ZXJcbn07XG5cbnZhciBCb3VuZGFyeU5vZGVSdWxlID0gZnVuY3Rpb24gQm91bmRhcnlOb2RlUnVsZSAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxMiA9IHsgTW9kMkJvdW5kYXJ5Tm9kZVJ1bGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTU9EMl9CT1VOREFSWV9SVUxFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEVORFBPSU5UX0JPVU5EQVJZX1JVTEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTVVMVElWQUxFTlRfRU5EUE9JTlRfQk9VTkRBUllfUlVMRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNT05PVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sT0dDX1NGU19CT1VOREFSWV9SVUxFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmlzSW5Cb3VuZGFyeSA9IGZ1bmN0aW9uIGlzSW5Cb3VuZGFyeSAoYm91bmRhcnlDb3VudCkge307XG5Cb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCb3VuZGFyeU5vZGVSdWxlXG59O1xuc3RhdGljQWNjZXNzb3JzJDEyLk1vZDJCb3VuZGFyeU5vZGVSdWxlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1vZDJCb3VuZGFyeU5vZGVSdWxlIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSB9O1xuc3RhdGljQWNjZXNzb3JzJDEyLk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuTU9EMl9CT1VOREFSWV9SVUxFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNb2QyQm91bmRhcnlOb2RlUnVsZSgpIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuRU5EUE9JTlRfQk9VTkRBUllfUlVMRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlKCkgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5NVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSgpIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTIuTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlKCkgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQm91bmRhcnlOb2RlUnVsZS5NT0QyX0JPVU5EQVJZX1JVTEUgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEJvdW5kYXJ5Tm9kZVJ1bGUsIHN0YXRpY0FjY2Vzc29ycyQxMiApO1xuXG52YXIgTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUgPSBmdW5jdGlvbiBNb2QyQm91bmRhcnlOb2RlUnVsZSAoKSB7fTtcblxuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmlzSW5Cb3VuZGFyeSA9IGZ1bmN0aW9uIGlzSW5Cb3VuZGFyeSAoYm91bmRhcnlDb3VudCkge1xuICByZXR1cm4gYm91bmRhcnlDb3VudCAlIDIgPT09IDFcbn07XG5Nb2QyQm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQm91bmRhcnlOb2RlUnVsZV1cbn07XG5Nb2QyQm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb2QyQm91bmRhcnlOb2RlUnVsZVxufTtcblxudmFyIEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSA9IGZ1bmN0aW9uIEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSAoKSB7fTtcblxuRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pc0luQm91bmRhcnkgPSBmdW5jdGlvbiBpc0luQm91bmRhcnkgKGJvdW5kYXJ5Q291bnQpIHtcbiAgcmV0dXJuIGJvdW5kYXJ5Q291bnQgPiAwXG59O1xuRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFyeU5vZGVSdWxlXVxufTtcbkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGVcbn07XG5cbnZhciBNdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSA9IGZ1bmN0aW9uIE11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlICgpIHt9O1xuXG5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuaXNJbkJvdW5kYXJ5ID0gZnVuY3Rpb24gaXNJbkJvdW5kYXJ5IChib3VuZGFyeUNvdW50KSB7XG4gIHJldHVybiBib3VuZGFyeUNvdW50ID4gMVxufTtcbk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtCb3VuZGFyeU5vZGVSdWxlXVxufTtcbk11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE11bHRpVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlXG59O1xuXG52YXIgTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZSA9IGZ1bmN0aW9uIE1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUgKCkge307XG5cbk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmlzSW5Cb3VuZGFyeSA9IGZ1bmN0aW9uIGlzSW5Cb3VuZGFyeSAoYm91bmRhcnlDb3VudCkge1xuICByZXR1cm4gYm91bmRhcnlDb3VudCA9PT0gMVxufTtcbk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0JvdW5kYXJ5Tm9kZVJ1bGVdXG59O1xuTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vVmFsZW50RW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlXG59O1xuXG4vLyBpbXBvcnQgSXRlcmF0b3IgZnJvbSAnLi9JdGVyYXRvcidcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9Db2xsZWN0aW9uLmh0bWxcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBDb2xsZWN0aW9uID0gZnVuY3Rpb24gQ29sbGVjdGlvbiAoKSB7fTtcblxuQ29sbGVjdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICgpIHt9O1xuXG4vKipcbiAqIEFwcGVuZHMgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiB0aGUgc3BlY2lmaWVkIGNvbGxlY3Rpb24gdG8gdGhlIGVuZCBvZiB0aGlzXG4gKiBsaXN0LCBpbiB0aGUgb3JkZXIgdGhhdCB0aGV5IGFyZSByZXR1cm5lZCBieSB0aGUgc3BlY2lmaWVkIGNvbGxlY3Rpb24nc1xuICogaXRlcmF0b3IgKG9wdGlvbmFsIG9wZXJhdGlvbikuXG4gKiBAcGFyYW0ge2phdmFzY3JpcHQudXRpbC5Db2xsZWN0aW9ufSBjXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiBhZGRBbGwgKCkge307XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY29sbGVjdGlvbiBjb250YWlucyBubyBlbGVtZW50cy5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbkNvbGxlY3Rpb24ucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZWxlbWVudHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICogQHJldHVybiB7amF2YXNjcmlwdC51dGlsLkl0ZXJhdG9yfVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZWxlbWVudHMgaW4gdGhpcyBjb2xsZWN0aW9uLlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiB0aGlzIGNvbGxlY3Rpb24uXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqL1xuQ29sbGVjdGlvbi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKCkge307XG5cbi8qKlxuICogUmVtb3ZlcyBhIHNpbmdsZSBpbnN0YW5jZSBvZiB0aGUgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gaWYgaXRcbiAqIGlzIHByZXNlbnQuIChvcHRpb25hbClcbiAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5Db2xsZWN0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge307XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2VcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbiAobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xufVxuSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5JbmRleE91dE9mQm91bmRzRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ0luZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb24nO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0l0ZXJhdG9yLmh0bWxcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEl0ZXJhdG9yID0gZnVuY3Rpb24gSXRlcmF0b3IgKCkge307XG5cbkl0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gaGFzTmV4dCAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IGVsZW1lbnQgaW4gdGhlIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuSXRlcmF0b3IucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHt9O1xuXG4vKipcbiAqIFJlbW92ZXMgZnJvbSB0aGUgdW5kZXJseWluZyBjb2xsZWN0aW9uIHRoZSBsYXN0IGVsZW1lbnQgcmV0dXJuZWQgYnkgdGhlXG4gKiBpdGVyYXRvciAob3B0aW9uYWwgb3BlcmF0aW9uKS5cbiAqL1xuSXRlcmF0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoKSB7fTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9MaXN0Lmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7amF2YXNjcmlwdC51dGlsLkNvbGxlY3Rpb259XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBMaXN0ID0gKGZ1bmN0aW9uIChDb2xsZWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIExpc3QgKCkge1xuICAgIENvbGxlY3Rpb24kJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggQ29sbGVjdGlvbiQkMSApIExpc3QuX19wcm90b19fID0gQ29sbGVjdGlvbiQkMTtcbiAgTGlzdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBDb2xsZWN0aW9uJCQxICYmIENvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIExpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTGlzdDtcblxuICBMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkgeyB9O1xuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgZWxlbWVudCBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIGluIHRoaXMgbGlzdCB3aXRoIHRoZVxuICAgKiBzcGVjaWZpZWQgZWxlbWVudCAob3B0aW9uYWwgb3BlcmF0aW9uKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIExpc3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoKSB7IH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNvbGxlY3Rpb24gY29udGFpbnMgbm8gZWxlbWVudHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBMaXN0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7IH07XG5cbiAgcmV0dXJuIExpc3Q7XG59KENvbGxlY3Rpb24pKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZVxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uIChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG59XG5Ob1N1Y2hFbGVtZW50RXhjZXB0aW9uLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4vKipcbiAqIEB0eXBlIHtzdHJpbmd9XG4gKi9cbk5vU3VjaEVsZW1lbnRFeGNlcHRpb24ucHJvdG90eXBlLm5hbWUgPSAnTm9TdWNoRWxlbWVudEV4Y2VwdGlvbic7XG5cbi8vIGltcG9ydCBPcGVyYXRpb25Ob3RTdXBwb3J0ZWQgZnJvbSAnLi9PcGVyYXRpb25Ob3RTdXBwb3J0ZWQnXG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvQXJyYXlMaXN0Lmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyBMaXN0XG4gKiBAcHJpdmF0ZVxuICovXG52YXIgQXJyYXlMaXN0ID0gKGZ1bmN0aW9uIChMaXN0JCQxKSB7XG4gIGZ1bmN0aW9uIEFycmF5TGlzdCAoKSB7XG4gICAgTGlzdCQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuYXJyYXlfID0gW107XG5cbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIExpc3QkJDEgKSBBcnJheUxpc3QuX19wcm90b19fID0gTGlzdCQkMTtcbiAgQXJyYXlMaXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpc3QkJDEgJiYgTGlzdCQkMS5wcm90b3R5cGUgKTtcbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFycmF5TGlzdDtcblxuICBBcnJheUxpc3QucHJvdG90eXBlLmVuc3VyZUNhcGFjaXR5ID0gZnVuY3Rpb24gZW5zdXJlQ2FwYWNpdHkgKCkge307XG4gIEFycmF5TGlzdC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7IHJldHVybiBbTGlzdCQkMSwgQ29sbGVjdGlvbl0gfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB0aGlzLmFycmF5Xy5wdXNoKGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFycmF5Xy5zcGxpY2UoYXJndW1lbnRzWzBdLCBhcmd1bWVudHNbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gICAgdGhpcy5hcnJheV8gPSBbXTtcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLmFkZEFsbCA9IGZ1bmN0aW9uIGFkZEFsbCAoYykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IGMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB0aGlzJDEuYWRkKGkubmV4dCgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoaW5kZXgsIGVsZW1lbnQpIHtcbiAgICB2YXIgb2xkRWxlbWVudCA9IHRoaXMuYXJyYXlfW2luZGV4XTtcbiAgICB0aGlzLmFycmF5X1tpbmRleF0gPSBlbGVtZW50O1xuICAgIHJldHVybiBvbGRFbGVtZW50XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHtcbiAgICByZXR1cm4gbmV3IEl0ZXJhdG9yXyh0aGlzKVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCkge1xuICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy5zaXplKCkpIHtcbiAgICAgIHRocm93IG5ldyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uKClcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcnJheV9baW5kZXhdXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgQXJyYXlMaXN0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGhcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBBcnJheUxpc3QucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXMkMS5hcnJheV9baV0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEFycmF5TGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChvKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLmFycmF5Xy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHRoaXMkMS5hcnJheV9baV0gPT09IG8pIHtcbiAgICAgICAgdGhpcyQxLmFycmF5Xy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZm91bmRcbiAgfTtcblxuICByZXR1cm4gQXJyYXlMaXN0O1xufShMaXN0KSk7XG5cbi8qKlxuICogQGV4dGVuZHMge0l0ZXJhdG9yfVxuICogQHBhcmFtIHtBcnJheUxpc3R9IGFycmF5TGlzdFxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSXRlcmF0b3JfID0gKGZ1bmN0aW9uIChJdGVyYXRvciQkMSkge1xuICBmdW5jdGlvbiBJdGVyYXRvcl8gKGFycmF5TGlzdCkge1xuICAgIEl0ZXJhdG9yJCQxLmNhbGwodGhpcyk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5TGlzdH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICovXG4gICAgdGhpcy5hcnJheUxpc3RfID0gYXJyYXlMaXN0O1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQHByaXZhdGVcbiAgICAqL1xuICAgIHRoaXMucG9zaXRpb25fID0gMDtcbiAgfVxuXG4gIGlmICggSXRlcmF0b3IkJDEgKSBJdGVyYXRvcl8uX19wcm90b19fID0gSXRlcmF0b3IkJDE7XG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJdGVyYXRvciQkMSAmJiBJdGVyYXRvciQkMS5wcm90b3R5cGUgKTtcbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEl0ZXJhdG9yXztcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiBuZXh0ICgpIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvbl8gPT09IHRoaXMuYXJyYXlMaXN0Xy5zaXplKCkpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlMaXN0Xy5nZXQodGhpcy5wb3NpdGlvbl8rKylcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiBoYXNOZXh0ICgpIHtcbiAgICBpZiAodGhpcy5wb3NpdGlvbl8gPCB0aGlzLmFycmF5TGlzdF8uc2l6ZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFRPRE86IHNob3VsZCBiZSBpbiBMaXN0SXRlcmF0b3JcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCAoZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5TGlzdF8uc2V0KHRoaXMucG9zaXRpb25fIC0gMSwgZWxlbWVudClcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgdGhpcy5hcnJheUxpc3RfLnJlbW92ZSh0aGlzLmFycmF5TGlzdF8uZ2V0KHRoaXMucG9zaXRpb25fKSk7XG4gIH07XG5cbiAgcmV0dXJuIEl0ZXJhdG9yXztcbn0oSXRlcmF0b3IpKTtcblxudmFyIENvb3JkaW5hdGVMaXN0ID0gKGZ1bmN0aW9uIChBcnJheUxpc3QkJDEpIHtcbiAgZnVuY3Rpb24gQ29vcmRpbmF0ZUxpc3QgKCkge1xuICAgIEFycmF5TGlzdCQkMS5jYWxsKHRoaXMpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmVuc3VyZUNhcGFjaXR5KGNvb3JkLmxlbmd0aCk7XG4gICAgICB0aGlzLmFkZChjb29yZCwgdHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgY29vcmQkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBhbGxvd1JlcGVhdGVkID0gYXJndW1lbnRzWzFdO1xuICAgICAgdGhpcy5lbnN1cmVDYXBhY2l0eShjb29yZCQxLmxlbmd0aCk7XG4gICAgICB0aGlzLmFkZChjb29yZCQxLCBhbGxvd1JlcGVhdGVkKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIEFycmF5TGlzdCQkMSApIENvb3JkaW5hdGVMaXN0Ll9fcHJvdG9fXyA9IEFycmF5TGlzdCQkMTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQXJyYXlMaXN0JCQxICYmIEFycmF5TGlzdCQkMS5wcm90b3R5cGUgKTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29vcmRpbmF0ZUxpc3Q7XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgY29vcmRBcnJheVR5cGU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgc3RhdGljQWNjZXNzb3JzLmNvb3JkQXJyYXlUeXBlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBcnJheSgwKS5maWxsKG51bGwpIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICAgIHJldHVybiB0aGlzLmdldChpKVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gYWRkQWxsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgY29sbCA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBhbGxvd1JlcGVhdGVkID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgZm9yICh2YXIgaSA9IGNvbGwuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHRoaXMkMS5hZGQoaS5uZXh0KCksIGFsbG93UmVwZWF0ZWQpO1xuICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQ2hhbmdlZFxuICAgIH0gZWxzZSB7IHJldHVybiBBcnJheUxpc3QkJDEucHJvdG90eXBlLmFkZEFsbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNsb25lID0gQXJyYXlMaXN0JCQxLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zaXplKCk7IGkrKykge1xuICAgICAgY2xvbmUuYWRkKGksIHRoaXMkMS5nZXQoaSkuY29weSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb25lXG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS50b0Nvb3JkaW5hdGVBcnJheSA9IGZ1bmN0aW9uIHRvQ29vcmRpbmF0ZUFycmF5ICgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5KENvb3JkaW5hdGVMaXN0LmNvb3JkQXJyYXlUeXBlKVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMF07XG4gICAgICBBcnJheUxpc3QkJDEucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsIGNvb3JkKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmFyIGNvb3JkJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBhbGxvd1JlcGVhdGVkID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB0aGlzLmFkZChjb29yZCQxLCBhbGxvd1JlcGVhdGVkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdmFyIGNvb3JkJDIgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBhbGxvd1JlcGVhdGVkJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIGlmICghYWxsb3dSZXBlYXRlZCQxKSB7XG4gICAgICAgICAgaWYgKHRoaXMuc2l6ZSgpID49IDEpIHtcbiAgICAgICAgICAgIHZhciBsYXN0ID0gdGhpcy5nZXQodGhpcy5zaXplKCkgLSAxKTtcbiAgICAgICAgICAgIGlmIChsYXN0LmVxdWFsczJEKGNvb3JkJDIpKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgQXJyYXlMaXN0JCQxLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLCBjb29yZCQyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdib29sZWFuJykge1xuICAgICAgICB2YXIgb2JqID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgYWxsb3dSZXBlYXRlZCQyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB0aGlzLmFkZChvYmosIGFsbG93UmVwZWF0ZWQkMik7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Jvb2xlYW4nICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnYm9vbGVhbicpKSB7XG4gICAgICAgIHZhciBjb29yZCQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgYWxsb3dSZXBlYXRlZCQzID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgZGlyZWN0aW9uID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY29vcmQkMy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgICB0aGlzJDEuYWRkKGNvb3JkJDNbaSQxXSwgYWxsb3dSZXBlYXRlZCQzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yICh2YXIgaSQyID0gY29vcmQkMy5sZW5ndGggLSAxOyBpJDIgPj0gMDsgaSQyLS0pIHtcbiAgICAgICAgICAgIHRoaXMkMS5hZGQoY29vcmQkM1tpJDJdLCBhbGxvd1JlcGVhdGVkJDMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnYm9vbGVhbicgJiYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgICAgICB2YXIgaSQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgY29vcmQkNCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGFsbG93UmVwZWF0ZWQkNCA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKCFhbGxvd1JlcGVhdGVkJDQpIHtcbiAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2l6ZSgpO1xuICAgICAgICAgIGlmIChzaXplID4gMCkge1xuICAgICAgICAgICAgaWYgKGkkMyA+IDApIHtcbiAgICAgICAgICAgICAgdmFyIHByZXYgPSB0aGlzLmdldChpJDMgLSAxKTtcbiAgICAgICAgICAgICAgaWYgKHByZXYuZXF1YWxzMkQoY29vcmQkNCkpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkkMyA8IHNpemUpIHtcbiAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmdldChpJDMpO1xuICAgICAgICAgICAgICBpZiAobmV4dC5lcXVhbHMyRChjb29yZCQ0KSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIEFycmF5TGlzdCQkMS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcywgaSQzLCBjb29yZCQ0KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICAgIHZhciBjb29yZCQ1ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGFsbG93UmVwZWF0ZWQkNSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBzdGFydCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBlbmQgPSBhcmd1bWVudHNbM107XG4gICAgICB2YXIgaW5jID0gMTtcbiAgICAgIGlmIChzdGFydCA+IGVuZCkgeyBpbmMgPSAtMTsgfVxuICAgICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpICE9PSBlbmQ7IGkgKz0gaW5jKSB7XG4gICAgICAgIHRoaXMkMS5hZGQoY29vcmQkNVtpXSwgYWxsb3dSZXBlYXRlZCQ1KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9O1xuICBDb29yZGluYXRlTGlzdC5wcm90b3R5cGUuY2xvc2VSaW5nID0gZnVuY3Rpb24gY2xvc2VSaW5nICgpIHtcbiAgICBpZiAodGhpcy5zaXplKCkgPiAwKSB7IHRoaXMuYWRkKG5ldyBDb29yZGluYXRlKHRoaXMuZ2V0KDApKSwgZmFsc2UpOyB9XG4gIH07XG4gIENvb3JkaW5hdGVMaXN0LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgQ29vcmRpbmF0ZUxpc3QucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBDb29yZGluYXRlTGlzdFxuICB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBDb29yZGluYXRlTGlzdCwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIENvb3JkaW5hdGVMaXN0O1xufShBcnJheUxpc3QpKTtcblxudmFyIENvb3JkaW5hdGVBcnJheXMgPSBmdW5jdGlvbiBDb29yZGluYXRlQXJyYXlzICgpIHt9O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDEzID0geyBGb3J3YXJkQ29tcGFyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxCaWRpcmVjdGlvbmFsQ29tcGFyYXRvcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxjb29yZEFycmF5VHlwZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5zdGF0aWNBY2Nlc3NvcnMkMTMuRm9yd2FyZENvbXBhcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gRm9yd2FyZENvbXBhcmF0b3IgfTtcbnN0YXRpY0FjY2Vzc29ycyQxMy5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBCaWRpcmVjdGlvbmFsQ29tcGFyYXRvciB9O1xuc3RhdGljQWNjZXNzb3JzJDEzLmNvb3JkQXJyYXlUeXBlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBBcnJheSgwKS5maWxsKG51bGwpIH07XG5cbkNvb3JkaW5hdGVBcnJheXMucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db29yZGluYXRlQXJyYXlzLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheXNcbn07XG5Db29yZGluYXRlQXJyYXlzLmlzUmluZyA9IGZ1bmN0aW9uIGlzUmluZyAocHRzKSB7XG4gIGlmIChwdHMubGVuZ3RoIDwgNCkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoIXB0c1swXS5lcXVhbHMyRChwdHNbcHRzLmxlbmd0aCAtIDFdKSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkNvb3JkaW5hdGVBcnJheXMucHROb3RJbkxpc3QgPSBmdW5jdGlvbiBwdE5vdEluTGlzdCAodGVzdFB0cywgcHRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGVzdFB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciB0ZXN0UHQgPSB0ZXN0UHRzW2ldO1xuICAgIGlmIChDb29yZGluYXRlQXJyYXlzLmluZGV4T2YodGVzdFB0LCBwdHMpIDwgMCkgeyByZXR1cm4gdGVzdFB0IH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcbkNvb3JkaW5hdGVBcnJheXMuc2Nyb2xsID0gZnVuY3Rpb24gc2Nyb2xsIChjb29yZGluYXRlcywgZmlyc3RDb29yZGluYXRlKSB7XG4gIHZhciBpID0gQ29vcmRpbmF0ZUFycmF5cy5pbmRleE9mKGZpcnN0Q29vcmRpbmF0ZSwgY29vcmRpbmF0ZXMpO1xuICBpZiAoaSA8IDApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgbmV3Q29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoY29vcmRpbmF0ZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICBTeXN0ZW0uYXJyYXljb3B5KGNvb3JkaW5hdGVzLCBpLCBuZXdDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMubGVuZ3RoIC0gaSk7XG4gIFN5c3RlbS5hcnJheWNvcHkoY29vcmRpbmF0ZXMsIDAsIG5ld0Nvb3JkaW5hdGVzLCBjb29yZGluYXRlcy5sZW5ndGggLSBpLCBpKTtcbiAgU3lzdGVtLmFycmF5Y29weShuZXdDb29yZGluYXRlcywgMCwgY29vcmRpbmF0ZXMsIDAsIGNvb3JkaW5hdGVzLmxlbmd0aCk7XG59O1xuQ29vcmRpbmF0ZUFycmF5cy5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBjb29yZDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvb3JkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoY29vcmQxID09PSBjb29yZDIpIHsgcmV0dXJuIHRydWUgfVxuICAgIGlmIChjb29yZDEgPT09IG51bGwgfHwgY29vcmQyID09PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGNvb3JkMS5sZW5ndGggIT09IGNvb3JkMi5sZW5ndGgpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFjb29yZDFbaV0uZXF1YWxzKGNvb3JkMltpXSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGNvb3JkMSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBjb29yZDIkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgY29vcmRpbmF0ZUNvbXBhcmF0b3IgPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGNvb3JkMSQxID09PSBjb29yZDIkMSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKGNvb3JkMSQxID09PSBudWxsIHx8IGNvb3JkMiQxID09PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKGNvb3JkMSQxLmxlbmd0aCAhPT0gY29vcmQyJDEubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY29vcmQxJDEubGVuZ3RoOyBpJDErKykge1xuICAgICAgaWYgKGNvb3JkaW5hdGVDb21wYXJhdG9yLmNvbXBhcmUoY29vcmQxJDFbaSQxXSwgY29vcmQyJDFbaSQxXSkgIT09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheXMuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChjb29yZGluYXRlcywgZW52KSB7XG4gIHZhciBjb29yZExpc3QgPSBuZXcgQ29vcmRpbmF0ZUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlbnYuaW50ZXJzZWN0cyhjb29yZGluYXRlc1tpXSkpIHsgY29vcmRMaXN0LmFkZChjb29yZGluYXRlc1tpXSwgdHJ1ZSk7IH1cbiAgfVxuICByZXR1cm4gY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KClcbn07XG5Db29yZGluYXRlQXJyYXlzLmhhc1JlcGVhdGVkUG9pbnRzID0gZnVuY3Rpb24gaGFzUmVwZWF0ZWRQb2ludHMgKGNvb3JkKSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgY29vcmQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29vcmRbaSAtIDFdLmVxdWFscyhjb29yZFtpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbkNvb3JkaW5hdGVBcnJheXMucmVtb3ZlUmVwZWF0ZWRQb2ludHMgPSBmdW5jdGlvbiByZW1vdmVSZXBlYXRlZFBvaW50cyAoY29vcmQpIHtcbiAgaWYgKCFDb29yZGluYXRlQXJyYXlzLmhhc1JlcGVhdGVkUG9pbnRzKGNvb3JkKSkgeyByZXR1cm4gY29vcmQgfVxuICB2YXIgY29vcmRMaXN0ID0gbmV3IENvb3JkaW5hdGVMaXN0KGNvb3JkLCBmYWxzZSk7XG4gIHJldHVybiBjb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKVxufTtcbkNvb3JkaW5hdGVBcnJheXMucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKGNvb3JkKSB7XG4gIHZhciBsYXN0ID0gY29vcmQubGVuZ3RoIC0gMTtcbiAgdmFyIG1pZCA9IE1hdGgudHJ1bmMobGFzdCAvIDIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8PSBtaWQ7IGkrKykge1xuICAgIHZhciB0bXAgPSBjb29yZFtpXTtcbiAgICBjb29yZFtpXSA9IGNvb3JkW2xhc3QgLSBpXTtcbiAgICBjb29yZFtsYXN0IC0gaV0gPSB0bXA7XG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlzLnJlbW92ZU51bGwgPSBmdW5jdGlvbiByZW1vdmVOdWxsIChjb29yZCkge1xuICB2YXIgbm9uTnVsbCA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29vcmRbaV0gIT09IG51bGwpIHsgbm9uTnVsbCsrOyB9XG4gIH1cbiAgdmFyIG5ld0Nvb3JkID0gbmV3IEFycmF5KG5vbk51bGwpLmZpbGwobnVsbCk7XG4gIGlmIChub25OdWxsID09PSAwKSB7IHJldHVybiBuZXdDb29yZCB9XG4gIHZhciBqID0gMDtcbiAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY29vcmQubGVuZ3RoOyBpJDErKykge1xuICAgIGlmIChjb29yZFtpJDFdICE9PSBudWxsKSB7IG5ld0Nvb3JkW2orK10gPSBjb29yZFtpJDFdOyB9XG4gIH1cbiAgcmV0dXJuIG5ld0Nvb3JkXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5jb3B5RGVlcCA9IGZ1bmN0aW9uIGNvcHlEZWVwICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvcHkgPSBuZXcgQXJyYXkoY29vcmRpbmF0ZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvcHlbaV0gPSBuZXcgQ29vcmRpbmF0ZShjb29yZGluYXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNSkge1xuICAgIHZhciBzcmMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNyY1N0YXJ0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBkZXN0ID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBkZXN0U3RhcnQgPSBhcmd1bWVudHNbM107XG4gICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50c1s0XTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsZW5ndGg7IGkkMSsrKSB7XG4gICAgICBkZXN0W2Rlc3RTdGFydCArIGkkMV0gPSBuZXcgQ29vcmRpbmF0ZShzcmNbc3JjU3RhcnQgKyBpJDFdKTtcbiAgICB9XG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlzLmlzRXF1YWxSZXZlcnNlZCA9IGZ1bmN0aW9uIGlzRXF1YWxSZXZlcnNlZCAocHRzMSwgcHRzMikge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0czEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcDEgPSBwdHMxW2ldO1xuICAgIHZhciBwMiA9IHB0czJbcHRzMS5sZW5ndGggLSBpIC0gMV07XG4gICAgaWYgKHAxLmNvbXBhcmVUbyhwMikgIT09IDApIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkNvb3JkaW5hdGVBcnJheXMuZW52ZWxvcGUgPSBmdW5jdGlvbiBlbnZlbG9wZSAoY29vcmRpbmF0ZXMpIHtcbiAgdmFyIGVudiA9IG5ldyBFbnZlbG9wZSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZW52LmV4cGFuZFRvSW5jbHVkZShjb29yZGluYXRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGVudlxufTtcbkNvb3JkaW5hdGVBcnJheXMudG9Db29yZGluYXRlQXJyYXkgPSBmdW5jdGlvbiB0b0Nvb3JkaW5hdGVBcnJheSAoY29vcmRMaXN0KSB7XG4gIHJldHVybiBjb29yZExpc3QudG9BcnJheShDb29yZGluYXRlQXJyYXlzLmNvb3JkQXJyYXlUeXBlKVxufTtcbkNvb3JkaW5hdGVBcnJheXMuYXRMZWFzdE5Db29yZGluYXRlc09yTm90aGluZyA9IGZ1bmN0aW9uIGF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmcgKG4sIGMpIHtcbiAgcmV0dXJuIGMubGVuZ3RoID49IG4gPyBjIDogW11cbn07XG5Db29yZGluYXRlQXJyYXlzLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mIChjb29yZGluYXRlLCBjb29yZGluYXRlcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGNvb3JkaW5hdGUuZXF1YWxzKGNvb3JkaW5hdGVzW2ldKSkge1xuICAgICAgcmV0dXJuIGlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xXG59O1xuQ29vcmRpbmF0ZUFycmF5cy5pbmNyZWFzaW5nRGlyZWN0aW9uID0gZnVuY3Rpb24gaW5jcmVhc2luZ0RpcmVjdGlvbiAocHRzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC50cnVuYyhwdHMubGVuZ3RoIC8gMik7IGkrKykge1xuICAgIHZhciBqID0gcHRzLmxlbmd0aCAtIDEgLSBpO1xuICAgIHZhciBjb21wID0gcHRzW2ldLmNvbXBhcmVUbyhwdHNbal0pO1xuICAgIGlmIChjb21wICE9PSAwKSB7IHJldHVybiBjb21wIH1cbiAgfVxuICByZXR1cm4gMVxufTtcbkNvb3JkaW5hdGVBcnJheXMuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHB0czEsIHB0czIpIHtcbiAgdmFyIGkgPSAwO1xuICB3aGlsZSAoaSA8IHB0czEubGVuZ3RoICYmIGkgPCBwdHMyLmxlbmd0aCkge1xuICAgIHZhciBjb21wYXJlID0gcHRzMVtpXS5jb21wYXJlVG8ocHRzMltpXSk7XG4gICAgaWYgKGNvbXBhcmUgIT09IDApIHsgcmV0dXJuIGNvbXBhcmUgfVxuICAgIGkrKztcbiAgfVxuICBpZiAoaSA8IHB0czIubGVuZ3RoKSB7IHJldHVybiAtMSB9XG4gIGlmIChpIDwgcHRzMS5sZW5ndGgpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkNvb3JkaW5hdGVBcnJheXMubWluQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIG1pbkNvb3JkaW5hdGUgKGNvb3JkaW5hdGVzKSB7XG4gIHZhciBtaW5Db29yZCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobWluQ29vcmQgPT09IG51bGwgfHwgbWluQ29vcmQuY29tcGFyZVRvKGNvb3JkaW5hdGVzW2ldKSA+IDApIHtcbiAgICAgIG1pbkNvb3JkID0gY29vcmRpbmF0ZXNbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW5Db29yZFxufTtcbkNvb3JkaW5hdGVBcnJheXMuZXh0cmFjdCA9IGZ1bmN0aW9uIGV4dHJhY3QgKHB0cywgc3RhcnQsIGVuZCkge1xuICBzdGFydCA9IE1hdGhVdGlsLmNsYW1wKHN0YXJ0LCAwLCBwdHMubGVuZ3RoKTtcbiAgZW5kID0gTWF0aFV0aWwuY2xhbXAoZW5kLCAtMSwgcHRzLmxlbmd0aCk7XG4gIHZhciBucHRzID0gZW5kIC0gc3RhcnQgKyAxO1xuICBpZiAoZW5kIDwgMCkgeyBucHRzID0gMDsgfVxuICBpZiAoc3RhcnQgPj0gcHRzLmxlbmd0aCkgeyBucHRzID0gMDsgfVxuICBpZiAoZW5kIDwgc3RhcnQpIHsgbnB0cyA9IDA7IH1cbiAgdmFyIGV4dHJhY3RQdHMgPSBuZXcgQXJyYXkobnB0cykuZmlsbChudWxsKTtcbiAgaWYgKG5wdHMgPT09IDApIHsgcmV0dXJuIGV4dHJhY3RQdHMgfVxuICB2YXIgaVB0cyA9IDA7XG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8PSBlbmQ7IGkrKykge1xuICAgIGV4dHJhY3RQdHNbaVB0cysrXSA9IHB0c1tpXTtcbiAgfVxuICByZXR1cm4gZXh0cmFjdFB0c1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvb3JkaW5hdGVBcnJheXMsIHN0YXRpY0FjY2Vzc29ycyQxMyApO1xuXG52YXIgRm9yd2FyZENvbXBhcmF0b3IgPSBmdW5jdGlvbiBGb3J3YXJkQ29tcGFyYXRvciAoKSB7fTtcblxuRm9yd2FyZENvbXBhcmF0b3IucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChvMSwgbzIpIHtcbiAgdmFyIHB0czEgPSBvMTtcbiAgdmFyIHB0czIgPSBvMjtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheXMuY29tcGFyZShwdHMxLCBwdHMyKVxufTtcbkZvcndhcmRDb21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhdG9yXVxufTtcbkZvcndhcmRDb21wYXJhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEZvcndhcmRDb21wYXJhdG9yXG59O1xuXG52YXIgQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IgPSBmdW5jdGlvbiBCaWRpcmVjdGlvbmFsQ29tcGFyYXRvciAoKSB7fTtcblxuQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChvMSwgbzIpIHtcbiAgdmFyIHB0czEgPSBvMTtcbiAgdmFyIHB0czIgPSBvMjtcbiAgaWYgKHB0czEubGVuZ3RoIDwgcHRzMi5sZW5ndGgpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHB0czEubGVuZ3RoID4gcHRzMi5sZW5ndGgpIHsgcmV0dXJuIDEgfVxuICBpZiAocHRzMS5sZW5ndGggPT09IDApIHsgcmV0dXJuIDAgfVxuICB2YXIgZm9yd2FyZENvbXAgPSBDb29yZGluYXRlQXJyYXlzLmNvbXBhcmUocHRzMSwgcHRzMik7XG4gIHZhciBpc0VxdWFsUmV2ID0gQ29vcmRpbmF0ZUFycmF5cy5pc0VxdWFsUmV2ZXJzZWQocHRzMSwgcHRzMik7XG4gIGlmIChpc0VxdWFsUmV2KSB7IHJldHVybiAwIH1cbiAgcmV0dXJuIGZvcndhcmRDb21wXG59O1xuQmlkaXJlY3Rpb25hbENvbXBhcmF0b3IucHJvdG90eXBlLk9MRGNvbXBhcmUgPSBmdW5jdGlvbiBPTERjb21wYXJlIChvMSwgbzIpIHtcbiAgdmFyIHB0czEgPSBvMTtcbiAgdmFyIHB0czIgPSBvMjtcbiAgaWYgKHB0czEubGVuZ3RoIDwgcHRzMi5sZW5ndGgpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHB0czEubGVuZ3RoID4gcHRzMi5sZW5ndGgpIHsgcmV0dXJuIDEgfVxuICBpZiAocHRzMS5sZW5ndGggPT09IDApIHsgcmV0dXJuIDAgfVxuICB2YXIgZGlyMSA9IENvb3JkaW5hdGVBcnJheXMuaW5jcmVhc2luZ0RpcmVjdGlvbihwdHMxKTtcbiAgdmFyIGRpcjIgPSBDb29yZGluYXRlQXJyYXlzLmluY3JlYXNpbmdEaXJlY3Rpb24ocHRzMik7XG4gIHZhciBpMSA9IGRpcjEgPiAwID8gMCA6IHB0czEubGVuZ3RoIC0gMTtcbiAgdmFyIGkyID0gZGlyMiA+IDAgPyAwIDogcHRzMS5sZW5ndGggLSAxO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0czEubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY29tcGFyZVB0ID0gcHRzMVtpMV0uY29tcGFyZVRvKHB0czJbaTJdKTtcbiAgICBpZiAoY29tcGFyZVB0ICE9PSAwKSB7IHJldHVybiBjb21wYXJlUHQgfVxuICAgIGkxICs9IGRpcjE7XG4gICAgaTIgKz0gZGlyMjtcbiAgfVxuICByZXR1cm4gMFxufTtcbkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhdG9yXVxufTtcbkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJpZGlyZWN0aW9uYWxDb21wYXJhdG9yXG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL01hcC5odG1sXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgTWFwJDEgPSBmdW5jdGlvbiBNYXAgKCkge307XG5cbk1hcCQxLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKCkge307XG4vKipcbiAqIEFzc29jaWF0ZXMgdGhlIHNwZWNpZmllZCB2YWx1ZSB3aXRoIHRoZSBzcGVjaWZpZWQga2V5IGluIHRoaXMgbWFwIChvcHRpb25hbFxuICogb3BlcmF0aW9uKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5NYXAkMS5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gcHV0ICgpIHt9O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiBrZXktdmFsdWUgbWFwcGluZ3MgaW4gdGhpcyBtYXAuXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbk1hcCQxLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7fTtcblxuLyoqXG4gKiBSZXR1cm5zIGEgQ29sbGVjdGlvbiB2aWV3IG9mIHRoZSB2YWx1ZXMgY29udGFpbmVkIGluIHRoaXMgbWFwLlxuICogQHJldHVybiB7amF2YXNjcmlwdC51dGlsLkNvbGxlY3Rpb259XG4gKi9cbk1hcCQxLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMgKCkge307XG5cbi8qKlxuICogUmV0dXJucyBhIHtAbGluayBTZXR9IHZpZXcgb2YgdGhlIG1hcHBpbmdzIGNvbnRhaW5lZCBpbiB0aGlzIG1hcC5cbiAqIFRoZSBzZXQgaXMgYmFja2VkIGJ5IHRoZSBtYXAsIHNvIGNoYW5nZXMgdG8gdGhlIG1hcCBhcmVcbiAqIHJlZmxlY3RlZCBpbiB0aGUgc2V0LCBhbmQgdmljZS12ZXJzYS5JZiB0aGUgbWFwIGlzIG1vZGlmaWVkXG4gKiB3aGlsZSBhbiBpdGVyYXRpb24gb3ZlciB0aGUgc2V0IGlzIGluIHByb2dyZXNzIChleGNlcHQgdGhyb3VnaFxuICogdGhlIGl0ZXJhdG9yJ3Mgb3duIDx0dD5yZW1vdmU8L3R0PiBvcGVyYXRpb24sIG9yIHRocm91Z2ggdGhlXG4gKiA8dHQ+c2V0VmFsdWU8L3R0PiBvcGVyYXRpb24gb24gYSBtYXAgZW50cnkgcmV0dXJuZWQgYnkgdGhlXG4gKiBpdGVyYXRvcikgdGhlIHJlc3VsdHMgb2YgdGhlIGl0ZXJhdGlvbiBhcmUgdW5kZWZpbmVkLlRoZSBzZXRcbiAqIHN1cHBvcnRzIGVsZW1lbnQgcmVtb3ZhbCwgd2hpY2ggcmVtb3ZlcyB0aGUgY29ycmVzcG9uZGluZ1xuICogbWFwcGluZyBmcm9tIHRoZSBtYXAsIHZpYSB0aGUgPHR0Pkl0ZXJhdG9yLnJlbW92ZTwvdHQ+LFxuICogPHR0PlNldC5yZW1vdmU8L3R0PiwgPHR0PnJlbW92ZUFsbDwvdHQ+LCA8dHQ+cmV0YWluQWxsPC90dD4gYW5kXG4gKiA8dHQ+Y2xlYXI8L3R0PiBvcGVyYXRpb25zLkl0IGRvZXMgbm90IHN1cHBvcnQgdGhlXG4gKiA8dHQ+YWRkPC90dD4gb3IgPHR0PmFkZEFsbDwvdHQ+IG9wZXJhdGlvbnMuXG4gKlxuICogQHJldHVybiB7U2V0fSBhIHNldCB2aWV3IG9mIHRoZSBtYXBwaW5ncyBjb250YWluZWQgaW4gdGhpcyBtYXBcbiAqL1xuTWFwJDEucHJvdG90eXBlLmVudHJ5U2V0ID0gZnVuY3Rpb24gZW50cnlTZXQgKCkge307XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvU29ydGVkTWFwLmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7TWFwfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgU29ydGVkTWFwID0gKGZ1bmN0aW9uIChNYXApIHtcblx0ZnVuY3Rpb24gU29ydGVkTWFwICgpIHtcblx0XHRNYXAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fWlmICggTWFwICkgU29ydGVkTWFwLl9fcHJvdG9fXyA9IE1hcDtcblx0U29ydGVkTWFwLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIE1hcCAmJiBNYXAucHJvdG90eXBlICk7XG5cdFNvcnRlZE1hcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTb3J0ZWRNYXA7XG5cblx0XG5cblx0cmV0dXJuIFNvcnRlZE1hcDtcbn0oTWFwJDEpKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgT3B0aW9uYWwgbWVzc2FnZVxuICogQGV4dGVuZHMge0Vycm9yfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBPcGVyYXRpb25Ob3RTdXBwb3J0ZWQgKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZSB8fCAnJztcbn1cbk9wZXJhdGlvbk5vdFN1cHBvcnRlZC5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5PcGVyYXRpb25Ob3RTdXBwb3J0ZWQucHJvdG90eXBlLm5hbWUgPSAnT3BlcmF0aW9uTm90U3VwcG9ydGVkJztcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9TZXQuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtDb2xsZWN0aW9ufVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBTZXQoKSB7fVxuU2V0LnByb3RvdHlwZSA9IG5ldyBDb2xsZWN0aW9uKCk7XG5cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBzZXQgY29udGFpbnMgdGhlIHNwZWNpZmllZCBlbGVtZW50LiBNb3JlIGZvcm1hbGx5LFxuICogcmV0dXJucyB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoaXMgc2V0IGNvbnRhaW5zIGFuIGVsZW1lbnQgZSBzdWNoIHRoYXQgKG89PW51bGwgP1xuICogZT09bnVsbCA6IG8uZXF1YWxzKGUpKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5TZXQucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0hhc2hTZXQuaHRtbFxuICpcbiAqIEBleHRlbmRzIHtqYXZhc2NyaXB0LnV0aWwuU2V0fVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgSGFzaFNldCA9IChmdW5jdGlvbiAoU2V0JCQxKSB7XG4gIGZ1bmN0aW9uIEhhc2hTZXQgKCkge1xuICAgIFNldCQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuYXJyYXlfID0gW107XG5cbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29sbGVjdGlvbikge1xuICAgICAgdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIFNldCQkMSApIEhhc2hTZXQuX19wcm90b19fID0gU2V0JCQxO1xuICBIYXNoU2V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFNldCQkMSAmJiBTZXQkJDEucHJvdG90eXBlICk7XG4gIEhhc2hTZXQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSGFzaFNldDtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uIGNvbnRhaW5zIChvKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBlID0gdGhpcyQxLmFycmF5X1tpXTtcbiAgICAgIGlmIChlID09PSBvKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobykge1xuICAgIGlmICh0aGlzLmNvbnRhaW5zKG8pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICB0aGlzLmFycmF5Xy5wdXNoKG8pO1xuXG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiBhZGRBbGwgKGMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSBjLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdGhpcyQxLmFkZChpLm5leHQoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChvKSB7XG4gICAgLy8gdGhyb3cgbmV3IGphdmFzY3JpcHQudXRpbC5PcGVyYXRpb25Ob3RTdXBwb3J0ZWQoKVxuICAgIHRocm93IG5ldyBFcnJvcigpXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaFNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGhcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoU2V0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcnJheS5wdXNoKHRoaXMkMS5hcnJheV9baV0pO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hTZXQucHJvdG90eXBlLml0ZXJhdG9yID0gZnVuY3Rpb24gaXRlcmF0b3IgKCkge1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3JfJDEodGhpcylcbiAgfTtcblxuICByZXR1cm4gSGFzaFNldDtcbn0oU2V0KSk7XG5cbi8qKlxuICAgKiBAZXh0ZW5kcyB7SXRlcmF0b3J9XG4gICAqIEBwYXJhbSB7SGFzaFNldH0gaGFzaFNldFxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQHByaXZhdGVcbiAgICovXG52YXIgSXRlcmF0b3JfJDEgPSAoZnVuY3Rpb24gKEl0ZXJhdG9yJCQxKSB7XG4gIGZ1bmN0aW9uIEl0ZXJhdG9yXyAoaGFzaFNldCkge1xuICAgIEl0ZXJhdG9yJCQxLmNhbGwodGhpcyk7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0hhc2hTZXR9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmhhc2hTZXRfID0gaGFzaFNldDtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5wb3NpdGlvbl8gPSAwO1xuICB9XG5cbiAgaWYgKCBJdGVyYXRvciQkMSApIEl0ZXJhdG9yXy5fX3Byb3RvX18gPSBJdGVyYXRvciQkMTtcbiAgSXRlcmF0b3JfLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEl0ZXJhdG9yJCQxICYmIEl0ZXJhdG9yJCQxLnByb3RvdHlwZSApO1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSXRlcmF0b3JfO1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEl0ZXJhdG9yXy5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIG5leHQgKCkge1xuICAgIGlmICh0aGlzLnBvc2l0aW9uXyA9PT0gdGhpcy5oYXNoU2V0Xy5zaXplKCkpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hFbGVtZW50RXhjZXB0aW9uKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFzaFNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSXRlcmF0b3JfLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gaGFzTmV4dCAoKSB7XG4gICAgaWYgKHRoaXMucG9zaXRpb25fIDwgdGhpcy5oYXNoU2V0Xy5zaXplKCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBJdGVyYXRvcl8ucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gICAgdGhyb3cgbmV3IE9wZXJhdGlvbk5vdFN1cHBvcnRlZCgpXG4gIH07XG5cbiAgcmV0dXJuIEl0ZXJhdG9yXztcbn0oSXRlcmF0b3IpKTtcblxudmFyIEJMQUNLID0gMDtcbnZhciBSRUQgPSAxO1xuZnVuY3Rpb24gY29sb3JPZiAocCkgeyByZXR1cm4gKHAgPT09IG51bGwgPyBCTEFDSyA6IHAuY29sb3IpIH1cbmZ1bmN0aW9uIHBhcmVudE9mIChwKSB7IHJldHVybiAocCA9PT0gbnVsbCA/IG51bGwgOiBwLnBhcmVudCkgfVxuZnVuY3Rpb24gc2V0Q29sb3IgKHAsIGMpIHsgaWYgKHAgIT09IG51bGwpIHsgcC5jb2xvciA9IGM7IH0gfVxuZnVuY3Rpb24gbGVmdE9mIChwKSB7IHJldHVybiAocCA9PT0gbnVsbCA/IG51bGwgOiBwLmxlZnQpIH1cbmZ1bmN0aW9uIHJpZ2h0T2YgKHApIHsgcmV0dXJuIChwID09PSBudWxsID8gbnVsbCA6IHAucmlnaHQpIH1cblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly9kb3dubG9hZC5vcmFjbGUuY29tL2phdmFzZS82L2RvY3MvYXBpL2phdmEvdXRpbC9UcmVlTWFwLmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7U29ydGVkTWFwfVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBUcmVlTWFwICgpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLnJvb3RfID0gbnVsbDtcbiAgLyoqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICovXG4gIHRoaXMuc2l6ZV8gPSAwO1xufVxuVHJlZU1hcC5wcm90b3R5cGUgPSBuZXcgU29ydGVkTWFwKCk7XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdmFyIHAgPSB0aGlzLnJvb3RfO1xuICB3aGlsZSAocCAhPT0gbnVsbCkge1xuICAgIHZhciBjbXAgPSBrZXlbJ2NvbXBhcmVUbyddKHAua2V5KTtcbiAgICBpZiAoY21wIDwgMCkgeyBwID0gcC5sZWZ0OyB9XG4gICAgZWxzZSBpZiAoY21wID4gMCkgeyBwID0gcC5yaWdodDsgfVxuICAgIGVsc2UgeyByZXR1cm4gcC52YWx1ZSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIGlmICh0aGlzLnJvb3RfID09PSBudWxsKSB7XG4gICAgdGhpcy5yb290XyA9IHtcbiAgICAgIGtleToga2V5LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbGVmdDogbnVsbCxcbiAgICAgIHJpZ2h0OiBudWxsLFxuICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgY29sb3I6IEJMQUNLLFxuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlICgpIHsgcmV0dXJuIHRoaXMudmFsdWUgfSxcbiAgICAgIGdldEtleTogZnVuY3Rpb24gZ2V0S2V5ICgpIHsgcmV0dXJuIHRoaXMua2V5IH1cbiAgICB9O1xuICAgIHRoaXMuc2l6ZV8gPSAxO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgdmFyIHQgPSB0aGlzLnJvb3RfO1xuICB2YXIgcGFyZW50O1xuICB2YXIgY21wO1xuICBkbyB7XG4gICAgcGFyZW50ID0gdDtcbiAgICBjbXAgPSBrZXlbJ2NvbXBhcmVUbyddKHQua2V5KTtcbiAgICBpZiAoY21wIDwgMCkge1xuICAgICAgdCA9IHQubGVmdDtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHQgPSB0LnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb2xkVmFsdWUgPSB0LnZhbHVlO1xuICAgICAgdC52YWx1ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIG9sZFZhbHVlXG4gICAgfVxuICB9IHdoaWxlICh0ICE9PSBudWxsKVxuICB2YXIgZSA9IHtcbiAgICBrZXk6IGtleSxcbiAgICBsZWZ0OiBudWxsLFxuICAgIHJpZ2h0OiBudWxsLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBwYXJlbnQ6IHBhcmVudCxcbiAgICBjb2xvcjogQkxBQ0ssXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlICgpIHsgcmV0dXJuIHRoaXMudmFsdWUgfSxcbiAgICBnZXRLZXk6IGZ1bmN0aW9uIGdldEtleSAoKSB7IHJldHVybiB0aGlzLmtleSB9XG4gIH07XG4gIGlmIChjbXAgPCAwKSB7XG4gICAgcGFyZW50LmxlZnQgPSBlO1xuICB9IGVsc2Uge1xuICAgIHBhcmVudC5yaWdodCA9IGU7XG4gIH1cbiAgdGhpcy5maXhBZnRlckluc2VydGlvbihlKTtcbiAgdGhpcy5zaXplXysrO1xuICByZXR1cm4gbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0geFxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5maXhBZnRlckluc2VydGlvbiA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHguY29sb3IgPSBSRUQ7XG4gIHdoaWxlICh4ICE9IG51bGwgJiYgeCAhPT0gdGhpcy5yb290XyAmJiB4LnBhcmVudC5jb2xvciA9PT0gUkVEKSB7XG4gICAgaWYgKHBhcmVudE9mKHgpID09PSBsZWZ0T2YocGFyZW50T2YocGFyZW50T2YoeCkpKSkge1xuICAgICAgdmFyIHkgPSByaWdodE9mKHBhcmVudE9mKHBhcmVudE9mKHgpKSk7XG4gICAgICBpZiAoY29sb3JPZih5KSA9PT0gUkVEKSB7XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHgpLCBCTEFDSyk7XG4gICAgICAgIHNldENvbG9yKHksIEJMQUNLKTtcbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YocGFyZW50T2YoeCkpLCBSRUQpO1xuICAgICAgICB4ID0gcGFyZW50T2YocGFyZW50T2YoeCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHggPT09IHJpZ2h0T2YocGFyZW50T2YoeCkpKSB7XG4gICAgICAgICAgeCA9IHBhcmVudE9mKHgpO1xuICAgICAgICAgIHRoaXMkMS5yb3RhdGVMZWZ0KHgpO1xuICAgICAgICB9XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHgpLCBCTEFDSyk7XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHBhcmVudE9mKHgpKSwgUkVEKTtcbiAgICAgICAgdGhpcyQxLnJvdGF0ZVJpZ2h0KHBhcmVudE9mKHBhcmVudE9mKHgpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB5JDEgPSBsZWZ0T2YocGFyZW50T2YocGFyZW50T2YoeCkpKTtcbiAgICAgIGlmIChjb2xvck9mKHkkMSkgPT09IFJFRCkge1xuICAgICAgICBzZXRDb2xvcihwYXJlbnRPZih4KSwgQkxBQ0spO1xuICAgICAgICBzZXRDb2xvcih5JDEsIEJMQUNLKTtcbiAgICAgICAgc2V0Q29sb3IocGFyZW50T2YocGFyZW50T2YoeCkpLCBSRUQpO1xuICAgICAgICB4ID0gcGFyZW50T2YocGFyZW50T2YoeCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHggPT09IGxlZnRPZihwYXJlbnRPZih4KSkpIHtcbiAgICAgICAgICB4ID0gcGFyZW50T2YoeCk7XG4gICAgICAgICAgdGhpcyQxLnJvdGF0ZVJpZ2h0KHgpO1xuICAgICAgICB9XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHgpLCBCTEFDSyk7XG4gICAgICAgIHNldENvbG9yKHBhcmVudE9mKHBhcmVudE9mKHgpKSwgUkVEKTtcbiAgICAgICAgdGhpcyQxLnJvdGF0ZUxlZnQocGFyZW50T2YocGFyZW50T2YoeCkpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhpcy5yb290Xy5jb2xvciA9IEJMQUNLO1xufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgYXJyYXlMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgcCA9IHRoaXMuZ2V0Rmlyc3RFbnRyeSgpO1xuICBpZiAocCAhPT0gbnVsbCkge1xuICAgIGFycmF5TGlzdC5hZGQocC52YWx1ZSk7XG4gICAgd2hpbGUgKChwID0gVHJlZU1hcC5zdWNjZXNzb3IocCkpICE9PSBudWxsKSB7XG4gICAgICBhcnJheUxpc3QuYWRkKHAudmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXlMaXN0XG59O1xuXG4vKipcbiAqIEBvdmVycmlkZVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5lbnRyeVNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhhc2hTZXQgPSBuZXcgSGFzaFNldCgpO1xuICB2YXIgcCA9IHRoaXMuZ2V0Rmlyc3RFbnRyeSgpO1xuICBpZiAocCAhPT0gbnVsbCkge1xuICAgIGhhc2hTZXQuYWRkKHApO1xuICAgIHdoaWxlICgocCA9IFRyZWVNYXAuc3VjY2Vzc29yKHApKSAhPT0gbnVsbCkge1xuICAgICAgaGFzaFNldC5hZGQocCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBoYXNoU2V0XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBmdW5jdGlvbiAocCkge1xuICBpZiAocCAhPSBudWxsKSB7XG4gICAgdmFyIHIgPSBwLnJpZ2h0O1xuICAgIHAucmlnaHQgPSByLmxlZnQ7XG4gICAgaWYgKHIubGVmdCAhPSBudWxsKSB7IHIubGVmdC5wYXJlbnQgPSBwOyB9XG4gICAgci5wYXJlbnQgPSBwLnBhcmVudDtcbiAgICBpZiAocC5wYXJlbnQgPT09IG51bGwpIHsgdGhpcy5yb290XyA9IHI7IH0gZWxzZSBpZiAocC5wYXJlbnQubGVmdCA9PT0gcCkgeyBwLnBhcmVudC5sZWZ0ID0gcjsgfSBlbHNlIHsgcC5wYXJlbnQucmlnaHQgPSByOyB9XG4gICAgci5sZWZ0ID0gcDtcbiAgICBwLnBhcmVudCA9IHI7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IHBcbiAqL1xuVHJlZU1hcC5wcm90b3R5cGUucm90YXRlUmlnaHQgPSBmdW5jdGlvbiAocCkge1xuICBpZiAocCAhPSBudWxsKSB7XG4gICAgdmFyIGwgPSBwLmxlZnQ7XG4gICAgcC5sZWZ0ID0gbC5yaWdodDtcbiAgICBpZiAobC5yaWdodCAhPSBudWxsKSB7IGwucmlnaHQucGFyZW50ID0gcDsgfVxuICAgIGwucGFyZW50ID0gcC5wYXJlbnQ7XG4gICAgaWYgKHAucGFyZW50ID09PSBudWxsKSB7IHRoaXMucm9vdF8gPSBsOyB9IGVsc2UgaWYgKHAucGFyZW50LnJpZ2h0ID09PSBwKSB7IHAucGFyZW50LnJpZ2h0ID0gbDsgfSBlbHNlIHsgcC5wYXJlbnQubGVmdCA9IGw7IH1cbiAgICBsLnJpZ2h0ID0gcDtcbiAgICBwLnBhcmVudCA9IGw7XG4gIH1cbn07XG5cbi8qKlxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5UcmVlTWFwLnByb3RvdHlwZS5nZXRGaXJzdEVudHJ5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcCA9IHRoaXMucm9vdF87XG4gIGlmIChwICE9IG51bGwpIHtcbiAgICB3aGlsZSAocC5sZWZ0ICE9IG51bGwpIHtcbiAgICAgIHAgPSBwLmxlZnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBwXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSB0XG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5UcmVlTWFwLnN1Y2Nlc3NvciA9IGZ1bmN0aW9uICh0KSB7XG4gIGlmICh0ID09PSBudWxsKSB7IHJldHVybiBudWxsIH0gZWxzZSBpZiAodC5yaWdodCAhPT0gbnVsbCkge1xuICAgIHZhciBwID0gdC5yaWdodDtcbiAgICB3aGlsZSAocC5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICBwID0gcC5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gcFxuICB9IGVsc2Uge1xuICAgIHZhciBwJDEgPSB0LnBhcmVudDtcbiAgICB2YXIgY2ggPSB0O1xuICAgIHdoaWxlIChwJDEgIT09IG51bGwgJiYgY2ggPT09IHAkMS5yaWdodCkge1xuICAgICAgY2ggPSBwJDE7XG4gICAgICBwJDEgPSBwJDEucGFyZW50O1xuICAgIH1cbiAgICByZXR1cm4gcCQxXG4gIH1cbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVNYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnNpemVfXG59O1xuXG52YXIgTGluZWFsID0gZnVuY3Rpb24gTGluZWFsICgpIHt9O1xuXG5MaW5lYWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5MaW5lYWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGluZWFsXG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL1NvcnRlZFNldC5odG1sXG4gKlxuICogQGV4dGVuZHMge1NldH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU29ydGVkU2V0ICgpIHt9XG5Tb3J0ZWRTZXQucHJvdG90eXBlID0gbmV3IFNldCgpO1xuXG4vLyBpbXBvcnQgSXRlcmF0b3IgZnJvbSAnLi9JdGVyYXRvcidcbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvVHJlZVNldC5odG1sXG4gKlxuICogQGV4dGVuZHMge1NvcnRlZFNldH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gVHJlZVNldCAoKSB7XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXl9XG4gICAqIEBwcml2YXRlXG4gICovXG4gIHRoaXMuYXJyYXlfID0gW107XG5cbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvbGxlY3Rpb24pIHtcbiAgICB0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pO1xuICB9XG59XG5UcmVlU2V0LnByb3RvdHlwZSA9IG5ldyBTb3J0ZWRTZXQoKTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZVNldC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAobykge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IHRoaXMkMS5hcnJheV9baV07XG4gICAgaWYgKGVbJ2NvbXBhcmVUbyddKG8pID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLmNvbnRhaW5zKG8pKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZSA9IHRoaXMkMS5hcnJheV9baV07XG4gICAgaWYgKGVbJ2NvbXBhcmVUbyddKG8pID09PSAxKSB7XG4gICAgICB0aGlzJDEuYXJyYXlfLnNwbGljZShpLCAwLCBvKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgdGhpcy5hcnJheV8ucHVzaChvKTtcblxuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZVNldC5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGMpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IGMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdGhpcyQxLmFkZChpLm5leHQoKSk7XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblRyZWVTZXQucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gIHRocm93IG5ldyBPcGVyYXRpb25Ob3RTdXBwb3J0ZWQoKVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZVNldC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aFxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZVNldC5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aCA9PT0gMFxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZVNldC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGFycmF5ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuYXJyYXlfLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyYXkucHVzaCh0aGlzJDEuYXJyYXlfW2ldKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuVHJlZVNldC5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgSXRlcmF0b3JfJDIodGhpcylcbn07XG5cbi8qKlxuICogQGV4dGVuZHMge2phdmFzY3JpcHQudXRpbC5JdGVyYXRvcn1cbiAqIEBwYXJhbSB7amF2YXNjcmlwdC51dGlsLlRyZWVTZXR9IHRyZWVTZXRcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEl0ZXJhdG9yXyQyID0gZnVuY3Rpb24gKHRyZWVTZXQpIHtcbiAgLyoqXG4gICAqIEB0eXBlIHtqYXZhc2NyaXB0LnV0aWwuVHJlZVNldH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMudHJlZVNldF8gPSB0cmVlU2V0O1xuICAvKipcbiAgICogQHR5cGUge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXMucG9zaXRpb25fID0gMDtcbn07XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cbkl0ZXJhdG9yXyQyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5wb3NpdGlvbl8gPT09IHRoaXMudHJlZVNldF8uc2l6ZSgpKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaEVsZW1lbnRFeGNlcHRpb24oKVxuICB9XG4gIHJldHVybiB0aGlzLnRyZWVTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuSXRlcmF0b3JfJDIucHJvdG90eXBlLmhhc05leHQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnBvc2l0aW9uXyA8IHRoaXMudHJlZVNldF8uc2l6ZSgpKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuSXRlcmF0b3JfJDIucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhyb3cgbmV3IE9wZXJhdGlvbk5vdFN1cHBvcnRlZCgpXG59O1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL0FycmF5cy5odG1sXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgQXJyYXlzID0gZnVuY3Rpb24gQXJyYXlzICgpIHt9O1xuXG5BcnJheXMuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKCkge1xuICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGk7XG4gIHZhciB0O1xuICB2YXIgY29tcGFyYXRvcjtcbiAgdmFyIGNvbXBhcmU7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5jb21wYXJlVG8oYilcbiAgICB9O1xuICAgIGEuc29ydChjb21wYXJlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgY29tcGFyYXRvciA9IGFyZ3VtZW50c1sxXTtcbiAgICBjb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBjb21wYXJhdG9yWydjb21wYXJlJ10oYSwgYilcbiAgICB9O1xuICAgIGEuc29ydChjb21wYXJlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdCA9IGEuc2xpY2UoYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgIHQuc29ydCgpO1xuICAgIHZhciByID0gYS5zbGljZSgwLCBhcmd1bWVudHNbMV0pLmNvbmNhdCh0LCBhLnNsaWNlKGFyZ3VtZW50c1syXSwgYS5sZW5ndGgpKTtcbiAgICBhLnNwbGljZSgwLCBhLmxlbmd0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcbiAgICAgIGEucHVzaChyW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHQgPSBhLnNsaWNlKGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICBjb21wYXJhdG9yID0gYXJndW1lbnRzWzNdO1xuICAgIGNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGNvbXBhcmF0b3JbJ2NvbXBhcmUnXShhLCBiKVxuICAgIH07XG4gICAgdC5zb3J0KGNvbXBhcmUpO1xuICAgIHIgPSBhLnNsaWNlKDAsIGFyZ3VtZW50c1sxXSkuY29uY2F0KHQsIGEuc2xpY2UoYXJndW1lbnRzWzJdLCBhLmxlbmd0aCkpO1xuICAgIGEuc3BsaWNlKDAsIGEubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgci5sZW5ndGg7IGkrKykge1xuICAgICAgYS5wdXNoKHJbaV0pO1xuICAgIH1cbiAgfVxufTtcbi8qKlxuICogQHBhcmFtIHtBcnJheX0gYXJyYXlcbiAqIEByZXR1cm4ge0FycmF5TGlzdH1cbiAqL1xuQXJyYXlzLmFzTGlzdCA9IGZ1bmN0aW9uIGFzTGlzdCAoYXJyYXkpIHtcbiAgdmFyIGFycmF5TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyYXlMaXN0LmFkZChhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIGFycmF5TGlzdFxufTtcblxudmFyIERpbWVuc2lvbiA9IGZ1bmN0aW9uIERpbWVuc2lvbiAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxNCA9IHsgUDogeyBjb25maWd1cmFibGU6IHRydWUgfSxMOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEE6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sRkFMU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sVFJVRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxET05UQ0FSRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxTWU1fRkFMU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1lNX1RSVUU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1lNX0RPTlRDQVJFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNZTV9QOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNZTV9MOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LFNZTV9BOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbnN0YXRpY0FjY2Vzc29ycyQxNC5QLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5MLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5BLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDIgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5GQUxTRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMSB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlRSVUUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTIgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5ET05UQ0FSRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMyB9O1xuc3RhdGljQWNjZXNzb3JzJDE0LlNZTV9GQUxTRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnRicgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5TWU1fVFJVRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnVCcgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNC5TWU1fRE9OVENBUkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJyonIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuU1lNX1AuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzAnIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuU1lNX0wuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzEnIH07XG5zdGF0aWNBY2Nlc3NvcnMkMTQuU1lNX0EuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJzInIH07XG5cbkRpbWVuc2lvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkRpbWVuc2lvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBEaW1lbnNpb25cbn07XG5EaW1lbnNpb24udG9EaW1lbnNpb25TeW1ib2wgPSBmdW5jdGlvbiB0b0RpbWVuc2lvblN5bWJvbCAoZGltZW5zaW9uVmFsdWUpIHtcbiAgc3dpdGNoIChkaW1lbnNpb25WYWx1ZSkge1xuICAgIGNhc2UgRGltZW5zaW9uLkZBTFNFOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5TWU1fRkFMU0VcbiAgICBjYXNlIERpbWVuc2lvbi5UUlVFOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5TWU1fVFJVRVxuICAgIGNhc2UgRGltZW5zaW9uLkRPTlRDQVJFOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5TWU1fRE9OVENBUkVcbiAgICBjYXNlIERpbWVuc2lvbi5QOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5TWU1fUFxuICAgIGNhc2UgRGltZW5zaW9uLkw6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLlNZTV9MXG4gICAgY2FzZSBEaW1lbnNpb24uQTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uU1lNX0FcbiAgICBkZWZhdWx0OlxuICB9XG4gIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1Vua25vd24gZGltZW5zaW9uIHZhbHVlOiAnICsgZGltZW5zaW9uVmFsdWUpXG59O1xuRGltZW5zaW9uLnRvRGltZW5zaW9uVmFsdWUgPSBmdW5jdGlvbiB0b0RpbWVuc2lvblZhbHVlIChkaW1lbnNpb25TeW1ib2wpIHtcbiAgc3dpdGNoIChDaGFyYWN0ZXIudG9VcHBlckNhc2UoZGltZW5zaW9uU3ltYm9sKSkge1xuICAgIGNhc2UgRGltZW5zaW9uLlNZTV9GQUxTRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uRkFMU0VcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fVFJVRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uVFJVRVxuICAgIGNhc2UgRGltZW5zaW9uLlNZTV9ET05UQ0FSRTpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uRE9OVENBUkVcbiAgICBjYXNlIERpbWVuc2lvbi5TWU1fUDpcbiAgICAgIHJldHVybiBEaW1lbnNpb24uUFxuICAgIGNhc2UgRGltZW5zaW9uLlNZTV9MOlxuICAgICAgcmV0dXJuIERpbWVuc2lvbi5MXG4gICAgY2FzZSBEaW1lbnNpb24uU1lNX0E6XG4gICAgICByZXR1cm4gRGltZW5zaW9uLkFcbiAgICBkZWZhdWx0OlxuICB9XG4gIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1Vua25vd24gZGltZW5zaW9uIHN5bWJvbDogJyArIGRpbWVuc2lvblN5bWJvbClcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBEaW1lbnNpb24sIHN0YXRpY0FjY2Vzc29ycyQxNCApO1xuXG52YXIgR2VvbWV0cnlGaWx0ZXIgPSBmdW5jdGlvbiBHZW9tZXRyeUZpbHRlciAoKSB7fTtcblxuR2VvbWV0cnlGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZ2VvbSkge307XG5HZW9tZXRyeUZpbHRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5RmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5RmlsdGVyXG59O1xuXG52YXIgQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyID0gZnVuY3Rpb24gQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyICgpIHt9O1xuXG5Db29yZGluYXRlU2VxdWVuY2VGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoc2VxLCBpKSB7fTtcbkNvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlci5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyLnByb3RvdHlwZS5pc0dlb21ldHJ5Q2hhbmdlZCA9IGZ1bmN0aW9uIGlzR2VvbWV0cnlDaGFuZ2VkICgpIHt9O1xuQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlclxufTtcblxudmFyIEdlb21ldHJ5Q29sbGVjdGlvbiA9IChmdW5jdGlvbiAoR2VvbWV0cnkkJDEpIHtcbiAgZnVuY3Rpb24gR2VvbWV0cnlDb2xsZWN0aW9uIChnZW9tZXRyaWVzLCBmYWN0b3J5KSB7XG4gICAgR2VvbWV0cnkkJDEuY2FsbCh0aGlzLCBmYWN0b3J5KTtcbiAgICB0aGlzLl9nZW9tZXRyaWVzID0gZ2VvbWV0cmllcyB8fCBbXTtcblxuICAgIGlmIChHZW9tZXRyeSQkMS5oYXNOdWxsRWxlbWVudHModGhpcy5fZ2VvbWV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2dlb21ldHJpZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzJylcbiAgICB9XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5JCQxICkgR2VvbWV0cnlDb2xsZWN0aW9uLl9fcHJvdG9fXyA9IEdlb21ldHJ5JCQxO1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkkJDEgJiYgR2VvbWV0cnkkJDEucHJvdG90eXBlICk7XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW9tZXRyeUNvbGxlY3Rpb247XG5cbiAgdmFyIHN0YXRpY0FjY2Vzc29ycyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmNvbXB1dGVFbnZlbG9wZUludGVybmFsID0gZnVuY3Rpb24gY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGVudmVsb3BlID0gbmV3IEVudmVsb3BlKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbnZlbG9wZS5leHBhbmRUb0luY2x1ZGUodGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7XG4gICAgfVxuICAgIHJldHVybiBlbnZlbG9wZVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEdlb21ldHJ5TiA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5TiAobikge1xuICAgIHJldHVybiB0aGlzLl9nZW9tZXRyaWVzW25dXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkkJDEuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTlxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNvb3JkaW5hdGVzID0gbmV3IEFycmF5KHRoaXMuZ2V0TnVtUG9pbnRzKCkpLmZpbGwobnVsbCk7XG4gICAgdmFyIGsgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZENvb3JkaW5hdGVzID0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkQ29vcmRpbmF0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaysrO1xuICAgICAgICBjb29yZGluYXRlc1trXSA9IGNoaWxkQ29vcmRpbmF0ZXNbal07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb29yZGluYXRlc1xuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldEFyZWEgPSBmdW5jdGlvbiBnZXRBcmVhICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcmVhID0gMC4wO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJlYSArPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0QXJlYSgpO1xuICAgIH1cbiAgICByZXR1cm4gYXJlYVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgdmFyIG90aGVyQ29sbGVjdGlvbiA9IG90aGVyO1xuICAgICAgaWYgKHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoICE9PSBvdGhlckNvbGxlY3Rpb24uX2dlb21ldHJpZXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmVxdWFsc0V4YWN0KG90aGVyQ29sbGVjdGlvbi5fZ2VvbWV0cmllc1tpXSwgdG9sZXJhbmNlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7IHJldHVybiBHZW9tZXRyeSQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcyQxLl9nZW9tZXRyaWVzW2ldLm5vcm1hbGl6ZSgpO1xuICAgIH1cbiAgICBBcnJheXMuc29ydCh0aGlzLl9nZW9tZXRyaWVzKTtcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cmllc1swXS5nZXRDb29yZGluYXRlKClcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRCb3VuZGFyeURpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5RGltZW5zaW9uICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBkaW1lbnNpb24gPSBEaW1lbnNpb24uRkFMU0U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkaW1lbnNpb24gPSBNYXRoLm1heChkaW1lbnNpb24sIHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpbWVuc2lvblxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZGltZW5zaW9uID0gRGltZW5zaW9uLkZBTFNFO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGltZW5zaW9uID0gTWF0aC5tYXgoZGltZW5zaW9uLCB0aGlzJDEuX2dlb21ldHJpZXNbaV0uZ2V0RGltZW5zaW9uKCkpO1xuICAgIH1cbiAgICByZXR1cm4gZGltZW5zaW9uXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzdW0gPSAwLjA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBzdW0gKz0gdGhpcyQxLl9nZW9tZXRyaWVzW2ldLmdldExlbmd0aCgpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0TnVtUG9pbnRzID0gZnVuY3Rpb24gZ2V0TnVtUG9pbnRzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBudW1Qb2ludHMgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgbnVtUG9pbnRzICs9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5nZXROdW1Qb2ludHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bVBvaW50c1xuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmdldE51bUdlb21ldHJpZXMgPSBmdW5jdGlvbiBnZXROdW1HZW9tZXRyaWVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGhcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbiA9IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO1xuICAgIHZhciByZXZHZW9tcyA9IG5ldyBBcnJheShuKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmV2R2VvbXNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKHJldkdlb21zKVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmNvbXBhcmVUb1NhbWVDbGFzcyA9IGZ1bmN0aW9uIGNvbXBhcmVUb1NhbWVDbGFzcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIG8gPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdGhlc2VFbGVtZW50cyA9IG5ldyBUcmVlU2V0KEFycmF5cy5hc0xpc3QodGhpcy5fZ2VvbWV0cmllcykpO1xuICAgICAgdmFyIG90aGVyRWxlbWVudHMgPSBuZXcgVHJlZVNldChBcnJheXMuYXNMaXN0KG8uX2dlb21ldHJpZXMpKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmUodGhlc2VFbGVtZW50cywgb3RoZXJFbGVtZW50cylcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY29tcCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBnYyA9IG8kMTtcbiAgICAgIHZhciBuMSA9IHRoaXMuZ2V0TnVtR2VvbWV0cmllcygpO1xuICAgICAgdmFyIG4yID0gZ2MuZ2V0TnVtR2VvbWV0cmllcygpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBuMSAmJiBpIDwgbjIpIHtcbiAgICAgICAgdmFyIHRoaXNHZW9tID0gdGhpcyQxLmdldEdlb21ldHJ5TihpKTtcbiAgICAgICAgdmFyIG90aGVyR2VvbSA9IGdjLmdldEdlb21ldHJ5TihpKTtcbiAgICAgICAgdmFyIGhvbGVDb21wID0gdGhpc0dlb20uY29tcGFyZVRvU2FtZUNsYXNzKG90aGVyR2VvbSwgY29tcCk7XG4gICAgICAgIGlmIChob2xlQ29tcCAhPT0gMCkgeyByZXR1cm4gaG9sZUNvbXAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IG4xKSB7IHJldHVybiAxIH1cbiAgICAgIGlmIChpIDwgbjIpIHsgcmV0dXJuIC0xIH1cbiAgICAgIHJldHVybiAwXG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5hcHBseShmaWx0ZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoID09PSAwKSB7IHJldHVybiBudWxsIH1cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuX2dlb21ldHJpZXNbaSQxXS5hcHBseShmaWx0ZXIkMSk7XG4gICAgICAgIGlmIChmaWx0ZXIkMS5pc0RvbmUoKSkge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXIkMS5pc0dlb21ldHJ5Q2hhbmdlZCgpKSB7IHRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCk7IH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEdlb21ldHJ5RmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgZmlsdGVyJDIuZmlsdGVyKHRoaXMpO1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgIHRoaXMkMS5fZ2VvbWV0cmllc1tpJDJdLmFwcGx5KGZpbHRlciQyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEdlb21ldHJ5Q29tcG9uZW50RmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZmlsdGVyJDMuZmlsdGVyKHRoaXMpO1xuICAgICAgZm9yICh2YXIgaSQzID0gMDsgaSQzIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkkMysrKSB7XG4gICAgICAgIHRoaXMkMS5fZ2VvbWV0cmllc1tpJDNdLmFwcGx5KGZpbHRlciQzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKTtcbiAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKTtcbiAgICByZXR1cm4gbnVsbFxuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGdjID0gR2VvbWV0cnkkJDEucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7XG4gICAgZ2MuX2dlb21ldHJpZXMgPSBuZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBnYy5fZ2VvbWV0cmllc1tpXSA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5jbG9uZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZ2NcbiAgfTtcbiAgR2VvbWV0cnlDb2xsZWN0aW9uLnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xuICB9O1xuICBHZW9tZXRyeUNvbGxlY3Rpb24ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBnZW9tZXRyaWVzID0gbmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgZ2VvbWV0cmllc1tpXSA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5jb3B5KCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMsIHRoaXMuX2ZhY3RvcnkpXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIXRoaXMkMS5fZ2VvbWV0cmllc1tpXS5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIEdlb21ldHJ5Q29sbGVjdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvblxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNTY5NDcyNzcyNjM5NTAyMTQ2NyB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBHZW9tZXRyeUNvbGxlY3Rpb24sIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb247XG59KEdlb21ldHJ5KSk7XG5cbnZhciBNdWx0aUxpbmVTdHJpbmcgPSAoZnVuY3Rpb24gKEdlb21ldHJ5Q29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBNdWx0aUxpbmVTdHJpbmcgKCkge1xuICAgIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeUNvbGxlY3Rpb24kJDEgKSBNdWx0aUxpbmVTdHJpbmcuX19wcm90b19fID0gR2VvbWV0cnlDb2xsZWN0aW9uJCQxO1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnlDb2xsZWN0aW9uJCQxICYmIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpTGluZVN0cmluZztcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeS5TT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLCBvdGhlciwgdG9sZXJhbmNlKVxuICAgIH0gZWxzZSB7IHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKCkpIHtcbiAgICAgIHJldHVybiBEaW1lbnNpb24uRkFMU0VcbiAgICB9XG4gICAgcmV0dXJuIDBcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCF0aGlzJDEuX2dlb21ldHJpZXNbaV0uaXNDbG9zZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXREaW1lbnNpb24gPSBmdW5jdGlvbiBnZXREaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAxXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG5MaW5lcyA9IHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoO1xuICAgIHZhciByZXZMaW5lcyA9IG5ldyBBcnJheShuTGluZXMpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXZMaW5lc1tuTGluZXMgLSAxIC0gaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHJldkxpbmVzKVxuICB9O1xuICBNdWx0aUxpbmVTdHJpbmcucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRhcnlPcCh0aGlzKS5nZXRCb3VuZGFyeSgpXG4gIH07XG4gIE11bHRpTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ011bHRpTGluZVN0cmluZydcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbGluZVN0cmluZ3MgPSBuZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lU3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgbGluZVN0cmluZ3NbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uY29weSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE11bHRpTGluZVN0cmluZyhsaW5lU3RyaW5ncywgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW0xpbmVhbF1cbiAgfTtcbiAgTXVsdGlMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTXVsdGlMaW5lU3RyaW5nXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDgxNjY2NjUxMzI0NDU0MzM3NDEgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTXVsdGlMaW5lU3RyaW5nLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTXVsdGlMaW5lU3RyaW5nO1xufShHZW9tZXRyeUNvbGxlY3Rpb24pKTtcblxudmFyIEJvdW5kYXJ5T3AgPSBmdW5jdGlvbiBCb3VuZGFyeU9wICgpIHtcbiAgdGhpcy5fZ2VvbSA9IG51bGw7XG4gIHRoaXMuX2dlb21GYWN0ID0gbnVsbDtcbiAgdGhpcy5fYm5SdWxlID0gbnVsbDtcbiAgdGhpcy5fZW5kcG9pbnRNYXAgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBiblJ1bGUgPSBCb3VuZGFyeU5vZGVSdWxlLk1PRDJfQk9VTkRBUllfUlVMRTtcbiAgICB0aGlzLl9nZW9tID0gZ2VvbTtcbiAgICB0aGlzLl9nZW9tRmFjdCA9IGdlb20uZ2V0RmFjdG9yeSgpO1xuICAgIHRoaXMuX2JuUnVsZSA9IGJuUnVsZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb20kMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYm5SdWxlJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fZ2VvbSA9IGdlb20kMTtcbiAgICB0aGlzLl9nZW9tRmFjdCA9IGdlb20kMS5nZXRGYWN0b3J5KCk7XG4gICAgdGhpcy5fYm5SdWxlID0gYm5SdWxlJDE7XG4gIH1cbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5ib3VuZGFyeU11bHRpTGluZVN0cmluZyA9IGZ1bmN0aW9uIGJvdW5kYXJ5TXVsdGlMaW5lU3RyaW5nIChtTGluZSkge1xuICBpZiAodGhpcy5fZ2VvbS5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKVxuICB9XG4gIHZhciBiZHlQdHMgPSB0aGlzLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKG1MaW5lKTtcbiAgaWYgKGJkeVB0cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2VvbUZhY3QuY3JlYXRlUG9pbnQoYmR5UHRzWzBdKVxuICB9XG4gIHJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhiZHlQdHMpXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gIGlmICh0aGlzLl9nZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZykgeyByZXR1cm4gdGhpcy5ib3VuZGFyeUxpbmVTdHJpbmcodGhpcy5fZ2VvbSkgfVxuICBpZiAodGhpcy5fZ2VvbSBpbnN0YW5jZW9mIE11bHRpTGluZVN0cmluZykgeyByZXR1cm4gdGhpcy5ib3VuZGFyeU11bHRpTGluZVN0cmluZyh0aGlzLl9nZW9tKSB9XG4gIHJldHVybiB0aGlzLl9nZW9tLmdldEJvdW5kYXJ5KClcbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5ib3VuZGFyeUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBib3VuZGFyeUxpbmVTdHJpbmcgKGxpbmUpIHtcbiAgaWYgKHRoaXMuX2dlb20uaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KClcbiAgfVxuICBpZiAobGluZS5pc0Nsb3NlZCgpKSB7XG4gICAgdmFyIGNsb3NlZEVuZHBvaW50T25Cb3VuZGFyeSA9IHRoaXMuX2JuUnVsZS5pc0luQm91bmRhcnkoMik7XG4gICAgaWYgKGNsb3NlZEVuZHBvaW50T25Cb3VuZGFyeSkge1xuICAgICAgcmV0dXJuIGxpbmUuZ2V0U3RhcnRQb2ludCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2dlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoW2xpbmUuZ2V0U3RhcnRQb2ludCgpLCBsaW5lLmdldEVuZFBvaW50KCldKVxufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmdldEVtcHR5TXVsdGlQb2ludCA9IGZ1bmN0aW9uIGdldEVtcHR5TXVsdGlQb2ludCAoKSB7XG4gIHJldHVybiB0aGlzLl9nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KClcbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5jb21wdXRlQm91bmRhcnlDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzIChtTGluZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBiZHlQdHMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX2VuZHBvaW50TWFwID0gbmV3IFRyZWVNYXAoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtTGluZS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBsaW5lID0gbUxpbmUuZ2V0R2VvbWV0cnlOKGkpO1xuICAgIGlmIChsaW5lLmdldE51bVBvaW50cygpID09PSAwKSB7IGNvbnRpbnVlIH1cbiAgICB0aGlzJDEuYWRkRW5kcG9pbnQobGluZS5nZXRDb29yZGluYXRlTigwKSk7XG4gICAgdGhpcyQxLmFkZEVuZHBvaW50KGxpbmUuZ2V0Q29vcmRpbmF0ZU4obGluZS5nZXROdW1Qb2ludHMoKSAtIDEpKTtcbiAgfVxuICBmb3IgKHZhciBpdCA9IHRoaXMuX2VuZHBvaW50TWFwLmVudHJ5U2V0KCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlbnRyeSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgY291bnRlciA9IGVudHJ5LmdldFZhbHVlKCk7XG4gICAgdmFyIHZhbGVuY2UgPSBjb3VudGVyLmNvdW50O1xuICAgIGlmICh0aGlzJDEuX2JuUnVsZS5pc0luQm91bmRhcnkodmFsZW5jZSkpIHtcbiAgICAgIGJkeVB0cy5hZGQoZW50cnkuZ2V0S2V5KCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5cy50b0Nvb3JkaW5hdGVBcnJheShiZHlQdHMpXG59O1xuQm91bmRhcnlPcC5wcm90b3R5cGUuYWRkRW5kcG9pbnQgPSBmdW5jdGlvbiBhZGRFbmRwb2ludCAocHQpIHtcbiAgdmFyIGNvdW50ZXIgPSB0aGlzLl9lbmRwb2ludE1hcC5nZXQocHQpO1xuICBpZiAoY291bnRlciA9PT0gbnVsbCkge1xuICAgIGNvdW50ZXIgPSBuZXcgQ291bnRlcigpO1xuICAgIHRoaXMuX2VuZHBvaW50TWFwLnB1dChwdCwgY291bnRlcik7XG4gIH1cbiAgY291bnRlci5jb3VudCsrO1xufTtcbkJvdW5kYXJ5T3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Cb3VuZGFyeU9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJvdW5kYXJ5T3Bcbn07XG5Cb3VuZGFyeU9wLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBib3AgPSBuZXcgQm91bmRhcnlPcChnKTtcbiAgICByZXR1cm4gYm9wLmdldEJvdW5kYXJ5KClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGckMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYm5SdWxlID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBib3AkMSA9IG5ldyBCb3VuZGFyeU9wKGckMSwgYm5SdWxlKTtcbiAgICByZXR1cm4gYm9wJDEuZ2V0Qm91bmRhcnkoKVxuICB9XG59O1xuXG52YXIgQ291bnRlciA9IGZ1bmN0aW9uIENvdW50ZXIgKCkge1xuICB0aGlzLmNvdW50ID0gbnVsbDtcbn07XG5Db3VudGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ291bnRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb3VudGVyXG59O1xuXG4vLyBib3VuZGFyeVxuXG5mdW5jdGlvbiBQcmludFN0cmVhbSAoKSB7fVxuXG5mdW5jdGlvbiBTdHJpbmdSZWFkZXIgKCkge31cblxudmFyIERlY2ltYWxGb3JtYXQgPSBmdW5jdGlvbiBEZWNpbWFsRm9ybWF0ICgpIHt9O1xuXG5mdW5jdGlvbiBCeXRlQXJyYXlPdXRwdXRTdHJlYW0gKCkge31cblxuZnVuY3Rpb24gSU9FeGNlcHRpb24gKCkge31cblxuZnVuY3Rpb24gTGluZU51bWJlclJlYWRlciAoKSB7fVxuXG52YXIgU3RyaW5nVXRpbCA9IGZ1bmN0aW9uIFN0cmluZ1V0aWwgKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTUgPSB7IE5FV0xJTkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU0lNUExFX09SRElOQVRFX0ZPUk1BVDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5TdHJpbmdVdGlsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU3RyaW5nVXRpbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTdHJpbmdVdGlsXG59O1xuU3RyaW5nVXRpbC5jaGFycyA9IGZ1bmN0aW9uIGNoYXJzIChjLCBuKSB7XG4gIHZhciBjaCA9IG5ldyBBcnJheShuKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGNoW2ldID0gYztcbiAgfVxuICByZXR1cm4gU3RyaW5nKGNoKVxufTtcblN0cmluZ1V0aWwuZ2V0U3RhY2tUcmFjZSA9IGZ1bmN0aW9uIGdldFN0YWNrVHJhY2UgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciB0ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvcyA9IG5ldyBCeXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICB2YXIgcHMgPSBuZXcgUHJpbnRTdHJlYW0ob3MpO1xuICAgIHQucHJpbnRTdGFja1RyYWNlKHBzKTtcbiAgICByZXR1cm4gb3MudG9TdHJpbmcoKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgdCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkZXB0aCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgc3RhY2tUcmFjZSA9ICcnO1xuICAgIHZhciBzdHJpbmdSZWFkZXIgPSBuZXcgU3RyaW5nUmVhZGVyKFN0cmluZ1V0aWwuZ2V0U3RhY2tUcmFjZSh0JDEpKTtcbiAgICB2YXIgbGluZU51bWJlclJlYWRlciA9IG5ldyBMaW5lTnVtYmVyUmVhZGVyKHN0cmluZ1JlYWRlcik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXB0aDsgaSsrKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGFja1RyYWNlICs9IGxpbmVOdW1iZXJSZWFkZXIucmVhZExpbmUoKSArIFN0cmluZ1V0aWwuTkVXTElORTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBJT0V4Y2VwdGlvbikge1xuICAgICAgICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgpO1xuICAgICAgICB9IGVsc2UgeyB0aHJvdyBlIH1cbiAgICAgIH0gZmluYWxseSB7fVxuICAgIH1cbiAgICByZXR1cm4gc3RhY2tUcmFjZVxuICB9XG59O1xuU3RyaW5nVXRpbC5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChzLCBzZXBhcmF0b3IpIHtcbiAgdmFyIHNlcGFyYXRvcmxlbiA9IHNlcGFyYXRvci5sZW5ndGg7XG4gIHZhciB0b2tlbkxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciB0bXBTdHJpbmcgPSAnJyArIHM7XG4gIHZhciBwb3MgPSB0bXBTdHJpbmcuaW5kZXhPZihzZXBhcmF0b3IpO1xuICB3aGlsZSAocG9zID49IDApIHtcbiAgICB2YXIgdG9rZW4gPSB0bXBTdHJpbmcuc3Vic3RyaW5nKDAsIHBvcyk7XG4gICAgdG9rZW5MaXN0LmFkZCh0b2tlbik7XG4gICAgdG1wU3RyaW5nID0gdG1wU3RyaW5nLnN1YnN0cmluZyhwb3MgKyBzZXBhcmF0b3JsZW4pO1xuICAgIHBvcyA9IHRtcFN0cmluZy5pbmRleE9mKHNlcGFyYXRvcik7XG4gIH1cbiAgaWYgKHRtcFN0cmluZy5sZW5ndGggPiAwKSB7IHRva2VuTGlzdC5hZGQodG1wU3RyaW5nKTsgfVxuICB2YXIgcmVzID0gbmV3IEFycmF5KHRva2VuTGlzdC5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzW2ldID0gdG9rZW5MaXN0LmdldChpKTtcbiAgfVxuICByZXR1cm4gcmVzXG59O1xuU3RyaW5nVXRpbC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gU3RyaW5nVXRpbC5TSU1QTEVfT1JESU5BVEVfRk9STUFULmZvcm1hdChkKVxuICB9XG59O1xuU3RyaW5nVXRpbC5zcGFjZXMgPSBmdW5jdGlvbiBzcGFjZXMgKG4pIHtcbiAgcmV0dXJuIFN0cmluZ1V0aWwuY2hhcnMoJyAnLCBuKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQxNS5ORVdMSU5FLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN5c3RlbS5nZXRQcm9wZXJ0eSgnbGluZS5zZXBhcmF0b3InKSB9O1xuc3RhdGljQWNjZXNzb3JzJDE1LlNJTVBMRV9PUkRJTkFURV9GT1JNQVQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERlY2ltYWxGb3JtYXQoJzAuIycpIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTdHJpbmdVdGlsLCBzdGF0aWNBY2Nlc3NvcnMkMTUgKTtcblxudmFyIENvb3JkaW5hdGVTZXF1ZW5jZXMgPSBmdW5jdGlvbiBDb29yZGluYXRlU2VxdWVuY2VzICgpIHt9O1xuXG5Db29yZGluYXRlU2VxdWVuY2VzLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VzXG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5Q29vcmQgPSBmdW5jdGlvbiBjb3B5Q29vcmQgKHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zKSB7XG4gIHZhciBtaW5EaW0gPSBNYXRoLm1pbihzcmMuZ2V0RGltZW5zaW9uKCksIGRlc3QuZ2V0RGltZW5zaW9uKCkpO1xuICBmb3IgKHZhciBkaW0gPSAwOyBkaW0gPCBtaW5EaW07IGRpbSsrKSB7XG4gICAgZGVzdC5zZXRPcmRpbmF0ZShkZXN0UG9zLCBkaW0sIHNyYy5nZXRPcmRpbmF0ZShzcmNQb3MsIGRpbSkpO1xuICB9XG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5pc1JpbmcgPSBmdW5jdGlvbiBpc1JpbmcgKHNlcSkge1xuICB2YXIgbiA9IHNlcS5zaXplKCk7XG4gIGlmIChuID09PSAwKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKG4gPD0gMykgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gc2VxLmdldE9yZGluYXRlKDAsIENvb3JkaW5hdGVTZXF1ZW5jZS5YKSA9PT0gc2VxLmdldE9yZGluYXRlKG4gLSAxLCBDb29yZGluYXRlU2VxdWVuY2UuWCkgJiYgc2VxLmdldE9yZGluYXRlKDAsIENvb3JkaW5hdGVTZXF1ZW5jZS5ZKSA9PT0gc2VxLmdldE9yZGluYXRlKG4gLSAxLCBDb29yZGluYXRlU2VxdWVuY2UuWSlcbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmlzRXF1YWwgPSBmdW5jdGlvbiBpc0VxdWFsIChjczEsIGNzMikge1xuICB2YXIgY3MxU2l6ZSA9IGNzMS5zaXplKCk7XG4gIHZhciBjczJTaXplID0gY3MyLnNpemUoKTtcbiAgaWYgKGNzMVNpemUgIT09IGNzMlNpemUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGRpbSA9IE1hdGgubWluKGNzMS5nZXREaW1lbnNpb24oKSwgY3MyLmdldERpbWVuc2lvbigpKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjczFTaXplOyBpKyspIHtcbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRpbTsgZCsrKSB7XG4gICAgICB2YXIgdjEgPSBjczEuZ2V0T3JkaW5hdGUoaSwgZCk7XG4gICAgICB2YXIgdjIgPSBjczIuZ2V0T3JkaW5hdGUoaSwgZCk7XG4gICAgICBpZiAoY3MxLmdldE9yZGluYXRlKGksIGQpID09PSBjczIuZ2V0T3JkaW5hdGUoaSwgZCkpIHsgY29udGludWUgfVxuICAgICAgaWYgKERvdWJsZS5pc05hTih2MSkgJiYgRG91YmxlLmlzTmFOKHYyKSkgeyBjb250aW51ZSB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmV4dGVuZCA9IGZ1bmN0aW9uIGV4dGVuZCAoZmFjdCwgc2VxLCBzaXplKSB7XG4gIHZhciBuZXdzZXEgPSBmYWN0LmNyZWF0ZShzaXplLCBzZXEuZ2V0RGltZW5zaW9uKCkpO1xuICB2YXIgbiA9IHNlcS5zaXplKCk7XG4gIENvb3JkaW5hdGVTZXF1ZW5jZXMuY29weShzZXEsIDAsIG5ld3NlcSwgMCwgbik7XG4gIGlmIChuID4gMCkge1xuICAgIGZvciAodmFyIGkgPSBuOyBpIDwgc2l6ZTsgaSsrKSB7IENvb3JkaW5hdGVTZXF1ZW5jZXMuY29weShzZXEsIG4gLSAxLCBuZXdzZXEsIGksIDEpOyB9XG4gIH1cbiAgcmV0dXJuIG5ld3NlcVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKHNlcSkge1xuICB2YXIgbGFzdCA9IHNlcS5zaXplKCkgLSAxO1xuICB2YXIgbWlkID0gTWF0aC50cnVuYyhsYXN0IC8gMik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG1pZDsgaSsrKSB7XG4gICAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5zd2FwKHNlcSwgaSwgbGFzdCAtIGkpO1xuICB9XG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy5zd2FwID0gZnVuY3Rpb24gc3dhcCAoc2VxLCBpLCBqKSB7XG4gIGlmIChpID09PSBqKSB7IHJldHVybiBudWxsIH1cbiAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgc2VxLmdldERpbWVuc2lvbigpOyBkaW0rKykge1xuICAgIHZhciB0bXAgPSBzZXEuZ2V0T3JkaW5hdGUoaSwgZGltKTtcbiAgICBzZXEuc2V0T3JkaW5hdGUoaSwgZGltLCBzZXEuZ2V0T3JkaW5hdGUoaiwgZGltKSk7XG4gICAgc2VxLnNldE9yZGluYXRlKGosIGRpbSwgdG1wKTtcbiAgfVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHNyYywgc3JjUG9zLCBkZXN0LCBkZXN0UG9zLCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIENvb3JkaW5hdGVTZXF1ZW5jZXMuY29weUNvb3JkKHNyYywgc3JjUG9zICsgaSwgZGVzdCwgZGVzdFBvcyArIGkpO1xuICB9XG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlcy50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgY3MgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNpemUgPSBjcy5zaXplKCk7XG4gICAgaWYgKHNpemUgPT09IDApIHsgcmV0dXJuICcoKScgfVxuICAgIHZhciBkaW0gPSBjcy5nZXREaW1lbnNpb24oKTtcbiAgICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICAgIGJ1Zi5hcHBlbmQoJygnKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgaWYgKGkgPiAwKSB7IGJ1Zi5hcHBlbmQoJyAnKTsgfVxuICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykge1xuICAgICAgICBpZiAoZCA+IDApIHsgYnVmLmFwcGVuZCgnLCcpOyB9XG4gICAgICAgIGJ1Zi5hcHBlbmQoU3RyaW5nVXRpbC50b1N0cmluZyhjcy5nZXRPcmRpbmF0ZShpLCBkKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICBidWYuYXBwZW5kKCcpJyk7XG4gICAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG4gIH1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VzLmVuc3VyZVZhbGlkUmluZyA9IGZ1bmN0aW9uIGVuc3VyZVZhbGlkUmluZyAoZmFjdCwgc2VxKSB7XG4gIHZhciBuID0gc2VxLnNpemUoKTtcbiAgaWYgKG4gPT09IDApIHsgcmV0dXJuIHNlcSB9XG4gIGlmIChuIDw9IDMpIHsgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZXMuY3JlYXRlQ2xvc2VkUmluZyhmYWN0LCBzZXEsIDQpIH1cbiAgdmFyIGlzQ2xvc2VkID0gc2VxLmdldE9yZGluYXRlKDAsIENvb3JkaW5hdGVTZXF1ZW5jZS5YKSA9PT0gc2VxLmdldE9yZGluYXRlKG4gLSAxLCBDb29yZGluYXRlU2VxdWVuY2UuWCkgJiYgc2VxLmdldE9yZGluYXRlKDAsIENvb3JkaW5hdGVTZXF1ZW5jZS5ZKSA9PT0gc2VxLmdldE9yZGluYXRlKG4gLSAxLCBDb29yZGluYXRlU2VxdWVuY2UuWSk7XG4gIGlmIChpc0Nsb3NlZCkgeyByZXR1cm4gc2VxIH1cbiAgcmV0dXJuIENvb3JkaW5hdGVTZXF1ZW5jZXMuY3JlYXRlQ2xvc2VkUmluZyhmYWN0LCBzZXEsIG4gKyAxKVxufTtcbkNvb3JkaW5hdGVTZXF1ZW5jZXMuY3JlYXRlQ2xvc2VkUmluZyA9IGZ1bmN0aW9uIGNyZWF0ZUNsb3NlZFJpbmcgKGZhY3QsIHNlcSwgc2l6ZSkge1xuICB2YXIgbmV3c2VxID0gZmFjdC5jcmVhdGUoc2l6ZSwgc2VxLmdldERpbWVuc2lvbigpKTtcbiAgdmFyIG4gPSBzZXEuc2l6ZSgpO1xuICBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHkoc2VxLCAwLCBuZXdzZXEsIDAsIG4pO1xuICBmb3IgKHZhciBpID0gbjsgaSA8IHNpemU7IGkrKykgeyBDb29yZGluYXRlU2VxdWVuY2VzLmNvcHkoc2VxLCAwLCBuZXdzZXEsIGksIDEpOyB9XG4gIHJldHVybiBuZXdzZXFcbn07XG5cbnZhciBMaW5lU3RyaW5nID0gKGZ1bmN0aW9uIChHZW9tZXRyeSQkMSkge1xuICBmdW5jdGlvbiBMaW5lU3RyaW5nIChwb2ludHMsIGZhY3RvcnkpIHtcbiAgICBHZW9tZXRyeSQkMS5jYWxsKHRoaXMsIGZhY3RvcnkpO1xuICAgIHRoaXMuX3BvaW50cyA9IG51bGw7XG4gICAgdGhpcy5pbml0KHBvaW50cyk7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5JCQxICkgTGluZVN0cmluZy5fX3Byb3RvX18gPSBHZW9tZXRyeSQkMTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHZW9tZXRyeSQkMSAmJiBHZW9tZXRyeSQkMS5wcm90b3R5cGUgKTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lU3RyaW5nO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgPSBmdW5jdGlvbiBjb21wdXRlRW52ZWxvcGVJbnRlcm5hbCAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbmV3IEVudmVsb3BlKClcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BvaW50cy5leHBhbmRFbnZlbG9wZShuZXcgRW52ZWxvcGUoKSlcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaXNSaW5nID0gZnVuY3Rpb24gaXNSaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0Nsb3NlZCgpICYmIHRoaXMuaXNTaW1wbGUoKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeSQkMS5TT1JUSU5ERVhfTElORVNUUklOR1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzLnRvQ29vcmRpbmF0ZUFycmF5KClcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICghdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyhvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB2YXIgb3RoZXJMaW5lU3RyaW5nID0gb3RoZXI7XG4gICAgICBpZiAodGhpcy5fcG9pbnRzLnNpemUoKSAhPT0gb3RoZXJMaW5lU3RyaW5nLl9wb2ludHMuc2l6ZSgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9wb2ludHMuc2l6ZSgpOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzJDEuZXF1YWwodGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSwgb3RoZXJMaW5lU3RyaW5nLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSwgdG9sZXJhbmNlKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7IHJldHVybiBHZW9tZXRyeSQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE1hdGgudHJ1bmModGhpcy5fcG9pbnRzLnNpemUoKSAvIDIpOyBpKyspIHtcbiAgICAgIHZhciBqID0gdGhpcyQxLl9wb2ludHMuc2l6ZSgpIC0gMSAtIGk7XG4gICAgICBpZiAoIXRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSkuZXF1YWxzKHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaikpKSB7XG4gICAgICAgIGlmICh0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGkpLmNvbXBhcmVUbyh0aGlzJDEuX3BvaW50cy5nZXRDb29yZGluYXRlKGopKSA+IDApIHtcbiAgICAgICAgICBDb29yZGluYXRlU2VxdWVuY2VzLnJldmVyc2UodGhpcyQxLl9wb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUoMClcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQoKSkge1xuICAgICAgcmV0dXJuIERpbWVuc2lvbi5GQUxTRVxuICAgIH1cbiAgICByZXR1cm4gMFxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlTigwKS5lcXVhbHMyRCh0aGlzLmdldENvb3JkaW5hdGVOKHRoaXMuZ2V0TnVtUG9pbnRzKCkgLSAxKSlcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0RW5kUG9pbnQgPSBmdW5jdGlvbiBnZXRFbmRQb2ludCAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZXRQb2ludE4odGhpcy5nZXROdW1Qb2ludHMoKSAtIDEpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0TGVuZ3RoID0gZnVuY3Rpb24gZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gQ0dBbGdvcml0aG1zLmNvbXB1dGVMZW5ndGgodGhpcy5fcG9pbnRzKVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5nZXROdW1Qb2ludHMgPSBmdW5jdGlvbiBnZXROdW1Qb2ludHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9wb2ludHMuc2l6ZSgpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICB2YXIgc2VxID0gdGhpcy5fcG9pbnRzLmNvcHkoKTtcbiAgICBDb29yZGluYXRlU2VxdWVuY2VzLnJldmVyc2Uoc2VxKTtcbiAgICB2YXIgcmV2TGluZSA9IHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoc2VxKTtcbiAgICByZXR1cm4gcmV2TGluZVxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jb21wYXJlVG9TYW1lQ2xhc3MgPSBmdW5jdGlvbiBjb21wYXJlVG9TYW1lQ2xhc3MgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBvID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxpbmUgPSBvO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgd2hpbGUgKGkgPCB0aGlzLl9wb2ludHMuc2l6ZSgpICYmIGogPCBsaW5lLl9wb2ludHMuc2l6ZSgpKSB7XG4gICAgICAgIHZhciBjb21wYXJpc29uID0gdGhpcyQxLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKS5jb21wYXJlVG8obGluZS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaikpO1xuICAgICAgICBpZiAoY29tcGFyaXNvbiAhPT0gMCkge1xuICAgICAgICAgIHJldHVybiBjb21wYXJpc29uXG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgICAgICBqKys7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IHRoaXMuX3BvaW50cy5zaXplKCkpIHtcbiAgICAgICAgcmV0dXJuIDFcbiAgICAgIH1cbiAgICAgIGlmIChqIDwgbGluZS5fcG9pbnRzLnNpemUoKSkge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvbXAgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbGluZSQxID0gbyQxO1xuICAgICAgcmV0dXJuIGNvbXAuY29tcGFyZSh0aGlzLl9wb2ludHMsIGxpbmUkMS5fcG9pbnRzKVxuICAgIH1cbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiBhcHBseSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZUZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BvaW50cy5zaXplKCk7IGkrKykge1xuICAgICAgICBmaWx0ZXIuZmlsdGVyKHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlRmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgaWYgKHRoaXMuX3BvaW50cy5zaXplKCkgPT09IDApIHsgcmV0dXJuIG51bGwgfVxuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5fcG9pbnRzLnNpemUoKTsgaSQxKyspIHtcbiAgICAgICAgZmlsdGVyJDEuZmlsdGVyKHRoaXMkMS5fcG9pbnRzLCBpJDEpO1xuICAgICAgICBpZiAoZmlsdGVyJDEuaXNEb25lKCkpIHsgYnJlYWsgfVxuICAgICAgfVxuICAgICAgaWYgKGZpbHRlciQxLmlzR2VvbWV0cnlDaGFuZ2VkKCkpIHsgdGhpcy5nZW9tZXRyeUNoYW5nZWQoKTsgfVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgR2VvbWV0cnlGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDIgPSBhcmd1bWVudHNbMF07XG4gICAgICBmaWx0ZXIkMi5maWx0ZXIodGhpcyk7XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBHZW9tZXRyeUNvbXBvbmVudEZpbHRlcikpIHtcbiAgICAgIHZhciBmaWx0ZXIkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZpbHRlciQzLmZpbHRlcih0aGlzKTtcbiAgICB9XG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldEJvdW5kYXJ5ID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnkgKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRhcnlPcCh0aGlzKS5nZXRCb3VuZGFyeSgpXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmlzRXF1aXZhbGVudENsYXNzID0gZnVuY3Rpb24gaXNFcXVpdmFsZW50Q2xhc3MgKG90aGVyKSB7XG4gICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTGluZVN0cmluZ1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgbHMgPSBHZW9tZXRyeSQkMS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBscy5fcG9pbnRzID0gdGhpcy5fcG9pbnRzLmNsb25lKCk7XG4gICAgcmV0dXJuIGxzXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVOID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZU4gKG4pIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzLmdldENvb3JkaW5hdGUobilcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ0xpbmVTdHJpbmcnXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IExpbmVTdHJpbmcodGhpcy5fcG9pbnRzLmNvcHkoKSwgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9pbnRzLnNpemUoKSA9PT0gMFxuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAocG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cyA9PT0gbnVsbCkge1xuICAgICAgcG9pbnRzID0gdGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSk7XG4gICAgfVxuICAgIGlmIChwb2ludHMuc2l6ZSgpID09PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZVN0cmluZyAoZm91bmQgJyArIHBvaW50cy5zaXplKCkgKyAnIC0gbXVzdCBiZSAwIG9yID49IDIpJylcbiAgICB9XG4gICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xuICB9O1xuICBMaW5lU3RyaW5nLnByb3RvdHlwZS5pc0Nvb3JkaW5hdGUgPSBmdW5jdGlvbiBpc0Nvb3JkaW5hdGUgKHB0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3BvaW50cy5zaXplKCk7IGkrKykge1xuICAgICAgaWYgKHRoaXMkMS5fcG9pbnRzLmdldENvb3JkaW5hdGUoaSkuZXF1YWxzKHB0KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuZ2V0U3RhcnRQb2ludCA9IGZ1bmN0aW9uIGdldFN0YXJ0UG9pbnQgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0UG9pbnROKDApXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldFBvaW50TiA9IGZ1bmN0aW9uIGdldFBvaW50TiAobikge1xuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLl9wb2ludHMuZ2V0Q29vcmRpbmF0ZShuKSlcbiAgfTtcbiAgTGluZVN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtMaW5lYWxdXG4gIH07XG4gIExpbmVTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBMaW5lU3RyaW5nXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMxMTA2Njk4MjgwNjUzNjU1NjAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTGluZVN0cmluZywgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIExpbmVTdHJpbmc7XG59KEdlb21ldHJ5KSk7XG5cbnZhciBQdW50YWwgPSBmdW5jdGlvbiBQdW50YWwgKCkge307XG5cblB1bnRhbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblB1bnRhbC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQdW50YWxcbn07XG5cbnZhciBQb2ludCA9IChmdW5jdGlvbiAoR2VvbWV0cnkkJDEpIHtcbiAgZnVuY3Rpb24gUG9pbnQgKGNvb3JkaW5hdGVzLCBmYWN0b3J5KSB7XG4gICAgR2VvbWV0cnkkJDEuY2FsbCh0aGlzLCBmYWN0b3J5KTtcbiAgICB0aGlzLl9jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzIHx8IG51bGw7XG4gICAgdGhpcy5pbml0KHRoaXMuX2Nvb3JkaW5hdGVzKTtcbiAgfVxuXG4gIGlmICggR2VvbWV0cnkkJDEgKSBQb2ludC5fX3Byb3RvX18gPSBHZW9tZXRyeSQkMTtcbiAgUG9pbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkkJDEgJiYgR2VvbWV0cnkkJDEucHJvdG90eXBlICk7XG4gIFBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFBvaW50O1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbiAgUG9pbnQucHJvdG90eXBlLmNvbXB1dGVFbnZlbG9wZUludGVybmFsID0gZnVuY3Rpb24gY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgKCkge1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG5ldyBFbnZlbG9wZSgpXG4gICAgfVxuICAgIHZhciBlbnYgPSBuZXcgRW52ZWxvcGUoKTtcbiAgICBlbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuX2Nvb3JkaW5hdGVzLmdldFgoMCksIHRoaXMuX2Nvb3JkaW5hdGVzLmdldFkoMCkpO1xuICAgIHJldHVybiBlbnZcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5JCQxLlNPUlRJTkRFWF9QT0lOVFxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNFbXB0eSgpID8gW10gOiBbdGhpcy5nZXRDb29yZGluYXRlKCldXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5lcXVhbHNFeGFjdCA9IGZ1bmN0aW9uIGVxdWFsc0V4YWN0ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICghdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyhvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkgJiYgb3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkgIT09IG90aGVyLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmVxdWFsKG90aGVyLmdldENvb3JkaW5hdGUoKSwgdGhpcy5nZXRDb29yZGluYXRlKCksIHRvbGVyYW5jZSlcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnkkJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplICgpIHt9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlcy5zaXplKCkgIT09IDAgPyB0aGlzLl9jb29yZGluYXRlcy5nZXRDb29yZGluYXRlKDApIDogbnVsbFxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIERpbWVuc2lvbi5GQUxTRVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMFxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0TnVtUG9pbnRzID0gZnVuY3Rpb24gZ2V0TnVtUG9pbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5pc0VtcHR5KCkgPyAwIDogMVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UgKCkge1xuICAgIHJldHVybiB0aGlzLmNvcHkoKVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFggKCkge1xuICAgIGlmICh0aGlzLmdldENvb3JkaW5hdGUoKSA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnZXRYIGNhbGxlZCBvbiBlbXB0eSBQb2ludCcpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS54XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5jb21wYXJlVG9TYW1lQ2xhc3MgPSBmdW5jdGlvbiBjb21wYXJlVG9TYW1lQ2xhc3MgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgcG9pbnQkMSA9IG90aGVyO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyhwb2ludCQxLmdldENvb3JkaW5hdGUoKSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvbXAgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgcG9pbnQgPSBvdGhlciQxO1xuICAgICAgcmV0dXJuIGNvbXAuY29tcGFyZSh0aGlzLl9jb29yZGluYXRlcywgcG9pbnQuX2Nvb3JkaW5hdGVzKVxuICAgIH1cbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkgKCkge1xuICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlRmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgZmlsdGVyLmZpbHRlcih0aGlzLmdldENvb3JkaW5hdGUoKSk7XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgZmlsdGVyJDEuZmlsdGVyKHRoaXMuX2Nvb3JkaW5hdGVzLCAwKTtcbiAgICAgIGlmIChmaWx0ZXIkMS5pc0dlb21ldHJ5Q2hhbmdlZCgpKSB7IHRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCk7IH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIEdlb21ldHJ5RmlsdGVyKSkge1xuICAgICAgdmFyIGZpbHRlciQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgZmlsdGVyJDIuZmlsdGVyKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgR2VvbWV0cnlDb21wb25lbnRGaWx0ZXIpKSB7XG4gICAgICB2YXIgZmlsdGVyJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICBmaWx0ZXIkMy5maWx0ZXIodGhpcyk7XG4gICAgfVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHAgPSBHZW9tZXRyeSQkMS5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBwLl9jb29yZGluYXRlcyA9IHRoaXMuX2Nvb3JkaW5hdGVzLmNsb25lKCk7XG4gICAgcmV0dXJuIHBcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdQb2ludCdcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMuX2Nvb3JkaW5hdGVzLmNvcHkoKSwgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmdldENvb3JkaW5hdGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVTZXF1ZW5jZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSAoKSB7XG4gICAgaWYgKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dldFkgY2FsbGVkIG9uIGVtcHR5IFBvaW50JylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnlcbiAgfTtcbiAgUG9pbnQucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXMuc2l6ZSgpID09PSAwXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoY29vcmRpbmF0ZXMpIHtcbiAgICBpZiAoY29vcmRpbmF0ZXMgPT09IG51bGwpIHtcbiAgICAgIGNvb3JkaW5hdGVzID0gdGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSk7XG4gICAgfVxuICAgIEFzc2VydC5pc1RydWUoY29vcmRpbmF0ZXMuc2l6ZSgpIDw9IDEpO1xuICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXM7XG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5pc1NpbXBsZSA9IGZ1bmN0aW9uIGlzU2ltcGxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICBQb2ludC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtQdW50YWxdXG4gIH07XG4gIFBvaW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gUG9pbnRcbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDkwMjAyMjcwMjc0NjYxNDU3MCB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQb2ludCwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIFBvaW50O1xufShHZW9tZXRyeSkpO1xuXG52YXIgUG9seWdvbmFsID0gZnVuY3Rpb24gUG9seWdvbmFsICgpIHt9O1xuXG5Qb2x5Z29uYWwucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb2x5Z29uYWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9seWdvbmFsXG59O1xuXG52YXIgUG9seWdvbiA9IChmdW5jdGlvbiAoR2VvbWV0cnkkJDEpIHtcbiAgZnVuY3Rpb24gUG9seWdvbiAoc2hlbGwsIGhvbGVzLCBmYWN0b3J5KSB7XG4gICAgR2VvbWV0cnkkJDEuY2FsbCh0aGlzLCBmYWN0b3J5KTtcbiAgICB0aGlzLl9zaGVsbCA9IG51bGw7XG4gICAgdGhpcy5faG9sZXMgPSBudWxsO1xuICAgIGlmIChzaGVsbCA9PT0gbnVsbCkge1xuICAgICAgc2hlbGwgPSB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKCk7XG4gICAgfVxuICAgIGlmIChob2xlcyA9PT0gbnVsbCkge1xuICAgICAgaG9sZXMgPSBbXTtcbiAgICB9XG4gICAgaWYgKEdlb21ldHJ5JCQxLmhhc051bGxFbGVtZW50cyhob2xlcykpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ2hvbGVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50cycpXG4gICAgfVxuICAgIGlmIChzaGVsbC5pc0VtcHR5KCkgJiYgR2VvbWV0cnkkJDEuaGFzTm9uRW1wdHlFbGVtZW50cyhob2xlcykpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ3NoZWxsIGlzIGVtcHR5IGJ1dCBob2xlcyBhcmUgbm90JylcbiAgICB9XG4gICAgdGhpcy5fc2hlbGwgPSBzaGVsbDtcbiAgICB0aGlzLl9ob2xlcyA9IGhvbGVzO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeSQkMSApIFBvbHlnb24uX19wcm90b19fID0gR2VvbWV0cnkkJDE7XG4gIFBvbHlnb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnkkJDEgJiYgR2VvbWV0cnkkJDEucHJvdG90eXBlICk7XG4gIFBvbHlnb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUG9seWdvbjtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmNvbXB1dGVFbnZlbG9wZUludGVybmFsID0gZnVuY3Rpb24gY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwgKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGVsbC5nZXRFbnZlbG9wZUludGVybmFsKClcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkkJDEuU09SVElOREVYX1BPTFlHT05cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBbXVxuICAgIH1cbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKTtcbiAgICB2YXIgayA9IC0xO1xuICAgIHZhciBzaGVsbENvb3JkaW5hdGVzID0gdGhpcy5fc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHNoZWxsQ29vcmRpbmF0ZXMubGVuZ3RoOyB4KyspIHtcbiAgICAgIGsrKztcbiAgICAgIGNvb3JkaW5hdGVzW2tdID0gc2hlbGxDb29yZGluYXRlc1t4XTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkQ29vcmRpbmF0ZXMgPSB0aGlzJDEuX2hvbGVzW2ldLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGNoaWxkQ29vcmRpbmF0ZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaysrO1xuICAgICAgICBjb29yZGluYXRlc1trXSA9IGNoaWxkQ29vcmRpbmF0ZXNbal07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb29yZGluYXRlc1xuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRBcmVhID0gZnVuY3Rpb24gZ2V0QXJlYSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJlYSA9IDAuMDtcbiAgICBhcmVhICs9IE1hdGguYWJzKENHQWxnb3JpdGhtcy5zaWduZWRBcmVhKHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJlYSAtPSBNYXRoLmFicyhDR0FsZ29yaXRobXMuc2lnbmVkQXJlYSh0aGlzJDEuX2hvbGVzW2ldLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKSk7XG4gICAgfVxuICAgIHJldHVybiBhcmVhXG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmlzUmVjdGFuZ2xlID0gZnVuY3Rpb24gaXNSZWN0YW5nbGUgKCkge1xuICAgIGlmICh0aGlzLmdldE51bUludGVyaW9yUmluZygpICE9PSAwKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRoaXMuX3NoZWxsID09PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gICAgaWYgKHRoaXMuX3NoZWxsLmdldE51bVBvaW50cygpICE9PSA1KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIHNlcSA9IHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpO1xuICAgIHZhciBlbnYgPSB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDU7IGkrKykge1xuICAgICAgdmFyIHggPSBzZXEuZ2V0WChpKTtcbiAgICAgIGlmICghKHggPT09IGVudi5nZXRNaW5YKCkgfHwgeCA9PT0gZW52LmdldE1heFgoKSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHZhciB5ID0gc2VxLmdldFkoaSk7XG4gICAgICBpZiAoISh5ID09PSBlbnYuZ2V0TWluWSgpIHx8IHkgPT09IGVudi5nZXRNYXhZKCkpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHZhciBwcmV2WCA9IHNlcS5nZXRYKDApO1xuICAgIHZhciBwcmV2WSA9IHNlcS5nZXRZKDApO1xuICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8PSA0OyBpJDErKykge1xuICAgICAgdmFyIHgkMSA9IHNlcS5nZXRYKGkkMSk7XG4gICAgICB2YXIgeSQxID0gc2VxLmdldFkoaSQxKTtcbiAgICAgIHZhciB4Q2hhbmdlZCA9IHgkMSAhPT0gcHJldlg7XG4gICAgICB2YXIgeUNoYW5nZWQgPSB5JDEgIT09IHByZXZZO1xuICAgICAgaWYgKHhDaGFuZ2VkID09PSB5Q2hhbmdlZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgcHJldlggPSB4JDE7XG4gICAgICBwcmV2WSA9IHkkMTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG90aGVyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmICghdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyhvdGhlcikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICB2YXIgb3RoZXJQb2x5Z29uID0gb3RoZXI7XG4gICAgICB2YXIgdGhpc1NoZWxsID0gdGhpcy5fc2hlbGw7XG4gICAgICB2YXIgb3RoZXJQb2x5Z29uU2hlbGwgPSBvdGhlclBvbHlnb24uX3NoZWxsO1xuICAgICAgaWYgKCF0aGlzU2hlbGwuZXF1YWxzRXhhY3Qob3RoZXJQb2x5Z29uU2hlbGwsIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faG9sZXMubGVuZ3RoICE9PSBvdGhlclBvbHlnb24uX2hvbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCF0aGlzJDEuX2hvbGVzW2ldLmVxdWFsc0V4YWN0KG90aGVyUG9seWdvbi5faG9sZXNbaV0sIHRvbGVyYW5jZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnkkJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMubm9ybWFsaXplKHRoaXMuX3NoZWxsLCB0cnVlKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLm5vcm1hbGl6ZSh0aGlzJDEuX2hvbGVzW2ldLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBBcnJheXMuc29ydCh0aGlzLl9ob2xlcyk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgcmluZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjbG9ja3dpc2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAocmluZy5pc0VtcHR5KCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIHZhciB1bmlxdWVDb29yZGluYXRlcyA9IG5ldyBBcnJheShyaW5nLmdldENvb3JkaW5hdGVzKCkubGVuZ3RoIC0gMSkuZmlsbChudWxsKTtcbiAgICAgIFN5c3RlbS5hcnJheWNvcHkocmluZy5nZXRDb29yZGluYXRlcygpLCAwLCB1bmlxdWVDb29yZGluYXRlcywgMCwgdW5pcXVlQ29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICAgIHZhciBtaW5Db29yZGluYXRlID0gQ29vcmRpbmF0ZUFycmF5cy5taW5Db29yZGluYXRlKHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICBDb29yZGluYXRlQXJyYXlzLnNjcm9sbCh1bmlxdWVDb29yZGluYXRlcywgbWluQ29vcmRpbmF0ZSk7XG4gICAgICBTeXN0ZW0uYXJyYXljb3B5KHVuaXF1ZUNvb3JkaW5hdGVzLCAwLCByaW5nLmdldENvb3JkaW5hdGVzKCksIDAsIHVuaXF1ZUNvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgICByaW5nLmdldENvb3JkaW5hdGVzKClbdW5pcXVlQ29vcmRpbmF0ZXMubGVuZ3RoXSA9IHVuaXF1ZUNvb3JkaW5hdGVzWzBdO1xuICAgICAgaWYgKENHQWxnb3JpdGhtcy5pc0NDVyhyaW5nLmdldENvb3JkaW5hdGVzKCkpID09PSBjbG9ja3dpc2UpIHtcbiAgICAgICAgQ29vcmRpbmF0ZUFycmF5cy5yZXZlcnNlKHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NoZWxsLmdldENvb3JkaW5hdGUoKVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXROdW1JbnRlcmlvclJpbmcgPSBmdW5jdGlvbiBnZXROdW1JbnRlcmlvclJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9ob2xlcy5sZW5ndGhcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24gPSBmdW5jdGlvbiBnZXRCb3VuZGFyeURpbWVuc2lvbiAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMlxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbiBnZXRMZW5ndGggKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGxlbiA9IDAuMDtcbiAgICBsZW4gKz0gdGhpcy5fc2hlbGwuZ2V0TGVuZ3RoKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGVuICs9IHRoaXMkMS5faG9sZXNbaV0uZ2V0TGVuZ3RoKCk7XG4gICAgfVxuICAgIHJldHVybiBsZW5cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0TnVtUG9pbnRzID0gZnVuY3Rpb24gZ2V0TnVtUG9pbnRzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBudW1Qb2ludHMgPSB0aGlzLl9zaGVsbC5nZXROdW1Qb2ludHMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBudW1Qb2ludHMgKz0gdGhpcyQxLl9ob2xlc1tpXS5nZXROdW1Qb2ludHMoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bVBvaW50c1xuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9seSA9IHRoaXMuY29weSgpO1xuICAgIHBvbHkuX3NoZWxsID0gdGhpcy5fc2hlbGwuY29weSgpLnJldmVyc2UoKTtcbiAgICBwb2x5Ll9ob2xlcyA9IG5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9seS5faG9sZXNbaV0gPSB0aGlzJDEuX2hvbGVzW2ldLmNvcHkoKS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBwb2x5XG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmNvbnZleEh1bGwgPSBmdW5jdGlvbiBjb252ZXhIdWxsICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFeHRlcmlvclJpbmcoKS5jb252ZXhIdWxsKClcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuY29tcGFyZVRvU2FtZUNsYXNzID0gZnVuY3Rpb24gY29tcGFyZVRvU2FtZUNsYXNzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0aGlzU2hlbGwgPSB0aGlzLl9zaGVsbDtcbiAgICAgIHZhciBvdGhlclNoZWxsID0gby5fc2hlbGw7XG4gICAgICByZXR1cm4gdGhpc1NoZWxsLmNvbXBhcmVUb1NhbWVDbGFzcyhvdGhlclNoZWxsKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIG8kMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBjb21wID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHBvbHkgPSBvJDE7XG4gICAgICB2YXIgdGhpc1NoZWxsJDEgPSB0aGlzLl9zaGVsbDtcbiAgICAgIHZhciBvdGhlclNoZWxsJDEgPSBwb2x5Ll9zaGVsbDtcbiAgICAgIHZhciBzaGVsbENvbXAgPSB0aGlzU2hlbGwkMS5jb21wYXJlVG9TYW1lQ2xhc3Mob3RoZXJTaGVsbCQxLCBjb21wKTtcbiAgICAgIGlmIChzaGVsbENvbXAgIT09IDApIHsgcmV0dXJuIHNoZWxsQ29tcCB9XG4gICAgICB2YXIgbkhvbGUxID0gdGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKTtcbiAgICAgIHZhciBuSG9sZTIgPSBwb2x5LmdldE51bUludGVyaW9yUmluZygpO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgd2hpbGUgKGkgPCBuSG9sZTEgJiYgaSA8IG5Ib2xlMikge1xuICAgICAgICB2YXIgdGhpc0hvbGUgPSB0aGlzJDEuZ2V0SW50ZXJpb3JSaW5nTihpKTtcbiAgICAgICAgdmFyIG90aGVySG9sZSA9IHBvbHkuZ2V0SW50ZXJpb3JSaW5nTihpKTtcbiAgICAgICAgdmFyIGhvbGVDb21wID0gdGhpc0hvbGUuY29tcGFyZVRvU2FtZUNsYXNzKG90aGVySG9sZSwgY29tcCk7XG4gICAgICAgIGlmIChob2xlQ29tcCAhPT0gMCkgeyByZXR1cm4gaG9sZUNvbXAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IG5Ib2xlMSkgeyByZXR1cm4gMSB9XG4gICAgICBpZiAoaSA8IG5Ib2xlMikgeyByZXR1cm4gLTEgfVxuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkgKGZpbHRlcikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGhhc0ludGVyZmFjZShmaWx0ZXIsIENvb3JkaW5hdGVGaWx0ZXIpKSB7XG4gICAgICB0aGlzLl9zaGVsbC5hcHBseShmaWx0ZXIpO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5faG9sZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuX2hvbGVzW2kkMV0uYXBwbHkoZmlsdGVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhhc0ludGVyZmFjZShmaWx0ZXIsIENvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcikpIHtcbiAgICAgIHRoaXMuX3NoZWxsLmFwcGx5KGZpbHRlcik7XG4gICAgICBpZiAoIWZpbHRlci5pc0RvbmUoKSkge1xuICAgICAgICBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkkMisrKSB7XG4gICAgICAgICAgdGhpcyQxLl9ob2xlc1tpJDJdLmFwcGx5KGZpbHRlcik7XG4gICAgICAgICAgaWYgKGZpbHRlci5pc0RvbmUoKSkgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXIuaXNHZW9tZXRyeUNoYW5nZWQoKSkgeyB0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpOyB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoZmlsdGVyLCBHZW9tZXRyeUZpbHRlcikpIHtcbiAgICAgIGZpbHRlci5maWx0ZXIodGhpcyk7XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoZmlsdGVyLCBHZW9tZXRyeUNvbXBvbmVudEZpbHRlcikpIHtcbiAgICAgIGZpbHRlci5maWx0ZXIodGhpcyk7XG4gICAgICB0aGlzLl9zaGVsbC5hcHBseShmaWx0ZXIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzJDEuX2hvbGVzW2ldLmFwcGx5KGZpbHRlcik7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpXG4gICAgfVxuICAgIHZhciByaW5ncyA9IG5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGggKyAxKS5maWxsKG51bGwpO1xuICAgIHJpbmdzWzBdID0gdGhpcy5fc2hlbGw7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcmluZ3NbaSArIDFdID0gdGhpcyQxLl9ob2xlc1tpXTtcbiAgICB9XG4gICAgaWYgKHJpbmdzLmxlbmd0aCA8PSAxKSB7IHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHJpbmdzWzBdLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKSB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhyaW5ncylcbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiBjbG9uZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9seSA9IEdlb21ldHJ5JCQxLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIHBvbHkuX3NoZWxsID0gdGhpcy5fc2hlbGwuY2xvbmUoKTtcbiAgICBwb2x5Ll9ob2xlcyA9IG5ldyBBcnJheSh0aGlzLl9ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9seS5faG9sZXNbaV0gPSB0aGlzJDEuX2hvbGVzW2ldLmNsb25lKCk7XG4gICAgfVxuICAgIHJldHVybiBwb2x5XG4gIH07XG4gIFBvbHlnb24ucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdQb2x5Z29uJ1xuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgc2hlbGwgPSB0aGlzLl9zaGVsbC5jb3B5KCk7XG4gICAgdmFyIGhvbGVzID0gbmV3IEFycmF5KHRoaXMuX2hvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvbGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBob2xlc1tpXSA9IHRoaXMkMS5faG9sZXNbaV0uY29weSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvbHlnb24oc2hlbGwsIGhvbGVzLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRFeHRlcmlvclJpbmcgPSBmdW5jdGlvbiBnZXRFeHRlcmlvclJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLl9zaGVsbFxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NoZWxsLmlzRW1wdHkoKVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5nZXRJbnRlcmlvclJpbmdOID0gZnVuY3Rpb24gZ2V0SW50ZXJpb3JSaW5nTiAobikge1xuICAgIHJldHVybiB0aGlzLl9ob2xlc1tuXVxuICB9O1xuICBQb2x5Z29uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW1BvbHlnb25hbF1cbiAgfTtcbiAgUG9seWdvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFBvbHlnb25cbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTM0OTQ3OTIyMDA4MjE3NjQ1MzMgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggUG9seWdvbiwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIFBvbHlnb247XG59KEdlb21ldHJ5KSk7XG5cbnZhciBNdWx0aVBvaW50ID0gKGZ1bmN0aW9uIChHZW9tZXRyeUNvbGxlY3Rpb24kJDEpIHtcbiAgZnVuY3Rpb24gTXVsdGlQb2ludCAoKSB7XG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uJCQxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5Q29sbGVjdGlvbiQkMSApIE11bHRpUG9pbnQuX19wcm90b19fID0gR2VvbWV0cnlDb2xsZWN0aW9uJCQxO1xuICBNdWx0aVBvaW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5Q29sbGVjdGlvbiQkMSAmJiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTXVsdGlQb2ludDtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0U29ydEluZGV4ID0gZnVuY3Rpb24gZ2V0U29ydEluZGV4ICgpIHtcbiAgICByZXR1cm4gR2VvbWV0cnkuU09SVElOREVYX01VTFRJUE9JTlRcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmVxdWFsc0V4YWN0ID0gZnVuY3Rpb24gZXF1YWxzRXhhY3QgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgb3RoZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgdG9sZXJhbmNlID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKG90aGVyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcywgb3RoZXIsIHRvbGVyYW5jZSlcbiAgICB9IGVsc2UgeyByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uJCQxLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLl9nZW9tZXRyaWVzW25dLmdldENvb3JkaW5hdGUoKVxuICAgIH0gZWxzZSB7IHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmdldENvb3JkaW5hdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIHJldHVybiBEaW1lbnNpb24uRkFMU0VcbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMFxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5nZXRCb3VuZGFyeSA9IGZ1bmN0aW9uIGdldEJvdW5kYXJ5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpXG4gIH07XG4gIE11bHRpUG9pbnQucHJvdG90eXBlLmdldEdlb21ldHJ5VHlwZSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5VHlwZSAoKSB7XG4gICAgcmV0dXJuICdNdWx0aVBvaW50J1xuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9pbnRzID0gbmV3IEFycmF5KHRoaXMuX2dlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwb2ludHNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uY29weSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE11bHRpUG9pbnQocG9pbnRzLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBNdWx0aVBvaW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW1B1bnRhbF1cbiAgfTtcbiAgTXVsdGlQb2ludC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE11bHRpUG9pbnRcbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTgwNDg0NzQ4NzQxNzUzNTU0NDkgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTXVsdGlQb2ludCwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIE11bHRpUG9pbnQ7XG59KEdlb21ldHJ5Q29sbGVjdGlvbikpO1xuXG52YXIgTGluZWFyUmluZyA9IChmdW5jdGlvbiAoTGluZVN0cmluZyQkMSkge1xuICBmdW5jdGlvbiBMaW5lYXJSaW5nIChwb2ludHMsIGZhY3RvcnkpIHtcbiAgICBpZiAocG9pbnRzIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBmYWN0b3J5IGluc3RhbmNlb2YgR2VvbWV0cnlGYWN0b3J5KSB7XG4gICAgICBwb2ludHMgPSBmYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUocG9pbnRzKTtcbiAgICB9XG4gICAgTGluZVN0cmluZyQkMS5jYWxsKHRoaXMsIHBvaW50cywgZmFjdG9yeSk7XG4gICAgdGhpcy52YWxpZGF0ZUNvbnN0cnVjdGlvbigpO1xuICB9XG5cbiAgaWYgKCBMaW5lU3RyaW5nJCQxICkgTGluZWFyUmluZy5fX3Byb3RvX18gPSBMaW5lU3RyaW5nJCQxO1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIExpbmVTdHJpbmckJDEgJiYgTGluZVN0cmluZyQkMS5wcm90b3R5cGUgKTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMaW5lYXJSaW5nO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IE1JTklNVU1fVkFMSURfU0laRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmdldFNvcnRJbmRleCA9IGZ1bmN0aW9uIGdldFNvcnRJbmRleCAoKSB7XG4gICAgcmV0dXJuIEdlb21ldHJ5LlNPUlRJTkRFWF9MSU5FQVJSSU5HXG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIHJldHVybiBEaW1lbnNpb24uRkFMU0VcbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuaXNDbG9zZWQgPSBmdW5jdGlvbiBpc0Nsb3NlZCAoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gTGluZVN0cmluZyQkMS5wcm90b3R5cGUuaXNDbG9zZWQuY2FsbCh0aGlzKVxuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZSAoKSB7XG4gICAgdmFyIHNlcSA9IHRoaXMuX3BvaW50cy5jb3B5KCk7XG4gICAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5yZXZlcnNlKHNlcSk7XG4gICAgdmFyIHJldiA9IHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoc2VxKTtcbiAgICByZXR1cm4gcmV2XG4gIH07XG4gIExpbmVhclJpbmcucHJvdG90eXBlLnZhbGlkYXRlQ29uc3RydWN0aW9uID0gZnVuY3Rpb24gdmFsaWRhdGVDb25zdHJ1Y3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkgJiYgIUxpbmVTdHJpbmckJDEucHJvdG90eXBlLmlzQ2xvc2VkLmNhbGwodGhpcykpIHtcbiAgICAgIHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1BvaW50cyBvZiBMaW5lYXJSaW5nIGRvIG5vdCBmb3JtIGEgY2xvc2VkIGxpbmVzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCkgPj0gMSAmJiB0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKSA8IExpbmVhclJpbmcuTUlOSU1VTV9WQUxJRF9TSVpFKSB7XG4gICAgICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZWFyUmluZyAoZm91bmQgJyArIHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpICsgJyAtIG11c3QgYmUgMCBvciA+PSA0KScpXG4gICAgfVxuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5nZXRHZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeVR5cGUgKCkge1xuICAgIHJldHVybiAnTGluZWFyUmluZydcbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgTGluZWFyUmluZyh0aGlzLl9wb2ludHMuY29weSgpLCB0aGlzLl9mYWN0b3J5KVxuICB9O1xuICBMaW5lYXJSaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgTGluZWFyUmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIExpbmVhclJpbmdcbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLk1JTklNVU1fVkFMSURfU0laRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0IH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC00MjYxMTQyMDg0MDg1ODUxODI5IH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExpbmVhclJpbmcsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBMaW5lYXJSaW5nO1xufShMaW5lU3RyaW5nKSk7XG5cbnZhciBNdWx0aVBvbHlnb24gPSAoZnVuY3Rpb24gKEdlb21ldHJ5Q29sbGVjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBNdWx0aVBvbHlnb24gKCkge1xuICAgIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeUNvbGxlY3Rpb24kJDEgKSBNdWx0aVBvbHlnb24uX19wcm90b19fID0gR2VvbWV0cnlDb2xsZWN0aW9uJCQxO1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnlDb2xsZWN0aW9uJCQxICYmIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE11bHRpUG9seWdvbjtcblxuICB2YXIgc3RhdGljQWNjZXNzb3JzID0geyBzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRTb3J0SW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0SW5kZXggKCkge1xuICAgIHJldHVybiBHZW9tZXRyeS5TT1JUSU5ERVhfTVVMVElQT0xZR09OXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZXF1YWxzRXhhY3QgPSBmdW5jdGlvbiBlcXVhbHNFeGFjdCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBvdGhlciA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB0b2xlcmFuY2UgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3Mob3RoZXIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbiQkMS5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLCBvdGhlciwgdG9sZXJhbmNlKVxuICAgIH0gZWxzZSB7IHJldHVybiBHZW9tZXRyeUNvbGxlY3Rpb24kJDEucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLmdldEJvdW5kYXJ5RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlEaW1lbnNpb24gKCkge1xuICAgIHJldHVybiAxXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0RGltZW5zaW9uID0gZnVuY3Rpb24gZ2V0RGltZW5zaW9uICgpIHtcbiAgICByZXR1cm4gMlxuICB9O1xuICBNdWx0aVBvbHlnb24ucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBuID0gdGhpcy5fZ2VvbWV0cmllcy5sZW5ndGg7XG4gICAgdmFyIHJldkdlb21zID0gbmV3IEFycmF5KG4pLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXZHZW9tc1tpXSA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXS5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24ocmV2R2VvbXMpXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0Qm91bmRhcnkgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKVxuICAgIH1cbiAgICB2YXIgYWxsUmluZ3MgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9seWdvbiA9IHRoaXMkMS5fZ2VvbWV0cmllc1tpXTtcbiAgICAgIHZhciByaW5ncyA9IHBvbHlnb24uZ2V0Qm91bmRhcnkoKTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZ3MuZ2V0TnVtR2VvbWV0cmllcygpOyBqKyspIHtcbiAgICAgICAgYWxsUmluZ3MuYWRkKHJpbmdzLmdldEdlb21ldHJ5TihqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBhbGxSaW5nc0FycmF5ID0gbmV3IEFycmF5KGFsbFJpbmdzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgICByZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGFsbFJpbmdzLnRvQXJyYXkoYWxsUmluZ3NBcnJheSkpXG4gIH07XG4gIE11bHRpUG9seWdvbi5wcm90b3R5cGUuZ2V0R2VvbWV0cnlUeXBlID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlUeXBlICgpIHtcbiAgICByZXR1cm4gJ011bHRpUG9seWdvbidcbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgcG9seWdvbnMgPSBuZXcgQXJyYXkodGhpcy5fZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29ucy5sZW5ndGg7IGkrKykge1xuICAgICAgcG9seWdvbnNbaV0gPSB0aGlzJDEuX2dlb21ldHJpZXNbaV0uY29weSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE11bHRpUG9seWdvbihwb2x5Z29ucywgdGhpcy5fZmFjdG9yeSlcbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW1BvbHlnb25hbF1cbiAgfTtcbiAgTXVsdGlQb2x5Z29uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTXVsdGlQb2x5Z29uXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC01NTEwMzM1Mjk3NjY5NzU4NzUgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggTXVsdGlQb2x5Z29uLCBzdGF0aWNBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTXVsdGlQb2x5Z29uO1xufShHZW9tZXRyeUNvbGxlY3Rpb24pKTtcblxudmFyIEdlb21ldHJ5RWRpdG9yID0gZnVuY3Rpb24gR2VvbWV0cnlFZGl0b3IgKGZhY3RvcnkpIHtcbiAgdGhpcy5fZmFjdG9yeSA9IGZhY3RvcnkgfHwgbnVsbDtcbiAgdGhpcy5faXNVc2VyRGF0YUNvcGllZCA9IGZhbHNlO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxNiA9IHsgTm9PcEdlb21ldHJ5T3BlcmF0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENvb3JkaW5hdGVPcGVyYXRpb246IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5HZW9tZXRyeUVkaXRvci5wcm90b3R5cGUuc2V0Q29weVVzZXJEYXRhID0gZnVuY3Rpb24gc2V0Q29weVVzZXJEYXRhIChpc1VzZXJEYXRhQ29waWVkKSB7XG4gIHRoaXMuX2lzVXNlckRhdGFDb3BpZWQgPSBpc1VzZXJEYXRhQ29waWVkO1xufTtcbkdlb21ldHJ5RWRpdG9yLnByb3RvdHlwZS5lZGl0ID0gZnVuY3Rpb24gZWRpdCAoZ2VvbWV0cnksIG9wZXJhdGlvbikge1xuICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcmVzdWx0ID0gdGhpcy5lZGl0SW50ZXJuYWwoZ2VvbWV0cnksIG9wZXJhdGlvbik7XG4gIGlmICh0aGlzLl9pc1VzZXJEYXRhQ29waWVkKSB7XG4gICAgcmVzdWx0LnNldFVzZXJEYXRhKGdlb21ldHJ5LmdldFVzZXJEYXRhKCkpO1xuICB9XG4gIHJldHVybiByZXN1bHRcbn07XG5HZW9tZXRyeUVkaXRvci5wcm90b3R5cGUuZWRpdEludGVybmFsID0gZnVuY3Rpb24gZWRpdEludGVybmFsIChnZW9tZXRyeSwgb3BlcmF0aW9uKSB7XG4gIGlmICh0aGlzLl9mYWN0b3J5ID09PSBudWxsKSB7IHRoaXMuX2ZhY3RvcnkgPSBnZW9tZXRyeS5nZXRGYWN0b3J5KCk7IH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuZWRpdEdlb21ldHJ5Q29sbGVjdGlvbihnZW9tZXRyeSwgb3BlcmF0aW9uKVxuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0UG9seWdvbihnZW9tZXRyeSwgb3BlcmF0aW9uKVxuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgcmV0dXJuIG9wZXJhdGlvbi5lZGl0KGdlb21ldHJ5LCB0aGlzLl9mYWN0b3J5KVxuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICByZXR1cm4gb3BlcmF0aW9uLmVkaXQoZ2VvbWV0cnksIHRoaXMuX2ZhY3RvcnkpXG4gIH1cbiAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCdVbnN1cHBvcnRlZCBHZW9tZXRyeSBjbGFzczogJyArIGdlb21ldHJ5LmdldENsYXNzKCkuZ2V0TmFtZSgpKTtcbiAgcmV0dXJuIG51bGxcbn07XG5HZW9tZXRyeUVkaXRvci5wcm90b3R5cGUuZWRpdEdlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIGVkaXRHZW9tZXRyeUNvbGxlY3Rpb24gKGNvbGxlY3Rpb24sIG9wZXJhdGlvbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjb2xsZWN0aW9uRm9yVHlwZSA9IG9wZXJhdGlvbi5lZGl0KGNvbGxlY3Rpb24sIHRoaXMuX2ZhY3RvcnkpO1xuICB2YXIgZ2VvbWV0cmllcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsZWN0aW9uRm9yVHlwZS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBnZW9tZXRyeSA9IHRoaXMkMS5lZGl0KGNvbGxlY3Rpb25Gb3JUeXBlLmdldEdlb21ldHJ5TihpKSwgb3BlcmF0aW9uKTtcbiAgICBpZiAoZ2VvbWV0cnkgPT09IG51bGwgfHwgZ2VvbWV0cnkuaXNFbXB0eSgpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBnZW9tZXRyaWVzLmFkZChnZW9tZXRyeSk7XG4gIH1cbiAgaWYgKGNvbGxlY3Rpb25Gb3JUeXBlLmdldENsYXNzKCkgPT09IE11bHRpUG9pbnQpIHtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGdlb21ldHJpZXMudG9BcnJheShbXSkpXG4gIH1cbiAgaWYgKGNvbGxlY3Rpb25Gb3JUeXBlLmdldENsYXNzKCkgPT09IE11bHRpTGluZVN0cmluZykge1xuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhnZW9tZXRyaWVzLnRvQXJyYXkoW10pKVxuICB9XG4gIGlmIChjb2xsZWN0aW9uRm9yVHlwZS5nZXRDbGFzcygpID09PSBNdWx0aVBvbHlnb24pIHtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZ2VvbWV0cmllcy50b0FycmF5KFtdKSlcbiAgfVxuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcy50b0FycmF5KFtdKSlcbn07XG5HZW9tZXRyeUVkaXRvci5wcm90b3R5cGUuZWRpdFBvbHlnb24gPSBmdW5jdGlvbiBlZGl0UG9seWdvbiAocG9seWdvbiwgb3BlcmF0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG5ld1BvbHlnb24gPSBvcGVyYXRpb24uZWRpdChwb2x5Z29uLCB0aGlzLl9mYWN0b3J5KTtcbiAgaWYgKG5ld1BvbHlnb24gPT09IG51bGwpIHsgbmV3UG9seWdvbiA9IHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihudWxsKTsgfVxuICBpZiAobmV3UG9seWdvbi5pc0VtcHR5KCkpIHtcbiAgICByZXR1cm4gbmV3UG9seWdvblxuICB9XG4gIHZhciBzaGVsbCA9IHRoaXMuZWRpdChuZXdQb2x5Z29uLmdldEV4dGVyaW9yUmluZygpLCBvcGVyYXRpb24pO1xuICBpZiAoc2hlbGwgPT09IG51bGwgfHwgc2hlbGwuaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbigpXG4gIH1cbiAgdmFyIGhvbGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1BvbHlnb24uZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkrKykge1xuICAgIHZhciBob2xlID0gdGhpcyQxLmVkaXQobmV3UG9seWdvbi5nZXRJbnRlcmlvclJpbmdOKGkpLCBvcGVyYXRpb24pO1xuICAgIGlmIChob2xlID09PSBudWxsIHx8IGhvbGUuaXNFbXB0eSgpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBob2xlcy5hZGQoaG9sZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlUG9seWdvbihzaGVsbCwgaG9sZXMudG9BcnJheShbXSkpXG59O1xuR2VvbWV0cnlFZGl0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeUVkaXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUVkaXRvclxufTtcbkdlb21ldHJ5RWRpdG9yLkdlb21ldHJ5RWRpdG9yT3BlcmF0aW9uID0gZnVuY3Rpb24gR2VvbWV0cnlFZGl0b3JPcGVyYXRpb24gKCkge307XG5zdGF0aWNBY2Nlc3NvcnMkMTYuTm9PcEdlb21ldHJ5T3BlcmF0aW9uLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5vT3BHZW9tZXRyeU9wZXJhdGlvbiB9O1xuc3RhdGljQWNjZXNzb3JzJDE2LkNvb3JkaW5hdGVPcGVyYXRpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29vcmRpbmF0ZU9wZXJhdGlvbiB9O1xuc3RhdGljQWNjZXNzb3JzJDE2LkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBDb29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24gfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdlb21ldHJ5RWRpdG9yLCBzdGF0aWNBY2Nlc3NvcnMkMTYgKTtcblxudmFyIE5vT3BHZW9tZXRyeU9wZXJhdGlvbiA9IGZ1bmN0aW9uIE5vT3BHZW9tZXRyeU9wZXJhdGlvbiAoKSB7fTtcblxuTm9PcEdlb21ldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5lZGl0ID0gZnVuY3Rpb24gZWRpdCAoZ2VvbWV0cnksIGZhY3RvcnkpIHtcbiAgcmV0dXJuIGdlb21ldHJ5XG59O1xuTm9PcEdlb21ldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUVkaXRvci5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbl1cbn07XG5Ob09wR2VvbWV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9PcEdlb21ldHJ5T3BlcmF0aW9uXG59O1xuXG52YXIgQ29vcmRpbmF0ZU9wZXJhdGlvbiA9IGZ1bmN0aW9uIENvb3JkaW5hdGVPcGVyYXRpb24gKCkge307XG5cbkNvb3JkaW5hdGVPcGVyYXRpb24ucHJvdG90eXBlLmVkaXQgPSBmdW5jdGlvbiBlZGl0IChnZW9tZXRyeSwgZmFjdG9yeSkge1xuICB2YXIgY29vcmRzID0gdGhpcy5lZGl0Q29vcmRpbmF0ZXMoZ2VvbWV0cnkuZ2V0Q29vcmRpbmF0ZXMoKSwgZ2VvbWV0cnkpO1xuICBpZiAoY29vcmRzID09PSBudWxsKSB7IHJldHVybiBnZW9tZXRyeSB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIExpbmVhclJpbmcpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGNvb3JkcylcbiAgfVxuICBpZiAoZ2VvbWV0cnkgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhjb29yZHMpXG4gIH1cbiAgaWYgKGdlb21ldHJ5IGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICBpZiAoY29vcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVBvaW50KGNvb3Jkc1swXSlcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUG9pbnQoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gZ2VvbWV0cnlcbn07XG5Db29yZGluYXRlT3BlcmF0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUVkaXRvci5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbl1cbn07XG5Db29yZGluYXRlT3BlcmF0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVPcGVyYXRpb25cbn07XG5cbnZhciBDb29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24gPSBmdW5jdGlvbiBDb29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24gKCkge307XG5cbkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbi5wcm90b3R5cGUuZWRpdCA9IGZ1bmN0aW9uIGVkaXQgKGdlb21ldHJ5LCBmYWN0b3J5KSB7XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIExpbmVhclJpbmcpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZWRpdChnZW9tZXRyeS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSwgZ2VvbWV0cnkpKVxuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZWRpdChnZW9tZXRyeS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSwgZ2VvbWV0cnkpKVxuICB9XG4gIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy5lZGl0KGdlb21ldHJ5LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLCBnZW9tZXRyeSkpXG4gIH1cbiAgcmV0dXJuIGdlb21ldHJ5XG59O1xuQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUVkaXRvci5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbl1cbn07XG5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZVNlcXVlbmNlT3BlcmF0aW9uXG59O1xuXG52YXIgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UgPSBmdW5jdGlvbiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZSAoKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX2RpbWVuc2lvbiA9IDM7XG4gIHRoaXMuX2Nvb3JkaW5hdGVzID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5fZGltZW5zaW9uID0gMztcbiAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSkge1xuICAgICAgdmFyIHNpemUgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9jb29yZGluYXRlcyA9IG5ldyBBcnJheShzaXplKS5maWxsKG51bGwpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLl9jb29yZGluYXRlc1tpXSA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb29yZGluYXRlU2VxdWVuY2UpKSB7XG4gICAgICB2YXIgY29vcmRTZXEgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoY29vcmRTZXEgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoMCkuZmlsbChudWxsKTtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIHRoaXMuX2RpbWVuc2lvbiA9IGNvb3JkU2VxLmdldERpbWVuc2lvbigpO1xuICAgICAgdGhpcy5fY29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoY29vcmRTZXEuc2l6ZSgpKS5maWxsKG51bGwpO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuX2Nvb3JkaW5hdGVzW2kkMV0gPSBjb29yZFNlcS5nZXRDb29yZGluYXRlQ29weShpJDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5ICYmIE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRpbWVuc2lvbiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXM7XG4gICAgICB0aGlzLl9kaW1lbnNpb24gPSBkaW1lbnNpb247XG4gICAgICBpZiAoY29vcmRpbmF0ZXMgPT09IG51bGwpIHsgdGhpcy5fY29vcmRpbmF0ZXMgPSBuZXcgQXJyYXkoMCkuZmlsbChudWxsKTsgfVxuICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pICYmIE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSkge1xuICAgICAgdmFyIHNpemUkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaW1lbnNpb24kMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzID0gbmV3IEFycmF5KHNpemUkMSkuZmlsbChudWxsKTtcbiAgICAgIHRoaXMuX2RpbWVuc2lvbiA9IGRpbWVuc2lvbiQxO1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgc2l6ZSQxOyBpJDIrKykge1xuICAgICAgICB0aGlzJDEuX2Nvb3JkaW5hdGVzW2kkMl0gPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxOCA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLnNldE9yZGluYXRlID0gZnVuY3Rpb24gc2V0T3JkaW5hdGUgKGluZGV4LCBvcmRpbmF0ZUluZGV4LCB2YWx1ZSkge1xuICBzd2l0Y2ggKG9yZGluYXRlSW5kZXgpIHtcbiAgICBjYXNlIENvb3JkaW5hdGVTZXF1ZW5jZS5YOlxuICAgICAgdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnggPSB2YWx1ZTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBDb29yZGluYXRlU2VxdWVuY2UuWTpcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS55ID0gdmFsdWU7XG4gICAgICBicmVha1xuICAgIGNhc2UgQ29vcmRpbmF0ZVNlcXVlbmNlLlo6XG4gICAgICB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueiA9IHZhbHVlO1xuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignaW52YWxpZCBvcmRpbmF0ZUluZGV4JylcbiAgfVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGhcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0T3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRPcmRpbmF0ZSAoaW5kZXgsIG9yZGluYXRlSW5kZXgpIHtcbiAgc3dpdGNoIChvcmRpbmF0ZUluZGV4KSB7XG4gICAgY2FzZSBDb29yZGluYXRlU2VxdWVuY2UuWDpcbiAgICAgIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueFxuICAgIGNhc2UgQ29vcmRpbmF0ZVNlcXVlbmNlLlk6XG4gICAgICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnlcbiAgICBjYXNlIENvb3JkaW5hdGVTZXF1ZW5jZS5aOlxuICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS56XG4gICAgZGVmYXVsdDpcbiAgfVxuICByZXR1cm4gRG91YmxlLk5hTlxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGkgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVzW2ldXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29vcmQgPSBhcmd1bWVudHNbMV07XG4gICAgY29vcmQueCA9IHRoaXMuX2Nvb3JkaW5hdGVzW2luZGV4XS54O1xuICAgIGNvb3JkLnkgPSB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueTtcbiAgICBjb29yZC56ID0gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLno7XG4gIH1cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZUNvcHkgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlQ29weSAoaSkge1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUodGhpcy5fY29vcmRpbmF0ZXNbaV0pXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldERpbWVuc2lvbiA9IGZ1bmN0aW9uIGdldERpbWVuc2lvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9kaW1lbnNpb25cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFggKGluZGV4KSB7XG4gIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1tpbmRleF0ueFxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY2xvbmVDb29yZGluYXRlcyA9IG5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNsb25lQ29vcmRpbmF0ZXNbaV0gPSB0aGlzJDEuX2Nvb3JkaW5hdGVzW2ldLmNsb25lKCk7XG4gIH1cbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZShjbG9uZUNvb3JkaW5hdGVzLCB0aGlzLl9kaW1lbnNpb24pXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmV4cGFuZEVudmVsb3BlID0gZnVuY3Rpb24gZXhwYW5kRW52ZWxvcGUgKGVudikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMkMS5fY29vcmRpbmF0ZXNbaV0pO1xuICB9XG4gIHJldHVybiBlbnZcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjbG9uZUNvb3JkaW5hdGVzID0gbmV3IEFycmF5KHRoaXMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY2xvbmVDb29yZGluYXRlc1tpXSA9IHRoaXMkMS5fY29vcmRpbmF0ZXNbaV0uY29weSgpO1xuICB9XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UoY2xvbmVDb29yZGluYXRlcywgdGhpcy5fZGltZW5zaW9uKVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoID4gMCkge1xuICAgIHZhciBzdHJCdWYgPSBuZXcgU3RyaW5nQnVmZmVyKDE3ICogdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoKTtcbiAgICBzdHJCdWYuYXBwZW5kKCcoJyk7XG4gICAgc3RyQnVmLmFwcGVuZCh0aGlzLl9jb29yZGluYXRlc1swXSk7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgc3RyQnVmLmFwcGVuZCgnLCAnKTtcbiAgICAgIHN0ckJ1Zi5hcHBlbmQodGhpcyQxLl9jb29yZGluYXRlc1tpXSk7XG4gICAgfVxuICAgIHN0ckJ1Zi5hcHBlbmQoJyknKTtcbiAgICByZXR1cm4gc3RyQnVmLnRvU3RyaW5nKClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJygpJ1xuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UucHJvdG90eXBlLmdldFkgPSBmdW5jdGlvbiBnZXRZIChpbmRleCkge1xuICByZXR1cm4gdGhpcy5fY29vcmRpbmF0ZXNbaW5kZXhdLnlcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUudG9Db29yZGluYXRlQXJyYXkgPSBmdW5jdGlvbiB0b0Nvb3JkaW5hdGVBcnJheSAoKSB7XG4gIHJldHVybiB0aGlzLl9jb29yZGluYXRlc1xufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlU2VxdWVuY2UsIFNlcmlhbGl6YWJsZV1cbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQxOC5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC05MTU0Mzg1MDE2MDE4NDA2NTAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlLCBzdGF0aWNBY2Nlc3NvcnMkMTggKTtcblxudmFyIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeSA9IGZ1bmN0aW9uIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeSAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQxNyA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSxpbnN0YW5jZU9iamVjdDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkucHJvdG90eXBlLnJlYWRSZXNvbHZlID0gZnVuY3Rpb24gcmVhZFJlc29sdmUgKCkge1xuICByZXR1cm4gQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5Lmluc3RhbmNlKClcbn07XG5Db29yZGluYXRlQXJyYXlTZXF1ZW5jZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKGNvb3JkaW5hdGVzKVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgICAgdmFyIGNvb3JkU2VxID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBDb29yZGluYXRlQXJyYXlTZXF1ZW5jZShjb29yZFNlcSlcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBzaXplID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkaW1lbnNpb24gPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGRpbWVuc2lvbiA+IDMpIHsgZGltZW5zaW9uID0gMzsgfVxuICAgIGlmIChkaW1lbnNpb24gPCAyKSB7IHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2Uoc2l6ZSkgfVxuICAgIHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2Uoc2l6ZSwgZGltZW5zaW9uKVxuICB9XG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LCBTZXJpYWxpemFibGVdXG59O1xuQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeVxufTtcbkNvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5pbnN0YW5jZSA9IGZ1bmN0aW9uIGluc3RhbmNlICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5pbnN0YW5jZU9iamVjdFxufTtcblxuc3RhdGljQWNjZXNzb3JzJDE3LnNlcmlhbFZlcnNpb25VSUQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTQwOTk1NzcwOTk2MDc1NTE2NTcgfTtcbnN0YXRpY0FjY2Vzc29ycyQxNy5pbnN0YW5jZU9iamVjdC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2VGYWN0b3J5KCkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeSwgc3RhdGljQWNjZXNzb3JzJDE3ICk7XG5cbi8qKlxuICogQHNlZSBodHRwOi8vZG93bmxvYWQub3JhY2xlLmNvbS9qYXZhc2UvNi9kb2NzL2FwaS9qYXZhL3V0aWwvSGFzaE1hcC5odG1sXG4gKlxuICogQGV4dGVuZHMge2phdmFzY3JpcHQudXRpbC5NYXB9XG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBIYXNoTWFwID0gKGZ1bmN0aW9uIChNYXBJbnRlcmZhY2UpIHtcbiAgZnVuY3Rpb24gSGFzaE1hcCAoKSB7XG4gICAgTWFwSW50ZXJmYWNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5tYXBfID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgaWYgKCBNYXBJbnRlcmZhY2UgKSBIYXNoTWFwLl9fcHJvdG9fXyA9IE1hcEludGVyZmFjZTtcbiAgSGFzaE1hcC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBNYXBJbnRlcmZhY2UgJiYgTWFwSW50ZXJmYWNlLnByb3RvdHlwZSApO1xuICBIYXNoTWFwLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhhc2hNYXA7XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwXy5nZXQoa2V5KSB8fCBudWxsXG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaE1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24gcHV0IChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5tYXBfLnNldChrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gdmFsdWVcbiAgfTtcblxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBIYXNoTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMgKCkge1xuICAgIHZhciBhcnJheUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdmFyIGl0ID0gdGhpcy5tYXBfLnZhbHVlcygpO1xuICAgIHZhciBvID0gaXQubmV4dCgpO1xuICAgIHdoaWxlICghby5kb25lKSB7XG4gICAgICBhcnJheUxpc3QuYWRkKG8udmFsdWUpO1xuICAgICAgbyA9IGl0Lm5leHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5TGlzdFxuICB9O1xuXG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIEhhc2hNYXAucHJvdG90eXBlLmVudHJ5U2V0ID0gZnVuY3Rpb24gZW50cnlTZXQgKCkge1xuICAgIHZhciBoYXNoU2V0ID0gbmV3IEhhc2hTZXQoKTtcbiAgICB0aGlzLm1hcF8uZW50cmllcygpLmZvckVhY2goZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiBoYXNoU2V0LmFkZChlbnRyeSk7IH0pO1xuICAgIHJldHVybiBoYXNoU2V0XG4gIH07XG5cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgSGFzaE1hcC5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge1xuICAgIHJldHVybiB0aGlzLm1hcF8uc2l6ZSgpXG4gIH07XG5cbiAgcmV0dXJuIEhhc2hNYXA7XG59KE1hcCQxKSk7XG5cbnZhciBQcmVjaXNpb25Nb2RlbCA9IGZ1bmN0aW9uIFByZWNpc2lvbk1vZGVsICgpIHtcbiAgdGhpcy5fbW9kZWxUeXBlID0gbnVsbDtcbiAgdGhpcy5fc2NhbGUgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX21vZGVsVHlwZSA9IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgVHlwZSkge1xuICAgICAgdmFyIG1vZGVsVHlwZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX21vZGVsVHlwZSA9IG1vZGVsVHlwZTtcbiAgICAgIGlmIChtb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7XG4gICAgICAgIHRoaXMuc2V0U2NhbGUoMS4wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgc2NhbGUgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLl9tb2RlbFR5cGUgPSBQcmVjaXNpb25Nb2RlbC5GSVhFRDtcbiAgICAgIHRoaXMuc2V0U2NhbGUoc2NhbGUpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgUHJlY2lzaW9uTW9kZWwpIHtcbiAgICAgIHZhciBwbSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuX21vZGVsVHlwZSA9IHBtLl9tb2RlbFR5cGU7XG4gICAgICB0aGlzLl9zY2FsZSA9IHBtLl9zY2FsZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMTkgPSB7IHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sbWF4aW11bVByZWNpc2VWYWx1ZTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAob3RoZXIpIHtcbiAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQcmVjaXNpb25Nb2RlbCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgb3RoZXJQcmVjaXNpb25Nb2RlbCA9IG90aGVyO1xuICByZXR1cm4gdGhpcy5fbW9kZWxUeXBlID09PSBvdGhlclByZWNpc2lvbk1vZGVsLl9tb2RlbFR5cGUgJiYgdGhpcy5fc2NhbGUgPT09IG90aGVyUHJlY2lzaW9uTW9kZWwuX3NjYWxlXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgb3RoZXIgPSBvO1xuICB2YXIgc2lnRGlnaXRzID0gdGhpcy5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKTtcbiAgdmFyIG90aGVyU2lnRGlnaXRzID0gb3RoZXIuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCk7XG4gIHJldHVybiBuZXcgSW50ZWdlcihzaWdEaWdpdHMpLmNvbXBhcmVUbyhuZXcgSW50ZWdlcihvdGhlclNpZ0RpZ2l0cykpXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUgKCkge1xuICByZXR1cm4gdGhpcy5fc2NhbGVcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuaXNGbG9hdGluZyA9IGZ1bmN0aW9uIGlzRmxvYXRpbmcgKCkge1xuICByZXR1cm4gdGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElORyB8fCB0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HX1NJTkdMRVxufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5nZXRUeXBlID0gZnVuY3Rpb24gZ2V0VHlwZSAoKSB7XG4gIHJldHVybiB0aGlzLl9tb2RlbFR5cGVcbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBkZXNjcmlwdGlvbiA9ICdVTktOT1dOJztcbiAgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkcpIHtcbiAgICBkZXNjcmlwdGlvbiA9ICdGbG9hdGluZyc7XG4gIH0gZWxzZSBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElOR19TSU5HTEUpIHtcbiAgICBkZXNjcmlwdGlvbiA9ICdGbG9hdGluZy1TaW5nbGUnO1xuICB9IGVsc2UgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRklYRUQpIHtcbiAgICBkZXNjcmlwdGlvbiA9ICdGaXhlZCAoU2NhbGU9JyArIHRoaXMuZ2V0U2NhbGUoKSArICcpJztcbiAgfVxuICByZXR1cm4gZGVzY3JpcHRpb25cbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUubWFrZVByZWNpc2UgPSBmdW5jdGlvbiBtYWtlUHJlY2lzZSAoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJykge1xuICAgIHZhciB2YWwgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKERvdWJsZS5pc05hTih2YWwpKSB7IHJldHVybiB2YWwgfVxuICAgIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZMT0FUSU5HX1NJTkdMRSkge1xuICAgICAgdmFyIGZsb2F0U2luZ2xlVmFsID0gdmFsO1xuICAgICAgcmV0dXJuIGZsb2F0U2luZ2xlVmFsXG4gICAgfVxuICAgIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiB0aGlzLl9zY2FsZSkgLyB0aGlzLl9zY2FsZVxuICAgIH1cbiAgICByZXR1cm4gdmFsXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElORykgeyByZXR1cm4gbnVsbCB9XG4gICAgY29vcmQueCA9IHRoaXMubWFrZVByZWNpc2UoY29vcmQueCk7XG4gICAgY29vcmQueSA9IHRoaXMubWFrZVByZWNpc2UoY29vcmQueSk7XG4gIH1cbn07XG5QcmVjaXNpb25Nb2RlbC5wcm90b3R5cGUuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzID0gZnVuY3Rpb24gZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzICgpIHtcbiAgdmFyIG1heFNpZ0RpZ2l0cyA9IDE2O1xuICBpZiAodGhpcy5fbW9kZWxUeXBlID09PSBQcmVjaXNpb25Nb2RlbC5GTE9BVElORykge1xuICAgIG1heFNpZ0RpZ2l0cyA9IDE2O1xuICB9IGVsc2UgaWYgKHRoaXMuX21vZGVsVHlwZSA9PT0gUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkdfU0lOR0xFKSB7XG4gICAgbWF4U2lnRGlnaXRzID0gNjtcbiAgfSBlbHNlIGlmICh0aGlzLl9tb2RlbFR5cGUgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7XG4gICAgbWF4U2lnRGlnaXRzID0gMSArIE1hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGgubG9nKHRoaXMuZ2V0U2NhbGUoKSkgLyBNYXRoLmxvZygxMCkpKTtcbiAgfVxuICByZXR1cm4gbWF4U2lnRGlnaXRzXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUgKHNjYWxlKSB7XG4gIHRoaXMuX3NjYWxlID0gTWF0aC5hYnMoc2NhbGUpO1xufTtcblByZWNpc2lvbk1vZGVsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZXJpYWxpemFibGUsIENvbXBhcmFibGVdXG59O1xuUHJlY2lzaW9uTW9kZWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUHJlY2lzaW9uTW9kZWxcbn07XG5QcmVjaXNpb25Nb2RlbC5tb3N0UHJlY2lzZSA9IGZ1bmN0aW9uIG1vc3RQcmVjaXNlIChwbTEsIHBtMikge1xuICBpZiAocG0xLmNvbXBhcmVUbyhwbTIpID49IDApIHsgcmV0dXJuIHBtMSB9XG4gIHJldHVybiBwbTJcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMTkuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA3Nzc3MjYzNTc4Nzc3ODAzODM1IH07XG5zdGF0aWNBY2Nlc3NvcnMkMTkubWF4aW11bVByZWNpc2VWYWx1ZS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA5MDA3MTk5MjU0NzQwOTkyLjAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFByZWNpc2lvbk1vZGVsLCBzdGF0aWNBY2Nlc3NvcnMkMTkgKTtcblxudmFyIFR5cGUgPSBmdW5jdGlvbiBUeXBlIChuYW1lKSB7XG4gIHRoaXMuX25hbWUgPSBuYW1lIHx8IG51bGw7XG4gIFR5cGUubmFtZVRvVHlwZU1hcC5wdXQobmFtZSwgdGhpcyk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDEkMSA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSxuYW1lVG9UeXBlTWFwOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5UeXBlLnByb3RvdHlwZS5yZWFkUmVzb2x2ZSA9IGZ1bmN0aW9uIHJlYWRSZXNvbHZlICgpIHtcbiAgcmV0dXJuIFR5cGUubmFtZVRvVHlwZU1hcC5nZXQodGhpcy5fbmFtZSlcbn07XG5UeXBlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIHRoaXMuX25hbWVcbn07XG5UeXBlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZXJpYWxpemFibGVdXG59O1xuVHlwZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBUeXBlXG59O1xuc3RhdGljQWNjZXNzb3JzJDEkMS5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIC01NTI4NjAyNjMxNzMxNTg5ODIyIH07XG5zdGF0aWNBY2Nlc3NvcnMkMSQxLm5hbWVUb1R5cGVNYXAuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEhhc2hNYXAoKSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggVHlwZSwgc3RhdGljQWNjZXNzb3JzJDEkMSApO1xuXG5QcmVjaXNpb25Nb2RlbC5UeXBlID0gVHlwZTtcblByZWNpc2lvbk1vZGVsLkZJWEVEID0gbmV3IFR5cGUoJ0ZJWEVEJyk7XG5QcmVjaXNpb25Nb2RlbC5GTE9BVElORyA9IG5ldyBUeXBlKCdGTE9BVElORycpO1xuUHJlY2lzaW9uTW9kZWwuRkxPQVRJTkdfU0lOR0xFID0gbmV3IFR5cGUoJ0ZMT0FUSU5HIFNJTkdMRScpO1xuXG52YXIgR2VvbWV0cnlGYWN0b3J5ID0gZnVuY3Rpb24gR2VvbWV0cnlGYWN0b3J5ICgpIHtcbiAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBuZXcgUHJlY2lzaW9uTW9kZWwoKTtcbiAgdGhpcy5fU1JJRCA9IDA7XG4gIHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgPSBHZW9tZXRyeUZhY3RvcnkuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKTtcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSkpIHtcbiAgICAgIHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgPSBhcmd1bWVudHNbMF07XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBQcmVjaXNpb25Nb2RlbCkge1xuICAgICAgdGhpcy5fcHJlY2lzaW9uTW9kZWwgPSBhcmd1bWVudHNbMF07XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9TUklEID0gYXJndW1lbnRzWzFdO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9TUklEID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgPSBhcmd1bWVudHNbMl07XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMiA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS50b0dlb21ldHJ5ID0gZnVuY3Rpb24gdG9HZW9tZXRyeSAoZW52ZWxvcGUpIHtcbiAgaWYgKGVudmVsb3BlLmlzTnVsbCgpKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQobnVsbClcbiAgfVxuICBpZiAoZW52ZWxvcGUuZ2V0TWluWCgpID09PSBlbnZlbG9wZS5nZXRNYXhYKCkgJiYgZW52ZWxvcGUuZ2V0TWluWSgpID09PSBlbnZlbG9wZS5nZXRNYXhZKCkpIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2ludChuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNaW5YKCksIGVudmVsb3BlLmdldE1pblkoKSkpXG4gIH1cbiAgaWYgKGVudmVsb3BlLmdldE1pblgoKSA9PT0gZW52ZWxvcGUuZ2V0TWF4WCgpIHx8IGVudmVsb3BlLmdldE1pblkoKSA9PT0gZW52ZWxvcGUuZ2V0TWF4WSgpKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyhbbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWluWCgpLCBlbnZlbG9wZS5nZXRNaW5ZKCkpLCBuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNYXhYKCksIGVudmVsb3BlLmdldE1heFkoKSldKVxuICB9XG4gIHJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKFtuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNaW5YKCksIGVudmVsb3BlLmdldE1pblkoKSksIG5ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1pblgoKSwgZW52ZWxvcGUuZ2V0TWF4WSgpKSwgbmV3IENvb3JkaW5hdGUoZW52ZWxvcGUuZ2V0TWF4WCgpLCBlbnZlbG9wZS5nZXRNYXhZKCkpLCBuZXcgQ29vcmRpbmF0ZShlbnZlbG9wZS5nZXRNYXhYKCksIGVudmVsb3BlLmdldE1pblkoKSksIG5ldyBDb29yZGluYXRlKGVudmVsb3BlLmdldE1pblgoKSwgZW52ZWxvcGUuZ2V0TWluWSgpKV0pLCBudWxsKVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlTGluZVN0cmluZyA9IGZ1bmN0aW9uIGNyZWF0ZUxpbmVTdHJpbmcgKGNvb3JkaW5hdGVzKSB7XG4gIGlmICghY29vcmRpbmF0ZXMpIHsgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSksIHRoaXMpIH1cbiAgZWxzZSBpZiAoY29vcmRpbmF0ZXMgaW5zdGFuY2VvZiBBcnJheSkgeyByZXR1cm4gbmV3IExpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGNvb3JkaW5hdGVzKSwgdGhpcykgfVxuICBlbHNlIGlmIChoYXNJbnRlcmZhY2UoY29vcmRpbmF0ZXMsIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHsgcmV0dXJuIG5ldyBMaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCB0aGlzKSB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiBjcmVhdGVNdWx0aUxpbmVTdHJpbmcgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZXcgTXVsdGlMaW5lU3RyaW5nKG51bGwsIHRoaXMpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsaW5lU3RyaW5ncyA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gbmV3IE11bHRpTGluZVN0cmluZyhsaW5lU3RyaW5ncywgdGhpcylcbiAgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuYnVpbGRHZW9tZXRyeSA9IGZ1bmN0aW9uIGJ1aWxkR2VvbWV0cnkgKGdlb21MaXN0KSB7XG4gIHZhciBnZW9tQ2xhc3MgPSBudWxsO1xuICB2YXIgaXNIZXRlcm9nZW5lb3VzID0gZmFsc2U7XG4gIHZhciBoYXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBmYWxzZTtcbiAgZm9yICh2YXIgaSA9IGdlb21MaXN0Lml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBnZW9tID0gaS5uZXh0KCk7XG4gICAgdmFyIHBhcnRDbGFzcyA9IGdlb20uZ2V0Q2xhc3MoKTtcbiAgICBpZiAoZ2VvbUNsYXNzID09PSBudWxsKSB7XG4gICAgICBnZW9tQ2xhc3MgPSBwYXJ0Q2xhc3M7XG4gICAgfVxuICAgIGlmIChwYXJ0Q2xhc3MgIT09IGdlb21DbGFzcykge1xuICAgICAgaXNIZXRlcm9nZW5lb3VzID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGdlb20uaXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQoKSkgeyBoYXNHZW9tZXRyeUNvbGxlY3Rpb24gPSB0cnVlOyB9XG4gIH1cbiAgaWYgKGdlb21DbGFzcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpXG4gIH1cbiAgaWYgKGlzSGV0ZXJvZ2VuZW91cyB8fCBoYXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oR2VvbWV0cnlGYWN0b3J5LnRvR2VvbWV0cnlBcnJheShnZW9tTGlzdCkpXG4gIH1cbiAgdmFyIGdlb20wID0gZ2VvbUxpc3QuaXRlcmF0b3IoKS5uZXh0KCk7XG4gIHZhciBpc0NvbGxlY3Rpb24gPSBnZW9tTGlzdC5zaXplKCkgPiAxO1xuICBpZiAoaXNDb2xsZWN0aW9uKSB7XG4gICAgaWYgKGdlb20wIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2x5Z29uKEdlb21ldHJ5RmFjdG9yeS50b1BvbHlnb25BcnJheShnZW9tTGlzdCkpXG4gICAgfSBlbHNlIGlmIChnZW9tMCBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpTGluZVN0cmluZyhHZW9tZXRyeUZhY3RvcnkudG9MaW5lU3RyaW5nQXJyYXkoZ2VvbUxpc3QpKVxuICAgIH0gZWxzZSBpZiAoZ2VvbTAgaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChHZW9tZXRyeUZhY3RvcnkudG9Qb2ludEFycmF5KGdlb21MaXN0KSlcbiAgICB9XG4gICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCdVbmhhbmRsZWQgY2xhc3M6ICcgKyBnZW9tMC5nZXRDbGFzcygpLmdldE5hbWUoKSk7XG4gIH1cbiAgcmV0dXJuIGdlb20wXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyA9IGZ1bmN0aW9uIGNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzIChjb29yZGluYXRlcykge1xuICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGNvb3JkaW5hdGVzICE9PSBudWxsID8gdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGNvb3JkaW5hdGVzKSA6IG51bGwpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVQb2ludCA9IGZ1bmN0aW9uIGNyZWF0ZVBvaW50ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2ludCh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVQb2ludChjb29yZGluYXRlICE9PSBudWxsID8gdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtjb29yZGluYXRlXSkgOiBudWxsKVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIG5ldyBQb2ludChjb29yZGluYXRlcywgdGhpcylcbiAgICB9XG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnlcbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZVBvbHlnb24gPSBmdW5jdGlvbiBjcmVhdGVQb2x5Z29uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24obnVsbCwgbnVsbCwgdGhpcylcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvb3JkaW5hdGVTZXF1ZW5jZSkpIHtcbiAgICAgIHZhciBjb29yZGluYXRlcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKGNvb3JkaW5hdGVzKSlcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZXMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKGNvb3JkaW5hdGVzJDEpKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZWFyUmluZykge1xuICAgICAgdmFyIHNoZWxsID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbihzaGVsbCwgbnVsbClcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBzaGVsbCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBob2xlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICByZXR1cm4gbmV3IFBvbHlnb24oc2hlbGwkMSwgaG9sZXMsIHRoaXMpXG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmdldFNSSUQgPSBmdW5jdGlvbiBnZXRTUklEICgpIHtcbiAgcmV0dXJuIHRoaXMuX1NSSURcbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIGNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCwgdGhpcylcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21ldHJpZXMgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIG5ldyBHZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgdGhpcylcbiAgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuY3JlYXRlR2VvbWV0cnkgPSBmdW5jdGlvbiBjcmVhdGVHZW9tZXRyeSAoZykge1xuICB2YXIgZWRpdG9yID0gbmV3IEdlb21ldHJ5RWRpdG9yKHRoaXMpO1xuICByZXR1cm4gZWRpdG9yLmVkaXQoZywge1xuICAgIGVkaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHZhciBjb29yZFNlcSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgLy8gY29uc3QgZ2VvbWV0cnkgPSBhcmd1bWVudHNbMV1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkuY3JlYXRlKGNvb3JkU2VxKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmdldFByZWNpc2lvbk1vZGVsID0gZnVuY3Rpb24gZ2V0UHJlY2lzaW9uTW9kZWwgKCkge1xuICByZXR1cm4gdGhpcy5fcHJlY2lzaW9uTW9kZWxcbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZUxpbmVhclJpbmcgPSBmdW5jdGlvbiBjcmVhdGVMaW5lYXJSaW5nICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyhjb29yZGluYXRlcyAhPT0gbnVsbCA/IHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShjb29yZGluYXRlcykgOiBudWxsKVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gbmV3IExpbmVhclJpbmcoY29vcmRpbmF0ZXMkMSwgdGhpcylcbiAgICB9XG4gIH1cbn07XG5HZW9tZXRyeUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU11bHRpUG9seWdvbiA9IGZ1bmN0aW9uIGNyZWF0ZU11bHRpUG9seWdvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBNdWx0aVBvbHlnb24obnVsbCwgdGhpcylcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHBvbHlnb25zID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiBuZXcgTXVsdGlQb2x5Z29uKHBvbHlnb25zLCB0aGlzKVxuICB9XG59O1xuR2VvbWV0cnlGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVNdWx0aVBvaW50ID0gZnVuY3Rpb24gY3JlYXRlTXVsdGlQb2ludCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE11bHRpUG9pbnQobnVsbCwgdGhpcylcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICB2YXIgcG9pbnQgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gbmV3IE11bHRpUG9pbnQocG9pbnQsIHRoaXMpXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChjb29yZGluYXRlcyAhPT0gbnVsbCA/IHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShjb29yZGluYXRlcykgOiBudWxsKVxuICAgIH0gZWxzZSBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29vcmRpbmF0ZVNlcXVlbmNlKSkge1xuICAgICAgdmFyIGNvb3JkaW5hdGVzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICBpZiAoY29vcmRpbmF0ZXMkMSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKVxuICAgICAgfVxuICAgICAgdmFyIHBvaW50cyA9IG5ldyBBcnJheShjb29yZGluYXRlcyQxLnNpemUoKSkuZmlsbChudWxsKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMkMS5zaXplKCk7IGkrKykge1xuICAgICAgICB2YXIgcHRTZXEgPSB0aGlzJDEuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSgxLCBjb29yZGluYXRlcyQxLmdldERpbWVuc2lvbigpKTtcbiAgICAgICAgQ29vcmRpbmF0ZVNlcXVlbmNlcy5jb3B5KGNvb3JkaW5hdGVzJDEsIGksIHB0U2VxLCAwLCAxKTtcbiAgICAgICAgcG9pbnRzW2ldID0gdGhpcyQxLmNyZWF0ZVBvaW50KHB0U2VxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQocG9pbnRzKVxuICAgIH1cbiAgfVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VyaWFsaXphYmxlXVxufTtcbkdlb21ldHJ5RmFjdG9yeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeUZhY3Rvcnlcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9NdWx0aVBvbHlnb25BcnJheSA9IGZ1bmN0aW9uIHRvTXVsdGlQb2x5Z29uQXJyYXkgKG11bHRpUG9seWdvbnMpIHtcbiAgdmFyIG11bHRpUG9seWdvbkFycmF5ID0gbmV3IEFycmF5KG11bHRpUG9seWdvbnMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gbXVsdGlQb2x5Z29ucy50b0FycmF5KG11bHRpUG9seWdvbkFycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS50b0dlb21ldHJ5QXJyYXkgPSBmdW5jdGlvbiB0b0dlb21ldHJ5QXJyYXkgKGdlb21ldHJpZXMpIHtcbiAgaWYgKGdlb21ldHJpZXMgPT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgZ2VvbWV0cnlBcnJheSA9IG5ldyBBcnJheShnZW9tZXRyaWVzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIGdlb21ldHJpZXMudG9BcnJheShnZW9tZXRyeUFycmF5KVxufTtcbkdlb21ldHJ5RmFjdG9yeS5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSA9IGZ1bmN0aW9uIGdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5ICgpIHtcbiAgcmV0dXJuIENvb3JkaW5hdGVBcnJheVNlcXVlbmNlRmFjdG9yeS5pbnN0YW5jZSgpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvTXVsdGlMaW5lU3RyaW5nQXJyYXkgPSBmdW5jdGlvbiB0b011bHRpTGluZVN0cmluZ0FycmF5IChtdWx0aUxpbmVTdHJpbmdzKSB7XG4gIHZhciBtdWx0aUxpbmVTdHJpbmdBcnJheSA9IG5ldyBBcnJheShtdWx0aUxpbmVTdHJpbmdzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIG11bHRpTGluZVN0cmluZ3MudG9BcnJheShtdWx0aUxpbmVTdHJpbmdBcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9MaW5lU3RyaW5nQXJyYXkgPSBmdW5jdGlvbiB0b0xpbmVTdHJpbmdBcnJheSAobGluZVN0cmluZ3MpIHtcbiAgdmFyIGxpbmVTdHJpbmdBcnJheSA9IG5ldyBBcnJheShsaW5lU3RyaW5ncy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBsaW5lU3RyaW5ncy50b0FycmF5KGxpbmVTdHJpbmdBcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9NdWx0aVBvaW50QXJyYXkgPSBmdW5jdGlvbiB0b011bHRpUG9pbnRBcnJheSAobXVsdGlQb2ludHMpIHtcbiAgdmFyIG11bHRpUG9pbnRBcnJheSA9IG5ldyBBcnJheShtdWx0aVBvaW50cy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBtdWx0aVBvaW50cy50b0FycmF5KG11bHRpUG9pbnRBcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9MaW5lYXJSaW5nQXJyYXkgPSBmdW5jdGlvbiB0b0xpbmVhclJpbmdBcnJheSAobGluZWFyUmluZ3MpIHtcbiAgdmFyIGxpbmVhclJpbmdBcnJheSA9IG5ldyBBcnJheShsaW5lYXJSaW5ncy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIHJldHVybiBsaW5lYXJSaW5ncy50b0FycmF5KGxpbmVhclJpbmdBcnJheSlcbn07XG5HZW9tZXRyeUZhY3RvcnkudG9Qb2ludEFycmF5ID0gZnVuY3Rpb24gdG9Qb2ludEFycmF5IChwb2ludHMpIHtcbiAgdmFyIHBvaW50QXJyYXkgPSBuZXcgQXJyYXkocG9pbnRzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgcmV0dXJuIHBvaW50cy50b0FycmF5KHBvaW50QXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LnRvUG9seWdvbkFycmF5ID0gZnVuY3Rpb24gdG9Qb2x5Z29uQXJyYXkgKHBvbHlnb25zKSB7XG4gIHZhciBwb2x5Z29uQXJyYXkgPSBuZXcgQXJyYXkocG9seWdvbnMuc2l6ZSgpKS5maWxsKG51bGwpO1xuICByZXR1cm4gcG9seWdvbnMudG9BcnJheShwb2x5Z29uQXJyYXkpXG59O1xuR2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQgPSBmdW5jdGlvbiBjcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkIChjb29yZCwgZXhlbXBsYXIpIHtcbiAgZXhlbXBsYXIuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZShjb29yZCk7XG4gIHJldHVybiBleGVtcGxhci5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQoY29vcmQpXG59O1xuc3RhdGljQWNjZXNzb3JzJDIuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtNjgyMDUyNDc1MzA5NDA5NTYzNSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggR2VvbWV0cnlGYWN0b3J5LCBzdGF0aWNBY2Nlc3NvcnMkMiApO1xuXG52YXIgZ2VvbWV0cnlUeXBlcyA9IFsnUG9pbnQnLCAnTXVsdGlQb2ludCcsICdMaW5lU3RyaW5nJywgJ011bHRpTGluZVN0cmluZycsICdQb2x5Z29uJywgJ011bHRpUG9seWdvbiddO1xuXG4vKipcbiAqIENsYXNzIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIFdlbGwtS25vd24gVGV4dC5DcmVhdGUgYSBuZXcgcGFyc2VyIGZvciBHZW9KU09OXG4gKiBOT1RFOiBBZGFwdGVkIGZyb20gT3BlbkxheWVycyAyLjExIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHBhcnNlciBmb3IgR2VvSlNPTlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnlGYWN0b3J5fSBnZW9tZXRyeUZhY3RvcnlcbiAqIEByZXR1cm4gQW4gaW5zdGFuY2Ugb2YgR2VvSnNvblBhcnNlci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xudmFyIEdlb0pTT05QYXJzZXIgPSBmdW5jdGlvbiBHZW9KU09OUGFyc2VyIChnZW9tZXRyeUZhY3RvcnkpIHtcbiAgdGhpcy5nZW9tZXRyeUZhY3RvcnkgPSBnZW9tZXRyeUZhY3RvcnkgfHwgbmV3IEdlb21ldHJ5RmFjdG9yeSgpO1xufTtcbi8qKlxuICogRGVzZXJpYWxpemUgYSBHZW9KU09OIG9iamVjdCBhbmQgcmV0dXJuIHRoZSBHZW9tZXRyeSBvciBGZWF0dXJlKENvbGxlY3Rpb24pIHdpdGggSlNUUyBHZW9tZXRyaWVzXG4gKlxuICogQHBhcmFtIHt9XG4gKiAgICAgICAgQSBHZW9KU09OIG9iamVjdC5cbiAqIEByZXR1cm4ge30gQSBHZW9tZXRyeSBpbnN0YW5jZSBvciBvYmplY3QgcmVwcmVzZW50aW5nIGEgRmVhdHVyZShDb2xsZWN0aW9uKSB3aXRoIEdlb21ldHJ5IGluc3RhbmNlcy5cbiAqIEBwcml2YXRlXG4gKi9cbkdlb0pTT05QYXJzZXIucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiByZWFkIChqc29uKSB7XG4gIHZhciBvYmo7XG4gIGlmICh0eXBlb2YganNvbiA9PT0gJ3N0cmluZycpIHtcbiAgICBvYmogPSBKU09OLnBhcnNlKGpzb24pO1xuICB9IGVsc2Uge1xuICAgIG9iaiA9IGpzb247XG4gIH1cblxuICB2YXIgdHlwZSA9IG9iai50eXBlO1xuXG4gIGlmICghcGFyc2VbdHlwZV0pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gR2VvSlNPTiB0eXBlOiAnICsgb2JqLnR5cGUpXG4gIH1cblxuICBpZiAoZ2VvbWV0cnlUeXBlcy5pbmRleE9mKHR5cGUpICE9PSAtMSkge1xuICAgIHJldHVybiBwYXJzZVt0eXBlXS5hcHBseSh0aGlzLCBbb2JqLmNvb3JkaW5hdGVzXSlcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgIHJldHVybiBwYXJzZVt0eXBlXS5hcHBseSh0aGlzLCBbb2JqLmdlb21ldHJpZXNdKVxuICB9XG5cbiAgLy8gZmVhdHVyZSBvciBmZWF0dXJlIGNvbGxlY3Rpb25cbiAgcmV0dXJuIHBhcnNlW3R5cGVdLmFwcGx5KHRoaXMsIFtvYmpdKVxufTtcblxuLyoqXG4gKiBTZXJpYWxpemUgYSBHZW9tZXRyeSBvYmplY3QgaW50byBHZW9KU09OXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeX1cbiAqICAgICAgICBnZW9tZXRyeSBBIEdlb21ldHJ5IG9yIGFycmF5IG9mIEdlb21ldHJpZXMuXG4gKiBAcmV0dXJuIHtPYmplY3R9IEEgR2VvSlNPTiBvYmplY3QgcmVwcmVzdGluZyB0aGUgaW5wdXQgR2VvbWV0cnkvR2VvbWV0cmllcy5cbiAqIEBwcml2YXRlXG4gKi9cbkdlb0pTT05QYXJzZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKGdlb21ldHJ5KSB7XG4gIHZhciB0eXBlID0gZ2VvbWV0cnkuZ2V0R2VvbWV0cnlUeXBlKCk7XG5cbiAgaWYgKCFleHRyYWN0W3R5cGVdKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHZW9tZXRyeSBpcyBub3Qgc3VwcG9ydGVkJylcbiAgfVxuXG4gIHJldHVybiBleHRyYWN0W3R5cGVdLmFwcGx5KHRoaXMsIFtnZW9tZXRyeV0pXG59O1xuXG52YXIgcGFyc2UgPSB7XG4gIC8qKlxuICAgKiBQYXJzZSBhIEdlb0pTT04gRmVhdHVyZSBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9XG4gICAqICAgICAgICAgIG9iaiBPYmplY3QgdG8gcGFyc2UuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRmVhdHVyZSB3aXRoIGdlb21ldHJ5L2Jib3ggY29udmVydGVkIHRvIEpTVFMgR2VvbWV0cmllcy5cbiAgICovXG4gIEZlYXR1cmU6IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgZmVhdHVyZSA9IHt9O1xuXG4gICAgLy8gY29weSBmZWF0dXJlc1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGZlYXR1cmVba2V5XSA9IG9ialtrZXldO1xuICAgIH1cblxuICAgIC8vIHBhcnNlIGdlb21ldHJ5XG4gICAgaWYgKG9iai5nZW9tZXRyeSkge1xuICAgICAgdmFyIHR5cGUgPSBvYmouZ2VvbWV0cnkudHlwZTtcbiAgICAgIGlmICghcGFyc2VbdHlwZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEdlb0pTT04gdHlwZTogJyArIG9iai50eXBlKVxuICAgICAgfVxuICAgICAgZmVhdHVyZS5nZW9tZXRyeSA9IHRoaXMucmVhZChvYmouZ2VvbWV0cnkpO1xuICAgIH1cblxuICAgIC8vIGJib3hcbiAgICBpZiAob2JqLmJib3gpIHtcbiAgICAgIGZlYXR1cmUuYmJveCA9IHBhcnNlLmJib3guYXBwbHkodGhpcywgW29iai5iYm94XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmVcbiAgfSxcblxuICAvKipcbiAgICogUGFyc2UgYSBHZW9KU09OIEZlYXR1cmVDb2xsZWN0aW9uIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH1cbiAgICogICAgICAgICAgb2JqIE9iamVjdCB0byBwYXJzZS5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBGZWF0dXJlQ29sbGVjdGlvbiB3aXRoIGdlb21ldHJ5L2Jib3ggY29udmVydGVkIHRvIEpTVFMgR2VvbWV0cmllcy5cbiAgICovXG4gIEZlYXR1cmVDb2xsZWN0aW9uOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSB7fTtcblxuICAgIGlmIChvYmouZmVhdHVyZXMpIHtcbiAgICAgIGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmZlYXR1cmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLnB1c2godGhpcyQxLnJlYWQob2JqLmZlYXR1cmVzW2ldKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9iai5iYm94KSB7XG4gICAgICBmZWF0dXJlQ29sbGVjdGlvbi5iYm94ID0gdGhpcy5wYXJzZS5iYm94LmFwcGx5KHRoaXMsIFtvYmouYmJveF0pO1xuICAgIH1cblxuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvblxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IHRoZSBvcmRpbmF0ZXMgaW4gYW4gYXJyYXkgdG8gYW4gYXJyYXkgb2YgQ29vcmRpbmF0ZXNcbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgd2l0aCB7TnVtYmVyfXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSB3aXRoIENvb3JkaW5hdGVzLlxuICAgKi9cbiAgY29vcmRpbmF0ZXM6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciBjb29yZGluYXRlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzdWIgPSBhcnJheVtpXTtcbiAgICAgIGNvb3JkaW5hdGVzLnB1c2gobmV3IENvb3JkaW5hdGUoc3ViWzBdLCBzdWJbMV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvb3JkaW5hdGVzXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgdGhlIGJib3ggdG8gYSBMaW5lYXJSaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGggW3hNaW4sIHlNaW4sIHhNYXgsIHlNYXhdLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBDb29yZGluYXRlcy5cbiAgICovXG4gIGJib3g6IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKFtcbiAgICAgIG5ldyBDb29yZGluYXRlKGFycmF5WzBdLCBhcnJheVsxXSksXG4gICAgICBuZXcgQ29vcmRpbmF0ZShhcnJheVsyXSwgYXJyYXlbMV0pLFxuICAgICAgbmV3IENvb3JkaW5hdGUoYXJyYXlbMl0sIGFycmF5WzNdKSxcbiAgICAgIG5ldyBDb29yZGluYXRlKGFycmF5WzBdLCBhcnJheVszXSksXG4gICAgICBuZXcgQ29vcmRpbmF0ZShhcnJheVswXSwgYXJyYXlbMV0pXG4gICAgXSlcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB3aXRoIG9yZGluYXRlcyB0byBhIFBvaW50XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGggb3JkaW5hdGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtQb2ludH0gUG9pbnQuXG4gICAqL1xuICBQb2ludDogZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgdmFyIGNvb3JkaW5hdGUgPSBuZXcgQ29vcmRpbmF0ZShhcnJheVswXSwgYXJyYXlbMV0pO1xuICAgIHJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChjb29yZGluYXRlKVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5IHdpdGggY29vcmRpbmF0ZXMgdG8gYSBNdWx0aVBvaW50XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGggY29vcmRpbmF0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge011bHRpUG9pbnR9IE11bHRpUG9pbnQuXG4gICAqL1xuICBNdWx0aVBvaW50OiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICBwb2ludHMucHVzaChwYXJzZS5Qb2ludC5hcHBseSh0aGlzJDEsIFthcnJheVtpXV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQocG9pbnRzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5IHdpdGggY29vcmRpbmF0ZXMgdG8gYSBMaW5lU3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGggY29vcmRpbmF0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0xpbmVTdHJpbmd9IExpbmVTdHJpbmcuXG4gICAqL1xuICBMaW5lU3RyaW5nOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgY29vcmRpbmF0ZXMgPSBwYXJzZS5jb29yZGluYXRlcy5hcHBseSh0aGlzLCBbYXJyYXldKTtcbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhjb29yZGluYXRlcylcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB3aXRoIGNvb3JkaW5hdGVzIHRvIGEgTXVsdGlMaW5lU3RyaW5nXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IHdpdGggY29vcmRpbmF0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge011bHRpTGluZVN0cmluZ30gTXVsdGlMaW5lU3RyaW5nLlxuICAgKi9cbiAgTXVsdGlMaW5lU3RyaW5nOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBsaW5lU3RyaW5ncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxpbmVTdHJpbmdzLnB1c2gocGFyc2UuTGluZVN0cmluZy5hcHBseSh0aGlzJDEsIFthcnJheVtpXV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhsaW5lU3RyaW5ncylcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhbiBBcnJheSB0byBhIFBvbHlnb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX1cbiAgICogICAgICAgICAgYXJyYXkgQXJyYXkgd2l0aCBzaGVsbCBhbmQgaG9sZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge1BvbHlnb259IFBvbHlnb24uXG4gICAqL1xuICBQb2x5Z29uOiBmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBzaGVsbENvb3JkaW5hdGVzID0gcGFyc2UuY29vcmRpbmF0ZXMuYXBwbHkodGhpcywgW2FycmF5WzBdXSk7XG4gICAgdmFyIHNoZWxsID0gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhzaGVsbENvb3JkaW5hdGVzKTtcbiAgICB2YXIgaG9sZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgaG9sZSA9IGFycmF5W2ldO1xuICAgICAgdmFyIGNvb3JkaW5hdGVzID0gcGFyc2UuY29vcmRpbmF0ZXMuYXBwbHkodGhpcyQxLCBbaG9sZV0pO1xuICAgICAgdmFyIGxpbmVhclJpbmcgPSB0aGlzJDEuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoY29vcmRpbmF0ZXMpO1xuICAgICAgaG9sZXMucHVzaChsaW5lYXJSaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24oc2hlbGwsIGhvbGVzKVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5IHRvIGEgTXVsdGlQb2x5Z29uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IG9mIGFycmF5cyB3aXRoIHNoZWxsIGFuZCByaW5ncy5cbiAgICpcbiAgICogQHJldHVybiB7TXVsdGlQb2x5Z29ufSBNdWx0aVBvbHlnb24uXG4gICAqL1xuICBNdWx0aVBvbHlnb246IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvbHlnb25zID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBvbHlnb24gPSBhcnJheVtpXTtcbiAgICAgIHBvbHlnb25zLnB1c2gocGFyc2UuUG9seWdvbi5hcHBseSh0aGlzJDEsIFtwb2x5Z29uXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKHBvbHlnb25zKVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGFuIEFycmF5IHRvIGEgR2VvbWV0cnlDb2xsZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9XG4gICAqICAgICAgICAgIGFycmF5IEFycmF5IG9mIEdlb0pTT04gZ2VvbWV0cmllcy5cbiAgICpcbiAgICogQHJldHVybiB7R2VvbWV0cnlDb2xsZWN0aW9ufSBHZW9tZXRyeUNvbGxlY3Rpb24uXG4gICAqL1xuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uIChhcnJheSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGdlb21ldHJpZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgZ2VvbWV0cnkgPSBhcnJheVtpXTtcbiAgICAgIGdlb21ldHJpZXMucHVzaCh0aGlzJDEucmVhZChnZW9tZXRyeSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGdlb21ldHJpZXMpXG4gIH1cbn07XG5cbnZhciBleHRyYWN0ID0ge1xuICAvKipcbiAgICogQ29udmVydCBhIENvb3JkaW5hdGUgdG8gYW4gQXJyYXlcbiAgICpcbiAgICogQHBhcmFtIHtDb29yZGluYXRlfVxuICAgKiAgICAgICAgICBjb29yZGluYXRlIENvb3JkaW5hdGUgdG8gY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIG9yZGluYXRlcy5cbiAgICovXG4gIGNvb3JkaW5hdGU6IGZ1bmN0aW9uIChjb29yZGluYXRlKSB7XG4gICAgcmV0dXJuIFtjb29yZGluYXRlLngsIGNvb3JkaW5hdGUueV1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIFBvaW50IHRvIGEgR2VvSlNPTiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtQb2ludH1cbiAgICogICAgICAgICAgcG9pbnQgUG9pbnQgdG8gY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIDIgb3JkaW5hdGVzIChwYWlyZWQgdG8gYSBjb29yZGluYXRlKS5cbiAgICovXG4gIFBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICB2YXIgYXJyYXkgPSBleHRyYWN0LmNvb3JkaW5hdGUuYXBwbHkodGhpcywgW3BvaW50LmdldENvb3JkaW5hdGUoKV0pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgY29vcmRpbmF0ZXM6IGFycmF5XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgTXVsdGlQb2ludCB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlQb2ludH1cbiAgICogICAgICAgICAgbXVsdGlwb2ludCBNdWx0aVBvaW50IHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBjb29yZGluYXRlcy5cbiAgICovXG4gIE11bHRpUG9pbnQ6IGZ1bmN0aW9uIChtdWx0aXBvaW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpcG9pbnQuX2dlb21ldHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBwb2ludCA9IG11bHRpcG9pbnQuX2dlb21ldHJpZXNbaV07XG4gICAgICB2YXIgZ2VvSnNvbiA9IGV4dHJhY3QuUG9pbnQuYXBwbHkodGhpcyQxLCBbcG9pbnRdKTtcbiAgICAgIGFycmF5LnB1c2goZ2VvSnNvbi5jb29yZGluYXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTXVsdGlQb2ludCcsXG4gICAgICBjb29yZGluYXRlczogYXJyYXlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBMaW5lU3RyaW5nIHRvIGEgR2VvSlNPTiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtMaW5lU3RyaW5nfVxuICAgKiAgICAgICAgICBsaW5lc3RyaW5nIExpbmVTdHJpbmcgdG8gY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGNvb3JkaW5hdGVzLlxuICAgKi9cbiAgTGluZVN0cmluZzogZnVuY3Rpb24gKGxpbmVzdHJpbmcpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBhcnJheSA9IFtdO1xuICAgIHZhciBjb29yZGluYXRlcyA9IGxpbmVzdHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkaW5hdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY29vcmRpbmF0ZSA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgYXJyYXkucHVzaChleHRyYWN0LmNvb3JkaW5hdGUuYXBwbHkodGhpcyQxLCBbY29vcmRpbmF0ZV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgIGNvb3JkaW5hdGVzOiBhcnJheVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydCBhIE11bHRpTGluZVN0cmluZyB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7TXVsdGlMaW5lU3RyaW5nfVxuICAgKiAgICAgICAgICBtdWx0aWxpbmVzdHJpbmcgTXVsdGlMaW5lU3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiBBcnJheSBvZiBjb29yZGluYXRlcy5cbiAgICovXG4gIE11bHRpTGluZVN0cmluZzogZnVuY3Rpb24gKG11bHRpbGluZXN0cmluZykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aWxpbmVzdHJpbmcuX2dlb21ldHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lc3RyaW5nID0gbXVsdGlsaW5lc3RyaW5nLl9nZW9tZXRyaWVzW2ldO1xuICAgICAgdmFyIGdlb0pzb24gPSBleHRyYWN0LkxpbmVTdHJpbmcuYXBwbHkodGhpcyQxLCBbbGluZXN0cmluZ10pO1xuICAgICAgYXJyYXkucHVzaChnZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICAgICAgY29vcmRpbmF0ZXM6IGFycmF5XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgUG9seWdvbiB0byBhIEdlb0pTT04gb2JqZWN0XG4gICAqXG4gICAqIEBwYXJhbSB7UG9seWdvbn1cbiAgICogICAgICAgICAgcG9seWdvbiBQb2x5Z29uIHRvIGNvbnZlcnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSB3aXRoIHNoZWxsLCBob2xlcy5cbiAgICovXG4gIFBvbHlnb246IGZ1bmN0aW9uIChwb2x5Z29uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICB2YXIgc2hlbGxHZW9Kc29uID0gZXh0cmFjdC5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsIFtwb2x5Z29uLl9zaGVsbF0pO1xuICAgIGFycmF5LnB1c2goc2hlbGxHZW9Kc29uLmNvb3JkaW5hdGVzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb24uX2hvbGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgaG9sZSA9IHBvbHlnb24uX2hvbGVzW2ldO1xuICAgICAgdmFyIGhvbGVHZW9Kc29uID0gZXh0cmFjdC5MaW5lU3RyaW5nLmFwcGx5KHRoaXMkMSwgW2hvbGVdKTtcbiAgICAgIGFycmF5LnB1c2goaG9sZUdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgY29vcmRpbmF0ZXM6IGFycmF5XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGEgTXVsdGlQb2x5Z29uIHRvIGEgR2VvSlNPTiBvYmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtNdWx0aVBvbHlnb259XG4gICAqICAgICAgICAgIG11bHRpcG9seWdvbiBNdWx0aVBvbHlnb24gdG8gY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIHBvbHlnb25zLlxuICAgKi9cbiAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbiAobXVsdGlwb2x5Z29uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG11bHRpcG9seWdvbi5fZ2VvbWV0cmllcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHBvbHlnb24gPSBtdWx0aXBvbHlnb24uX2dlb21ldHJpZXNbaV07XG4gICAgICB2YXIgZ2VvSnNvbiA9IGV4dHJhY3QuUG9seWdvbi5hcHBseSh0aGlzJDEsIFtwb2x5Z29uXSk7XG4gICAgICBhcnJheS5wdXNoKGdlb0pzb24uY29vcmRpbmF0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICBjb29yZGluYXRlczogYXJyYXlcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnQgYSBHZW9tZXRyeUNvbGxlY3Rpb24gdG8gYSBHZW9KU09OIG9iamVjdFxuICAgKlxuICAgKiBAcGFyYW0ge0dlb21ldHJ5Q29sbGVjdGlvbn1cbiAgICogICAgICAgICAgY29sbGVjdGlvbiBHZW9tZXRyeUNvbGxlY3Rpb24gdG8gY29udmVydC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IG9mIGdlb21ldHJpZXMuXG4gICAqL1xuICBHZW9tZXRyeUNvbGxlY3Rpb246IGZ1bmN0aW9uIChjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbGxlY3Rpb24uX2dlb21ldHJpZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBnZW9tZXRyeSA9IGNvbGxlY3Rpb24uX2dlb21ldHJpZXNbaV07XG4gICAgICB2YXIgdHlwZSA9IGdlb21ldHJ5LmdldEdlb21ldHJ5VHlwZSgpO1xuICAgICAgYXJyYXkucHVzaChleHRyYWN0W3R5cGVdLmFwcGx5KHRoaXMkMSwgW2dlb21ldHJ5XSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbicsXG4gICAgICBnZW9tZXRyaWVzOiBhcnJheVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGdlb21ldHJ5IGluIEdlb0pTT04gdG8gYSB7QGxpbmsgR2VvbWV0cnl9LlxuICovXG5cbi8qKlxuICogQSA8Y29kZT5HZW9KU09OUmVhZGVyPC9jb2RlPiBpcyBwYXJhbWV0ZXJpemVkIGJ5IGEgPGNvZGU+R2VvbWV0cnlGYWN0b3J5PC9jb2RlPixcbiAqIHRvIGFsbG93IGl0IHRvIGNyZWF0ZSA8Y29kZT5HZW9tZXRyeTwvY29kZT4gb2JqZWN0cyBvZiB0aGUgYXBwcm9wcmlhdGVcbiAqIGltcGxlbWVudGF0aW9uLiBJbiBwYXJ0aWN1bGFyLCB0aGUgPGNvZGU+R2VvbWV0cnlGYWN0b3J5PC9jb2RlPiBkZXRlcm1pbmVzXG4gKiB0aGUgPGNvZGU+UHJlY2lzaW9uTW9kZWw8L2NvZGU+IGFuZCA8Y29kZT5TUklEPC9jb2RlPiB0aGF0IGlzIHVzZWQuXG4gKlxuICogQHBhcmFtIHtHZW9tZXRyeUZhY3Rvcnl9IGdlb21ldHJ5RmFjdG9yeVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBHZW9KU09OUmVhZGVyID0gZnVuY3Rpb24gR2VvSlNPTlJlYWRlciAoZ2VvbWV0cnlGYWN0b3J5KSB7XG4gIHRoaXMuZ2VvbWV0cnlGYWN0b3J5ID0gZ2VvbWV0cnlGYWN0b3J5IHx8IG5ldyBHZW9tZXRyeUZhY3RvcnkoKTtcbiAgdGhpcy5wcmVjaXNpb25Nb2RlbCA9IHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCk7XG4gIHRoaXMucGFyc2VyID0gbmV3IEdlb0pTT05QYXJzZXIodGhpcy5nZW9tZXRyeUZhY3RvcnkpO1xufTtcbi8qKlxuICogUmVhZHMgYSBHZW9KU09OIHJlcHJlc2VudGF0aW9uIG9mIGEge0BsaW5rIEdlb21ldHJ5fVxuICpcbiAqIFdpbGwgYWxzbyBwYXJzZSBHZW9KU09OIEZlYXR1cmVzL0ZlYXR1cmVDb2xsZWN0aW9ucyBhcyBjdXN0b20gb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGdlb0pzb24gYSBHZW9KU09OIE9iamVjdCBvciBTdHJpbmcuXG4gKiBAcmV0dXJuIHtHZW9tZXRyeXxPYmplY3R9IGEgPGNvZGU+R2VvbWV0cnkgb3IgRmVhdHVyZS9GZWF0dXJlQ29sbGVjdGlvbiByZXByZXNlbnRhdGlvbi48L2NvZGU+XG4gKiBAbWVtYmVyb2YgR2VvSlNPTlJlYWRlclxuICovXG5HZW9KU09OUmVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gcmVhZCAoZ2VvSnNvbikge1xuICB2YXIgZ2VvbWV0cnkgPSB0aGlzLnBhcnNlci5yZWFkKGdlb0pzb24pO1xuXG4gIGlmICh0aGlzLnByZWNpc2lvbk1vZGVsLmdldFR5cGUoKSA9PT0gUHJlY2lzaW9uTW9kZWwuRklYRUQpIHtcbiAgICB0aGlzLnJlZHVjZVByZWNpc2lvbihnZW9tZXRyeSk7XG4gIH1cblxuICByZXR1cm4gZ2VvbWV0cnlcbn07XG5cbi8vIE5PVEU6IHRoaXMgaXMgYSBoYWNrXG5HZW9KU09OUmVhZGVyLnByb3RvdHlwZS5yZWR1Y2VQcmVjaXNpb24gPSBmdW5jdGlvbiByZWR1Y2VQcmVjaXNpb24gKGdlb21ldHJ5KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGksIGxlbjtcblxuICBpZiAoZ2VvbWV0cnkuY29vcmRpbmF0ZSkge1xuICAgIHRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoZ2VvbWV0cnkuY29vcmRpbmF0ZSk7XG4gIH0gZWxzZSBpZiAoZ2VvbWV0cnkucG9pbnRzKSB7XG4gICAgZm9yIChpID0gMCwgbGVuID0gZ2VvbWV0cnkucG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0aGlzJDEucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UoZ2VvbWV0cnkucG9pbnRzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZ2VvbWV0cnkuZ2VvbWV0cmllcykge1xuICAgIGZvciAoaSA9IDAsIGxlbiA9IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMkMS5yZWR1Y2VQcmVjaXNpb24oZ2VvbWV0cnkuZ2VvbWV0cmllc1tpXSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEBtb2R1bGUgR2VvSlNPTldyaXRlclxuICovXG5cbi8qKlxuICogV3JpdGVzIHRoZSBHZW9KU09OIHJlcHJlc2VudGF0aW9uIG9mIGEge0BsaW5rIEdlb21ldHJ5fS4gVGhlXG4gKiBUaGUgR2VvSlNPTiBmb3JtYXQgaXMgZGVmaW5lZCA8QVxuICogSFJFRj1cImh0dHA6Ly9nZW9qc29uLm9yZy9nZW9qc29uLXNwZWMuaHRtbFwiPmhlcmU8L0E+LlxuICovXG5cbi8qKlxuICogVGhlIDxjb2RlPkdlb0pTT05Xcml0ZXI8L2NvZGU+IG91dHB1dHMgY29vcmRpbmF0ZXMgcm91bmRlZCB0byB0aGUgcHJlY2lzaW9uXG4gKiBtb2RlbC4gT25seSB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGVcbiAqIG9yZGluYXRlcyB0byB0aGUgcmVxdWlyZWQgcHJlY2lzaW9uIHdpbGwgYmUgb3V0cHV0LlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnlGYWN0b3J5fSBnZW9tZXRyeUZhY3RvcnlcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgR2VvSlNPTldyaXRlciA9IGZ1bmN0aW9uIEdlb0pTT05Xcml0ZXIgKCkge1xuICB0aGlzLnBhcnNlciA9IG5ldyBHZW9KU09OUGFyc2VyKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtcbn07XG4vKipcbiAqIENvbnZlcnRzIGEgPGNvZGU+R2VvbWV0cnk8L2NvZGU+IHRvIGl0cyBHZW9KU09OIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7R2VvbWV0cnl9XG4gKiAgICAgICAgZ2VvbWV0cnkgYSA8Y29kZT5HZW9tZXRyeTwvY29kZT4gdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIEdlb0pTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIEdlb21ldHJ5LlxuICogQG1lbWJlcm9mIEdlb0pTT05Xcml0ZXJcbiAqL1xuR2VvSlNPTldyaXRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoZ2VvbWV0cnkpIHtcbiAgcmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKGdlb21ldHJ5KVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW5kZWYgKi9cblxuLy8gaW9cblxudmFyIFBvc2l0aW9uID0gZnVuY3Rpb24gUG9zaXRpb24gKCkge307XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjAgPSB7IE9OOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LExFRlQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sUklHSFQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuUG9zaXRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb3NpdGlvblxufTtcblBvc2l0aW9uLm9wcG9zaXRlID0gZnVuY3Rpb24gb3Bwb3NpdGUgKHBvc2l0aW9uKSB7XG4gIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uTEVGVCkgeyByZXR1cm4gUG9zaXRpb24uUklHSFQgfVxuICBpZiAocG9zaXRpb24gPT09IFBvc2l0aW9uLlJJR0hUKSB7IHJldHVybiBQb3NpdGlvbi5MRUZUIH1cbiAgcmV0dXJuIHBvc2l0aW9uXG59O1xuc3RhdGljQWNjZXNzb3JzJDIwLk9OLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMC5MRUZULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMC5SSUdIVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBQb3NpdGlvbiwgc3RhdGljQWNjZXNzb3JzJDIwICk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIE9wdGlvbmFsIG1lc3NhZ2VcbiAqIEBleHRlbmRzIHtFcnJvcn1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRW1wdHlTdGFja0V4Y2VwdGlvbiAobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xufVxuRW1wdHlTdGFja0V4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5FbXB0eVN0YWNrRXhjZXB0aW9uLnByb3RvdHlwZS5uYW1lID0gJ0VtcHR5U3RhY2tFeGNlcHRpb24nO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL2Rvd25sb2FkLm9yYWNsZS5jb20vamF2YXNlLzYvZG9jcy9hcGkvamF2YS91dGlsL1N0YWNrLmh0bWxcbiAqXG4gKiBAZXh0ZW5kcyB7TGlzdH1cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gU3RhY2sgKCkge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpcy5hcnJheV8gPSBbXTtcbn1cblN0YWNrLnByb3RvdHlwZSA9IG5ldyBMaXN0KCk7XG5cbi8qKlxuICogQG92ZXJyaWRlXG4gKi9cblN0YWNrLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoZSkge1xuICB0aGlzLmFycmF5Xy5wdXNoKGUpO1xuICByZXR1cm4gdHJ1ZVxufTtcblxuLyoqXG4gKiBAb3ZlcnJpZGVcbiAqL1xuU3RhY2sucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuc2l6ZSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKClcbiAgfVxuXG4gIHJldHVybiB0aGlzLmFycmF5X1tpbmRleF1cbn07XG5cbi8qKlxuICogUHVzaGVzIGFuIGl0ZW0gb250byB0aGUgdG9wIG9mIHRoaXMgc3RhY2suXG4gKiBAcGFyYW0ge09iamVjdH0gZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5TdGFjay5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChlKSB7XG4gIHRoaXMuYXJyYXlfLnB1c2goZSk7XG4gIHJldHVybiBlXG59O1xuXG4vKipcbiAqIFB1c2hlcyBhbiBpdGVtIG9udG8gdGhlIHRvcCBvZiB0aGlzIHN0YWNrLlxuICogQHBhcmFtIHtPYmplY3R9IGVcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuU3RhY2sucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uIChlKSB7XG4gIGlmICh0aGlzLmFycmF5Xy5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlTdGFja0V4Y2VwdGlvbigpXG4gIH1cblxuICByZXR1cm4gdGhpcy5hcnJheV8ucG9wKClcbn07XG5cbi8qKlxuICogTG9va3MgYXQgdGhlIG9iamVjdCBhdCB0aGUgdG9wIG9mIHRoaXMgc3RhY2sgd2l0aG91dCByZW1vdmluZyBpdCBmcm9tIHRoZVxuICogc3RhY2suXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cblN0YWNrLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hcnJheV8ubGVuZ3RoID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5U3RhY2tFeGNlcHRpb24oKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuYXJyYXlfW3RoaXMuYXJyYXlfLmxlbmd0aCAtIDFdXG59O1xuXG4vKipcbiAqIFRlc3RzIGlmIHRoaXMgc3RhY2sgaXMgZW1wdHkuXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGFuZCBvbmx5IGlmIHRoaXMgc3RhY2sgY29udGFpbnMgbm8gaXRlbXM7IGZhbHNlXG4gKiAgICAgICAgIG90aGVyd2lzZS5cbiAqL1xuU3RhY2sucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5hcnJheV8ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufTtcblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5TdGFjay5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuZW1wdHkoKVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSAxLWJhc2VkIHBvc2l0aW9uIHdoZXJlIGFuIG9iamVjdCBpcyBvbiB0aGlzIHN0YWNrLiBJZiB0aGUgb2JqZWN0XG4gKiBvIG9jY3VycyBhcyBhbiBpdGVtIGluIHRoaXMgc3RhY2ssIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGRpc3RhbmNlIGZyb20gdGhlXG4gKiB0b3Agb2YgdGhlIHN0YWNrIG9mIHRoZSBvY2N1cnJlbmNlIG5lYXJlc3QgdGhlIHRvcCBvZiB0aGUgc3RhY2s7IHRoZSB0b3Btb3N0XG4gKiBpdGVtIG9uIHRoZSBzdGFjayBpcyBjb25zaWRlcmVkIHRvIGJlIGF0IGRpc3RhbmNlIDEuIFRoZSBlcXVhbHMgbWV0aG9kIGlzXG4gKiB1c2VkIHRvIGNvbXBhcmUgbyB0byB0aGUgaXRlbXMgaW4gdGhpcyBzdGFjay5cbiAqXG4gKiBOT1RFOiBkb2VzIG5vdCBjdXJyZW50bHkgYWN0dWFsbHkgdXNlIGVxdWFscy4gKD09PSBpcyB1c2VkKVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSAxLWJhc2VkIHBvc2l0aW9uIGZyb20gdGhlIHRvcCBvZiB0aGUgc3RhY2sgd2hlcmUgdGhlXG4gKiAgICAgICAgIG9iamVjdCBpcyBsb2NhdGVkOyB0aGUgcmV0dXJuIHZhbHVlIC0xIGluZGljYXRlcyB0aGF0IHRoZSBvYmplY3QgaXNcbiAqICAgICAgICAgbm90IG9uIHRoZSBzdGFjay5cbiAqL1xuU3RhY2sucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5pbmRleE9mKG8pXG59O1xuXG4vKipcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqIEBleHBvcnRcbiAqL1xuU3RhY2sucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGhcbn07XG5cbi8qKlxuICogQHJldHVybiB7QXJyYXl9XG4gKi9cblN0YWNrLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgYXJyYXkgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5hcnJheV8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnJheS5wdXNoKHRoaXMkMS5hcnJheV9baV0pO1xuICB9XG5cbiAgcmV0dXJuIGFycmF5XG59O1xuXG52YXIgUmlnaHRtb3N0RWRnZUZpbmRlciA9IGZ1bmN0aW9uIFJpZ2h0bW9zdEVkZ2VGaW5kZXIgKCkge1xuICB0aGlzLl9taW5JbmRleCA9IC0xO1xuICB0aGlzLl9taW5Db29yZCA9IG51bGw7XG4gIHRoaXMuX21pbkRlID0gbnVsbDtcbiAgdGhpcy5fb3JpZW50ZWREZSA9IG51bGw7XG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5fbWluQ29vcmRcbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5nZXRSaWdodG1vc3RTaWRlID0gZnVuY3Rpb24gZ2V0UmlnaHRtb3N0U2lkZSAoZGUsIGluZGV4KSB7XG4gIHZhciBzaWRlID0gdGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KGRlLCBpbmRleCk7XG4gIGlmIChzaWRlIDwgMCkgeyBzaWRlID0gdGhpcy5nZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50KGRlLCBpbmRleCAtIDEpOyB9XG4gIGlmIChzaWRlIDwgMCkge1xuICAgIHRoaXMuX21pbkNvb3JkID0gbnVsbDtcbiAgICB0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZShkZSk7XG4gIH1cbiAgcmV0dXJuIHNpZGVcbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4ID0gZnVuY3Rpb24gZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleCAoKSB7XG4gIHZhciBwdHMgPSB0aGlzLl9taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgQXNzZXJ0LmlzVHJ1ZSh0aGlzLl9taW5JbmRleCA+IDAgJiYgdGhpcy5fbWluSW5kZXggPCBwdHMubGVuZ3RoLCAncmlnaHRtb3N0IHBvaW50IGV4cGVjdGVkIHRvIGJlIGludGVyaW9yIHZlcnRleCBvZiBlZGdlJyk7XG4gIHZhciBwUHJldiA9IHB0c1t0aGlzLl9taW5JbmRleCAtIDFdO1xuICB2YXIgcE5leHQgPSBwdHNbdGhpcy5fbWluSW5kZXggKyAxXTtcbiAgdmFyIG9yaWVudGF0aW9uID0gQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbih0aGlzLl9taW5Db29yZCwgcE5leHQsIHBQcmV2KTtcbiAgdmFyIHVzZVByZXYgPSBmYWxzZTtcbiAgaWYgKHBQcmV2LnkgPCB0aGlzLl9taW5Db29yZC55ICYmIHBOZXh0LnkgPCB0aGlzLl9taW5Db29yZC55ICYmIG9yaWVudGF0aW9uID09PSBDR0FsZ29yaXRobXMuQ09VTlRFUkNMT0NLV0lTRSkge1xuICAgIHVzZVByZXYgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHBQcmV2LnkgPiB0aGlzLl9taW5Db29yZC55ICYmIHBOZXh0LnkgPiB0aGlzLl9taW5Db29yZC55ICYmIG9yaWVudGF0aW9uID09PSBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFKSB7XG4gICAgdXNlUHJldiA9IHRydWU7XG4gIH1cbiAgaWYgKHVzZVByZXYpIHtcbiAgICB0aGlzLl9taW5JbmRleCA9IHRoaXMuX21pbkluZGV4IC0gMTtcbiAgfVxufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQgPSBmdW5jdGlvbiBnZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50IChkZSwgaSkge1xuICB2YXIgZSA9IGRlLmdldEVkZ2UoKTtcbiAgdmFyIGNvb3JkID0gZS5nZXRDb29yZGluYXRlcygpO1xuICBpZiAoaSA8IDAgfHwgaSArIDEgPj0gY29vcmQubGVuZ3RoKSB7IHJldHVybiAtMSB9XG4gIGlmIChjb29yZFtpXS55ID09PSBjb29yZFtpICsgMV0ueSkgeyByZXR1cm4gLTEgfVxuICB2YXIgcG9zID0gUG9zaXRpb24uTEVGVDtcbiAgaWYgKGNvb3JkW2ldLnkgPCBjb29yZFtpICsgMV0ueSkgeyBwb3MgPSBQb3NpdGlvbi5SSUdIVDsgfVxuICByZXR1cm4gcG9zXG59O1xuUmlnaHRtb3N0RWRnZUZpbmRlci5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uIGdldEVkZ2UgKCkge1xuICByZXR1cm4gdGhpcy5fb3JpZW50ZWREZVxufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSAoZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29vcmQgPSBkZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLl9taW5Db29yZCA9PT0gbnVsbCB8fCBjb29yZFtpXS54ID4gdGhpcyQxLl9taW5Db29yZC54KSB7XG4gICAgICB0aGlzJDEuX21pbkRlID0gZGU7XG4gICAgICB0aGlzJDEuX21pbkluZGV4ID0gaTtcbiAgICAgIHRoaXMkMS5fbWluQ29vcmQgPSBjb29yZFtpXTtcbiAgICB9XG4gIH1cbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5maW5kUmlnaHRtb3N0RWRnZUF0Tm9kZSA9IGZ1bmN0aW9uIGZpbmRSaWdodG1vc3RFZGdlQXROb2RlICgpIHtcbiAgdmFyIG5vZGUgPSB0aGlzLl9taW5EZS5nZXROb2RlKCk7XG4gIHZhciBzdGFyID0gbm9kZS5nZXRFZGdlcygpO1xuICB0aGlzLl9taW5EZSA9IHN0YXIuZ2V0UmlnaHRtb3N0RWRnZSgpO1xuICBpZiAoIXRoaXMuX21pbkRlLmlzRm9yd2FyZCgpKSB7XG4gICAgdGhpcy5fbWluRGUgPSB0aGlzLl9taW5EZS5nZXRTeW0oKTtcbiAgICB0aGlzLl9taW5JbmRleCA9IHRoaXMuX21pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLmxlbmd0aCAtIDE7XG4gIH1cbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5maW5kRWRnZSA9IGZ1bmN0aW9uIGZpbmRFZGdlIChkaXJFZGdlTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSBkaXJFZGdlTGlzdC5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpLm5leHQoKTtcbiAgICBpZiAoIWRlLmlzRm9yd2FyZCgpKSB7IGNvbnRpbnVlIH1cbiAgICB0aGlzJDEuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKGRlKTtcbiAgfVxuICBBc3NlcnQuaXNUcnVlKHRoaXMuX21pbkluZGV4ICE9PSAwIHx8IHRoaXMuX21pbkNvb3JkLmVxdWFscyh0aGlzLl9taW5EZS5nZXRDb29yZGluYXRlKCkpLCAnaW5jb25zaXN0ZW5jeSBpbiByaWdodG1vc3QgcHJvY2Vzc2luZycpO1xuICBpZiAodGhpcy5fbWluSW5kZXggPT09IDApIHtcbiAgICB0aGlzLmZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCk7XG4gIH1cbiAgdGhpcy5fb3JpZW50ZWREZSA9IHRoaXMuX21pbkRlO1xuICB2YXIgcmlnaHRtb3N0U2lkZSA9IHRoaXMuZ2V0UmlnaHRtb3N0U2lkZSh0aGlzLl9taW5EZSwgdGhpcy5fbWluSW5kZXgpO1xuICBpZiAocmlnaHRtb3N0U2lkZSA9PT0gUG9zaXRpb24uTEVGVCkge1xuICAgIHRoaXMuX29yaWVudGVkRGUgPSB0aGlzLl9taW5EZS5nZXRTeW0oKTtcbiAgfVxufTtcblJpZ2h0bW9zdEVkZ2VGaW5kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5SaWdodG1vc3RFZGdlRmluZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFJpZ2h0bW9zdEVkZ2VGaW5kZXJcbn07XG5cbnZhciBUb3BvbG9neUV4Y2VwdGlvbiA9IChmdW5jdGlvbiAoUnVudGltZUV4Y2VwdGlvbiQkMSkge1xuICBmdW5jdGlvbiBUb3BvbG9neUV4Y2VwdGlvbiAobXNnLCBwdCkge1xuICAgIFJ1bnRpbWVFeGNlcHRpb24kJDEuY2FsbCh0aGlzLCBUb3BvbG9neUV4Y2VwdGlvbi5tc2dXaXRoQ29vcmQobXNnLCBwdCkpO1xuICAgIHRoaXMucHQgPSBwdCA/IG5ldyBDb29yZGluYXRlKHB0KSA6IG51bGw7XG4gICAgdGhpcy5uYW1lID0gJ1RvcG9sb2d5RXhjZXB0aW9uJztcbiAgfVxuXG4gIGlmICggUnVudGltZUV4Y2VwdGlvbiQkMSApIFRvcG9sb2d5RXhjZXB0aW9uLl9fcHJvdG9fXyA9IFJ1bnRpbWVFeGNlcHRpb24kJDE7XG4gIFRvcG9sb2d5RXhjZXB0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJ1bnRpbWVFeGNlcHRpb24kJDEgJiYgUnVudGltZUV4Y2VwdGlvbiQkMS5wcm90b3R5cGUgKTtcbiAgVG9wb2xvZ3lFeGNlcHRpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gVG9wb2xvZ3lFeGNlcHRpb247XG4gIFRvcG9sb2d5RXhjZXB0aW9uLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHRcbiAgfTtcbiAgVG9wb2xvZ3lFeGNlcHRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBUb3BvbG9neUV4Y2VwdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFRvcG9sb2d5RXhjZXB0aW9uXG4gIH07XG4gIFRvcG9sb2d5RXhjZXB0aW9uLm1zZ1dpdGhDb29yZCA9IGZ1bmN0aW9uIG1zZ1dpdGhDb29yZCAobXNnLCBwdCkge1xuICAgIGlmICghcHQpIHsgcmV0dXJuIG1zZyArICcgWyAnICsgcHQgKyAnIF0nIH1cbiAgICByZXR1cm4gbXNnXG4gIH07XG5cbiAgcmV0dXJuIFRvcG9sb2d5RXhjZXB0aW9uO1xufShSdW50aW1lRXhjZXB0aW9uKSk7XG5cbnZhciBMaW5rZWRMaXN0ID0gZnVuY3Rpb24gTGlua2VkTGlzdCAoKSB7XG4gIHRoaXMuYXJyYXlfID0gW107XG59O1xuTGlua2VkTGlzdC5wcm90b3R5cGUuYWRkTGFzdCA9IGZ1bmN0aW9uIGFkZExhc3QgKGUpIHtcbiAgdGhpcy5hcnJheV8ucHVzaChlKTtcbn07XG5MaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmVGaXJzdCA9IGZ1bmN0aW9uIHJlbW92ZUZpcnN0ICgpIHtcbiAgcmV0dXJuIHRoaXMuYXJyYXlfLnNoaWZ0KClcbn07XG5MaW5rZWRMaXN0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSAoKSB7XG4gIHJldHVybiB0aGlzLmFycmF5Xy5sZW5ndGggPT09IDBcbn07XG5cbnZhciBCdWZmZXJTdWJncmFwaCA9IGZ1bmN0aW9uIEJ1ZmZlclN1YmdyYXBoICgpIHtcbiAgdGhpcy5fZmluZGVyID0gbnVsbDtcbiAgdGhpcy5fZGlyRWRnZUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX25vZGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9yaWdodE1vc3RDb29yZCA9IG51bGw7XG4gIHRoaXMuX2VudiA9IG51bGw7XG4gIHRoaXMuX2ZpbmRlciA9IG5ldyBSaWdodG1vc3RFZGdlRmluZGVyKCk7XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNsZWFyVmlzaXRlZEVkZ2VzID0gZnVuY3Rpb24gY2xlYXJWaXNpdGVkRWRnZXMgKCkge1xuICBmb3IgKHZhciBpdCA9IHRoaXMuX2RpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgZGUuc2V0VmlzaXRlZChmYWxzZSk7XG4gIH1cbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldFJpZ2h0bW9zdENvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5fcmlnaHRNb3N0Q29vcmRcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuY29tcHV0ZU5vZGVEZXB0aCA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlRGVwdGggKG4pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnRFZGdlID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IG4uZ2V0RWRnZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpLm5leHQoKTtcbiAgICBpZiAoZGUuaXNWaXNpdGVkKCkgfHwgZGUuZ2V0U3ltKCkuaXNWaXNpdGVkKCkpIHtcbiAgICAgIHN0YXJ0RWRnZSA9IGRlO1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgaWYgKHN0YXJ0RWRnZSA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ3VuYWJsZSB0byBmaW5kIGVkZ2UgdG8gY29tcHV0ZSBkZXB0aHMgYXQgJyArIG4uZ2V0Q29vcmRpbmF0ZSgpKSB9XG4gIG4uZ2V0RWRnZXMoKS5jb21wdXRlRGVwdGhzKHN0YXJ0RWRnZSk7XG4gIGZvciAodmFyIGkkMSA9IG4uZ2V0RWRnZXMoKS5pdGVyYXRvcigpOyBpJDEuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSQxID0gaSQxLm5leHQoKTtcbiAgICBkZSQxLnNldFZpc2l0ZWQodHJ1ZSk7XG4gICAgdGhpcyQxLmNvcHlTeW1EZXB0aHMoZGUkMSk7XG4gIH1cbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuY29tcHV0ZURlcHRoID0gZnVuY3Rpb24gY29tcHV0ZURlcHRoIChvdXRzaWRlRGVwdGgpIHtcbiAgdGhpcy5jbGVhclZpc2l0ZWRFZGdlcygpO1xuICB2YXIgZGUgPSB0aGlzLl9maW5kZXIuZ2V0RWRnZSgpO1xuICAvLyBjb25zdCBuID0gZGUuZ2V0Tm9kZSgpXG4gIC8vIGNvbnN0IGxhYmVsID0gZGUuZ2V0TGFiZWwoKVxuICBkZS5zZXRFZGdlRGVwdGhzKFBvc2l0aW9uLlJJR0hULCBvdXRzaWRlRGVwdGgpO1xuICB0aGlzLmNvcHlTeW1EZXB0aHMoZGUpO1xuICB0aGlzLmNvbXB1dGVEZXB0aHMoZGUpO1xufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUgKG5vZGUpIHtcbiAgdGhpcy5hZGRSZWFjaGFibGUobm9kZSk7XG4gIHRoaXMuX2ZpbmRlci5maW5kRWRnZSh0aGlzLl9kaXJFZGdlTGlzdCk7XG4gIHRoaXMuX3JpZ2h0TW9zdENvb3JkID0gdGhpcy5fZmluZGVyLmdldENvb3JkaW5hdGUoKTtcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuZmluZFJlc3VsdEVkZ2VzID0gZnVuY3Rpb24gZmluZFJlc3VsdEVkZ2VzICgpIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgIGlmIChkZS5nZXREZXB0aChQb3NpdGlvbi5SSUdIVCkgPj0gMSAmJiBkZS5nZXREZXB0aChQb3NpdGlvbi5MRUZUKSA8PSAwICYmICFkZS5pc0ludGVyaW9yQXJlYUVkZ2UoKSkge1xuICAgICAgZGUuc2V0SW5SZXN1bHQodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNvbXB1dGVEZXB0aHMgPSBmdW5jdGlvbiBjb21wdXRlRGVwdGhzIChzdGFydEVkZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbm9kZXNWaXNpdGVkID0gbmV3IEhhc2hTZXQoKTtcbiAgdmFyIG5vZGVRdWV1ZSA9IG5ldyBMaW5rZWRMaXN0KCk7XG4gIHZhciBzdGFydE5vZGUgPSBzdGFydEVkZ2UuZ2V0Tm9kZSgpO1xuICBub2RlUXVldWUuYWRkTGFzdChzdGFydE5vZGUpO1xuICBub2Rlc1Zpc2l0ZWQuYWRkKHN0YXJ0Tm9kZSk7XG4gIHN0YXJ0RWRnZS5zZXRWaXNpdGVkKHRydWUpO1xuICB3aGlsZSAoIW5vZGVRdWV1ZS5pc0VtcHR5KCkpIHtcbiAgICB2YXIgbiA9IG5vZGVRdWV1ZS5yZW1vdmVGaXJzdCgpO1xuICAgIG5vZGVzVmlzaXRlZC5hZGQobik7XG4gICAgdGhpcyQxLmNvbXB1dGVOb2RlRGVwdGgobik7XG4gICAgZm9yICh2YXIgaSA9IG4uZ2V0RWRnZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGkubmV4dCgpO1xuICAgICAgdmFyIHN5bSA9IGRlLmdldFN5bSgpO1xuICAgICAgaWYgKHN5bS5pc1Zpc2l0ZWQoKSkgeyBjb250aW51ZSB9XG4gICAgICB2YXIgYWRqTm9kZSA9IHN5bS5nZXROb2RlKCk7XG4gICAgICBpZiAoIW5vZGVzVmlzaXRlZC5jb250YWlucyhhZGpOb2RlKSkge1xuICAgICAgICBub2RlUXVldWUuYWRkTGFzdChhZGpOb2RlKTtcbiAgICAgICAgbm9kZXNWaXNpdGVkLmFkZChhZGpOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBncmFwaCA9IG87XG4gIGlmICh0aGlzLl9yaWdodE1vc3RDb29yZC54IDwgZ3JhcGguX3JpZ2h0TW9zdENvb3JkLngpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAodGhpcy5fcmlnaHRNb3N0Q29vcmQueCA+IGdyYXBoLl9yaWdodE1vc3RDb29yZC54KSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5nZXRFbnZlbG9wZSA9IGZ1bmN0aW9uIGdldEVudmVsb3BlICgpIHtcbiAgaWYgKHRoaXMuX2VudiA9PT0gbnVsbCkge1xuICAgIHZhciBlZGdlRW52ID0gbmV3IEVudmVsb3BlKCk7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLl9kaXJFZGdlTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGlyRWRnZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBwdHMgPSBkaXJFZGdlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGVkZ2VFbnYuZXhwYW5kVG9JbmNsdWRlKHB0c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2VudiA9IGVkZ2VFbnY7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2VudlxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5hZGRSZWFjaGFibGUgPSBmdW5jdGlvbiBhZGRSZWFjaGFibGUgKHN0YXJ0Tm9kZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBub2RlU3RhY2sgPSBuZXcgU3RhY2soKTtcbiAgbm9kZVN0YWNrLmFkZChzdGFydE5vZGUpO1xuICB3aGlsZSAoIW5vZGVTdGFjay5lbXB0eSgpKSB7XG4gICAgdmFyIG5vZGUgPSBub2RlU3RhY2sucG9wKCk7XG4gICAgdGhpcyQxLmFkZChub2RlLCBub2RlU3RhY2spO1xuICB9XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmNvcHlTeW1EZXB0aHMgPSBmdW5jdGlvbiBjb3B5U3ltRGVwdGhzIChkZSkge1xuICB2YXIgc3ltID0gZGUuZ2V0U3ltKCk7XG4gIHN5bS5zZXREZXB0aChQb3NpdGlvbi5MRUZULCBkZS5nZXREZXB0aChQb3NpdGlvbi5SSUdIVCkpO1xuICBzeW0uc2V0RGVwdGgoUG9zaXRpb24uUklHSFQsIGRlLmdldERlcHRoKFBvc2l0aW9uLkxFRlQpKTtcbn07XG5CdWZmZXJTdWJncmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChub2RlLCBub2RlU3RhY2spIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBub2RlLnNldFZpc2l0ZWQodHJ1ZSk7XG4gIHRoaXMuX25vZGVzLmFkZChub2RlKTtcbiAgZm9yICh2YXIgaSA9IG5vZGUuZ2V0RWRnZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZGUgPSBpLm5leHQoKTtcbiAgICB0aGlzJDEuX2RpckVkZ2VMaXN0LmFkZChkZSk7XG4gICAgdmFyIHN5bSA9IGRlLmdldFN5bSgpO1xuICAgIHZhciBzeW1Ob2RlID0gc3ltLmdldE5vZGUoKTtcbiAgICBpZiAoIXN5bU5vZGUuaXNWaXNpdGVkKCkpIHsgbm9kZVN0YWNrLnB1c2goc3ltTm9kZSk7IH1cbiAgfVxufTtcbkJ1ZmZlclN1YmdyYXBoLnByb3RvdHlwZS5nZXROb2RlcyA9IGZ1bmN0aW9uIGdldE5vZGVzICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzXG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmdldERpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiBnZXREaXJlY3RlZEVkZ2VzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RpckVkZ2VMaXN0XG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuQnVmZmVyU3ViZ3JhcGgucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyU3ViZ3JhcGhcbn07XG5cbnZhciBUb3BvbG9neUxvY2F0aW9uID0gZnVuY3Rpb24gVG9wb2xvZ3lMb2NhdGlvbiAoKSB7XG4gIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMubG9jYXRpb24gPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzWzBdO1xuICAgICAgdGhpcy5pbml0KGxvY2F0aW9uLmxlbmd0aCk7XG4gICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpIHtcbiAgICAgIHZhciBvbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMuaW5pdCgxKTtcbiAgICAgIHRoaXMubG9jYXRpb25bUG9zaXRpb24uT05dID0gb247XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBUb3BvbG9neUxvY2F0aW9uKSB7XG4gICAgICB2YXIgZ2wgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluaXQoZ2wubG9jYXRpb24ubGVuZ3RoKTtcbiAgICAgIGlmIChnbCAhPT0gbnVsbCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0aGlzJDEubG9jYXRpb25baV0gPSBnbC5sb2NhdGlvbltpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIG9uJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxlZnQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHJpZ2h0ID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuaW5pdCgzKTtcbiAgICB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLk9OXSA9IG9uJDE7XG4gICAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5MRUZUXSA9IGxlZnQ7XG4gICAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5SSUdIVF0gPSByaWdodDtcbiAgfVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLnNldEFsbExvY2F0aW9ucyA9IGZ1bmN0aW9uIHNldEFsbExvY2F0aW9ucyAobG9jVmFsdWUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzJDEubG9jYXRpb25baV0gPSBsb2NWYWx1ZTtcbiAgfVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5sb2NhdGlvbltpXSAhPT0gTG9jYXRpb24uTk9ORSkgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuc2V0QWxsTG9jYXRpb25zSWZOdWxsID0gZnVuY3Rpb24gc2V0QWxsTG9jYXRpb25zSWZOdWxsIChsb2NWYWx1ZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzJDEubG9jYXRpb25baV0gPT09IExvY2F0aW9uLk5PTkUpIHsgdGhpcyQxLmxvY2F0aW9uW2ldID0gbG9jVmFsdWU7IH1cbiAgfVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmlzTGluZSA9IGZ1bmN0aW9uIGlzTGluZSAoKSB7XG4gIHJldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aCA9PT0gMVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gbWVyZ2UgKGdsKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGdsLmxvY2F0aW9uLmxlbmd0aCA+IHRoaXMubG9jYXRpb24ubGVuZ3RoKSB7XG4gICAgdmFyIG5ld0xvYyA9IG5ldyBBcnJheSgzKS5maWxsKG51bGwpO1xuICAgIG5ld0xvY1tQb3NpdGlvbi5PTl0gPSB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLk9OXTtcbiAgICBuZXdMb2NbUG9zaXRpb24uTEVGVF0gPSBMb2NhdGlvbi5OT05FO1xuICAgIG5ld0xvY1tQb3NpdGlvbi5SSUdIVF0gPSBMb2NhdGlvbi5OT05FO1xuICAgIHRoaXMubG9jYXRpb24gPSBuZXdMb2M7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxvY2F0aW9uLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMkMS5sb2NhdGlvbltpXSA9PT0gTG9jYXRpb24uTk9ORSAmJiBpIDwgZ2wubG9jYXRpb24ubGVuZ3RoKSB7IHRoaXMkMS5sb2NhdGlvbltpXSA9IGdsLmxvY2F0aW9uW2ldOyB9XG4gIH1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5nZXRMb2NhdGlvbnMgPSBmdW5jdGlvbiBnZXRMb2NhdGlvbnMgKCkge1xuICByZXR1cm4gdGhpcy5sb2NhdGlvblxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmZsaXAgPSBmdW5jdGlvbiBmbGlwICgpIHtcbiAgaWYgKHRoaXMubG9jYXRpb24ubGVuZ3RoIDw9IDEpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgdGVtcCA9IHRoaXMubG9jYXRpb25bUG9zaXRpb24uTEVGVF07XG4gIHRoaXMubG9jYXRpb25bUG9zaXRpb24uTEVGVF0gPSB0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLlJJR0hUXTtcbiAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5SSUdIVF0gPSB0ZW1wO1xufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICBpZiAodGhpcy5sb2NhdGlvbi5sZW5ndGggPiAxKSB7IGJ1Zi5hcHBlbmQoTG9jYXRpb24udG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW1Bvc2l0aW9uLkxFRlRdKSk7IH1cbiAgYnVmLmFwcGVuZChMb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bUG9zaXRpb24uT05dKSk7XG4gIGlmICh0aGlzLmxvY2F0aW9uLmxlbmd0aCA+IDEpIHsgYnVmLmFwcGVuZChMb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bUG9zaXRpb24uUklHSFRdKSk7IH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuc2V0TG9jYXRpb25zID0gZnVuY3Rpb24gc2V0TG9jYXRpb25zIChvbiwgbGVmdCwgcmlnaHQpIHtcbiAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5PTl0gPSBvbjtcbiAgdGhpcy5sb2NhdGlvbltQb3NpdGlvbi5MRUZUXSA9IGxlZnQ7XG4gIHRoaXMubG9jYXRpb25bUG9zaXRpb24uUklHSFRdID0gcmlnaHQ7XG59O1xuVG9wb2xvZ3lMb2NhdGlvbi5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwb3NJbmRleCkge1xuICBpZiAocG9zSW5kZXggPCB0aGlzLmxvY2F0aW9uLmxlbmd0aCkgeyByZXR1cm4gdGhpcy5sb2NhdGlvbltwb3NJbmRleF0gfVxuICByZXR1cm4gTG9jYXRpb24uTk9ORVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmlzQXJlYSA9IGZ1bmN0aW9uIGlzQXJlYSAoKSB7XG4gIHJldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aCA+IDFcbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pc0FueU51bGwgPSBmdW5jdGlvbiBpc0FueU51bGwgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sb2NhdGlvbi5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzJDEubG9jYXRpb25baV0gPT09IExvY2F0aW9uLk5PTkUpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gc2V0TG9jYXRpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsb2NWYWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldExvY2F0aW9uKFBvc2l0aW9uLk9OLCBsb2NWYWx1ZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBsb2NJbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG9jVmFsdWUkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmxvY2F0aW9uW2xvY0luZGV4XSA9IGxvY1ZhbHVlJDE7XG4gIH1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoc2l6ZSkge1xuICB0aGlzLmxvY2F0aW9uID0gbmV3IEFycmF5KHNpemUpLmZpbGwobnVsbCk7XG4gIHRoaXMuc2V0QWxsTG9jYXRpb25zKExvY2F0aW9uLk5PTkUpO1xufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmlzRXF1YWxPblNpZGUgPSBmdW5jdGlvbiBpc0VxdWFsT25TaWRlIChsZSwgbG9jSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMubG9jYXRpb25bbG9jSW5kZXhdID09PSBsZS5sb2NhdGlvbltsb2NJbmRleF1cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5hbGxQb3NpdGlvbnNFcXVhbCA9IGZ1bmN0aW9uIGFsbFBvc2l0aW9uc0VxdWFsIChsb2MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubG9jYXRpb24ubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLmxvY2F0aW9uW2ldICE9PSBsb2MpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcblRvcG9sb2d5TG9jYXRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Ub3BvbG9neUxvY2F0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFRvcG9sb2d5TG9jYXRpb25cbn07XG5cbnZhciBMYWJlbCA9IGZ1bmN0aW9uIExhYmVsICgpIHtcbiAgdGhpcy5lbHQgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKSB7XG4gICAgICB2YXIgb25Mb2MgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmVsdFswXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKG9uTG9jKTtcbiAgICAgIHRoaXMuZWx0WzFdID0gbmV3IFRvcG9sb2d5TG9jYXRpb24ob25Mb2MpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGFiZWwpIHtcbiAgICAgIHZhciBsYmwgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmVsdFswXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKGxibC5lbHRbMF0pO1xuICAgICAgdGhpcy5lbHRbMV0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihsYmwuZWx0WzFdKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9uTG9jJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5lbHRbMF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihMb2NhdGlvbi5OT05FKTtcbiAgICB0aGlzLmVsdFsxXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKExvY2F0aW9uLk5PTkUpO1xuICAgIHRoaXMuZWx0W2dlb21JbmRleF0uc2V0TG9jYXRpb24ob25Mb2MkMSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBvbkxvYyQyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsZWZ0TG9jID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciByaWdodExvYyA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLmVsdFswXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKG9uTG9jJDIsIGxlZnRMb2MsIHJpZ2h0TG9jKTtcbiAgICB0aGlzLmVsdFsxXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKG9uTG9jJDIsIGxlZnRMb2MsIHJpZ2h0TG9jKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgdmFyIGdlb21JbmRleCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvbkxvYyQzID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBsZWZ0TG9jJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHJpZ2h0TG9jJDEgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5lbHRbMF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbihMb2NhdGlvbi5OT05FLCBMb2NhdGlvbi5OT05FLCBMb2NhdGlvbi5OT05FKTtcbiAgICB0aGlzLmVsdFsxXSA9IG5ldyBUb3BvbG9neUxvY2F0aW9uKExvY2F0aW9uLk5PTkUsIExvY2F0aW9uLk5PTkUsIExvY2F0aW9uLk5PTkUpO1xuICAgIHRoaXMuZWx0W2dlb21JbmRleCQxXS5zZXRMb2NhdGlvbnMob25Mb2MkMywgbGVmdExvYyQxLCByaWdodExvYyQxKTtcbiAgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5nZXRHZW9tZXRyeUNvdW50ID0gZnVuY3Rpb24gZ2V0R2VvbWV0cnlDb3VudCAoKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGlmICghdGhpcy5lbHRbMF0uaXNOdWxsKCkpIHsgY291bnQrKzsgfVxuICBpZiAoIXRoaXMuZWx0WzFdLmlzTnVsbCgpKSB7IGNvdW50Kys7IH1cbiAgcmV0dXJuIGNvdW50XG59O1xuTGFiZWwucHJvdG90eXBlLnNldEFsbExvY2F0aW9ucyA9IGZ1bmN0aW9uIHNldEFsbExvY2F0aW9ucyAoZ2VvbUluZGV4LCBsb2NhdGlvbikge1xuICB0aGlzLmVsdFtnZW9tSW5kZXhdLnNldEFsbExvY2F0aW9ucyhsb2NhdGlvbik7XG59O1xuTGFiZWwucHJvdG90eXBlLmlzTnVsbCA9IGZ1bmN0aW9uIGlzTnVsbCAoZ2VvbUluZGV4KSB7XG4gIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXhdLmlzTnVsbCgpXG59O1xuTGFiZWwucHJvdG90eXBlLnNldEFsbExvY2F0aW9uc0lmTnVsbCA9IGZ1bmN0aW9uIHNldEFsbExvY2F0aW9uc0lmTnVsbCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsIGxvY2F0aW9uKTtcbiAgICB0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLCBsb2NhdGlvbik7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvY2F0aW9uJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5lbHRbZ2VvbUluZGV4XS5zZXRBbGxMb2NhdGlvbnNJZk51bGwobG9jYXRpb24kMSk7XG4gIH1cbn07XG5MYWJlbC5wcm90b3R5cGUuaXNMaW5lID0gZnVuY3Rpb24gaXNMaW5lIChnZW9tSW5kZXgpIHtcbiAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleF0uaXNMaW5lKClcbn07XG5MYWJlbC5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbiBtZXJnZSAobGJsKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICBpZiAodGhpcyQxLmVsdFtpXSA9PT0gbnVsbCAmJiBsYmwuZWx0W2ldICE9PSBudWxsKSB7XG4gICAgICB0aGlzJDEuZWx0W2ldID0gbmV3IFRvcG9sb2d5TG9jYXRpb24obGJsLmVsdFtpXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMkMS5lbHRbaV0ubWVyZ2UobGJsLmVsdFtpXSk7XG4gICAgfVxuICB9XG59O1xuTGFiZWwucHJvdG90eXBlLmZsaXAgPSBmdW5jdGlvbiBmbGlwICgpIHtcbiAgdGhpcy5lbHRbMF0uZmxpcCgpO1xuICB0aGlzLmVsdFsxXS5mbGlwKCk7XG59O1xuTGFiZWwucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0TG9jYXRpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuZWx0W2dlb21JbmRleF0uZ2V0KFBvc2l0aW9uLk9OKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbUluZGV4JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBvc0luZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXgkMV0uZ2V0KHBvc0luZGV4KVxuICB9XG59O1xuTGFiZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgYnVmID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuICBpZiAodGhpcy5lbHRbMF0gIT09IG51bGwpIHtcbiAgICBidWYuYXBwZW5kKCdBOicpO1xuICAgIGJ1Zi5hcHBlbmQodGhpcy5lbHRbMF0udG9TdHJpbmcoKSk7XG4gIH1cbiAgaWYgKHRoaXMuZWx0WzFdICE9PSBudWxsKSB7XG4gICAgYnVmLmFwcGVuZCgnIEI6Jyk7XG4gICAgYnVmLmFwcGVuZCh0aGlzLmVsdFsxXS50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKClcbn07XG5MYWJlbC5wcm90b3R5cGUuaXNBcmVhID0gZnVuY3Rpb24gaXNBcmVhICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5lbHRbMF0uaXNBcmVhKCkgfHwgdGhpcy5lbHRbMV0uaXNBcmVhKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb21JbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4XS5pc0FyZWEoKVxuICB9XG59O1xuTGFiZWwucHJvdG90eXBlLmlzQW55TnVsbCA9IGZ1bmN0aW9uIGlzQW55TnVsbCAoZ2VvbUluZGV4KSB7XG4gIHJldHVybiB0aGlzLmVsdFtnZW9tSW5kZXhdLmlzQW55TnVsbCgpXG59O1xuTGFiZWwucHJvdG90eXBlLnNldExvY2F0aW9uID0gZnVuY3Rpb24gc2V0TG9jYXRpb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuZWx0W2dlb21JbmRleF0uc2V0TG9jYXRpb24oUG9zaXRpb24uT04sIGxvY2F0aW9uKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGdlb21JbmRleCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwb3NJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbG9jYXRpb24kMSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLmVsdFtnZW9tSW5kZXgkMV0uc2V0TG9jYXRpb24ocG9zSW5kZXgsIGxvY2F0aW9uJDEpO1xuICB9XG59O1xuTGFiZWwucHJvdG90eXBlLmlzRXF1YWxPblNpZGUgPSBmdW5jdGlvbiBpc0VxdWFsT25TaWRlIChsYmwsIHNpZGUpIHtcbiAgcmV0dXJuIHRoaXMuZWx0WzBdLmlzRXF1YWxPblNpZGUobGJsLmVsdFswXSwgc2lkZSkgJiYgdGhpcy5lbHRbMV0uaXNFcXVhbE9uU2lkZShsYmwuZWx0WzFdLCBzaWRlKVxufTtcbkxhYmVsLnByb3RvdHlwZS5hbGxQb3NpdGlvbnNFcXVhbCA9IGZ1bmN0aW9uIGFsbFBvc2l0aW9uc0VxdWFsIChnZW9tSW5kZXgsIGxvYykge1xuICByZXR1cm4gdGhpcy5lbHRbZ2VvbUluZGV4XS5hbGxQb3NpdGlvbnNFcXVhbChsb2MpXG59O1xuTGFiZWwucHJvdG90eXBlLnRvTGluZSA9IGZ1bmN0aW9uIHRvTGluZSAoZ2VvbUluZGV4KSB7XG4gIGlmICh0aGlzLmVsdFtnZW9tSW5kZXhdLmlzQXJlYSgpKSB7IHRoaXMuZWx0W2dlb21JbmRleF0gPSBuZXcgVG9wb2xvZ3lMb2NhdGlvbih0aGlzLmVsdFtnZW9tSW5kZXhdLmxvY2F0aW9uWzBdKTsgfVxufTtcbkxhYmVsLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTGFiZWwucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGFiZWxcbn07XG5MYWJlbC50b0xpbmVMYWJlbCA9IGZ1bmN0aW9uIHRvTGluZUxhYmVsIChsYWJlbCkge1xuICB2YXIgbGluZUxhYmVsID0gbmV3IExhYmVsKExvY2F0aW9uLk5PTkUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGxpbmVMYWJlbC5zZXRMb2NhdGlvbihpLCBsYWJlbC5nZXRMb2NhdGlvbihpKSk7XG4gIH1cbiAgcmV0dXJuIGxpbmVMYWJlbFxufTtcblxudmFyIEVkZ2VSaW5nID0gZnVuY3Rpb24gRWRnZVJpbmcgKCkge1xuICB0aGlzLl9zdGFydERlID0gbnVsbDtcbiAgdGhpcy5fbWF4Tm9kZURlZ3JlZSA9IC0xO1xuICB0aGlzLl9lZGdlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fcHRzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9sYWJlbCA9IG5ldyBMYWJlbChMb2NhdGlvbi5OT05FKTtcbiAgdGhpcy5fcmluZyA9IG51bGw7XG4gIHRoaXMuX2lzSG9sZSA9IG51bGw7XG4gIHRoaXMuX3NoZWxsID0gbnVsbDtcbiAgdGhpcy5faG9sZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IG51bGw7XG4gIHZhciBzdGFydCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdlb21ldHJ5RmFjdG9yeSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gZ2VvbWV0cnlGYWN0b3J5O1xuICB0aGlzLmNvbXB1dGVQb2ludHMoc3RhcnQpO1xuICB0aGlzLmNvbXB1dGVSaW5nKCk7XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmNvbXB1dGVSaW5nID0gZnVuY3Rpb24gY29tcHV0ZVJpbmcgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmICh0aGlzLl9yaW5nICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGNvb3JkID0gbmV3IEFycmF5KHRoaXMuX3B0cy5zaXplKCkpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fcHRzLnNpemUoKTsgaSsrKSB7XG4gICAgY29vcmRbaV0gPSB0aGlzJDEuX3B0cy5nZXQoaSk7XG4gIH1cbiAgdGhpcy5fcmluZyA9IHRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGNvb3JkKTtcbiAgdGhpcy5faXNIb2xlID0gQ0dBbGdvcml0aG1zLmlzQ0NXKHRoaXMuX3JpbmcuZ2V0Q29vcmRpbmF0ZXMoKSk7XG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmlzSXNvbGF0ZWQgPSBmdW5jdGlvbiBpc0lzb2xhdGVkICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKSA9PT0gMVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5jb21wdXRlUG9pbnRzID0gZnVuY3Rpb24gY29tcHV0ZVBvaW50cyAoc3RhcnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl9zdGFydERlID0gc3RhcnQ7XG4gIHZhciBkZSA9IHN0YXJ0O1xuICB2YXIgaXNGaXJzdEVkZ2UgPSB0cnVlO1xuICBkbyB7XG4gICAgaWYgKGRlID09PSBudWxsKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbignRm91bmQgbnVsbCBEaXJlY3RlZEVkZ2UnKSB9XG4gICAgaWYgKGRlLmdldEVkZ2VSaW5nKCkgPT09IHRoaXMkMSkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ0RpcmVjdGVkIEVkZ2UgdmlzaXRlZCB0d2ljZSBkdXJpbmcgcmluZy1idWlsZGluZyBhdCAnICsgZGUuZ2V0Q29vcmRpbmF0ZSgpKSB9XG4gICAgdGhpcyQxLl9lZGdlcy5hZGQoZGUpO1xuICAgIHZhciBsYWJlbCA9IGRlLmdldExhYmVsKCk7XG4gICAgQXNzZXJ0LmlzVHJ1ZShsYWJlbC5pc0FyZWEoKSk7XG4gICAgdGhpcyQxLm1lcmdlTGFiZWwobGFiZWwpO1xuICAgIHRoaXMkMS5hZGRQb2ludHMoZGUuZ2V0RWRnZSgpLCBkZS5pc0ZvcndhcmQoKSwgaXNGaXJzdEVkZ2UpO1xuICAgIGlzRmlyc3RFZGdlID0gZmFsc2U7XG4gICAgdGhpcyQxLnNldEVkZ2VSaW5nKGRlLCB0aGlzJDEpO1xuICAgIGRlID0gdGhpcyQxLmdldE5leHQoZGUpO1xuICB9IHdoaWxlIChkZSAhPT0gdGhpcy5fc3RhcnREZSlcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0TGluZWFyUmluZyA9IGZ1bmN0aW9uIGdldExpbmVhclJpbmcgKCkge1xuICByZXR1cm4gdGhpcy5fcmluZ1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICByZXR1cm4gdGhpcy5fcHRzLmdldChpKVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5jb21wdXRlTWF4Tm9kZURlZ3JlZSA9IGZ1bmN0aW9uIGNvbXB1dGVNYXhOb2RlRGVncmVlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl9tYXhOb2RlRGVncmVlID0gMDtcbiAgdmFyIGRlID0gdGhpcy5fc3RhcnREZTtcbiAgZG8ge1xuICAgIHZhciBub2RlID0gZGUuZ2V0Tm9kZSgpO1xuICAgIHZhciBkZWdyZWUgPSBub2RlLmdldEVkZ2VzKCkuZ2V0T3V0Z29pbmdEZWdyZWUodGhpcyQxKTtcbiAgICBpZiAoZGVncmVlID4gdGhpcyQxLl9tYXhOb2RlRGVncmVlKSB7IHRoaXMkMS5fbWF4Tm9kZURlZ3JlZSA9IGRlZ3JlZTsgfVxuICAgIGRlID0gdGhpcyQxLmdldE5leHQoZGUpO1xuICB9IHdoaWxlIChkZSAhPT0gdGhpcy5fc3RhcnREZSlcbiAgdGhpcy5fbWF4Tm9kZURlZ3JlZSAqPSAyO1xufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5hZGRQb2ludHMgPSBmdW5jdGlvbiBhZGRQb2ludHMgKGVkZ2UsIGlzRm9yd2FyZCwgaXNGaXJzdEVkZ2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZWRnZVB0cyA9IGVkZ2UuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgaWYgKGlzRm9yd2FyZCkge1xuICAgIHZhciBzdGFydEluZGV4ID0gMTtcbiAgICBpZiAoaXNGaXJzdEVkZ2UpIHsgc3RhcnRJbmRleCA9IDA7IH1cbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IGVkZ2VQdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMkMS5fcHRzLmFkZChlZGdlUHRzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHN0YXJ0SW5kZXgkMSA9IGVkZ2VQdHMubGVuZ3RoIC0gMjtcbiAgICBpZiAoaXNGaXJzdEVkZ2UpIHsgc3RhcnRJbmRleCQxID0gZWRnZVB0cy5sZW5ndGggLSAxOyB9XG4gICAgZm9yICh2YXIgaSQxID0gc3RhcnRJbmRleCQxOyBpJDEgPj0gMDsgaSQxLS0pIHtcbiAgICAgIHRoaXMkMS5fcHRzLmFkZChlZGdlUHRzW2kkMV0pO1xuICAgIH1cbiAgfVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5pc0hvbGUgPSBmdW5jdGlvbiBpc0hvbGUgKCkge1xuICByZXR1cm4gdGhpcy5faXNIb2xlXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLnNldEluUmVzdWx0ID0gZnVuY3Rpb24gc2V0SW5SZXN1bHQgKCkge1xuICB2YXIgZGUgPSB0aGlzLl9zdGFydERlO1xuICBkbyB7XG4gICAgZGUuZ2V0RWRnZSgpLnNldEluUmVzdWx0KHRydWUpO1xuICAgIGRlID0gZGUuZ2V0TmV4dCgpO1xuICB9IHdoaWxlIChkZSAhPT0gdGhpcy5fc3RhcnREZSlcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQgKHApIHtcbiAgdmFyIHNoZWxsID0gdGhpcy5nZXRMaW5lYXJSaW5nKCk7XG4gIHZhciBlbnYgPSBzaGVsbC5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIGlmICghZW52LmNvbnRhaW5zKHApKSB7IHJldHVybiBmYWxzZSB9XG4gIGlmICghQ0dBbGdvcml0aG1zLmlzUG9pbnRJblJpbmcocCwgc2hlbGwuZ2V0Q29vcmRpbmF0ZXMoKSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgZm9yICh2YXIgaSA9IHRoaXMuX2hvbGVzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBob2xlID0gaS5uZXh0KCk7XG4gICAgaWYgKGhvbGUuY29udGFpbnNQb2ludChwKSkgeyByZXR1cm4gZmFsc2UgfVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmFkZEhvbGUgPSBmdW5jdGlvbiBhZGRIb2xlIChyaW5nKSB7XG4gIHRoaXMuX2hvbGVzLmFkZChyaW5nKTtcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuaXNTaGVsbCA9IGZ1bmN0aW9uIGlzU2hlbGwgKCkge1xuICByZXR1cm4gdGhpcy5fc2hlbGwgPT09IG51bGxcbn07XG5FZGdlUmluZy5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiBnZXRMYWJlbCAoKSB7XG4gIHJldHVybiB0aGlzLl9sYWJlbFxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uIGdldEVkZ2VzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VzXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldE1heE5vZGVEZWdyZWUgPSBmdW5jdGlvbiBnZXRNYXhOb2RlRGVncmVlICgpIHtcbiAgaWYgKHRoaXMuX21heE5vZGVEZWdyZWUgPCAwKSB7IHRoaXMuY29tcHV0ZU1heE5vZGVEZWdyZWUoKTsgfVxuICByZXR1cm4gdGhpcy5fbWF4Tm9kZURlZ3JlZVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5nZXRTaGVsbCA9IGZ1bmN0aW9uIGdldFNoZWxsICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NoZWxsXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLm1lcmdlTGFiZWwgPSBmdW5jdGlvbiBtZXJnZUxhYmVsICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZGVMYWJlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLm1lcmdlTGFiZWwoZGVMYWJlbCwgMCk7XG4gICAgdGhpcy5tZXJnZUxhYmVsKGRlTGFiZWwsIDEpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZGVMYWJlbCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnZW9tSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxvYyA9IGRlTGFiZWwkMS5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLlJJR0hUKTtcbiAgICBpZiAobG9jID09PSBMb2NhdGlvbi5OT05FKSB7IHJldHVybiBudWxsIH1cbiAgICBpZiAodGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4KSA9PT0gTG9jYXRpb24uTk9ORSkge1xuICAgICAgdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oZ2VvbUluZGV4LCBsb2MpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbn07XG5FZGdlUmluZy5wcm90b3R5cGUuc2V0U2hlbGwgPSBmdW5jdGlvbiBzZXRTaGVsbCAoc2hlbGwpIHtcbiAgdGhpcy5fc2hlbGwgPSBzaGVsbDtcbiAgaWYgKHNoZWxsICE9PSBudWxsKSB7IHNoZWxsLmFkZEhvbGUodGhpcyk7IH1cbn07XG5FZGdlUmluZy5wcm90b3R5cGUudG9Qb2x5Z29uID0gZnVuY3Rpb24gdG9Qb2x5Z29uIChnZW9tZXRyeUZhY3RvcnkpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgaG9sZUxSID0gbmV3IEFycmF5KHRoaXMuX2hvbGVzLnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9ob2xlcy5zaXplKCk7IGkrKykge1xuICAgIGhvbGVMUltpXSA9IHRoaXMkMS5faG9sZXMuZ2V0KGkpLmdldExpbmVhclJpbmcoKTtcbiAgfVxuICB2YXIgcG9seSA9IGdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKHRoaXMuZ2V0TGluZWFyUmluZygpLCBob2xlTFIpO1xuICByZXR1cm4gcG9seVxufTtcbkVkZ2VSaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRWRnZVJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZVJpbmdcbn07XG5cbnZhciBNaW5pbWFsRWRnZVJpbmcgPSAoZnVuY3Rpb24gKEVkZ2VSaW5nJCQxKSB7XG4gIGZ1bmN0aW9uIE1pbmltYWxFZGdlUmluZyAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnZW9tZXRyeUZhY3RvcnkgPSBhcmd1bWVudHNbMV07XG4gICAgRWRnZVJpbmckJDEuY2FsbCh0aGlzLCBzdGFydCwgZ2VvbWV0cnlGYWN0b3J5KTtcbiAgfVxuXG4gIGlmICggRWRnZVJpbmckJDEgKSBNaW5pbWFsRWRnZVJpbmcuX19wcm90b19fID0gRWRnZVJpbmckJDE7XG4gIE1pbmltYWxFZGdlUmluZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBFZGdlUmluZyQkMSAmJiBFZGdlUmluZyQkMS5wcm90b3R5cGUgKTtcbiAgTWluaW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1pbmltYWxFZGdlUmluZztcbiAgTWluaW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5zZXRFZGdlUmluZyA9IGZ1bmN0aW9uIHNldEVkZ2VSaW5nIChkZSwgZXIpIHtcbiAgICBkZS5zZXRNaW5FZGdlUmluZyhlcik7XG4gIH07XG4gIE1pbmltYWxFZGdlUmluZy5wcm90b3R5cGUuZ2V0TmV4dCA9IGZ1bmN0aW9uIGdldE5leHQgKGRlKSB7XG4gICAgcmV0dXJuIGRlLmdldE5leHRNaW4oKVxuICB9O1xuICBNaW5pbWFsRWRnZVJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBNaW5pbWFsRWRnZVJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBNaW5pbWFsRWRnZVJpbmdcbiAgfTtcblxuICByZXR1cm4gTWluaW1hbEVkZ2VSaW5nO1xufShFZGdlUmluZykpO1xuXG52YXIgTWF4aW1hbEVkZ2VSaW5nID0gKGZ1bmN0aW9uIChFZGdlUmluZyQkMSkge1xuICBmdW5jdGlvbiBNYXhpbWFsRWRnZVJpbmcgKCkge1xuICAgIHZhciBzdGFydCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZ2VvbWV0cnlGYWN0b3J5ID0gYXJndW1lbnRzWzFdO1xuICAgIEVkZ2VSaW5nJCQxLmNhbGwodGhpcywgc3RhcnQsIGdlb21ldHJ5RmFjdG9yeSk7XG4gIH1cblxuICBpZiAoIEVkZ2VSaW5nJCQxICkgTWF4aW1hbEVkZ2VSaW5nLl9fcHJvdG9fXyA9IEVkZ2VSaW5nJCQxO1xuICBNYXhpbWFsRWRnZVJpbmcucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWRnZVJpbmckJDEgJiYgRWRnZVJpbmckJDEucHJvdG90eXBlICk7XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNYXhpbWFsRWRnZVJpbmc7XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUuYnVpbGRNaW5pbWFsUmluZ3MgPSBmdW5jdGlvbiBidWlsZE1pbmltYWxSaW5ncyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgbWluRWRnZVJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHZhciBkZSA9IHRoaXMuX3N0YXJ0RGU7XG4gICAgZG8ge1xuICAgICAgaWYgKGRlLmdldE1pbkVkZ2VSaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgdmFyIG1pbkVyID0gbmV3IE1pbmltYWxFZGdlUmluZyhkZSwgdGhpcyQxLl9nZW9tZXRyeUZhY3RvcnkpO1xuICAgICAgICBtaW5FZGdlUmluZ3MuYWRkKG1pbkVyKTtcbiAgICAgIH1cbiAgICAgIGRlID0gZGUuZ2V0TmV4dCgpO1xuICAgIH0gd2hpbGUgKGRlICE9PSB0aGlzLl9zdGFydERlKVxuICAgIHJldHVybiBtaW5FZGdlUmluZ3NcbiAgfTtcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5zZXRFZGdlUmluZyA9IGZ1bmN0aW9uIHNldEVkZ2VSaW5nIChkZSwgZXIpIHtcbiAgICBkZS5zZXRFZGdlUmluZyhlcik7XG4gIH07XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzID0gZnVuY3Rpb24gbGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBkZSA9IHRoaXMuX3N0YXJ0RGU7XG4gICAgZG8ge1xuICAgICAgdmFyIG5vZGUgPSBkZS5nZXROb2RlKCk7XG4gICAgICBub2RlLmdldEVkZ2VzKCkubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHRoaXMkMSk7XG4gICAgICBkZSA9IGRlLmdldE5leHQoKTtcbiAgICB9IHdoaWxlIChkZSAhPT0gdGhpcy5fc3RhcnREZSlcbiAgfTtcbiAgTWF4aW1hbEVkZ2VSaW5nLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gZ2V0TmV4dCAoZGUpIHtcbiAgICByZXR1cm4gZGUuZ2V0TmV4dCgpXG4gIH07XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE1heGltYWxFZGdlUmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIE1heGltYWxFZGdlUmluZ1xuICB9O1xuXG4gIHJldHVybiBNYXhpbWFsRWRnZVJpbmc7XG59KEVkZ2VSaW5nKSk7XG5cbnZhciBHcmFwaENvbXBvbmVudCA9IGZ1bmN0aW9uIEdyYXBoQ29tcG9uZW50ICgpIHtcbiAgdGhpcy5fbGFiZWwgPSBudWxsO1xuICB0aGlzLl9pc0luUmVzdWx0ID0gZmFsc2U7XG4gIHRoaXMuX2lzQ292ZXJlZCA9IGZhbHNlO1xuICB0aGlzLl9pc0NvdmVyZWRTZXQgPSBmYWxzZTtcbiAgdGhpcy5faXNWaXNpdGVkID0gZmFsc2U7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxhYmVsID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gIH1cbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuc2V0VmlzaXRlZCA9IGZ1bmN0aW9uIHNldFZpc2l0ZWQgKGlzVmlzaXRlZCkge1xuICB0aGlzLl9pc1Zpc2l0ZWQgPSBpc1Zpc2l0ZWQ7XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnNldEluUmVzdWx0ID0gZnVuY3Rpb24gc2V0SW5SZXN1bHQgKGlzSW5SZXN1bHQpIHtcbiAgdGhpcy5faXNJblJlc3VsdCA9IGlzSW5SZXN1bHQ7XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmlzQ292ZXJlZCA9IGZ1bmN0aW9uIGlzQ292ZXJlZCAoKSB7XG4gIHJldHVybiB0aGlzLl9pc0NvdmVyZWRcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuaXNDb3ZlcmVkU2V0ID0gZnVuY3Rpb24gaXNDb3ZlcmVkU2V0ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzQ292ZXJlZFNldFxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uIHNldExhYmVsIChsYWJlbCkge1xuICB0aGlzLl9sYWJlbCA9IGxhYmVsO1xufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5nZXRMYWJlbCA9IGZ1bmN0aW9uIGdldExhYmVsICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xhYmVsXG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLnNldENvdmVyZWQgPSBmdW5jdGlvbiBzZXRDb3ZlcmVkIChpc0NvdmVyZWQpIHtcbiAgdGhpcy5faXNDb3ZlcmVkID0gaXNDb3ZlcmVkO1xuICB0aGlzLl9pc0NvdmVyZWRTZXQgPSB0cnVlO1xufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS51cGRhdGVJTSA9IGZ1bmN0aW9uIHVwZGF0ZUlNIChpbSkge1xuICBBc3NlcnQuaXNUcnVlKHRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKSA+PSAyLCAnZm91bmQgcGFydGlhbCBsYWJlbCcpO1xuICB0aGlzLmNvbXB1dGVJTShpbSk7XG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmlzSW5SZXN1bHQgPSBmdW5jdGlvbiBpc0luUmVzdWx0ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzSW5SZXN1bHRcbn07XG5HcmFwaENvbXBvbmVudC5wcm90b3R5cGUuaXNWaXNpdGVkID0gZnVuY3Rpb24gaXNWaXNpdGVkICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzVmlzaXRlZFxufTtcbkdyYXBoQ29tcG9uZW50LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR3JhcGhDb21wb25lbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR3JhcGhDb21wb25lbnRcbn07XG5cbnZhciBOb2RlID0gKGZ1bmN0aW9uIChHcmFwaENvbXBvbmVudCQkMSkge1xuICBmdW5jdGlvbiBOb2RlICgpIHtcbiAgICBHcmFwaENvbXBvbmVudCQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX2Nvb3JkID0gbnVsbDtcbiAgICB0aGlzLl9lZGdlcyA9IG51bGw7XG4gICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBlZGdlcyA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9jb29yZCA9IGNvb3JkO1xuICAgIHRoaXMuX2VkZ2VzID0gZWRnZXM7XG4gICAgdGhpcy5fbGFiZWwgPSBuZXcgTGFiZWwoMCwgTG9jYXRpb24uTk9ORSk7XG4gIH1cblxuICBpZiAoIEdyYXBoQ29tcG9uZW50JCQxICkgTm9kZS5fX3Byb3RvX18gPSBHcmFwaENvbXBvbmVudCQkMTtcbiAgTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHcmFwaENvbXBvbmVudCQkMSAmJiBHcmFwaENvbXBvbmVudCQkMS5wcm90b3R5cGUgKTtcbiAgTm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBOb2RlO1xuICBOb2RlLnByb3RvdHlwZS5pc0luY2lkZW50RWRnZUluUmVzdWx0ID0gZnVuY3Rpb24gaXNJbmNpZGVudEVkZ2VJblJlc3VsdCAoKSB7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLmdldEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICBpZiAoZGUuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBOb2RlLnByb3RvdHlwZS5pc0lzb2xhdGVkID0gZnVuY3Rpb24gaXNJc29sYXRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhYmVsLmdldEdlb21ldHJ5Q291bnQoKSA9PT0gMVxuICB9O1xuICBOb2RlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nvb3JkXG4gIH07XG4gIE5vZGUucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICAgIG91dC5wcmludGxuKCdub2RlICcgKyB0aGlzLl9jb29yZCArICcgbGJsOiAnICsgdGhpcy5fbGFiZWwpO1xuICB9O1xuICBOb2RlLnByb3RvdHlwZS5jb21wdXRlSU0gPSBmdW5jdGlvbiBjb21wdXRlSU0gKGltKSB7fTtcbiAgTm9kZS5wcm90b3R5cGUuY29tcHV0ZU1lcmdlZExvY2F0aW9uID0gZnVuY3Rpb24gY29tcHV0ZU1lcmdlZExvY2F0aW9uIChsYWJlbDIsIGVsdEluZGV4KSB7XG4gICAgdmFyIGxvYyA9IExvY2F0aW9uLk5PTkU7XG4gICAgbG9jID0gdGhpcy5fbGFiZWwuZ2V0TG9jYXRpb24oZWx0SW5kZXgpO1xuICAgIGlmICghbGFiZWwyLmlzTnVsbChlbHRJbmRleCkpIHtcbiAgICAgIHZhciBuTG9jID0gbGFiZWwyLmdldExvY2F0aW9uKGVsdEluZGV4KTtcbiAgICAgIGlmIChsb2MgIT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IGxvYyA9IG5Mb2M7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY1xuICB9O1xuICBOb2RlLnByb3RvdHlwZS5zZXRMYWJlbCA9IGZ1bmN0aW9uIHNldExhYmVsICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIG9uTG9jYXRpb24gPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAodGhpcy5fbGFiZWwgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fbGFiZWwgPSBuZXcgTGFiZWwoYXJnSW5kZXgsIG9uTG9jYXRpb24pO1xuICAgICAgfSBlbHNlIHsgdGhpcy5fbGFiZWwuc2V0TG9jYXRpb24oYXJnSW5kZXgsIG9uTG9jYXRpb24pOyB9XG4gICAgfSBlbHNlIHsgcmV0dXJuIEdyYXBoQ29tcG9uZW50JCQxLnByb3RvdHlwZS5zZXRMYWJlbC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiBnZXRFZGdlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VkZ2VzXG4gIH07XG4gIE5vZGUucHJvdG90eXBlLm1lcmdlTGFiZWwgPSBmdW5jdGlvbiBtZXJnZUxhYmVsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICB2YXIgbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMubWVyZ2VMYWJlbChuLl9sYWJlbCk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMYWJlbCkge1xuICAgICAgdmFyIGxhYmVsMiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSB0aGlzJDEuY29tcHV0ZU1lcmdlZExvY2F0aW9uKGxhYmVsMiwgaSk7XG4gICAgICAgIHZhciB0aGlzTG9jID0gdGhpcyQxLl9sYWJlbC5nZXRMb2NhdGlvbihpKTtcbiAgICAgICAgaWYgKHRoaXNMb2MgPT09IExvY2F0aW9uLk5PTkUpIHsgdGhpcyQxLl9sYWJlbC5zZXRMb2NhdGlvbihpLCBsb2MpOyB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBOb2RlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGUpIHtcbiAgICB0aGlzLl9lZGdlcy5pbnNlcnQoZSk7XG4gICAgZS5zZXROb2RlKHRoaXMpO1xuICB9O1xuICBOb2RlLnByb3RvdHlwZS5zZXRMYWJlbEJvdW5kYXJ5ID0gZnVuY3Rpb24gc2V0TGFiZWxCb3VuZGFyeSAoYXJnSW5kZXgpIHtcbiAgICBpZiAodGhpcy5fbGFiZWwgPT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBsb2MgPSBMb2NhdGlvbi5OT05FO1xuICAgIGlmICh0aGlzLl9sYWJlbCAhPT0gbnVsbCkgeyBsb2MgPSB0aGlzLl9sYWJlbC5nZXRMb2NhdGlvbihhcmdJbmRleCk7IH1cbiAgICB2YXIgbmV3TG9jID0gbnVsbDtcbiAgICBzd2l0Y2ggKGxvYykge1xuICAgICAgY2FzZSBMb2NhdGlvbi5CT1VOREFSWTpcbiAgICAgICAgbmV3TG9jID0gTG9jYXRpb24uSU5URVJJT1I7XG4gICAgICAgIGJyZWFrXG4gICAgICBjYXNlIExvY2F0aW9uLklOVEVSSU9SOlxuICAgICAgICBuZXdMb2MgPSBMb2NhdGlvbi5CT1VOREFSWTtcbiAgICAgICAgYnJlYWtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIG5ld0xvYyA9IExvY2F0aW9uLkJPVU5EQVJZO1xuICAgICAgICBicmVha1xuICAgIH1cbiAgICB0aGlzLl9sYWJlbC5zZXRMb2NhdGlvbihhcmdJbmRleCwgbmV3TG9jKTtcbiAgfTtcbiAgTm9kZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIE5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBOb2RlXG4gIH07XG5cbiAgcmV0dXJuIE5vZGU7XG59KEdyYXBoQ29tcG9uZW50KSk7XG5cbnZhciBOb2RlTWFwID0gZnVuY3Rpb24gTm9kZU1hcCAoKSB7XG4gIHRoaXMubm9kZU1hcCA9IG5ldyBUcmVlTWFwKCk7XG4gIHRoaXMubm9kZUZhY3QgPSBudWxsO1xuICB2YXIgbm9kZUZhY3QgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMubm9kZUZhY3QgPSBub2RlRmFjdDtcbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gZmluZCAoY29vcmQpIHtcbiAgcmV0dXJuIHRoaXMubm9kZU1hcC5nZXQoY29vcmQpXG59O1xuTm9kZU1hcC5wcm90b3R5cGUuYWRkTm9kZSA9IGZ1bmN0aW9uIGFkZE5vZGUgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkge1xuICAgIHZhciBjb29yZCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbm9kZSA9IHRoaXMubm9kZU1hcC5nZXQoY29vcmQpO1xuICAgIGlmIChub2RlID09PSBudWxsKSB7XG4gICAgICBub2RlID0gdGhpcy5ub2RlRmFjdC5jcmVhdGVOb2RlKGNvb3JkKTtcbiAgICAgIHRoaXMubm9kZU1hcC5wdXQoY29vcmQsIG5vZGUpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICB2YXIgbiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbm9kZSQxID0gdGhpcy5ub2RlTWFwLmdldChuLmdldENvb3JkaW5hdGUoKSk7XG4gICAgaWYgKG5vZGUkMSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5ub2RlTWFwLnB1dChuLmdldENvb3JkaW5hdGUoKSwgbik7XG4gICAgICByZXR1cm4gblxuICAgIH1cbiAgICBub2RlJDEubWVyZ2VMYWJlbChuKTtcbiAgICByZXR1cm4gbm9kZSQxXG4gIH1cbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbiA9IGl0Lm5leHQoKTtcbiAgICBuLnByaW50KG91dCk7XG4gIH1cbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpXG59O1xuTm9kZU1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gdmFsdWVzICgpIHtcbiAgcmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKVxufTtcbk5vZGVNYXAucHJvdG90eXBlLmdldEJvdW5kYXJ5Tm9kZXMgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeU5vZGVzIChnZW9tSW5kZXgpIHtcbiAgdmFyIGJkeU5vZGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gdGhpcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IGkubmV4dCgpO1xuICAgIGlmIChub2RlLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZ2VvbUluZGV4KSA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgYmR5Tm9kZXMuYWRkKG5vZGUpOyB9XG4gIH1cbiAgcmV0dXJuIGJkeU5vZGVzXG59O1xuTm9kZU1hcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChlKSB7XG4gIHZhciBwID0gZS5nZXRDb29yZGluYXRlKCk7XG4gIHZhciBuID0gdGhpcy5hZGROb2RlKHApO1xuICBuLmFkZChlKTtcbn07XG5Ob2RlTWFwLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTm9kZU1hcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOb2RlTWFwXG59O1xuXG52YXIgUXVhZHJhbnQgPSBmdW5jdGlvbiBRdWFkcmFudCAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyMSA9IHsgTkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTlc6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU1c6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuUXVhZHJhbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5RdWFkcmFudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBRdWFkcmFudFxufTtcblF1YWRyYW50LmlzTm9ydGhlcm4gPSBmdW5jdGlvbiBpc05vcnRoZXJuIChxdWFkKSB7XG4gIHJldHVybiBxdWFkID09PSBRdWFkcmFudC5ORSB8fCBxdWFkID09PSBRdWFkcmFudC5OV1xufTtcblF1YWRyYW50LmlzT3Bwb3NpdGUgPSBmdW5jdGlvbiBpc09wcG9zaXRlIChxdWFkMSwgcXVhZDIpIHtcbiAgaWYgKHF1YWQxID09PSBxdWFkMikgeyByZXR1cm4gZmFsc2UgfVxuICB2YXIgZGlmZiA9IChxdWFkMSAtIHF1YWQyICsgNCkgJSA0O1xuICBpZiAoZGlmZiA9PT0gMikgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcblF1YWRyYW50LmNvbW1vbkhhbGZQbGFuZSA9IGZ1bmN0aW9uIGNvbW1vbkhhbGZQbGFuZSAocXVhZDEsIHF1YWQyKSB7XG4gIGlmIChxdWFkMSA9PT0gcXVhZDIpIHsgcmV0dXJuIHF1YWQxIH1cbiAgdmFyIGRpZmYgPSAocXVhZDEgLSBxdWFkMiArIDQpICUgNDtcbiAgaWYgKGRpZmYgPT09IDIpIHsgcmV0dXJuIC0xIH1cbiAgdmFyIG1pbiA9IHF1YWQxIDwgcXVhZDIgPyBxdWFkMSA6IHF1YWQyO1xuICB2YXIgbWF4ID0gcXVhZDEgPiBxdWFkMiA/IHF1YWQxIDogcXVhZDI7XG4gIGlmIChtaW4gPT09IDAgJiYgbWF4ID09PSAzKSB7IHJldHVybiAzIH1cbiAgcmV0dXJuIG1pblxufTtcblF1YWRyYW50LmlzSW5IYWxmUGxhbmUgPSBmdW5jdGlvbiBpc0luSGFsZlBsYW5lIChxdWFkLCBoYWxmUGxhbmUpIHtcbiAgaWYgKGhhbGZQbGFuZSA9PT0gUXVhZHJhbnQuU0UpIHtcbiAgICByZXR1cm4gcXVhZCA9PT0gUXVhZHJhbnQuU0UgfHwgcXVhZCA9PT0gUXVhZHJhbnQuU1dcbiAgfVxuICByZXR1cm4gcXVhZCA9PT0gaGFsZlBsYW5lIHx8IHF1YWQgPT09IGhhbGZQbGFuZSArIDFcbn07XG5RdWFkcmFudC5xdWFkcmFudCA9IGZ1bmN0aW9uIHF1YWRyYW50ICgpIHtcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdudW1iZXInICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgdmFyIGR4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkeSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZHggPT09IDAuMCAmJiBkeSA9PT0gMC4wKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ0Nhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgcG9pbnQgKCAnICsgZHggKyAnLCAnICsgZHkgKyAnICknKSB9XG4gICAgaWYgKGR4ID49IDAuMCkge1xuICAgICAgaWYgKGR5ID49IDAuMCkgeyByZXR1cm4gUXVhZHJhbnQuTkU7IH0gZWxzZSB7IHJldHVybiBRdWFkcmFudC5TRSB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkeSA+PSAwLjApIHsgcmV0dXJuIFF1YWRyYW50Lk5XOyB9IGVsc2UgeyByZXR1cm4gUXVhZHJhbnQuU1cgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChwMS54ID09PSBwMC54ICYmIHAxLnkgPT09IHAwLnkpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciB0d28gaWRlbnRpY2FsIHBvaW50cyAnICsgcDApIH1cbiAgICBpZiAocDEueCA+PSBwMC54KSB7XG4gICAgICBpZiAocDEueSA+PSBwMC55KSB7IHJldHVybiBRdWFkcmFudC5ORTsgfSBlbHNlIHsgcmV0dXJuIFF1YWRyYW50LlNFIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHAxLnkgPj0gcDAueSkgeyByZXR1cm4gUXVhZHJhbnQuTlc7IH0gZWxzZSB7IHJldHVybiBRdWFkcmFudC5TVyB9XG4gICAgfVxuICB9XG59O1xuc3RhdGljQWNjZXNzb3JzJDIxLk5FLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAgfTtcbnN0YXRpY0FjY2Vzc29ycyQyMS5OVy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjEuU1cuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuc3RhdGljQWNjZXNzb3JzJDIxLlNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFF1YWRyYW50LCBzdGF0aWNBY2Nlc3NvcnMkMjEgKTtcblxudmFyIEVkZ2VFbmQgPSBmdW5jdGlvbiBFZGdlRW5kICgpIHtcbiAgdGhpcy5fZWRnZSA9IG51bGw7XG4gIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgdGhpcy5fbm9kZSA9IG51bGw7XG4gIHRoaXMuX3AwID0gbnVsbDtcbiAgdGhpcy5fcDEgPSBudWxsO1xuICB0aGlzLl9keCA9IG51bGw7XG4gIHRoaXMuX2R5ID0gbnVsbDtcbiAgdGhpcy5fcXVhZHJhbnQgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBlZGdlID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuX2VkZ2UgPSBlZGdlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgZWRnZSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGxhYmVsID0gbnVsbDtcbiAgICB0aGlzLl9lZGdlID0gZWRnZSQxO1xuICAgIHRoaXMuaW5pdChwMCwgcDEpO1xuICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBlZGdlJDIgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAwJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHAxJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGxhYmVsJDEgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5fZWRnZSA9IGVkZ2UkMjtcbiAgICB0aGlzLmluaXQocDAkMSwgcDEkMSk7XG4gICAgdGhpcy5fbGFiZWwgPSBsYWJlbCQxO1xuICB9XG59O1xuRWRnZUVuZC5wcm90b3R5cGUuY29tcGFyZURpcmVjdGlvbiA9IGZ1bmN0aW9uIGNvbXBhcmVEaXJlY3Rpb24gKGUpIHtcbiAgaWYgKHRoaXMuX2R4ID09PSBlLl9keCAmJiB0aGlzLl9keSA9PT0gZS5fZHkpIHsgcmV0dXJuIDAgfVxuICBpZiAodGhpcy5fcXVhZHJhbnQgPiBlLl9xdWFkcmFudCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl9xdWFkcmFudCA8IGUuX3F1YWRyYW50KSB7IHJldHVybiAtMSB9XG4gIHJldHVybiBDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKGUuX3AwLCBlLl9wMSwgdGhpcy5fcDEpXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0RHkgPSBmdW5jdGlvbiBnZXREeSAoKSB7XG4gIHJldHVybiB0aGlzLl9keVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuX3AwXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuc2V0Tm9kZSA9IGZ1bmN0aW9uIHNldE5vZGUgKG5vZGUpIHtcbiAgdGhpcy5fbm9kZSA9IG5vZGU7XG59O1xuRWRnZUVuZC5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gIHZhciBhbmdsZSA9IE1hdGguYXRhbjIodGhpcy5fZHksIHRoaXMuX2R4KTtcbiAgdmFyIGNsYXNzTmFtZSA9IHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCk7XG4gIHZhciBsYXN0RG90UG9zID0gY2xhc3NOYW1lLmxhc3RJbmRleE9mKCcuJyk7XG4gIHZhciBuYW1lID0gY2xhc3NOYW1lLnN1YnN0cmluZyhsYXN0RG90UG9zICsgMSk7XG4gIG91dC5wcmludCgnICAnICsgbmFtZSArICc6ICcgKyB0aGlzLl9wMCArICcgLSAnICsgdGhpcy5fcDEgKyAnICcgKyB0aGlzLl9xdWFkcmFudCArICc6JyArIGFuZ2xlICsgJyAgICcgKyB0aGlzLl9sYWJlbCk7XG59O1xuRWRnZUVuZC5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvYmopIHtcbiAgdmFyIGUgPSBvYmo7XG4gIHJldHVybiB0aGlzLmNvbXBhcmVEaXJlY3Rpb24oZSlcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXREaXJlY3RlZENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXREaXJlY3RlZENvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5fcDFcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXREeCA9IGZ1bmN0aW9uIGdldER4ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2R4XG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiBnZXRMYWJlbCAoKSB7XG4gIHJldHVybiB0aGlzLl9sYWJlbFxufTtcbkVkZ2VFbmQucHJvdG90eXBlLmdldEVkZ2UgPSBmdW5jdGlvbiBnZXRFZGdlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2Vcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5nZXRRdWFkcmFudCA9IGZ1bmN0aW9uIGdldFF1YWRyYW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX3F1YWRyYW50XG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0Tm9kZSA9IGZ1bmN0aW9uIGdldE5vZGUgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZVxufTtcbkVkZ2VFbmQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMuX2R5LCB0aGlzLl9keCk7XG4gIHZhciBjbGFzc05hbWUgPSB0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpO1xuICB2YXIgbGFzdERvdFBvcyA9IGNsYXNzTmFtZS5sYXN0SW5kZXhPZignLicpO1xuICB2YXIgbmFtZSA9IGNsYXNzTmFtZS5zdWJzdHJpbmcobGFzdERvdFBvcyArIDEpO1xuICByZXR1cm4gJyAgJyArIG5hbWUgKyAnOiAnICsgdGhpcy5fcDAgKyAnIC0gJyArIHRoaXMuX3AxICsgJyAnICsgdGhpcy5fcXVhZHJhbnQgKyAnOicgKyBhbmdsZSArICcgICAnICsgdGhpcy5fbGFiZWxcbn07XG5FZGdlRW5kLnByb3RvdHlwZS5jb21wdXRlTGFiZWwgPSBmdW5jdGlvbiBjb21wdXRlTGFiZWwgKGJvdW5kYXJ5Tm9kZVJ1bGUpIHt9O1xuRWRnZUVuZC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKHAwLCBwMSkge1xuICB0aGlzLl9wMCA9IHAwO1xuICB0aGlzLl9wMSA9IHAxO1xuICB0aGlzLl9keCA9IHAxLnggLSBwMC54O1xuICB0aGlzLl9keSA9IHAxLnkgLSBwMC55O1xuICB0aGlzLl9xdWFkcmFudCA9IFF1YWRyYW50LnF1YWRyYW50KHRoaXMuX2R4LCB0aGlzLl9keSk7XG4gIEFzc2VydC5pc1RydWUoISh0aGlzLl9keCA9PT0gMCAmJiB0aGlzLl9keSA9PT0gMCksICdFZGdlRW5kIHdpdGggaWRlbnRpY2FsIGVuZHBvaW50cyBmb3VuZCcpO1xufTtcbkVkZ2VFbmQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuRWRnZUVuZC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlRW5kXG59O1xuXG52YXIgRGlyZWN0ZWRFZGdlID0gKGZ1bmN0aW9uIChFZGdlRW5kJCQxKSB7XG4gIGZ1bmN0aW9uIERpcmVjdGVkRWRnZSAoKSB7XG4gICAgdmFyIGVkZ2UgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGlzRm9yd2FyZCA9IGFyZ3VtZW50c1sxXTtcbiAgICBFZGdlRW5kJCQxLmNhbGwodGhpcywgZWRnZSk7XG4gICAgdGhpcy5faXNGb3J3YXJkID0gbnVsbDtcbiAgICB0aGlzLl9pc0luUmVzdWx0ID0gZmFsc2U7XG4gICAgdGhpcy5faXNWaXNpdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fc3ltID0gbnVsbDtcbiAgICB0aGlzLl9uZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9uZXh0TWluID0gbnVsbDtcbiAgICB0aGlzLl9lZGdlUmluZyA9IG51bGw7XG4gICAgdGhpcy5fbWluRWRnZVJpbmcgPSBudWxsO1xuICAgIHRoaXMuX2RlcHRoID0gWzAsIC05OTksIC05OTldO1xuICAgIHRoaXMuX2lzRm9yd2FyZCA9IGlzRm9yd2FyZDtcbiAgICBpZiAoaXNGb3J3YXJkKSB7XG4gICAgICB0aGlzLmluaXQoZWRnZS5nZXRDb29yZGluYXRlKDApLCBlZGdlLmdldENvb3JkaW5hdGUoMSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbiA9IGVkZ2UuZ2V0TnVtUG9pbnRzKCkgLSAxO1xuICAgICAgdGhpcy5pbml0KGVkZ2UuZ2V0Q29vcmRpbmF0ZShuKSwgZWRnZS5nZXRDb29yZGluYXRlKG4gLSAxKSk7XG4gICAgfVxuICAgIHRoaXMuY29tcHV0ZURpcmVjdGVkTGFiZWwoKTtcbiAgfVxuXG4gIGlmICggRWRnZUVuZCQkMSApIERpcmVjdGVkRWRnZS5fX3Byb3RvX18gPSBFZGdlRW5kJCQxO1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWRnZUVuZCQkMSAmJiBFZGdlRW5kJCQxLnByb3RvdHlwZSApO1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0ZWRFZGdlO1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldE5leHRNaW4gPSBmdW5jdGlvbiBnZXROZXh0TWluICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmV4dE1pblxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldERlcHRoID0gZnVuY3Rpb24gZ2V0RGVwdGggKHBvc2l0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoW3Bvc2l0aW9uXVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnNldFZpc2l0ZWQgPSBmdW5jdGlvbiBzZXRWaXNpdGVkIChpc1Zpc2l0ZWQpIHtcbiAgICB0aGlzLl9pc1Zpc2l0ZWQgPSBpc1Zpc2l0ZWQ7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuY29tcHV0ZURpcmVjdGVkTGFiZWwgPSBmdW5jdGlvbiBjb21wdXRlRGlyZWN0ZWRMYWJlbCAoKSB7XG4gICAgdGhpcy5fbGFiZWwgPSBuZXcgTGFiZWwodGhpcy5fZWRnZS5nZXRMYWJlbCgpKTtcbiAgICBpZiAoIXRoaXMuX2lzRm9yd2FyZCkgeyB0aGlzLl9sYWJlbC5mbGlwKCk7IH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXROZXh0ID0gZnVuY3Rpb24gZ2V0TmV4dCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25leHRcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXREZXB0aCA9IGZ1bmN0aW9uIHNldERlcHRoIChwb3NpdGlvbiwgZGVwdGhWYWwpIHtcbiAgICBpZiAodGhpcy5fZGVwdGhbcG9zaXRpb25dICE9PSAtOTk5KSB7XG4gICAgICBpZiAodGhpcy5fZGVwdGhbcG9zaXRpb25dICE9PSBkZXB0aFZhbCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ2Fzc2lnbmVkIGRlcHRocyBkbyBub3QgbWF0Y2gnLCB0aGlzLmdldENvb3JkaW5hdGUoKSkgfVxuICAgIH1cbiAgICB0aGlzLl9kZXB0aFtwb3NpdGlvbl0gPSBkZXB0aFZhbDtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5pc0ludGVyaW9yQXJlYUVkZ2UgPSBmdW5jdGlvbiBpc0ludGVyaW9yQXJlYUVkZ2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlzSW50ZXJpb3JBcmVhRWRnZSA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgIGlmICghKHRoaXMkMS5fbGFiZWwuaXNBcmVhKGkpICYmIHRoaXMkMS5fbGFiZWwuZ2V0TG9jYXRpb24oaSwgUG9zaXRpb24uTEVGVCkgPT09IExvY2F0aW9uLklOVEVSSU9SICYmIHRoaXMkMS5fbGFiZWwuZ2V0TG9jYXRpb24oaSwgUG9zaXRpb24uUklHSFQpID09PSBMb2NhdGlvbi5JTlRFUklPUikpIHtcbiAgICAgICAgaXNJbnRlcmlvckFyZWFFZGdlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc0ludGVyaW9yQXJlYUVkZ2VcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXROZXh0TWluID0gZnVuY3Rpb24gc2V0TmV4dE1pbiAobmV4dE1pbikge1xuICAgIHRoaXMuX25leHRNaW4gPSBuZXh0TWluO1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICAgIEVkZ2VFbmQkJDEucHJvdG90eXBlLnByaW50LmNhbGwodGhpcywgb3V0KTtcbiAgICBvdXQucHJpbnQoJyAnICsgdGhpcy5fZGVwdGhbUG9zaXRpb24uTEVGVF0gKyAnLycgKyB0aGlzLl9kZXB0aFtQb3NpdGlvbi5SSUdIVF0pO1xuICAgIG91dC5wcmludCgnICgnICsgdGhpcy5nZXREZXB0aERlbHRhKCkgKyAnKScpO1xuICAgIGlmICh0aGlzLl9pc0luUmVzdWx0KSB7IG91dC5wcmludCgnIGluUmVzdWx0Jyk7IH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXRNaW5FZGdlUmluZyA9IGZ1bmN0aW9uIHNldE1pbkVkZ2VSaW5nIChtaW5FZGdlUmluZykge1xuICAgIHRoaXMuX21pbkVkZ2VSaW5nID0gbWluRWRnZVJpbmc7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuaXNMaW5lRWRnZSA9IGZ1bmN0aW9uIGlzTGluZUVkZ2UgKCkge1xuICAgIHZhciBpc0xpbmUgPSB0aGlzLl9sYWJlbC5pc0xpbmUoMCkgfHwgdGhpcy5fbGFiZWwuaXNMaW5lKDEpO1xuICAgIHZhciBpc0V4dGVyaW9ySWZBcmVhMCA9ICF0aGlzLl9sYWJlbC5pc0FyZWEoMCkgfHwgdGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMCwgTG9jYXRpb24uRVhURVJJT1IpO1xuICAgIHZhciBpc0V4dGVyaW9ySWZBcmVhMSA9ICF0aGlzLl9sYWJlbC5pc0FyZWEoMSkgfHwgdGhpcy5fbGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMSwgTG9jYXRpb24uRVhURVJJT1IpO1xuICAgIHJldHVybiBpc0xpbmUgJiYgaXNFeHRlcmlvcklmQXJlYTAgJiYgaXNFeHRlcmlvcklmQXJlYTFcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXRFZGdlUmluZyA9IGZ1bmN0aW9uIHNldEVkZ2VSaW5nIChlZGdlUmluZykge1xuICAgIHRoaXMuX2VkZ2VSaW5nID0gZWRnZVJpbmc7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0TWluRWRnZVJpbmcgPSBmdW5jdGlvbiBnZXRNaW5FZGdlUmluZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21pbkVkZ2VSaW5nXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0RGVwdGhEZWx0YSA9IGZ1bmN0aW9uIGdldERlcHRoRGVsdGEgKCkge1xuICAgIHZhciBkZXB0aERlbHRhID0gdGhpcy5fZWRnZS5nZXREZXB0aERlbHRhKCk7XG4gICAgaWYgKCF0aGlzLl9pc0ZvcndhcmQpIHsgZGVwdGhEZWx0YSA9IC1kZXB0aERlbHRhOyB9XG4gICAgcmV0dXJuIGRlcHRoRGVsdGFcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXRJblJlc3VsdCA9IGZ1bmN0aW9uIHNldEluUmVzdWx0IChpc0luUmVzdWx0KSB7XG4gICAgdGhpcy5faXNJblJlc3VsdCA9IGlzSW5SZXN1bHQ7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0U3ltID0gZnVuY3Rpb24gZ2V0U3ltICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ltXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuaXNGb3J3YXJkID0gZnVuY3Rpb24gaXNGb3J3YXJkICgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNGb3J3YXJkXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuZ2V0RWRnZSA9IGZ1bmN0aW9uIGdldEVkZ2UgKCkge1xuICAgIHJldHVybiB0aGlzLl9lZGdlXG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUucHJpbnRFZGdlID0gZnVuY3Rpb24gcHJpbnRFZGdlIChvdXQpIHtcbiAgICB0aGlzLnByaW50KG91dCk7XG4gICAgb3V0LnByaW50KCcgJyk7XG4gICAgaWYgKHRoaXMuX2lzRm9yd2FyZCkgeyB0aGlzLl9lZGdlLnByaW50KG91dCk7IH0gZWxzZSB7IHRoaXMuX2VkZ2UucHJpbnRSZXZlcnNlKG91dCk7IH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXRTeW0gPSBmdW5jdGlvbiBzZXRTeW0gKGRlKSB7XG4gICAgdGhpcy5fc3ltID0gZGU7XG4gIH07XG4gIERpcmVjdGVkRWRnZS5wcm90b3R5cGUuc2V0VmlzaXRlZEVkZ2UgPSBmdW5jdGlvbiBzZXRWaXNpdGVkRWRnZSAoaXNWaXNpdGVkKSB7XG4gICAgdGhpcy5zZXRWaXNpdGVkKGlzVmlzaXRlZCk7XG4gICAgdGhpcy5fc3ltLnNldFZpc2l0ZWQoaXNWaXNpdGVkKTtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXRFZGdlRGVwdGhzID0gZnVuY3Rpb24gc2V0RWRnZURlcHRocyAocG9zaXRpb24sIGRlcHRoKSB7XG4gICAgdmFyIGRlcHRoRGVsdGEgPSB0aGlzLmdldEVkZ2UoKS5nZXREZXB0aERlbHRhKCk7XG4gICAgaWYgKCF0aGlzLl9pc0ZvcndhcmQpIHsgZGVwdGhEZWx0YSA9IC1kZXB0aERlbHRhOyB9XG4gICAgdmFyIGRpcmVjdGlvbkZhY3RvciA9IDE7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5MRUZUKSB7IGRpcmVjdGlvbkZhY3RvciA9IC0xOyB9XG4gICAgdmFyIG9wcG9zaXRlUG9zID0gUG9zaXRpb24ub3Bwb3NpdGUocG9zaXRpb24pO1xuICAgIHZhciBkZWx0YSA9IGRlcHRoRGVsdGEgKiBkaXJlY3Rpb25GYWN0b3I7XG4gICAgdmFyIG9wcG9zaXRlRGVwdGggPSBkZXB0aCArIGRlbHRhO1xuICAgIHRoaXMuc2V0RGVwdGgocG9zaXRpb24sIGRlcHRoKTtcbiAgICB0aGlzLnNldERlcHRoKG9wcG9zaXRlUG9zLCBvcHBvc2l0ZURlcHRoKTtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5nZXRFZGdlUmluZyA9IGZ1bmN0aW9uIGdldEVkZ2VSaW5nICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZWRnZVJpbmdcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5pc0luUmVzdWx0ID0gZnVuY3Rpb24gaXNJblJlc3VsdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzSW5SZXN1bHRcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLnByb3RvdHlwZS5zZXROZXh0ID0gZnVuY3Rpb24gc2V0TmV4dCAobmV4dCkge1xuICAgIHRoaXMuX25leHQgPSBuZXh0O1xuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmlzVmlzaXRlZCA9IGZ1bmN0aW9uIGlzVmlzaXRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVmlzaXRlZFxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBEaXJlY3RlZEVkZ2UucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBEaXJlY3RlZEVkZ2VcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlLmRlcHRoRmFjdG9yID0gZnVuY3Rpb24gZGVwdGhGYWN0b3IgKGN1cnJMb2NhdGlvbiwgbmV4dExvY2F0aW9uKSB7XG4gICAgaWYgKGN1cnJMb2NhdGlvbiA9PT0gTG9jYXRpb24uRVhURVJJT1IgJiYgbmV4dExvY2F0aW9uID09PSBMb2NhdGlvbi5JTlRFUklPUikgeyByZXR1cm4gMTsgfSBlbHNlIGlmIChjdXJyTG9jYXRpb24gPT09IExvY2F0aW9uLklOVEVSSU9SICYmIG5leHRMb2NhdGlvbiA9PT0gTG9jYXRpb24uRVhURVJJT1IpIHsgcmV0dXJuIC0xIH1cbiAgICByZXR1cm4gMFxuICB9O1xuXG4gIHJldHVybiBEaXJlY3RlZEVkZ2U7XG59KEVkZ2VFbmQpKTtcblxudmFyIE5vZGVGYWN0b3J5ID0gZnVuY3Rpb24gTm9kZUZhY3RvcnkgKCkge307XG5cbk5vZGVGYWN0b3J5LnByb3RvdHlwZS5jcmVhdGVOb2RlID0gZnVuY3Rpb24gY3JlYXRlTm9kZSAoY29vcmQpIHtcbiAgcmV0dXJuIG5ldyBOb2RlKGNvb3JkLCBudWxsKVxufTtcbk5vZGVGYWN0b3J5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTm9kZUZhY3RvcnkucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kZUZhY3Rvcnlcbn07XG5cbnZhciBQbGFuYXJHcmFwaCA9IGZ1bmN0aW9uIFBsYW5hckdyYXBoICgpIHtcbiAgdGhpcy5fZWRnZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX25vZGVzID0gbnVsbDtcbiAgdGhpcy5fZWRnZUVuZExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5fbm9kZXMgPSBuZXcgTm9kZU1hcChuZXcgTm9kZUZhY3RvcnkoKSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBub2RlRmFjdCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9ub2RlcyA9IG5ldyBOb2RlTWFwKG5vZGVGYWN0KTtcbiAgfVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5wcmludEVkZ2VzID0gZnVuY3Rpb24gcHJpbnRFZGdlcyAob3V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgb3V0LnByaW50bG4oJ0VkZ2VzOicpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2VkZ2VzLnNpemUoKTsgaSsrKSB7XG4gICAgb3V0LnByaW50bG4oJ2VkZ2UgJyArIGkgKyAnOicpO1xuICAgIHZhciBlID0gdGhpcyQxLl9lZGdlcy5nZXQoaSk7XG4gICAgZS5wcmludChvdXQpO1xuICAgIGUuZWlMaXN0LnByaW50KG91dCk7XG4gIH1cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIGZpbmQgKGNvb3JkKSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlcy5maW5kKGNvb3JkKVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5hZGROb2RlID0gZnVuY3Rpb24gYWRkTm9kZSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmFkZE5vZGUobm9kZSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLl9ub2Rlcy5hZGROb2RlKGNvb3JkKVxuICB9XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmdldE5vZGVJdGVyYXRvciA9IGZ1bmN0aW9uIGdldE5vZGVJdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9ub2Rlcy5pdGVyYXRvcigpXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gbGlua1Jlc3VsdERpcmVjdGVkRWRnZXMgKCkge1xuICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9ub2Rlcy5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICBub2RlLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKTtcbiAgfVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5kZWJ1Z1ByaW50bG4gPSBmdW5jdGlvbiBkZWJ1Z1ByaW50bG4gKG8pIHtcbiAgU3lzdGVtLm91dC5wcmludGxuKG8pO1xufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5pc0JvdW5kYXJ5Tm9kZSA9IGZ1bmN0aW9uIGlzQm91bmRhcnlOb2RlIChnZW9tSW5kZXgsIGNvb3JkKSB7XG4gIHZhciBub2RlID0gdGhpcy5fbm9kZXMuZmluZChjb29yZCk7XG4gIGlmIChub2RlID09PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBsYWJlbCA9IG5vZGUuZ2V0TGFiZWwoKTtcbiAgaWYgKGxhYmVsICE9PSBudWxsICYmIGxhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCkgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmxpbmtBbGxEaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gbGlua0FsbERpcmVjdGVkRWRnZXMgKCkge1xuICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9ub2Rlcy5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICBub2RlLmdldEVkZ2VzKCkubGlua0FsbERpcmVjdGVkRWRnZXMoKTtcbiAgfVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5tYXRjaEluU2FtZURpcmVjdGlvbiA9IGZ1bmN0aW9uIG1hdGNoSW5TYW1lRGlyZWN0aW9uIChwMCwgcDEsIGVwMCwgZXAxKSB7XG4gIGlmICghcDAuZXF1YWxzKGVwMCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24ocDAsIHAxLCBlcDEpID09PSBDR0FsZ29yaXRobXMuQ09MTElORUFSICYmIFF1YWRyYW50LnF1YWRyYW50KHAwLCBwMSkgPT09IFF1YWRyYW50LnF1YWRyYW50KGVwMCwgZXAxKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5nZXRFZGdlRW5kcyA9IGZ1bmN0aW9uIGdldEVkZ2VFbmRzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VFbmRMaXN0XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmRlYnVnUHJpbnQgPSBmdW5jdGlvbiBkZWJ1Z1ByaW50IChvKSB7XG4gIFN5c3RlbS5vdXQucHJpbnQobyk7XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmdldEVkZ2VJdGVyYXRvciA9IGZ1bmN0aW9uIGdldEVkZ2VJdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlcy5pdGVyYXRvcigpXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uID0gZnVuY3Rpb24gZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24gKHAwLCBwMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZXMuc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgZSA9IHRoaXMkMS5fZWRnZXMuZ2V0KGkpO1xuICAgIHZhciBlQ29vcmQgPSBlLmdldENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKHRoaXMkMS5tYXRjaEluU2FtZURpcmVjdGlvbihwMCwgcDEsIGVDb29yZFswXSwgZUNvb3JkWzFdKSkgeyByZXR1cm4gZSB9XG4gICAgaWYgKHRoaXMkMS5tYXRjaEluU2FtZURpcmVjdGlvbihwMCwgcDEsIGVDb29yZFtlQ29vcmQubGVuZ3RoIC0gMV0sIGVDb29yZFtlQ29vcmQubGVuZ3RoIC0gMl0pKSB7IHJldHVybiBlIH1cbiAgfVxuICByZXR1cm4gbnVsbFxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5pbnNlcnRFZGdlID0gZnVuY3Rpb24gaW5zZXJ0RWRnZSAoZSkge1xuICB0aGlzLl9lZGdlcy5hZGQoZSk7XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmZpbmRFZGdlRW5kID0gZnVuY3Rpb24gZmluZEVkZ2VFbmQgKGUpIHtcbiAgZm9yICh2YXIgaSA9IHRoaXMuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZWUgPSBpLm5leHQoKTtcbiAgICBpZiAoZWUuZ2V0RWRnZSgpID09PSBlKSB7IHJldHVybiBlZSB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuYWRkRWRnZXMgPSBmdW5jdGlvbiBhZGRFZGdlcyAoZWRnZXNUb0FkZCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gZWRnZXNUb0FkZC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgdGhpcyQxLl9lZGdlcy5hZGQoZSk7XG4gICAgdmFyIGRlMSA9IG5ldyBEaXJlY3RlZEVkZ2UoZSwgdHJ1ZSk7XG4gICAgdmFyIGRlMiA9IG5ldyBEaXJlY3RlZEVkZ2UoZSwgZmFsc2UpO1xuICAgIGRlMS5zZXRTeW0oZGUyKTtcbiAgICBkZTIuc2V0U3ltKGRlMSk7XG4gICAgdGhpcyQxLmFkZChkZTEpO1xuICAgIHRoaXMkMS5hZGQoZGUyKTtcbiAgfVxufTtcblBsYW5hckdyYXBoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGUpIHtcbiAgdGhpcy5fbm9kZXMuYWRkKGUpO1xuICB0aGlzLl9lZGdlRW5kTGlzdC5hZGQoZSk7XG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmdldE5vZGVzID0gZnVuY3Rpb24gZ2V0Tm9kZXMgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZXMudmFsdWVzKClcbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZmluZEVkZ2UgPSBmdW5jdGlvbiBmaW5kRWRnZSAocDAsIHAxKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lZGdlcy5zaXplKCk7IGkrKykge1xuICAgIHZhciBlID0gdGhpcyQxLl9lZGdlcy5nZXQoaSk7XG4gICAgdmFyIGVDb29yZCA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBpZiAocDAuZXF1YWxzKGVDb29yZFswXSkgJiYgcDEuZXF1YWxzKGVDb29yZFsxXSkpIHsgcmV0dXJuIGUgfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuUGxhbmFyR3JhcGgucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5QbGFuYXJHcmFwaC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQbGFuYXJHcmFwaFxufTtcblBsYW5hckdyYXBoLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzID0gZnVuY3Rpb24gbGlua1Jlc3VsdERpcmVjdGVkRWRnZXMgKG5vZGVzKSB7XG4gIGZvciAodmFyIG5vZGVpdCA9IG5vZGVzLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIG5vZGUgPSBub2RlaXQubmV4dCgpO1xuICAgIG5vZGUuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpO1xuICB9XG59O1xuXG52YXIgUG9seWdvbkJ1aWxkZXIgPSBmdW5jdGlvbiBQb2x5Z29uQnVpbGRlciAoKSB7XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IG51bGw7XG4gIHRoaXMuX3NoZWxsTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIGdlb21ldHJ5RmFjdG9yeSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gZ2VvbWV0cnlGYWN0b3J5O1xufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5zb3J0U2hlbGxzQW5kSG9sZXMgPSBmdW5jdGlvbiBzb3J0U2hlbGxzQW5kSG9sZXMgKGVkZ2VSaW5ncywgc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpIHtcbiAgZm9yICh2YXIgaXQgPSBlZGdlUmluZ3MuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZXIuaXNIb2xlKCkpIHtcbiAgICAgIGZyZWVIb2xlTGlzdC5hZGQoZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaGVsbExpc3QuYWRkKGVyKTtcbiAgICB9XG4gIH1cbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuY29tcHV0ZVBvbHlnb25zID0gZnVuY3Rpb24gY29tcHV0ZVBvbHlnb25zIChzaGVsbExpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgcmVzdWx0UG9seUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGl0ID0gc2hlbGxMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZXIgPSBpdC5uZXh0KCk7XG4gICAgdmFyIHBvbHkgPSBlci50b1BvbHlnb24odGhpcyQxLl9nZW9tZXRyeUZhY3RvcnkpO1xuICAgIHJlc3VsdFBvbHlMaXN0LmFkZChwb2x5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0UG9seUxpc3Rcbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUucGxhY2VGcmVlSG9sZXMgPSBmdW5jdGlvbiBwbGFjZUZyZWVIb2xlcyAoc2hlbGxMaXN0LCBmcmVlSG9sZUxpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpdCA9IGZyZWVIb2xlTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGhvbGUgPSBpdC5uZXh0KCk7XG4gICAgaWYgKGhvbGUuZ2V0U2hlbGwoKSA9PT0gbnVsbCkge1xuICAgICAgdmFyIHNoZWxsID0gdGhpcyQxLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoaG9sZSwgc2hlbGxMaXN0KTtcbiAgICAgIGlmIChzaGVsbCA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ3VuYWJsZSB0byBhc3NpZ24gaG9sZSB0byBhIHNoZWxsJywgaG9sZS5nZXRDb29yZGluYXRlKDApKSB9XG4gICAgICBob2xlLnNldFNoZWxsKHNoZWxsKTtcbiAgICB9XG4gIH1cbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuYnVpbGRNaW5pbWFsRWRnZVJpbmdzID0gZnVuY3Rpb24gYnVpbGRNaW5pbWFsRWRnZVJpbmdzIChtYXhFZGdlUmluZ3MsIHNoZWxsTGlzdCwgZnJlZUhvbGVMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVkZ2VSaW5ncyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaXQgPSBtYXhFZGdlUmluZ3MuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlciA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZXIuZ2V0TWF4Tm9kZURlZ3JlZSgpID4gMikge1xuICAgICAgZXIubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7XG4gICAgICB2YXIgbWluRWRnZVJpbmdzID0gZXIuYnVpbGRNaW5pbWFsUmluZ3MoKTtcbiAgICAgIHZhciBzaGVsbCA9IHRoaXMkMS5maW5kU2hlbGwobWluRWRnZVJpbmdzKTtcbiAgICAgIGlmIChzaGVsbCAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzJDEucGxhY2VQb2x5Z29uSG9sZXMoc2hlbGwsIG1pbkVkZ2VSaW5ncyk7XG4gICAgICAgIHNoZWxsTGlzdC5hZGQoc2hlbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJlZUhvbGVMaXN0LmFkZEFsbChtaW5FZGdlUmluZ3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlUmluZ3MuYWRkKGVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVkZ2VSaW5nc1xufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24gY29udGFpbnNQb2ludCAocCkge1xuICBmb3IgKHZhciBpdCA9IHRoaXMuX3NoZWxsTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVyID0gaXQubmV4dCgpO1xuICAgIGlmIChlci5jb250YWluc1BvaW50KHApKSB7IHJldHVybiB0cnVlIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuYnVpbGRNYXhpbWFsRWRnZVJpbmdzID0gZnVuY3Rpb24gYnVpbGRNYXhpbWFsRWRnZVJpbmdzIChkaXJFZGdlcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBtYXhFZGdlUmluZ3MgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGl0ID0gZGlyRWRnZXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZGUuaXNJblJlc3VsdCgpICYmIGRlLmdldExhYmVsKCkuaXNBcmVhKCkpIHtcbiAgICAgIGlmIChkZS5nZXRFZGdlUmluZygpID09PSBudWxsKSB7XG4gICAgICAgIHZhciBlciA9IG5ldyBNYXhpbWFsRWRnZVJpbmcoZGUsIHRoaXMkMS5fZ2VvbWV0cnlGYWN0b3J5KTtcbiAgICAgICAgbWF4RWRnZVJpbmdzLmFkZChlcik7XG4gICAgICAgIGVyLnNldEluUmVzdWx0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXhFZGdlUmluZ3Ncbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUucGxhY2VQb2x5Z29uSG9sZXMgPSBmdW5jdGlvbiBwbGFjZVBvbHlnb25Ib2xlcyAoc2hlbGwsIG1pbkVkZ2VSaW5ncykge1xuICBmb3IgKHZhciBpdCA9IG1pbkVkZ2VSaW5ncy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVyID0gaXQubmV4dCgpO1xuICAgIGlmIChlci5pc0hvbGUoKSkge1xuICAgICAgZXIuc2V0U2hlbGwoc2hlbGwpO1xuICAgIH1cbiAgfVxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5nZXRQb2x5Z29ucyA9IGZ1bmN0aW9uIGdldFBvbHlnb25zICgpIHtcbiAgdmFyIHJlc3VsdFBvbHlMaXN0ID0gdGhpcy5jb21wdXRlUG9seWdvbnModGhpcy5fc2hlbGxMaXN0KTtcbiAgcmV0dXJuIHJlc3VsdFBvbHlMaXN0XG59O1xuUG9seWdvbkJ1aWxkZXIucHJvdG90eXBlLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcgPSBmdW5jdGlvbiBmaW5kRWRnZVJpbmdDb250YWluaW5nICh0ZXN0RXIsIHNoZWxsTGlzdCkge1xuICB2YXIgdGVzdFJpbmcgPSB0ZXN0RXIuZ2V0TGluZWFyUmluZygpO1xuICB2YXIgdGVzdEVudiA9IHRlc3RSaW5nLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgdmFyIHRlc3RQdCA9IHRlc3RSaW5nLmdldENvb3JkaW5hdGVOKDApO1xuICB2YXIgbWluU2hlbGwgPSBudWxsO1xuICB2YXIgbWluRW52ID0gbnVsbDtcbiAgZm9yICh2YXIgaXQgPSBzaGVsbExpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciB0cnlTaGVsbCA9IGl0Lm5leHQoKTtcbiAgICB2YXIgdHJ5UmluZyA9IHRyeVNoZWxsLmdldExpbmVhclJpbmcoKTtcbiAgICB2YXIgdHJ5RW52ID0gdHJ5UmluZy5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gICAgaWYgKG1pblNoZWxsICE9PSBudWxsKSB7IG1pbkVudiA9IG1pblNoZWxsLmdldExpbmVhclJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCk7IH1cbiAgICB2YXIgaXNDb250YWluZWQgPSBmYWxzZTtcbiAgICBpZiAodHJ5RW52LmNvbnRhaW5zKHRlc3RFbnYpICYmIENHQWxnb3JpdGhtcy5pc1BvaW50SW5SaW5nKHRlc3RQdCwgdHJ5UmluZy5nZXRDb29yZGluYXRlcygpKSkgeyBpc0NvbnRhaW5lZCA9IHRydWU7IH1cbiAgICBpZiAoaXNDb250YWluZWQpIHtcbiAgICAgIGlmIChtaW5TaGVsbCA9PT0gbnVsbCB8fCBtaW5FbnYuY29udGFpbnModHJ5RW52KSkge1xuICAgICAgICBtaW5TaGVsbCA9IHRyeVNoZWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gbWluU2hlbGxcbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuZmluZFNoZWxsID0gZnVuY3Rpb24gZmluZFNoZWxsIChtaW5FZGdlUmluZ3MpIHtcbiAgdmFyIHNoZWxsQ291bnQgPSAwO1xuICB2YXIgc2hlbGwgPSBudWxsO1xuICBmb3IgKHZhciBpdCA9IG1pbkVkZ2VSaW5ncy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGVyID0gaXQubmV4dCgpO1xuICAgIGlmICghZXIuaXNIb2xlKCkpIHtcbiAgICAgIHNoZWxsID0gZXI7XG4gICAgICBzaGVsbENvdW50Kys7XG4gICAgfVxuICB9XG4gIEFzc2VydC5pc1RydWUoc2hlbGxDb3VudCA8PSAxLCAnZm91bmQgdHdvIHNoZWxscyBpbiBNaW5pbWFsRWRnZVJpbmcgbGlzdCcpO1xuICByZXR1cm4gc2hlbGxcbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ3JhcGggPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5hZGQoZ3JhcGguZ2V0RWRnZUVuZHMoKSwgZ3JhcGguZ2V0Tm9kZXMoKSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBkaXJFZGdlcyA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbm9kZXMgPSBhcmd1bWVudHNbMV07XG4gICAgUGxhbmFyR3JhcGgubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMobm9kZXMpO1xuICAgIHZhciBtYXhFZGdlUmluZ3MgPSB0aGlzLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyhkaXJFZGdlcyk7XG4gICAgdmFyIGZyZWVIb2xlTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB2YXIgZWRnZVJpbmdzID0gdGhpcy5idWlsZE1pbmltYWxFZGdlUmluZ3MobWF4RWRnZVJpbmdzLCB0aGlzLl9zaGVsbExpc3QsIGZyZWVIb2xlTGlzdCk7XG4gICAgdGhpcy5zb3J0U2hlbGxzQW5kSG9sZXMoZWRnZVJpbmdzLCB0aGlzLl9zaGVsbExpc3QsIGZyZWVIb2xlTGlzdCk7XG4gICAgdGhpcy5wbGFjZUZyZWVIb2xlcyh0aGlzLl9zaGVsbExpc3QsIGZyZWVIb2xlTGlzdCk7XG4gIH1cbn07XG5Qb2x5Z29uQnVpbGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblBvbHlnb25CdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvbHlnb25CdWlsZGVyXG59O1xuXG52YXIgQm91bmRhYmxlID0gZnVuY3Rpb24gQm91bmRhYmxlICgpIHt9O1xuXG5Cb3VuZGFibGUucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uIGdldEJvdW5kcyAoKSB7fTtcbkJvdW5kYWJsZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJvdW5kYWJsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCb3VuZGFibGVcbn07XG5cbnZhciBJdGVtQm91bmRhYmxlID0gZnVuY3Rpb24gSXRlbUJvdW5kYWJsZSAoKSB7XG4gIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIHRoaXMuX2l0ZW0gPSBudWxsO1xuICB2YXIgYm91bmRzID0gYXJndW1lbnRzWzBdO1xuICB2YXIgaXRlbSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fYm91bmRzID0gYm91bmRzO1xuICB0aGlzLl9pdGVtID0gaXRlbTtcbn07XG5JdGVtQm91bmRhYmxlLnByb3RvdHlwZS5nZXRJdGVtID0gZnVuY3Rpb24gZ2V0SXRlbSAoKSB7XG4gIHJldHVybiB0aGlzLl9pdGVtXG59O1xuSXRlbUJvdW5kYWJsZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gZ2V0Qm91bmRzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2JvdW5kc1xufTtcbkl0ZW1Cb3VuZGFibGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0JvdW5kYWJsZSwgU2VyaWFsaXphYmxlXVxufTtcbkl0ZW1Cb3VuZGFibGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSXRlbUJvdW5kYWJsZVxufTtcblxudmFyIFByaW9yaXR5UXVldWUgPSBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlICgpIHtcbiAgdGhpcy5fc2l6ZSA9IG51bGw7XG4gIHRoaXMuX2l0ZW1zID0gbnVsbDtcbiAgdGhpcy5fc2l6ZSA9IDA7XG4gIHRoaXMuX2l0ZW1zID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9pdGVtcy5hZGQobnVsbCk7XG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uIHBvbGwgKCkge1xuICBpZiAodGhpcy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgbWluSXRlbSA9IHRoaXMuX2l0ZW1zLmdldCgxKTtcbiAgdGhpcy5faXRlbXMuc2V0KDEsIHRoaXMuX2l0ZW1zLmdldCh0aGlzLl9zaXplKSk7XG4gIHRoaXMuX3NpemUgLT0gMTtcbiAgdGhpcy5yZW9yZGVyKDEpO1xuICByZXR1cm4gbWluSXRlbVxufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemVcbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5yZW9yZGVyID0gZnVuY3Rpb24gcmVvcmRlciAoaG9sZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBjaGlsZCA9IG51bGw7XG4gIHZhciB0bXAgPSB0aGlzLl9pdGVtcy5nZXQoaG9sZSk7XG4gIGZvciAoOyBob2xlICogMiA8PSB0aGlzLl9zaXplOyBob2xlID0gY2hpbGQpIHtcbiAgICBjaGlsZCA9IGhvbGUgKiAyO1xuICAgIGlmIChjaGlsZCAhPT0gdGhpcyQxLl9zaXplICYmIHRoaXMkMS5faXRlbXMuZ2V0KGNoaWxkICsgMSkuY29tcGFyZVRvKHRoaXMkMS5faXRlbXMuZ2V0KGNoaWxkKSkgPCAwKSB7IGNoaWxkKys7IH1cbiAgICBpZiAodGhpcyQxLl9pdGVtcy5nZXQoY2hpbGQpLmNvbXBhcmVUbyh0bXApIDwgMCkgeyB0aGlzJDEuX2l0ZW1zLnNldChob2xlLCB0aGlzJDEuX2l0ZW1zLmdldChjaGlsZCkpOyB9IGVsc2UgeyBicmVhayB9XG4gIH1cbiAgdGhpcy5faXRlbXMuc2V0KGhvbGUsIHRtcCk7XG59O1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhciAoKSB7XG4gIHRoaXMuX3NpemUgPSAwO1xuICB0aGlzLl9pdGVtcy5jbGVhcigpO1xufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NpemUgPT09IDBcbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl9pdGVtcy5hZGQobnVsbCk7XG4gIHRoaXMuX3NpemUgKz0gMTtcbiAgdmFyIGhvbGUgPSB0aGlzLl9zaXplO1xuICB0aGlzLl9pdGVtcy5zZXQoMCwgeCk7XG4gIGZvciAoOyB4LmNvbXBhcmVUbyh0aGlzLl9pdGVtcy5nZXQoTWF0aC50cnVuYyhob2xlIC8gMikpKSA8IDA7IGhvbGUgLz0gMikge1xuICAgIHRoaXMkMS5faXRlbXMuc2V0KGhvbGUsIHRoaXMkMS5faXRlbXMuZ2V0KE1hdGgudHJ1bmMoaG9sZSAvIDIpKSk7XG4gIH1cbiAgdGhpcy5faXRlbXMuc2V0KGhvbGUsIHgpO1xufTtcblByaW9yaXR5UXVldWUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFByaW9yaXR5UXVldWVcbn07XG5cbnZhciBJdGVtVmlzaXRvciA9IGZ1bmN0aW9uIEl0ZW1WaXNpdG9yICgpIHt9O1xuXG5JdGVtVmlzaXRvci5wcm90b3R5cGUudmlzaXRJdGVtID0gZnVuY3Rpb24gdmlzaXRJdGVtIChpdGVtKSB7fTtcbkl0ZW1WaXNpdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuSXRlbVZpc2l0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSXRlbVZpc2l0b3Jcbn07XG5cbnZhciBTcGF0aWFsSW5kZXggPSBmdW5jdGlvbiBTcGF0aWFsSW5kZXggKCkge307XG5cblNwYXRpYWxJbmRleC5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0IChpdGVtRW52LCBpdGVtKSB7fTtcblNwYXRpYWxJbmRleC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChpdGVtRW52LCBpdGVtKSB7fTtcblNwYXRpYWxJbmRleC5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiBxdWVyeSAoKSB7XG4gIC8vIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gIC8vIGNvbnN0IHNlYXJjaEVudiA9IGFyZ3VtZW50c1swXVxuICAvLyB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgLy8gY29uc3Qgc2VhcmNoRW52ID0gYXJndW1lbnRzWzBdXG4gIC8vIGNvbnN0IHZpc2l0b3IgPSBhcmd1bWVudHNbMV1cbiAgLy8gfVxufTtcblNwYXRpYWxJbmRleC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNwYXRpYWxJbmRleC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTcGF0aWFsSW5kZXhcbn07XG5cbnZhciBBYnN0cmFjdE5vZGUgPSBmdW5jdGlvbiBBYnN0cmFjdE5vZGUgKCkge1xuICB0aGlzLl9jaGlsZEJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX2JvdW5kcyA9IG51bGw7XG4gIHRoaXMuX2xldmVsID0gbnVsbDtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHt9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbGV2ZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyMiA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5nZXRMZXZlbCA9IGZ1bmN0aW9uIGdldExldmVsICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xldmVsXG59O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gIHJldHVybiB0aGlzLl9jaGlsZEJvdW5kYWJsZXMuc2l6ZSgpXG59O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5nZXRDaGlsZEJvdW5kYWJsZXMgPSBmdW5jdGlvbiBnZXRDaGlsZEJvdW5kYWJsZXMgKCkge1xuICByZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzXG59O1xuQWJzdHJhY3ROb2RlLnByb3RvdHlwZS5hZGRDaGlsZEJvdW5kYWJsZSA9IGZ1bmN0aW9uIGFkZENoaWxkQm91bmRhYmxlIChjaGlsZEJvdW5kYWJsZSkge1xuICBBc3NlcnQuaXNUcnVlKHRoaXMuX2JvdW5kcyA9PT0gbnVsbCk7XG4gIHRoaXMuX2NoaWxkQm91bmRhYmxlcy5hZGQoY2hpbGRCb3VuZGFibGUpO1xufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuaXNFbXB0eSA9IGZ1bmN0aW9uIGlzRW1wdHkgKCkge1xuICByZXR1cm4gdGhpcy5fY2hpbGRCb3VuZGFibGVzLmlzRW1wdHkoKVxufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuZ2V0Qm91bmRzID0gZnVuY3Rpb24gZ2V0Qm91bmRzICgpIHtcbiAgaWYgKHRoaXMuX2JvdW5kcyA9PT0gbnVsbCkge1xuICAgIHRoaXMuX2JvdW5kcyA9IHRoaXMuY29tcHV0ZUJvdW5kcygpO1xuICB9XG4gIHJldHVybiB0aGlzLl9ib3VuZHNcbn07XG5BYnN0cmFjdE5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0JvdW5kYWJsZSwgU2VyaWFsaXphYmxlXVxufTtcbkFic3RyYWN0Tm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBBYnN0cmFjdE5vZGVcbn07XG5zdGF0aWNBY2Nlc3NvcnMkMjIuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiA2NDkzNzIyMTg1OTA5NTczNzA4IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBBYnN0cmFjdE5vZGUsIHN0YXRpY0FjY2Vzc29ycyQyMiApO1xuXG52YXIgQ29sbGVjdGlvbnMgPSBmdW5jdGlvbiBDb2xsZWN0aW9ucyAoKSB7fTtcblxuQ29sbGVjdGlvbnMucmV2ZXJzZU9yZGVyID0gZnVuY3Rpb24gcmV2ZXJzZU9yZGVyICgpIHtcbiAgcmV0dXJuIHtcbiAgICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gICAgICByZXR1cm4gYi5jb21wYXJlVG8oYSlcbiAgICB9XG4gIH1cbn07XG5Db2xsZWN0aW9ucy5taW4gPSBmdW5jdGlvbiBtaW4gKGwpIHtcbiAgQ29sbGVjdGlvbnMuc29ydChsKTtcbiAgcmV0dXJuIGwuZ2V0KDApXG59O1xuQ29sbGVjdGlvbnMuc29ydCA9IGZ1bmN0aW9uIHNvcnQgKGwsIGMpIHtcbiAgdmFyIGEgPSBsLnRvQXJyYXkoKTtcbiAgaWYgKGMpIHtcbiAgICBBcnJheXMuc29ydChhLCBjKTtcbiAgfSBlbHNlIHtcbiAgICBBcnJheXMuc29ydChhKTtcbiAgfVxuICB2YXIgaSA9IGwuaXRlcmF0b3IoKTtcbiAgZm9yICh2YXIgcG9zID0gMCwgYWxlbiA9IGEubGVuZ3RoOyBwb3MgPCBhbGVuOyBwb3MrKykge1xuICAgIGkubmV4dCgpO1xuICAgIGkuc2V0KGFbcG9zXSk7XG4gIH1cbn07XG5Db2xsZWN0aW9ucy5zaW5nbGV0b25MaXN0ID0gZnVuY3Rpb24gc2luZ2xldG9uTGlzdCAobykge1xuICB2YXIgYXJyYXlMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBhcnJheUxpc3QuYWRkKG8pO1xuICByZXR1cm4gYXJyYXlMaXN0XG59O1xuXG52YXIgQm91bmRhYmxlUGFpciA9IGZ1bmN0aW9uIEJvdW5kYWJsZVBhaXIgKCkge1xuICB0aGlzLl9ib3VuZGFibGUxID0gbnVsbDtcbiAgdGhpcy5fYm91bmRhYmxlMiA9IG51bGw7XG4gIHRoaXMuX2Rpc3RhbmNlID0gbnVsbDtcbiAgdGhpcy5faXRlbURpc3RhbmNlID0gbnVsbDtcbiAgdmFyIGJvdW5kYWJsZTEgPSBhcmd1bWVudHNbMF07XG4gIHZhciBib3VuZGFibGUyID0gYXJndW1lbnRzWzFdO1xuICB2YXIgaXRlbURpc3RhbmNlID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9ib3VuZGFibGUxID0gYm91bmRhYmxlMTtcbiAgdGhpcy5fYm91bmRhYmxlMiA9IGJvdW5kYWJsZTI7XG4gIHRoaXMuX2l0ZW1EaXN0YW5jZSA9IGl0ZW1EaXN0YW5jZTtcbiAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLmRpc3RhbmNlKCk7XG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuZXhwYW5kVG9RdWV1ZSA9IGZ1bmN0aW9uIGV4cGFuZFRvUXVldWUgKHByaVEsIG1pbkRpc3RhbmNlKSB7XG4gIHZhciBpc0NvbXAxID0gQm91bmRhYmxlUGFpci5pc0NvbXBvc2l0ZSh0aGlzLl9ib3VuZGFibGUxKTtcbiAgdmFyIGlzQ29tcDIgPSBCb3VuZGFibGVQYWlyLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTIpO1xuICBpZiAoaXNDb21wMSAmJiBpc0NvbXAyKSB7XG4gICAgaWYgKEJvdW5kYWJsZVBhaXIuYXJlYSh0aGlzLl9ib3VuZGFibGUxKSA+IEJvdW5kYWJsZVBhaXIuYXJlYSh0aGlzLl9ib3VuZGFibGUyKSkge1xuICAgICAgdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMSwgdGhpcy5fYm91bmRhYmxlMiwgcHJpUSwgbWluRGlzdGFuY2UpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5leHBhbmQodGhpcy5fYm91bmRhYmxlMiwgdGhpcy5fYm91bmRhYmxlMSwgcHJpUSwgbWluRGlzdGFuY2UpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNDb21wMSkge1xuICAgIHRoaXMuZXhwYW5kKHRoaXMuX2JvdW5kYWJsZTEsIHRoaXMuX2JvdW5kYWJsZTIsIHByaVEsIG1pbkRpc3RhbmNlKTtcbiAgICByZXR1cm4gbnVsbFxuICB9IGVsc2UgaWYgKGlzQ29tcDIpIHtcbiAgICB0aGlzLmV4cGFuZCh0aGlzLl9ib3VuZGFibGUyLCB0aGlzLl9ib3VuZGFibGUxLCBwcmlRLCBtaW5EaXN0YW5jZSk7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCduZWl0aGVyIGJvdW5kYWJsZSBpcyBjb21wb3NpdGUnKVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmlzTGVhdmVzID0gZnVuY3Rpb24gaXNMZWF2ZXMgKCkge1xuICByZXR1cm4gIShCb3VuZGFibGVQYWlyLmlzQ29tcG9zaXRlKHRoaXMuX2JvdW5kYWJsZTEpIHx8IEJvdW5kYWJsZVBhaXIuaXNDb21wb3NpdGUodGhpcy5fYm91bmRhYmxlMikpXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBuZCA9IG87XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8IG5kLl9kaXN0YW5jZSkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5fZGlzdGFuY2UgPiBuZC5fZGlzdGFuY2UpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmV4cGFuZCA9IGZ1bmN0aW9uIGV4cGFuZCAoYm5kQ29tcG9zaXRlLCBibmRPdGhlciwgcHJpUSwgbWluRGlzdGFuY2UpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY2hpbGRyZW4gPSBibmRDb21wb3NpdGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCk7XG4gIGZvciAodmFyIGkgPSBjaGlsZHJlbi5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgY2hpbGQgPSBpLm5leHQoKTtcbiAgICB2YXIgYnAgPSBuZXcgQm91bmRhYmxlUGFpcihjaGlsZCwgYm5kT3RoZXIsIHRoaXMkMS5faXRlbURpc3RhbmNlKTtcbiAgICBpZiAoYnAuZ2V0RGlzdGFuY2UoKSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICBwcmlRLmFkZChicCk7XG4gICAgfVxuICB9XG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuZ2V0Qm91bmRhYmxlID0gZnVuY3Rpb24gZ2V0Qm91bmRhYmxlIChpKSB7XG4gIGlmIChpID09PSAwKSB7IHJldHVybiB0aGlzLl9ib3VuZGFibGUxIH1cbiAgcmV0dXJuIHRoaXMuX2JvdW5kYWJsZTJcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Rpc3RhbmNlXG59O1xuQm91bmRhYmxlUGFpci5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoKSB7XG4gIGlmICh0aGlzLmlzTGVhdmVzKCkpIHtcbiAgICByZXR1cm4gdGhpcy5faXRlbURpc3RhbmNlLmRpc3RhbmNlKHRoaXMuX2JvdW5kYWJsZTEsIHRoaXMuX2JvdW5kYWJsZTIpXG4gIH1cbiAgcmV0dXJuIHRoaXMuX2JvdW5kYWJsZTEuZ2V0Qm91bmRzKCkuZGlzdGFuY2UodGhpcy5fYm91bmRhYmxlMi5nZXRCb3VuZHMoKSlcbn07XG5Cb3VuZGFibGVQYWlyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbkJvdW5kYWJsZVBhaXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQm91bmRhYmxlUGFpclxufTtcbkJvdW5kYWJsZVBhaXIuYXJlYSA9IGZ1bmN0aW9uIGFyZWEgKGIpIHtcbiAgcmV0dXJuIGIuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpXG59O1xuQm91bmRhYmxlUGFpci5pc0NvbXBvc2l0ZSA9IGZ1bmN0aW9uIGlzQ29tcG9zaXRlIChpdGVtKSB7XG4gIHJldHVybiBpdGVtIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlXG59O1xuXG52YXIgQWJzdHJhY3RTVFJ0cmVlID0gZnVuY3Rpb24gQWJzdHJhY3RTVFJ0cmVlICgpIHtcbiAgdGhpcy5fcm9vdCA9IG51bGw7XG4gIHRoaXMuX2J1aWx0ID0gZmFsc2U7XG4gIHRoaXMuX2l0ZW1Cb3VuZGFibGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9ub2RlQ2FwYWNpdHkgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBub2RlQ2FwYWNpdHkgPSBBYnN0cmFjdFNUUnRyZWUuREVGQVVMVF9OT0RFX0NBUEFDSVRZO1xuICAgIHRoaXMuX25vZGVDYXBhY2l0eSA9IG5vZGVDYXBhY2l0eTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIG5vZGVDYXBhY2l0eSQxID0gYXJndW1lbnRzWzBdO1xuICAgIEFzc2VydC5pc1RydWUobm9kZUNhcGFjaXR5JDEgPiAxLCAnTm9kZSBjYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgdGhpcy5fbm9kZUNhcGFjaXR5ID0gbm9kZUNhcGFjaXR5JDE7XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjMgPSB7IEludGVyc2VjdHNPcDogeyBjb25maWd1cmFibGU6IHRydWUgfSxzZXJpYWxWZXJzaW9uVUlEOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFRkFVTFRfTk9ERV9DQVBBQ0lUWTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5nZXROb2RlQ2FwYWNpdHkgPSBmdW5jdGlvbiBnZXROb2RlQ2FwYWNpdHkgKCkge1xuICByZXR1cm4gdGhpcy5fbm9kZUNhcGFjaXR5XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5sYXN0Tm9kZSA9IGZ1bmN0aW9uIGxhc3ROb2RlIChub2Rlcykge1xuICByZXR1cm4gbm9kZXMuZ2V0KG5vZGVzLnNpemUoKSAtIDEpXG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gc2l6ZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIHRoaXMuYnVpbGQoKTtcbiAgICByZXR1cm4gdGhpcy5zaXplKHRoaXMuX3Jvb3QpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBub2RlID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzaXplID0gMDtcbiAgICBmb3IgKHZhciBpID0gbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgICAgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgIHNpemUgKz0gdGhpcyQxLnNpemUoY2hpbGRCb3VuZGFibGUpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEl0ZW1Cb3VuZGFibGUpIHtcbiAgICAgICAgc2l6ZSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZVxuICB9XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5yZW1vdmVJdGVtID0gZnVuY3Rpb24gcmVtb3ZlSXRlbSAobm9kZSwgaXRlbSkge1xuICB2YXIgY2hpbGRUb1JlbW92ZSA9IG51bGw7XG4gIGZvciAodmFyIGkgPSBub2RlLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEl0ZW1Cb3VuZGFibGUpIHtcbiAgICAgIGlmIChjaGlsZEJvdW5kYWJsZS5nZXRJdGVtKCkgPT09IGl0ZW0pIHsgY2hpbGRUb1JlbW92ZSA9IGNoaWxkQm91bmRhYmxlOyB9XG4gICAgfVxuICB9XG4gIGlmIChjaGlsZFRvUmVtb3ZlICE9PSBudWxsKSB7XG4gICAgbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUoY2hpbGRUb1JlbW92ZSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLml0ZW1zVHJlZSA9IGZ1bmN0aW9uIGl0ZW1zVHJlZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgdmFyIHZhbHVlc1RyZWUgPSB0aGlzLml0ZW1zVHJlZSh0aGlzLl9yb290KTtcbiAgICBpZiAodmFsdWVzVHJlZSA9PT0gbnVsbCkgeyByZXR1cm4gbmV3IEFycmF5TGlzdCgpIH1cbiAgICByZXR1cm4gdmFsdWVzVHJlZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgdmFsdWVzVHJlZUZvck5vZGUgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICB2YXIgdmFsdWVzVHJlZUZvckNoaWxkID0gdGhpcyQxLml0ZW1zVHJlZShjaGlsZEJvdW5kYWJsZSk7XG4gICAgICAgIGlmICh2YWx1ZXNUcmVlRm9yQ2hpbGQgIT09IG51bGwpIHsgdmFsdWVzVHJlZUZvck5vZGUuYWRkKHZhbHVlc1RyZWVGb3JDaGlsZCk7IH1cbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKSB7XG4gICAgICAgIHZhbHVlc1RyZWVGb3JOb2RlLmFkZChjaGlsZEJvdW5kYWJsZS5nZXRJdGVtKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZXNUcmVlRm9yTm9kZS5zaXplKCkgPD0gMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgcmV0dXJuIHZhbHVlc1RyZWVGb3JOb2RlXG4gIH1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoYm91bmRzLCBpdGVtKSB7XG4gIEFzc2VydC5pc1RydWUoIXRoaXMuX2J1aWx0LCAnQ2Fubm90IGluc2VydCBpdGVtcyBpbnRvIGFuIFNUUiBwYWNrZWQgUi10cmVlIGFmdGVyIGl0IGhhcyBiZWVuIGJ1aWx0LicpO1xuICB0aGlzLl9pdGVtQm91bmRhYmxlcy5hZGQobmV3IEl0ZW1Cb3VuZGFibGUoYm91bmRzLCBpdGVtKSk7XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5ib3VuZGFibGVzQXRMZXZlbCA9IGZ1bmN0aW9uIGJvdW5kYWJsZXNBdExldmVsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsZXZlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgYm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLmJvdW5kYWJsZXNBdExldmVsKGxldmVsLCB0aGlzLl9yb290LCBib3VuZGFibGVzKTtcbiAgICByZXR1cm4gYm91bmRhYmxlc1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgbGV2ZWwkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgdG9wID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBib3VuZGFibGVzJDEgPSBhcmd1bWVudHNbMl07XG4gICAgQXNzZXJ0LmlzVHJ1ZShsZXZlbCQxID4gLTIpO1xuICAgIGlmICh0b3AuZ2V0TGV2ZWwoKSA9PT0gbGV2ZWwkMSkge1xuICAgICAgYm91bmRhYmxlcyQxLmFkZCh0b3ApO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IHRvcC5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBib3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgIGlmIChib3VuZGFibGUgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgdGhpcyQxLmJvdW5kYWJsZXNBdExldmVsKGxldmVsJDEsIGJvdW5kYWJsZSwgYm91bmRhYmxlcyQxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEFzc2VydC5pc1RydWUoYm91bmRhYmxlIGluc3RhbmNlb2YgSXRlbUJvdW5kYWJsZSk7XG4gICAgICAgIGlmIChsZXZlbCQxID09PSAtMSkge1xuICAgICAgICAgIGJvdW5kYWJsZXMkMS5hZGQoYm91bmRhYmxlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uIHF1ZXJ5ICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzZWFyY2hCb3VuZHMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5idWlsZCgpO1xuICAgIHZhciBtYXRjaGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXNcbiAgICB9XG4gICAgaWYgKHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLl9yb290LmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMpKSB7XG4gICAgICB0aGlzLnF1ZXJ5KHNlYXJjaEJvdW5kcywgdGhpcy5fcm9vdCwgbWF0Y2hlcyk7XG4gICAgfVxuICAgIHJldHVybiBtYXRjaGVzXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBzZWFyY2hCb3VuZHMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgdmlzaXRvciA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBpZiAodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMuX3Jvb3QuZ2V0Qm91bmRzKCksIHNlYXJjaEJvdW5kcyQxKSkge1xuICAgICAgdGhpcy5xdWVyeShzZWFyY2hCb3VuZHMkMSwgdGhpcy5fcm9vdCwgdmlzaXRvcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1syXSwgSXRlbVZpc2l0b3IpICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBPYmplY3QgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSkge1xuICAgICAgdmFyIHNlYXJjaEJvdW5kcyQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIG5vZGUgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgdmlzaXRvciQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlcyA9IG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkQm91bmRhYmxlcy5zaXplKCk7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBjaGlsZEJvdW5kYWJsZXMuZ2V0KGkpO1xuICAgICAgICBpZiAoIXRoaXMkMS5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGNoaWxkQm91bmRhYmxlLmdldEJvdW5kcygpLCBzZWFyY2hCb3VuZHMkMikpIHtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICAgIHRoaXMkMS5xdWVyeShzZWFyY2hCb3VuZHMkMiwgY2hpbGRCb3VuZGFibGUsIHZpc2l0b3IkMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRCb3VuZGFibGUgaW5zdGFuY2VvZiBJdGVtQm91bmRhYmxlKSB7XG4gICAgICAgICAgdmlzaXRvciQxLnZpc2l0SXRlbShjaGlsZEJvdW5kYWJsZS5nZXRJdGVtKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzJdLCBMaXN0KSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkpIHtcbiAgICAgIHZhciBzZWFyY2hCb3VuZHMkMyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBub2RlJDEgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgbWF0Y2hlcyQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGNoaWxkQm91bmRhYmxlcyQxID0gbm9kZSQxLmdldENoaWxkQm91bmRhYmxlcygpO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRCb3VuZGFibGVzJDEuc2l6ZSgpOyBpJDErKykge1xuICAgICAgICB2YXIgY2hpbGRCb3VuZGFibGUkMSA9IGNoaWxkQm91bmRhYmxlcyQxLmdldChpJDEpO1xuICAgICAgICBpZiAoIXRoaXMkMS5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKGNoaWxkQm91bmRhYmxlJDEuZ2V0Qm91bmRzKCksIHNlYXJjaEJvdW5kcyQzKSkge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkQm91bmRhYmxlJDEgaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpIHtcbiAgICAgICAgICB0aGlzJDEucXVlcnkoc2VhcmNoQm91bmRzJDMsIGNoaWxkQm91bmRhYmxlJDEsIG1hdGNoZXMkMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hpbGRCb3VuZGFibGUkMSBpbnN0YW5jZW9mIEl0ZW1Cb3VuZGFibGUpIHtcbiAgICAgICAgICBtYXRjaGVzJDEuYWRkKGNoaWxkQm91bmRhYmxlJDEuZ2V0SXRlbSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBBc3NlcnQuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiBidWlsZCAoKSB7XG4gIGlmICh0aGlzLl9idWlsdCkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuX3Jvb3QgPSB0aGlzLl9pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCkgPyB0aGlzLmNyZWF0ZU5vZGUoMCkgOiB0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyh0aGlzLl9pdGVtQm91bmRhYmxlcywgLTEpO1xuICB0aGlzLl9pdGVtQm91bmRhYmxlcyA9IG51bGw7XG4gIHRoaXMuX2J1aWx0ID0gdHJ1ZTtcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmdldFJvb3QgPSBmdW5jdGlvbiBnZXRSb290ICgpIHtcbiAgdGhpcy5idWlsZCgpO1xuICByZXR1cm4gdGhpcy5fcm9vdFxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBzZWFyY2hCb3VuZHMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5idWlsZCgpO1xuICAgIGlmICh0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5fcm9vdC5nZXRCb3VuZHMoKSwgc2VhcmNoQm91bmRzKSkge1xuICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlKHNlYXJjaEJvdW5kcywgdGhpcy5fcm9vdCwgaXRlbSlcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBzZWFyY2hCb3VuZHMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaXRlbSQxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBmb3VuZCA9IHRoaXMucmVtb3ZlSXRlbShub2RlLCBpdGVtJDEpO1xuICAgIGlmIChmb3VuZCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgdmFyIGNoaWxkVG9QcnVuZSA9IG51bGw7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgIGlmICghdGhpcyQxLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMoY2hpbGRCb3VuZGFibGUuZ2V0Qm91bmRzKCksIHNlYXJjaEJvdW5kcyQxKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkQm91bmRhYmxlIGluc3RhbmNlb2YgQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgIGZvdW5kID0gdGhpcyQxLnJlbW92ZShzZWFyY2hCb3VuZHMkMSwgY2hpbGRCb3VuZGFibGUsIGl0ZW0kMSk7XG4gICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgIGNoaWxkVG9QcnVuZSA9IGNoaWxkQm91bmRhYmxlO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoaWxkVG9QcnVuZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkVG9QcnVuZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pc0VtcHR5KCkpIHtcbiAgICAgICAgbm9kZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5yZW1vdmUoY2hpbGRUb1BydW5lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmNyZWF0ZUhpZ2hlckxldmVscyA9IGZ1bmN0aW9uIGNyZWF0ZUhpZ2hlckxldmVscyAoYm91bmRhYmxlc09mQUxldmVsLCBsZXZlbCkge1xuICBBc3NlcnQuaXNUcnVlKCFib3VuZGFibGVzT2ZBTGV2ZWwuaXNFbXB0eSgpKTtcbiAgdmFyIHBhcmVudEJvdW5kYWJsZXMgPSB0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXMoYm91bmRhYmxlc09mQUxldmVsLCBsZXZlbCArIDEpO1xuICBpZiAocGFyZW50Qm91bmRhYmxlcy5zaXplKCkgPT09IDEpIHtcbiAgICByZXR1cm4gcGFyZW50Qm91bmRhYmxlcy5nZXQoMClcbiAgfVxuICByZXR1cm4gdGhpcy5jcmVhdGVIaWdoZXJMZXZlbHMocGFyZW50Qm91bmRhYmxlcywgbGV2ZWwgKyAxKVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuZGVwdGggPSBmdW5jdGlvbiBkZXB0aCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICAgIHRoaXMuYnVpbGQoKTtcbiAgICByZXR1cm4gdGhpcy5kZXB0aCh0aGlzLl9yb290KVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbm9kZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbWF4Q2hpbGREZXB0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IG5vZGUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgY2hpbGRCb3VuZGFibGUgPSBpLm5leHQoKTtcbiAgICAgIGlmIChjaGlsZEJvdW5kYWJsZSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkge1xuICAgICAgICB2YXIgY2hpbGREZXB0aCA9IHRoaXMkMS5kZXB0aChjaGlsZEJvdW5kYWJsZSk7XG4gICAgICAgIGlmIChjaGlsZERlcHRoID4gbWF4Q2hpbGREZXB0aCkgeyBtYXhDaGlsZERlcHRoID0gY2hpbGREZXB0aDsgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF4Q2hpbGREZXB0aCArIDFcbiAgfVxufTtcbkFic3RyYWN0U1RSdHJlZS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlcyA9IGZ1bmN0aW9uIGNyZWF0ZVBhcmVudEJvdW5kYWJsZXMgKGNoaWxkQm91bmRhYmxlcywgbmV3TGV2ZWwpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBBc3NlcnQuaXNUcnVlKCFjaGlsZEJvdW5kYWJsZXMuaXNFbXB0eSgpKTtcbiAgdmFyIHBhcmVudEJvdW5kYWJsZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHBhcmVudEJvdW5kYWJsZXMuYWRkKHRoaXMuY3JlYXRlTm9kZShuZXdMZXZlbCkpO1xuICB2YXIgc29ydGVkQ2hpbGRCb3VuZGFibGVzID0gbmV3IEFycmF5TGlzdChjaGlsZEJvdW5kYWJsZXMpO1xuICBDb2xsZWN0aW9ucy5zb3J0KHNvcnRlZENoaWxkQm91bmRhYmxlcywgdGhpcy5nZXRDb21wYXJhdG9yKCkpO1xuICBmb3IgKHZhciBpID0gc29ydGVkQ2hpbGRCb3VuZGFibGVzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgIGlmICh0aGlzJDEubGFzdE5vZGUocGFyZW50Qm91bmRhYmxlcykuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuc2l6ZSgpID09PSB0aGlzJDEuZ2V0Tm9kZUNhcGFjaXR5KCkpIHtcbiAgICAgIHBhcmVudEJvdW5kYWJsZXMuYWRkKHRoaXMkMS5jcmVhdGVOb2RlKG5ld0xldmVsKSk7XG4gICAgfVxuICAgIHRoaXMkMS5sYXN0Tm9kZShwYXJlbnRCb3VuZGFibGVzKS5hZGRDaGlsZEJvdW5kYWJsZShjaGlsZEJvdW5kYWJsZSk7XG4gIH1cbiAgcmV0dXJuIHBhcmVudEJvdW5kYWJsZXNcbn07XG5BYnN0cmFjdFNUUnRyZWUucHJvdG90eXBlLmlzRW1wdHkgPSBmdW5jdGlvbiBpc0VtcHR5ICgpIHtcbiAgaWYgKCF0aGlzLl9idWlsdCkgeyByZXR1cm4gdGhpcy5faXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpIH1cbiAgcmV0dXJuIHRoaXMuX3Jvb3QuaXNFbXB0eSgpXG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZXJpYWxpemFibGVdXG59O1xuQWJzdHJhY3RTVFJ0cmVlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZVxufTtcbkFic3RyYWN0U1RSdHJlZS5jb21wYXJlRG91YmxlcyA9IGZ1bmN0aW9uIGNvbXBhcmVEb3VibGVzIChhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMFxufTtcbnN0YXRpY0FjY2Vzc29ycyQyMy5JbnRlcnNlY3RzT3AuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gSW50ZXJzZWN0c09wIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjMuc2VyaWFsVmVyc2lvblVJRC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAtMzg4NjQzNTgxNDM2MDI0MTMzNyB9O1xuc3RhdGljQWNjZXNzb3JzJDIzLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxMCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQWJzdHJhY3RTVFJ0cmVlLCBzdGF0aWNBY2Nlc3NvcnMkMjMgKTtcblxudmFyIEludGVyc2VjdHNPcCA9IGZ1bmN0aW9uIEludGVyc2VjdHNPcCAoKSB7fTtcblxudmFyIEl0ZW1EaXN0YW5jZSA9IGZ1bmN0aW9uIEl0ZW1EaXN0YW5jZSAoKSB7fTtcblxuSXRlbURpc3RhbmNlLnByb3RvdHlwZS5kaXN0YW5jZSA9IGZ1bmN0aW9uIGRpc3RhbmNlIChpdGVtMSwgaXRlbTIpIHt9O1xuSXRlbURpc3RhbmNlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuSXRlbURpc3RhbmNlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEl0ZW1EaXN0YW5jZVxufTtcblxudmFyIFNUUnRyZWUgPSAoZnVuY3Rpb24gKEFic3RyYWN0U1RSdHJlZSQkMSkge1xuICBmdW5jdGlvbiBTVFJ0cmVlIChub2RlQ2FwYWNpdHkpIHtcbiAgICBub2RlQ2FwYWNpdHkgPSBub2RlQ2FwYWNpdHkgfHwgU1RSdHJlZS5ERUZBVUxUX05PREVfQ0FQQUNJVFk7XG4gICAgQWJzdHJhY3RTVFJ0cmVlJCQxLmNhbGwodGhpcywgbm9kZUNhcGFjaXR5KTtcbiAgfVxuXG4gIGlmICggQWJzdHJhY3RTVFJ0cmVlJCQxICkgU1RSdHJlZS5fX3Byb3RvX18gPSBBYnN0cmFjdFNUUnRyZWUkJDE7XG4gIFNUUnRyZWUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggQWJzdHJhY3RTVFJ0cmVlJCQxICYmIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUgKTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVFJ0cmVlO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IFNUUnRyZWVOb2RlOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LHNlcmlhbFZlcnNpb25VSUQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0seENvbXBhcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0seUNvbXBhcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0saW50ZXJzZWN0c09wOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFRkFVTFRfTk9ERV9DQVBBQ0lUWTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzID0gZnVuY3Rpb24gY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlcyAodmVydGljYWxTbGljZXMsIG5ld0xldmVsKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBBc3NlcnQuaXNUcnVlKHZlcnRpY2FsU2xpY2VzLmxlbmd0aCA+IDApO1xuICAgIHZhciBwYXJlbnRCb3VuZGFibGVzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljYWxTbGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHBhcmVudEJvdW5kYWJsZXMuYWRkQWxsKHRoaXMkMS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodmVydGljYWxTbGljZXNbaV0sIG5ld0xldmVsKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRCb3VuZGFibGVzXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOb2RlIChsZXZlbCkge1xuICAgIHJldHVybiBuZXcgU1RSdHJlZU5vZGUobGV2ZWwpXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUuc2l6ZS5jYWxsKHRoaXMpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUuc2l6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0ICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGl0ZW1FbnYgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChpdGVtRW52LmlzTnVsbCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLmluc2VydC5jYWxsKHRoaXMsIGl0ZW1FbnYsIGl0ZW0pO1xuICAgIH0gZWxzZSB7IHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLmluc2VydC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0c09wID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0c09wICgpIHtcbiAgICByZXR1cm4gU1RSdHJlZS5pbnRlcnNlY3RzT3BcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUudmVydGljYWxTbGljZXMgPSBmdW5jdGlvbiB2ZXJ0aWNhbFNsaWNlcyAoY2hpbGRCb3VuZGFibGVzLCBzbGljZUNvdW50KSB7XG4gICAgdmFyIHNsaWNlQ2FwYWNpdHkgPSBNYXRoLnRydW5jKE1hdGguY2VpbChjaGlsZEJvdW5kYWJsZXMuc2l6ZSgpIC8gc2xpY2VDb3VudCkpO1xuICAgIHZhciBzbGljZXMgPSBuZXcgQXJyYXkoc2xpY2VDb3VudCkuZmlsbChudWxsKTtcbiAgICB2YXIgaSA9IGNoaWxkQm91bmRhYmxlcy5pdGVyYXRvcigpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2xpY2VDb3VudDsgaisrKSB7XG4gICAgICBzbGljZXNbal0gPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgICB2YXIgYm91bmRhYmxlc0FkZGVkVG9TbGljZSA9IDA7XG4gICAgICB3aGlsZSAoaS5oYXNOZXh0KCkgJiYgYm91bmRhYmxlc0FkZGVkVG9TbGljZSA8IHNsaWNlQ2FwYWNpdHkpIHtcbiAgICAgICAgdmFyIGNoaWxkQm91bmRhYmxlID0gaS5uZXh0KCk7XG4gICAgICAgIHNsaWNlc1tqXS5hZGQoY2hpbGRCb3VuZGFibGUpO1xuICAgICAgICBib3VuZGFibGVzQWRkZWRUb1NsaWNlKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbGljZXNcbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiBxdWVyeSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBzZWFyY2hFbnYgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIHNlYXJjaEVudilcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBzZWFyY2hFbnYkMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciB2aXNpdG9yID0gYXJndW1lbnRzWzFdO1xuICAgICAgQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIHNlYXJjaEVudiQxLCB2aXNpdG9yKTtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzJdLCBJdGVtVmlzaXRvcikgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIE9iamVjdCAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBBYnN0cmFjdE5vZGUpKSB7XG4gICAgICAgIHZhciBzZWFyY2hCb3VuZHMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBub2RlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdmlzaXRvciQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcywgc2VhcmNoQm91bmRzLCBub2RlLCB2aXNpdG9yJDEpO1xuICAgICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzJdLCBMaXN0KSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgT2JqZWN0ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIEFic3RyYWN0Tm9kZSkpIHtcbiAgICAgICAgdmFyIHNlYXJjaEJvdW5kcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgbm9kZSQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsIHNlYXJjaEJvdW5kcyQxLCBub2RlJDEsIG1hdGNoZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU1RSdHJlZS5wcm90b3R5cGUuZ2V0Q29tcGFyYXRvciA9IGZ1bmN0aW9uIGdldENvbXBhcmF0b3IgKCkge1xuICAgIHJldHVybiBTVFJ0cmVlLnlDb21wYXJhdG9yXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSA9IGZ1bmN0aW9uIGNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZSAoY2hpbGRCb3VuZGFibGVzLCBuZXdMZXZlbCkge1xuICAgIHJldHVybiBBYnN0cmFjdFNUUnRyZWUkJDEucHJvdG90eXBlLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXMuY2FsbCh0aGlzLCBjaGlsZEJvdW5kYWJsZXMsIG5ld0xldmVsKVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgaXRlbUVudiA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBpdGVtID0gYXJndW1lbnRzWzFdO1xuICAgICAgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgaXRlbUVudiwgaXRlbSlcbiAgICB9IGVsc2UgeyByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5yZW1vdmUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmRlcHRoID0gZnVuY3Rpb24gZGVwdGggKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLnByb3RvdHlwZS5kZXB0aC5jYWxsKHRoaXMpXG4gICAgfSBlbHNlIHsgcmV0dXJuIEFic3RyYWN0U1RSdHJlZSQkMS5wcm90b3R5cGUuZGVwdGguYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXMgPSBmdW5jdGlvbiBjcmVhdGVQYXJlbnRCb3VuZGFibGVzIChjaGlsZEJvdW5kYWJsZXMsIG5ld0xldmVsKSB7XG4gICAgQXNzZXJ0LmlzVHJ1ZSghY2hpbGRCb3VuZGFibGVzLmlzRW1wdHkoKSk7XG4gICAgdmFyIG1pbkxlYWZDb3VudCA9IE1hdGgudHJ1bmMoTWF0aC5jZWlsKGNoaWxkQm91bmRhYmxlcy5zaXplKCkgLyB0aGlzLmdldE5vZGVDYXBhY2l0eSgpKSk7XG4gICAgdmFyIHNvcnRlZENoaWxkQm91bmRhYmxlcyA9IG5ldyBBcnJheUxpc3QoY2hpbGRCb3VuZGFibGVzKTtcbiAgICBDb2xsZWN0aW9ucy5zb3J0KHNvcnRlZENoaWxkQm91bmRhYmxlcywgU1RSdHJlZS54Q29tcGFyYXRvcik7XG4gICAgdmFyIHZlcnRpY2FsU2xpY2VzID0gdGhpcy52ZXJ0aWNhbFNsaWNlcyhzb3J0ZWRDaGlsZEJvdW5kYWJsZXMsIE1hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGguc3FydChtaW5MZWFmQ291bnQpKSkpO1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXModmVydGljYWxTbGljZXMsIG5ld0xldmVsKVxuICB9O1xuICBTVFJ0cmVlLnByb3RvdHlwZS5uZWFyZXN0TmVpZ2hib3VyID0gZnVuY3Rpb24gbmVhcmVzdE5laWdoYm91ciAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBJdGVtRGlzdGFuY2UpKSB7XG4gICAgICAgIHZhciBpdGVtRGlzdCA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgdmFyIGJwID0gbmV3IEJvdW5kYWJsZVBhaXIodGhpcy5nZXRSb290KCksIHRoaXMuZ2V0Um9vdCgpLCBpdGVtRGlzdCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoYnApXG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEJvdW5kYWJsZVBhaXIpIHtcbiAgICAgICAgdmFyIGluaXRCbmRQYWlyID0gYXJndW1lbnRzWzBdO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGluaXRCbmRQYWlyLCBEb3VibGUuUE9TSVRJVkVfSU5GSU5JVFkpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgU1RSdHJlZSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBJdGVtRGlzdGFuY2UpKSB7XG4gICAgICAgIHZhciB0cmVlID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgaXRlbURpc3QkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGJwJDEgPSBuZXcgQm91bmRhYmxlUGFpcih0aGlzLmdldFJvb3QoKSwgdHJlZS5nZXRSb290KCksIGl0ZW1EaXN0JDEpO1xuICAgICAgICByZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGJwJDEpXG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEJvdW5kYWJsZVBhaXIgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGluaXRCbmRQYWlyJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBtYXhEaXN0YW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGRpc3RhbmNlTG93ZXJCb3VuZCA9IG1heERpc3RhbmNlO1xuICAgICAgICB2YXIgbWluUGFpciA9IG51bGw7XG4gICAgICAgIHZhciBwcmlRID0gbmV3IFByaW9yaXR5UXVldWUoKTtcbiAgICAgICAgcHJpUS5hZGQoaW5pdEJuZFBhaXIkMSk7XG4gICAgICAgIHdoaWxlICghcHJpUS5pc0VtcHR5KCkgJiYgZGlzdGFuY2VMb3dlckJvdW5kID4gMC4wKSB7XG4gICAgICAgICAgdmFyIGJuZFBhaXIgPSBwcmlRLnBvbGwoKTtcbiAgICAgICAgICB2YXIgY3VycmVudERpc3RhbmNlID0gYm5kUGFpci5nZXREaXN0YW5jZSgpO1xuICAgICAgICAgIGlmIChjdXJyZW50RGlzdGFuY2UgPj0gZGlzdGFuY2VMb3dlckJvdW5kKSB7IGJyZWFrIH1cbiAgICAgICAgICBpZiAoYm5kUGFpci5pc0xlYXZlcygpKSB7XG4gICAgICAgICAgICBkaXN0YW5jZUxvd2VyQm91bmQgPSBjdXJyZW50RGlzdGFuY2U7XG4gICAgICAgICAgICBtaW5QYWlyID0gYm5kUGFpcjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYm5kUGFpci5leHBhbmRUb1F1ZXVlKHByaVEsIGRpc3RhbmNlTG93ZXJCb3VuZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbWluUGFpci5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLCBtaW5QYWlyLmdldEJvdW5kYWJsZSgxKS5nZXRJdGVtKCldXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB2YXIgZW52ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGl0ZW0gPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgaXRlbURpc3QkMiA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBibmQgPSBuZXcgSXRlbUJvdW5kYWJsZShlbnYsIGl0ZW0pO1xuICAgICAgdmFyIGJwJDIgPSBuZXcgQm91bmRhYmxlUGFpcih0aGlzLmdldFJvb3QoKSwgYm5kLCBpdGVtRGlzdCQyKTtcbiAgICAgIHJldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoYnAkMilbMF1cbiAgICB9XG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbU3BhdGlhbEluZGV4LCBTZXJpYWxpemFibGVdXG4gIH07XG4gIFNUUnRyZWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBTVFJ0cmVlXG4gIH07XG4gIFNUUnRyZWUuY2VudHJlWCA9IGZ1bmN0aW9uIGNlbnRyZVggKGUpIHtcbiAgICByZXR1cm4gU1RSdHJlZS5hdmcoZS5nZXRNaW5YKCksIGUuZ2V0TWF4WCgpKVxuICB9O1xuICBTVFJ0cmVlLmF2ZyA9IGZ1bmN0aW9uIGF2ZyAoYSwgYikge1xuICAgIHJldHVybiAoYSArIGIpIC8gMlxuICB9O1xuICBTVFJ0cmVlLmNlbnRyZVkgPSBmdW5jdGlvbiBjZW50cmVZIChlKSB7XG4gICAgcmV0dXJuIFNUUnRyZWUuYXZnKGUuZ2V0TWluWSgpLCBlLmdldE1heFkoKSlcbiAgfTtcbiAgc3RhdGljQWNjZXNzb3JzLlNUUnRyZWVOb2RlLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFNUUnRyZWVOb2RlIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDI1OTI3NDcwMjM2ODk1NjkwMCB9O1xuICBzdGF0aWNBY2Nlc3NvcnMueENvbXBhcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnRlcmZhY2VzXzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW0NvbXBhcmF0b3JdXG4gICAgICB9LFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24gKG8xLCBvMikge1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLmNvbXBhcmVEb3VibGVzKFNUUnRyZWUuY2VudHJlWChvMS5nZXRCb3VuZHMoKSksIFNUUnRyZWUuY2VudHJlWChvMi5nZXRCb3VuZHMoKSkpXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMueUNvbXBhcmF0b3IuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpbnRlcmZhY2VzXzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW0NvbXBhcmF0b3JdXG4gICAgICB9LFxuICAgICAgY29tcGFyZTogZnVuY3Rpb24gKG8xLCBvMikge1xuICAgICAgICByZXR1cm4gQWJzdHJhY3RTVFJ0cmVlJCQxLmNvbXBhcmVEb3VibGVzKFNUUnRyZWUuY2VudHJlWShvMS5nZXRCb3VuZHMoKSksIFNUUnRyZWUuY2VudHJlWShvMi5nZXRCb3VuZHMoKSkpXG4gICAgICB9XG4gICAgfVxuICB9O1xuICBzdGF0aWNBY2Nlc3NvcnMuaW50ZXJzZWN0c09wLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaW50ZXJmYWNlc186IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtBYnN0cmFjdFNUUnRyZWUkJDEuSW50ZXJzZWN0c09wXVxuICAgICAgfSxcbiAgICAgIGludGVyc2VjdHM6IGZ1bmN0aW9uIChhQm91bmRzLCBiQm91bmRzKSB7XG4gICAgICAgIHJldHVybiBhQm91bmRzLmludGVyc2VjdHMoYkJvdW5kcylcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5ERUZBVUxUX05PREVfQ0FQQUNJVFkuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMTAgfTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggU1RSdHJlZSwgc3RhdGljQWNjZXNzb3JzICk7XG5cbiAgcmV0dXJuIFNUUnRyZWU7XG59KEFic3RyYWN0U1RSdHJlZSkpO1xuXG52YXIgU1RSdHJlZU5vZGUgPSAoZnVuY3Rpb24gKEFic3RyYWN0Tm9kZSQkMSkge1xuICBmdW5jdGlvbiBTVFJ0cmVlTm9kZSAoKSB7XG4gICAgdmFyIGxldmVsID0gYXJndW1lbnRzWzBdO1xuICAgIEFic3RyYWN0Tm9kZSQkMS5jYWxsKHRoaXMsIGxldmVsKTtcbiAgfVxuXG4gIGlmICggQWJzdHJhY3ROb2RlJCQxICkgU1RSdHJlZU5vZGUuX19wcm90b19fID0gQWJzdHJhY3ROb2RlJCQxO1xuICBTVFJ0cmVlTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBBYnN0cmFjdE5vZGUkJDEgJiYgQWJzdHJhY3ROb2RlJCQxLnByb3RvdHlwZSApO1xuICBTVFJ0cmVlTm9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTVFJ0cmVlTm9kZTtcbiAgU1RSdHJlZU5vZGUucHJvdG90eXBlLmNvbXB1dGVCb3VuZHMgPSBmdW5jdGlvbiBjb21wdXRlQm91bmRzICgpIHtcbiAgICB2YXIgYm91bmRzID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBjaGlsZEJvdW5kYWJsZSA9IGkubmV4dCgpO1xuICAgICAgaWYgKGJvdW5kcyA9PT0gbnVsbCkge1xuICAgICAgICBib3VuZHMgPSBuZXcgRW52ZWxvcGUoY2hpbGRCb3VuZGFibGUuZ2V0Qm91bmRzKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm91bmRzLmV4cGFuZFRvSW5jbHVkZShjaGlsZEJvdW5kYWJsZS5nZXRCb3VuZHMoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBib3VuZHNcbiAgfTtcbiAgU1RSdHJlZU5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBTVFJ0cmVlTm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIFNUUnRyZWVOb2RlXG4gIH07XG5cbiAgcmV0dXJuIFNUUnRyZWVOb2RlO1xufShBYnN0cmFjdE5vZGUpKTtcblxudmFyIFNlZ21lbnRQb2ludENvbXBhcmF0b3IgPSBmdW5jdGlvbiBTZWdtZW50UG9pbnRDb21wYXJhdG9yICgpIHt9O1xuXG5TZWdtZW50UG9pbnRDb21wYXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU2VnbWVudFBvaW50Q29tcGFyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yXG59O1xuU2VnbWVudFBvaW50Q29tcGFyYXRvci5yZWxhdGl2ZVNpZ24gPSBmdW5jdGlvbiByZWxhdGl2ZVNpZ24gKHgwLCB4MSkge1xuICBpZiAoeDAgPCB4MSkgeyByZXR1cm4gLTEgfVxuICBpZiAoeDAgPiB4MSkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAob2N0YW50LCBwMCwgcDEpIHtcbiAgaWYgKHAwLmVxdWFsczJEKHAxKSkgeyByZXR1cm4gMCB9XG4gIHZhciB4U2lnbiA9IFNlZ21lbnRQb2ludENvbXBhcmF0b3IucmVsYXRpdmVTaWduKHAwLngsIHAxLngpO1xuICB2YXIgeVNpZ24gPSBTZWdtZW50UG9pbnRDb21wYXJhdG9yLnJlbGF0aXZlU2lnbihwMC55LCBwMS55KTtcbiAgc3dpdGNoIChvY3RhbnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoeFNpZ24sIHlTaWduKVxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSh5U2lnbiwgeFNpZ24pXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKHlTaWduLCAteFNpZ24pXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKC14U2lnbiwgeVNpZ24pXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuIFNlZ21lbnRQb2ludENvbXBhcmF0b3IuY29tcGFyZVZhbHVlKC14U2lnbiwgLXlTaWduKVxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiBTZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSgteVNpZ24sIC14U2lnbilcbiAgICBjYXNlIDY6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoLXlTaWduLCB4U2lnbilcbiAgICBjYXNlIDc6XG4gICAgICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlVmFsdWUoeFNpZ24sIC15U2lnbilcbiAgICBkZWZhdWx0OlxuICB9XG4gIEFzc2VydC5zaG91bGROZXZlclJlYWNoSGVyZSgnaW52YWxpZCBvY3RhbnQgdmFsdWUnKTtcbiAgcmV0dXJuIDBcbn07XG5TZWdtZW50UG9pbnRDb21wYXJhdG9yLmNvbXBhcmVWYWx1ZSA9IGZ1bmN0aW9uIGNvbXBhcmVWYWx1ZSAoY29tcGFyZVNpZ24wLCBjb21wYXJlU2lnbjEpIHtcbiAgaWYgKGNvbXBhcmVTaWduMCA8IDApIHsgcmV0dXJuIC0xIH1cbiAgaWYgKGNvbXBhcmVTaWduMCA+IDApIHsgcmV0dXJuIDEgfVxuICBpZiAoY29tcGFyZVNpZ24xIDwgMCkgeyByZXR1cm4gLTEgfVxuICBpZiAoY29tcGFyZVNpZ24xID4gMCkgeyByZXR1cm4gMSB9XG4gIHJldHVybiAwXG59O1xuXG52YXIgU2VnbWVudE5vZGUgPSBmdW5jdGlvbiBTZWdtZW50Tm9kZSAoKSB7XG4gIHRoaXMuX3NlZ1N0cmluZyA9IG51bGw7XG4gIHRoaXMuY29vcmQgPSBudWxsO1xuICB0aGlzLnNlZ21lbnRJbmRleCA9IG51bGw7XG4gIHRoaXMuX3NlZ21lbnRPY3RhbnQgPSBudWxsO1xuICB0aGlzLl9pc0ludGVyaW9yID0gbnVsbDtcbiAgdmFyIHNlZ1N0cmluZyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzFdO1xuICB2YXIgc2VnbWVudEluZGV4ID0gYXJndW1lbnRzWzJdO1xuICB2YXIgc2VnbWVudE9jdGFudCA9IGFyZ3VtZW50c1szXTtcbiAgdGhpcy5fc2VnU3RyaW5nID0gc2VnU3RyaW5nO1xuICB0aGlzLmNvb3JkID0gbmV3IENvb3JkaW5hdGUoY29vcmQpO1xuICB0aGlzLnNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleDtcbiAgdGhpcy5fc2VnbWVudE9jdGFudCA9IHNlZ21lbnRPY3RhbnQ7XG4gIHRoaXMuX2lzSW50ZXJpb3IgPSAhY29vcmQuZXF1YWxzMkQoc2VnU3RyaW5nLmdldENvb3JkaW5hdGUoc2VnbWVudEluZGV4KSk7XG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlICgpIHtcbiAgcmV0dXJuIHRoaXMuY29vcmRcbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gIG91dC5wcmludCh0aGlzLmNvb3JkKTtcbiAgb3V0LnByaW50KCcgc2VnICMgPSAnICsgdGhpcy5zZWdtZW50SW5kZXgpO1xufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG9iaikge1xuICB2YXIgb3RoZXIgPSBvYmo7XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA8IG90aGVyLnNlZ21lbnRJbmRleCkgeyByZXR1cm4gLTEgfVxuICBpZiAodGhpcy5zZWdtZW50SW5kZXggPiBvdGhlci5zZWdtZW50SW5kZXgpIHsgcmV0dXJuIDEgfVxuICBpZiAodGhpcy5jb29yZC5lcXVhbHMyRChvdGhlci5jb29yZCkpIHsgcmV0dXJuIDAgfVxuICByZXR1cm4gU2VnbWVudFBvaW50Q29tcGFyYXRvci5jb21wYXJlKHRoaXMuX3NlZ21lbnRPY3RhbnQsIHRoaXMuY29vcmQsIG90aGVyLmNvb3JkKVxufTtcblNlZ21lbnROb2RlLnByb3RvdHlwZS5pc0VuZFBvaW50ID0gZnVuY3Rpb24gaXNFbmRQb2ludCAobWF4U2VnbWVudEluZGV4KSB7XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA9PT0gMCAmJiAhdGhpcy5faXNJbnRlcmlvcikgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA9PT0gbWF4U2VnbWVudEluZGV4KSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuU2VnbWVudE5vZGUucHJvdG90eXBlLmlzSW50ZXJpb3IgPSBmdW5jdGlvbiBpc0ludGVyaW9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lzSW50ZXJpb3Jcbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5TZWdtZW50Tm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50Tm9kZVxufTtcblxuLy8gaW1wb3J0IEl0ZXJhdG9yIGZyb20gJy4uLy4uLy4uLy4uL2phdmEvdXRpbC9JdGVyYXRvcidcbnZhciBTZWdtZW50Tm9kZUxpc3QgPSBmdW5jdGlvbiBTZWdtZW50Tm9kZUxpc3QgKCkge1xuICB0aGlzLl9ub2RlTWFwID0gbmV3IFRyZWVNYXAoKTtcbiAgdGhpcy5fZWRnZSA9IG51bGw7XG4gIHZhciBlZGdlID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLl9lZGdlID0gZWRnZTtcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmdldFNwbGl0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRTcGxpdENvb3JkaW5hdGVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29vcmRMaXN0ID0gbmV3IENvb3JkaW5hdGVMaXN0KCk7XG4gIHRoaXMuYWRkRW5kcG9pbnRzKCk7XG4gIHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgdmFyIGVpUHJldiA9IGl0Lm5leHQoKTtcbiAgd2hpbGUgKGl0Lmhhc05leHQoKSkge1xuICAgIHZhciBlaSA9IGl0Lm5leHQoKTtcbiAgICB0aGlzJDEuYWRkRWRnZUNvb3JkaW5hdGVzKGVpUHJldiwgZWksIGNvb3JkTGlzdCk7XG4gICAgZWlQcmV2ID0gZWk7XG4gIH1cbiAgcmV0dXJuIGNvb3JkTGlzdC50b0Nvb3JkaW5hdGVBcnJheSgpXG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5hZGRDb2xsYXBzZWROb2RlcyA9IGZ1bmN0aW9uIGFkZENvbGxhcHNlZE5vZGVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgY29sbGFwc2VkVmVydGV4SW5kZXhlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXMoY29sbGFwc2VkVmVydGV4SW5kZXhlcyk7XG4gIHRoaXMuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKGNvbGxhcHNlZFZlcnRleEluZGV4ZXMpO1xuICBmb3IgKHZhciBpdCA9IGNvbGxhcHNlZFZlcnRleEluZGV4ZXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciB2ZXJ0ZXhJbmRleCA9IGl0Lm5leHQoKS5pbnRWYWx1ZSgpO1xuICAgIHRoaXMkMS5hZGQodGhpcyQxLl9lZGdlLmdldENvb3JkaW5hdGUodmVydGV4SW5kZXgpLCB2ZXJ0ZXhJbmRleCk7XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICBvdXQucHJpbnRsbignSW50ZXJzZWN0aW9uczonKTtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgZWkucHJpbnQob3V0KTtcbiAgfVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzID0gZnVuY3Rpb24gZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzIChjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lZGdlLnNpemUoKSAtIDI7IGkrKykge1xuICAgIHZhciBwMCA9IHRoaXMkMS5fZWRnZS5nZXRDb29yZGluYXRlKGkpO1xuICAgIC8vIGNvbnN0IHAxID0gdGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGkgKyAxKVxuICAgIHZhciBwMiA9IHRoaXMkMS5fZWRnZS5nZXRDb29yZGluYXRlKGkgKyAyKTtcbiAgICBpZiAocDAuZXF1YWxzMkQocDIpKSB7XG4gICAgICBjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzLmFkZChuZXcgSW50ZWdlcihpICsgMSkpO1xuICAgIH1cbiAgfVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuYWRkRWRnZUNvb3JkaW5hdGVzID0gZnVuY3Rpb24gYWRkRWRnZUNvb3JkaW5hdGVzIChlaTAsIGVpMSwgY29vcmRMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgLy8gbGV0IG5wdHMgPSBlaTEuc2VnbWVudEluZGV4IC0gZWkwLnNlZ21lbnRJbmRleCArIDJcbiAgdmFyIGxhc3RTZWdTdGFydFB0ID0gdGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKGVpMS5zZWdtZW50SW5kZXgpO1xuICB2YXIgdXNlSW50UHQxID0gZWkxLmlzSW50ZXJpb3IoKSB8fCAhZWkxLmNvb3JkLmVxdWFsczJEKGxhc3RTZWdTdGFydFB0KTtcbiAgLy8gaWYgKCF1c2VJbnRQdDEpIHtcbiAgLy8gbnB0cy0tXG4gIC8vIH1cbiAgLy8gY29uc3QgaXB0ID0gMFxuICBjb29yZExpc3QuYWRkKG5ldyBDb29yZGluYXRlKGVpMC5jb29yZCksIGZhbHNlKTtcbiAgZm9yICh2YXIgaSA9IGVpMC5zZWdtZW50SW5kZXggKyAxOyBpIDw9IGVpMS5zZWdtZW50SW5kZXg7IGkrKykge1xuICAgIGNvb3JkTGlzdC5hZGQodGhpcyQxLl9lZGdlLmdldENvb3JkaW5hdGUoaSkpO1xuICB9XG4gIGlmICh1c2VJbnRQdDEpIHtcbiAgICBjb29yZExpc3QuYWRkKG5ldyBDb29yZGluYXRlKGVpMS5jb29yZCkpO1xuICB9XG59O1xuU2VnbWVudE5vZGVMaXN0LnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuYWRkU3BsaXRFZGdlcyA9IGZ1bmN0aW9uIGFkZFNwbGl0RWRnZXMgKGVkZ2VMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdGhpcy5hZGRFbmRwb2ludHMoKTtcbiAgdGhpcy5hZGRDb2xsYXBzZWROb2RlcygpO1xuICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gIHZhciBlaVByZXYgPSBpdC5uZXh0KCk7XG4gIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgdmFyIG5ld0VkZ2UgPSB0aGlzJDEuY3JlYXRlU3BsaXRFZGdlKGVpUHJldiwgZWkpO1xuICAgIGVkZ2VMaXN0LmFkZChuZXdFZGdlKTtcbiAgICBlaVByZXYgPSBlaTtcbiAgfVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuZmluZENvbGxhcHNlSW5kZXggPSBmdW5jdGlvbiBmaW5kQ29sbGFwc2VJbmRleCAoZWkwLCBlaTEsIGNvbGxhcHNlZFZlcnRleEluZGV4KSB7XG4gIGlmICghZWkwLmNvb3JkLmVxdWFsczJEKGVpMS5jb29yZCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIG51bVZlcnRpY2VzQmV0d2VlbiA9IGVpMS5zZWdtZW50SW5kZXggLSBlaTAuc2VnbWVudEluZGV4O1xuICBpZiAoIWVpMS5pc0ludGVyaW9yKCkpIHtcbiAgICBudW1WZXJ0aWNlc0JldHdlZW4tLTtcbiAgfVxuICBpZiAobnVtVmVydGljZXNCZXR3ZWVuID09PSAxKSB7XG4gICAgY29sbGFwc2VkVmVydGV4SW5kZXhbMF0gPSBlaTAuc2VnbWVudEluZGV4ICsgMTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzID0gZnVuY3Rpb24gZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzIChjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvbGxhcHNlZFZlcnRleEluZGV4ID0gbmV3IEFycmF5KDEpLmZpbGwobnVsbCk7XG4gIHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgdmFyIGVpUHJldiA9IGl0Lm5leHQoKTtcbiAgd2hpbGUgKGl0Lmhhc05leHQoKSkge1xuICAgIHZhciBlaSA9IGl0Lm5leHQoKTtcbiAgICB2YXIgaXNDb2xsYXBzZWQgPSB0aGlzJDEuZmluZENvbGxhcHNlSW5kZXgoZWlQcmV2LCBlaSwgY29sbGFwc2VkVmVydGV4SW5kZXgpO1xuICAgIGlmIChpc0NvbGxhcHNlZCkgeyBjb2xsYXBzZWRWZXJ0ZXhJbmRleGVzLmFkZChuZXcgSW50ZWdlcihjb2xsYXBzZWRWZXJ0ZXhJbmRleFswXSkpOyB9XG4gICAgZWlQcmV2ID0gZWk7XG4gIH1cbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmdldEVkZ2UgPSBmdW5jdGlvbiBnZXRFZGdlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2Vcbn07XG5TZWdtZW50Tm9kZUxpc3QucHJvdG90eXBlLmFkZEVuZHBvaW50cyA9IGZ1bmN0aW9uIGFkZEVuZHBvaW50cyAoKSB7XG4gIHZhciBtYXhTZWdJbmRleCA9IHRoaXMuX2VkZ2Uuc2l6ZSgpIC0gMTtcbiAgdGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKDApLCAwKTtcbiAgdGhpcy5hZGQodGhpcy5fZWRnZS5nZXRDb29yZGluYXRlKG1heFNlZ0luZGV4KSwgbWF4U2VnSW5kZXgpO1xufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuY3JlYXRlU3BsaXRFZGdlID0gZnVuY3Rpb24gY3JlYXRlU3BsaXRFZGdlIChlaTAsIGVpMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBucHRzID0gZWkxLnNlZ21lbnRJbmRleCAtIGVpMC5zZWdtZW50SW5kZXggKyAyO1xuICB2YXIgbGFzdFNlZ1N0YXJ0UHQgPSB0aGlzLl9lZGdlLmdldENvb3JkaW5hdGUoZWkxLnNlZ21lbnRJbmRleCk7XG4gIHZhciB1c2VJbnRQdDEgPSBlaTEuaXNJbnRlcmlvcigpIHx8ICFlaTEuY29vcmQuZXF1YWxzMkQobGFzdFNlZ1N0YXJ0UHQpO1xuICBpZiAoIXVzZUludFB0MSkge1xuICAgIG5wdHMtLTtcbiAgfVxuICB2YXIgcHRzID0gbmV3IEFycmF5KG5wdHMpLmZpbGwobnVsbCk7XG4gIHZhciBpcHQgPSAwO1xuICBwdHNbaXB0KytdID0gbmV3IENvb3JkaW5hdGUoZWkwLmNvb3JkKTtcbiAgZm9yICh2YXIgaSA9IGVpMC5zZWdtZW50SW5kZXggKyAxOyBpIDw9IGVpMS5zZWdtZW50SW5kZXg7IGkrKykge1xuICAgIHB0c1tpcHQrK10gPSB0aGlzJDEuX2VkZ2UuZ2V0Q29vcmRpbmF0ZShpKTtcbiAgfVxuICBpZiAodXNlSW50UHQxKSB7IHB0c1tpcHRdID0gbmV3IENvb3JkaW5hdGUoZWkxLmNvb3JkKTsgfVxuICByZXR1cm4gbmV3IE5vZGVkU2VnbWVudFN0cmluZyhwdHMsIHRoaXMuX2VkZ2UuZ2V0RGF0YSgpKVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChpbnRQdCwgc2VnbWVudEluZGV4KSB7XG4gIHZhciBlaU5ldyA9IG5ldyBTZWdtZW50Tm9kZSh0aGlzLl9lZGdlLCBpbnRQdCwgc2VnbWVudEluZGV4LCB0aGlzLl9lZGdlLmdldFNlZ21lbnRPY3RhbnQoc2VnbWVudEluZGV4KSk7XG4gIHZhciBlaSA9IHRoaXMuX25vZGVNYXAuZ2V0KGVpTmV3KTtcbiAgaWYgKGVpICE9PSBudWxsKSB7XG4gICAgQXNzZXJ0LmlzVHJ1ZShlaS5jb29yZC5lcXVhbHMyRChpbnRQdCksICdGb3VuZCBlcXVhbCBub2RlcyB3aXRoIGRpZmZlcmVudCBjb29yZGluYXRlcycpO1xuICAgIHJldHVybiBlaVxuICB9XG4gIHRoaXMuX25vZGVNYXAucHV0KGVpTmV3LCBlaU5ldyk7XG4gIHJldHVybiBlaU5ld1xufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuY2hlY2tTcGxpdEVkZ2VzQ29ycmVjdG5lc3MgPSBmdW5jdGlvbiBjaGVja1NwbGl0RWRnZXNDb3JyZWN0bmVzcyAoc3BsaXRFZGdlcykge1xuICB2YXIgZWRnZVB0cyA9IHRoaXMuX2VkZ2UuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgdmFyIHNwbGl0MCA9IHNwbGl0RWRnZXMuZ2V0KDApO1xuICB2YXIgcHQwID0gc3BsaXQwLmdldENvb3JkaW5hdGUoMCk7XG4gIGlmICghcHQwLmVxdWFsczJEKGVkZ2VQdHNbMF0pKSB7IHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKCdiYWQgc3BsaXQgZWRnZSBzdGFydCBwb2ludCBhdCAnICsgcHQwKSB9XG4gIHZhciBzcGxpdG4gPSBzcGxpdEVkZ2VzLmdldChzcGxpdEVkZ2VzLnNpemUoKSAtIDEpO1xuICB2YXIgc3BsaXRuUHRzID0gc3BsaXRuLmdldENvb3JkaW5hdGVzKCk7XG4gIHZhciBwdG4gPSBzcGxpdG5QdHNbc3BsaXRuUHRzLmxlbmd0aCAtIDFdO1xuICBpZiAoIXB0bi5lcXVhbHMyRChlZGdlUHRzW2VkZ2VQdHMubGVuZ3RoIC0gMV0pKSB7IHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKCdiYWQgc3BsaXQgZWRnZSBlbmQgcG9pbnQgYXQgJyArIHB0bikgfVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNlZ21lbnROb2RlTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50Tm9kZUxpc3Rcbn07XG5cblxuXG4vLyBjbGFzcyBOb2RlVmVydGV4SXRlcmF0b3Ige1xuLy8gICBjb25zdHJ1Y3RvciAoKSB7XG4vLyAgICAgdGhpcy5fbm9kZUxpc3QgPSBudWxsXG4vLyAgICAgdGhpcy5fZWRnZSA9IG51bGxcbi8vICAgICB0aGlzLl9ub2RlSXQgPSBudWxsXG4vLyAgICAgdGhpcy5fY3Vyck5vZGUgPSBudWxsXG4vLyAgICAgdGhpcy5fbmV4dE5vZGUgPSBudWxsXG4vLyAgICAgdGhpcy5fY3VyclNlZ0luZGV4ID0gMFxuLy8gICAgIGxldCBub2RlTGlzdCA9IGFyZ3VtZW50c1swXVxuLy8gICAgIHRoaXMuX25vZGVMaXN0ID0gbm9kZUxpc3Rcbi8vICAgICB0aGlzLl9lZGdlID0gbm9kZUxpc3QuZ2V0RWRnZSgpXG4vLyAgICAgdGhpcy5fbm9kZUl0ID0gbm9kZUxpc3QuaXRlcmF0b3IoKVxuLy8gICAgIHRoaXMucmVhZE5leHROb2RlKClcbi8vICAgfVxuLy8gICBuZXh0ICgpIHtcbi8vICAgICBpZiAodGhpcy5fY3Vyck5vZGUgPT09IG51bGwpIHtcbi8vICAgICAgIHRoaXMuX2N1cnJOb2RlID0gdGhpcy5fbmV4dE5vZGVcbi8vICAgICAgIHRoaXMuX2N1cnJTZWdJbmRleCA9IHRoaXMuX2N1cnJOb2RlLnNlZ21lbnRJbmRleFxuLy8gICAgICAgdGhpcy5yZWFkTmV4dE5vZGUoKVxuLy8gICAgICAgcmV0dXJuIHRoaXMuX2N1cnJOb2RlXG4vLyAgICAgfVxuLy8gICAgIGlmICh0aGlzLl9uZXh0Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIG51bGxcbi8vICAgICBpZiAodGhpcy5fbmV4dE5vZGUuc2VnbWVudEluZGV4ID09PSB0aGlzLl9jdXJyTm9kZS5zZWdtZW50SW5kZXgpIHtcbi8vICAgICAgIHRoaXMuX2N1cnJOb2RlID0gdGhpcy5fbmV4dE5vZGVcbi8vICAgICAgIHRoaXMuX2N1cnJTZWdJbmRleCA9IHRoaXMuX2N1cnJOb2RlLnNlZ21lbnRJbmRleFxuLy8gICAgICAgdGhpcy5yZWFkTmV4dE5vZGUoKVxuLy8gICAgICAgcmV0dXJuIHRoaXMuX2N1cnJOb2RlXG4vLyAgICAgfVxuLy8gICAgIGlmICh0aGlzLl9uZXh0Tm9kZS5zZWdtZW50SW5kZXggPiB0aGlzLl9jdXJyTm9kZS5zZWdtZW50SW5kZXgpIHt9XG4vLyAgICAgcmV0dXJuIG51bGxcbi8vICAgfVxuLy8gICByZW1vdmUgKCkge1xuLy8gICAgIC8vIHRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKVxuLy8gICB9XG4vLyAgIGhhc05leHQgKCkge1xuLy8gICAgIGlmICh0aGlzLl9uZXh0Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlXG4vLyAgICAgcmV0dXJuIHRydWVcbi8vICAgfVxuLy8gICByZWFkTmV4dE5vZGUgKCkge1xuLy8gICAgIGlmICh0aGlzLl9ub2RlSXQuaGFzTmV4dCgpKSB0aGlzLl9uZXh0Tm9kZSA9IHRoaXMuX25vZGVJdC5uZXh0KCk7IGVsc2UgdGhpcy5fbmV4dE5vZGUgPSBudWxsXG4vLyAgIH1cbi8vICAgaW50ZXJmYWNlc18gKCkge1xuLy8gICAgIHJldHVybiBbSXRlcmF0b3JdXG4vLyAgIH1cbi8vICAgZ2V0Q2xhc3MgKCkge1xuLy8gICAgIHJldHVybiBOb2RlVmVydGV4SXRlcmF0b3Jcbi8vICAgfVxuLy8gfVxuXG52YXIgT2N0YW50ID0gZnVuY3Rpb24gT2N0YW50ICgpIHt9O1xuXG5PY3RhbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PY3RhbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT2N0YW50XG59O1xuT2N0YW50Lm9jdGFudCA9IGZ1bmN0aW9uIG9jdGFudCAoKSB7XG4gIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgIHZhciBkeCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZHkgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKGR4ID09PSAwLjAgJiYgZHkgPT09IDAuMCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciBwb2ludCAoICcgKyBkeCArICcsICcgKyBkeSArICcgKScpIH1cbiAgICB2YXIgYWR4ID0gTWF0aC5hYnMoZHgpO1xuICAgIHZhciBhZHkgPSBNYXRoLmFicyhkeSk7XG4gICAgaWYgKGR4ID49IDApIHtcbiAgICAgIGlmIChkeSA+PSAwKSB7XG4gICAgICAgIGlmIChhZHggPj0gYWR5KSB7IHJldHVybiAwOyB9IGVsc2UgeyByZXR1cm4gMSB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoYWR4ID49IGFkeSkgeyByZXR1cm4gNzsgfSBlbHNlIHsgcmV0dXJuIDYgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZHkgPj0gMCkge1xuICAgICAgICBpZiAoYWR4ID49IGFkeSkgeyByZXR1cm4gMzsgfSBlbHNlIHsgcmV0dXJuIDIgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGFkeCA+PSBhZHkpIHsgcmV0dXJuIDQ7IH0gZWxzZSB7IHJldHVybiA1IH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZHgkMSA9IHAxLnggLSBwMC54O1xuICAgIHZhciBkeSQxID0gcDEueSAtIHAwLnk7XG4gICAgaWYgKGR4JDEgPT09IDAuMCAmJiBkeSQxID09PSAwLjApIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgJyArIHAwKSB9XG4gICAgcmV0dXJuIE9jdGFudC5vY3RhbnQoZHgkMSwgZHkkMSlcbiAgfVxufTtcblxudmFyIFNlZ21lbnRTdHJpbmcgPSBmdW5jdGlvbiBTZWdtZW50U3RyaW5nICgpIHt9O1xuXG5TZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2l6ZSA9IGZ1bmN0aW9uIHNpemUgKCkge307XG5TZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge307XG5TZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkICgpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uIHNldERhdGEgKGRhdGEpIHt9O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIGdldERhdGEgKCkge307XG5TZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTZWdtZW50U3RyaW5nXG59O1xuXG52YXIgTm9kYWJsZVNlZ21lbnRTdHJpbmcgPSBmdW5jdGlvbiBOb2RhYmxlU2VnbWVudFN0cmluZyAoKSB7fTtcblxuTm9kYWJsZVNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmFkZEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbiAoaW50UHQsIHNlZ21lbnRJbmRleCkge307XG5Ob2RhYmxlU2VnbWVudFN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbU2VnbWVudFN0cmluZ11cbn07XG5Ob2RhYmxlU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOb2RhYmxlU2VnbWVudFN0cmluZ1xufTtcblxudmFyIE5vZGVkU2VnbWVudFN0cmluZyA9IGZ1bmN0aW9uIE5vZGVkU2VnbWVudFN0cmluZyAoKSB7XG4gIHRoaXMuX25vZGVMaXN0ID0gbmV3IFNlZ21lbnROb2RlTGlzdCh0aGlzKTtcbiAgdGhpcy5fcHRzID0gbnVsbDtcbiAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gIHZhciBkYXRhID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl9wdHMgPSBwdHM7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9wdHNcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0cy5sZW5ndGhcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7XG4gIHJldHVybiB0aGlzLl9wdHNbaV1cbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKCkge1xuICByZXR1cm4gdGhpcy5fcHRzWzBdLmVxdWFscyh0aGlzLl9wdHNbdGhpcy5fcHRzLmxlbmd0aCAtIDFdKVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0U2VnbWVudE9jdGFudCA9IGZ1bmN0aW9uIGdldFNlZ21lbnRPY3RhbnQgKGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gdGhpcy5fcHRzLmxlbmd0aCAtIDEpIHsgcmV0dXJuIC0xIH1cbiAgcmV0dXJuIHRoaXMuc2FmZU9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUoaW5kZXgpLCB0aGlzLmdldENvb3JkaW5hdGUoaW5kZXggKyAxKSlcbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiBzZXREYXRhIChkYXRhKSB7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuc2FmZU9jdGFudCA9IGZ1bmN0aW9uIHNhZmVPY3RhbnQgKHAwLCBwMSkge1xuICBpZiAocDAuZXF1YWxzMkQocDEpKSB7IHJldHVybiAwIH1cbiAgcmV0dXJuIE9jdGFudC5vY3RhbnQocDAsIHAxKVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0RGF0YSA9IGZ1bmN0aW9uIGdldERhdGEgKCkge1xuICByZXR1cm4gdGhpcy5fZGF0YVxufTtcbk5vZGVkU2VnbWVudFN0cmluZy5wcm90b3R5cGUuYWRkSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gYWRkSW50ZXJzZWN0aW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgaW50UHQkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuYWRkSW50ZXJzZWN0aW9uTm9kZShpbnRQdCQxLCBzZWdtZW50SW5kZXgpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgbGkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNlZ21lbnRJbmRleCQxID0gYXJndW1lbnRzWzFdO1xuICAgIC8vIGNvbnN0IGdlb21JbmRleCA9IGFyZ3VtZW50c1syXVxuICAgIHZhciBpbnRJbmRleCA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgaW50UHQgPSBuZXcgQ29vcmRpbmF0ZShsaS5nZXRJbnRlcnNlY3Rpb24oaW50SW5kZXgpKTtcbiAgICB0aGlzLmFkZEludGVyc2VjdGlvbihpbnRQdCwgc2VnbWVudEluZGV4JDEpO1xuICB9XG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIFdLVFdyaXRlci50b0xpbmVTdHJpbmcobmV3IENvb3JkaW5hdGVBcnJheVNlcXVlbmNlKHRoaXMuX3B0cykpXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXROb2RlTGlzdCA9IGZ1bmN0aW9uIGdldE5vZGVMaXN0ICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVMaXN0XG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb25Ob2RlID0gZnVuY3Rpb24gYWRkSW50ZXJzZWN0aW9uTm9kZSAoaW50UHQsIHNlZ21lbnRJbmRleCkge1xuICB2YXIgbm9ybWFsaXplZFNlZ21lbnRJbmRleCA9IHNlZ21lbnRJbmRleDtcbiAgdmFyIG5leHRTZWdJbmRleCA9IG5vcm1hbGl6ZWRTZWdtZW50SW5kZXggKyAxO1xuICBpZiAobmV4dFNlZ0luZGV4IDwgdGhpcy5fcHRzLmxlbmd0aCkge1xuICAgIHZhciBuZXh0UHQgPSB0aGlzLl9wdHNbbmV4dFNlZ0luZGV4XTtcbiAgICBpZiAoaW50UHQuZXF1YWxzMkQobmV4dFB0KSkge1xuICAgICAgbm9ybWFsaXplZFNlZ21lbnRJbmRleCA9IG5leHRTZWdJbmRleDtcbiAgICB9XG4gIH1cbiAgdmFyIGVpID0gdGhpcy5fbm9kZUxpc3QuYWRkKGludFB0LCBub3JtYWxpemVkU2VnbWVudEluZGV4KTtcbiAgcmV0dXJuIGVpXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gYWRkSW50ZXJzZWN0aW9ucyAobGksIHNlZ21lbnRJbmRleCwgZ2VvbUluZGV4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaS5nZXRJbnRlcnNlY3Rpb25OdW0oKTsgaSsrKSB7XG4gICAgdGhpcyQxLmFkZEludGVyc2VjdGlvbihsaSwgc2VnbWVudEluZGV4LCBnZW9tSW5kZXgsIGkpO1xuICB9XG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtOb2RhYmxlU2VnbWVudFN0cmluZ11cbn07XG5Ob2RlZFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kZWRTZWdtZW50U3RyaW5nXG59O1xuTm9kZWRTZWdtZW50U3RyaW5nLmdldE5vZGVkU3Vic3RyaW5ncyA9IGZ1bmN0aW9uIGdldE5vZGVkU3Vic3RyaW5ncyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHNlZ1N0cmluZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHJlc3VsdEVkZ2VsaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIE5vZGVkU2VnbWVudFN0cmluZy5nZXROb2RlZFN1YnN0cmluZ3Moc2VnU3RyaW5ncywgcmVzdWx0RWRnZWxpc3QpO1xuICAgIHJldHVybiByZXN1bHRFZGdlbGlzdFxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgc2VnU3RyaW5ncyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciByZXN1bHRFZGdlbGlzdCQxID0gYXJndW1lbnRzWzFdO1xuICAgIGZvciAodmFyIGkgPSBzZWdTdHJpbmdzJDEuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgc3MgPSBpLm5leHQoKTtcbiAgICAgIHNzLmdldE5vZGVMaXN0KCkuYWRkU3BsaXRFZGdlcyhyZXN1bHRFZGdlbGlzdCQxKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBMaW5lU2VnbWVudCA9IGZ1bmN0aW9uIExpbmVTZWdtZW50ICgpIHtcbiAgdGhpcy5wMCA9IG51bGw7XG4gIHRoaXMucDEgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMucDAgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHRoaXMucDEgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbHMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5wMCA9IG5ldyBDb29yZGluYXRlKGxzLnAwKTtcbiAgICB0aGlzLnAxID0gbmV3IENvb3JkaW5hdGUobHMucDEpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB0aGlzLnAwID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMucDEgPSBhcmd1bWVudHNbMV07XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciB4MCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeTAgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHgxID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciB5MSA9IGFyZ3VtZW50c1szXTtcbiAgICB0aGlzLnAwID0gbmV3IENvb3JkaW5hdGUoeDAsIHkwKTtcbiAgICB0aGlzLnAxID0gbmV3IENvb3JkaW5hdGUoeDEsIHkxKTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyNCA9IHsgc2VyaWFsVmVyc2lvblVJRDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm1pblggPSBmdW5jdGlvbiBtaW5YICgpIHtcbiAgcmV0dXJuIE1hdGgubWluKHRoaXMucDAueCwgdGhpcy5wMS54KVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5vcmllbnRhdGlvbkluZGV4ID0gZnVuY3Rpb24gb3JpZW50YXRpb25JbmRleCAoKSB7XG4gIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU2VnbWVudCkge1xuICAgIHZhciBzZWcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9yaWVudDAgPSBDR0FsZ29yaXRobXMub3JpZW50YXRpb25JbmRleCh0aGlzLnAwLCB0aGlzLnAxLCBzZWcucDApO1xuICAgIHZhciBvcmllbnQxID0gQ0dBbGdvcml0aG1zLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCwgdGhpcy5wMSwgc2VnLnAxKTtcbiAgICBpZiAob3JpZW50MCA+PSAwICYmIG9yaWVudDEgPj0gMCkgeyByZXR1cm4gTWF0aC5tYXgob3JpZW50MCwgb3JpZW50MSkgfVxuICAgIGlmIChvcmllbnQwIDw9IDAgJiYgb3JpZW50MSA8PSAwKSB7IHJldHVybiBNYXRoLm1heChvcmllbnQwLCBvcmllbnQxKSB9XG4gICAgcmV0dXJuIDBcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIENHQWxnb3JpdGhtcy5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsIHRoaXMucDEsIHApXG4gIH1cbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUudG9HZW9tZXRyeSA9IGZ1bmN0aW9uIHRvR2VvbWV0cnkgKGdlb21GYWN0b3J5KSB7XG4gIHJldHVybiBnZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLnAwLCB0aGlzLnAxXSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuaXNWZXJ0aWNhbCA9IGZ1bmN0aW9uIGlzVmVydGljYWwgKCkge1xuICByZXR1cm4gdGhpcy5wMC54ID09PSB0aGlzLnAxLnhcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvKSB7XG4gIGlmICghKG8gaW5zdGFuY2VvZiBMaW5lU2VnbWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgb3RoZXIgPSBvO1xuICByZXR1cm4gdGhpcy5wMC5lcXVhbHMob3RoZXIucDApICYmIHRoaXMucDEuZXF1YWxzKG90aGVyLnAxKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKGxpbmUpIHtcbiAgdmFyIGxpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICBsaS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMucDAsIHRoaXMucDEsIGxpbmUucDAsIGxpbmUucDEpO1xuICBpZiAobGkuaGFzSW50ZXJzZWN0aW9uKCkpIHsgcmV0dXJuIGxpLmdldEludGVyc2VjdGlvbigwKSB9XG4gIHJldHVybiBudWxsXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnByb2plY3QgPSBmdW5jdGlvbiBwcm9qZWN0ICgpIHtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAocC5lcXVhbHModGhpcy5wMCkgfHwgcC5lcXVhbHModGhpcy5wMSkpIHsgcmV0dXJuIG5ldyBDb29yZGluYXRlKHApIH1cbiAgICB2YXIgciA9IHRoaXMucHJvamVjdGlvbkZhY3RvcihwKTtcbiAgICB2YXIgY29vcmQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIGNvb3JkLnggPSB0aGlzLnAwLnggKyByICogKHRoaXMucDEueCAtIHRoaXMucDAueCk7XG4gICAgY29vcmQueSA9IHRoaXMucDAueSArIHIgKiAodGhpcy5wMS55IC0gdGhpcy5wMC55KTtcbiAgICByZXR1cm4gY29vcmRcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU2VnbWVudCkge1xuICAgIHZhciBzZWcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBmMCA9IHRoaXMucHJvamVjdGlvbkZhY3RvcihzZWcucDApO1xuICAgIHZhciBwZjEgPSB0aGlzLnByb2plY3Rpb25GYWN0b3Ioc2VnLnAxKTtcbiAgICBpZiAocGYwID49IDEuMCAmJiBwZjEgPj0gMS4wKSB7IHJldHVybiBudWxsIH1cbiAgICBpZiAocGYwIDw9IDAuMCAmJiBwZjEgPD0gMC4wKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgbmV3cDAgPSB0aGlzLnByb2plY3Qoc2VnLnAwKTtcbiAgICBpZiAocGYwIDwgMC4wKSB7IG5ld3AwID0gdGhpcy5wMDsgfVxuICAgIGlmIChwZjAgPiAxLjApIHsgbmV3cDAgPSB0aGlzLnAxOyB9XG4gICAgdmFyIG5ld3AxID0gdGhpcy5wcm9qZWN0KHNlZy5wMSk7XG4gICAgaWYgKHBmMSA8IDAuMCkgeyBuZXdwMSA9IHRoaXMucDA7IH1cbiAgICBpZiAocGYxID4gMS4wKSB7IG5ld3AxID0gdGhpcy5wMTsgfVxuICAgIHJldHVybiBuZXcgTGluZVNlZ21lbnQobmV3cDAsIG5ld3AxKVxuICB9XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZSAoKSB7XG4gIGlmICh0aGlzLnAxLmNvbXBhcmVUbyh0aGlzLnAwKSA8IDApIHsgdGhpcy5yZXZlcnNlKCk7IH1cbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuYW5nbGUgPSBmdW5jdGlvbiBhbmdsZSAoKSB7XG4gIHJldHVybiBNYXRoLmF0YW4yKHRoaXMucDEueSAtIHRoaXMucDAueSwgdGhpcy5wMS54IC0gdGhpcy5wMC54KVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoaSkge1xuICBpZiAoaSA9PT0gMCkgeyByZXR1cm4gdGhpcy5wMCB9XG4gIHJldHVybiB0aGlzLnAxXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmRpc3RhbmNlUGVycGVuZGljdWxhciA9IGZ1bmN0aW9uIGRpc3RhbmNlUGVycGVuZGljdWxhciAocCkge1xuICByZXR1cm4gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhcihwLCB0aGlzLnAwLCB0aGlzLnAxKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5taW5ZID0gZnVuY3Rpb24gbWluWSAoKSB7XG4gIHJldHVybiBNYXRoLm1pbih0aGlzLnAwLnksIHRoaXMucDEueSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubWlkUG9pbnQgPSBmdW5jdGlvbiBtaWRQb2ludCAoKSB7XG4gIHJldHVybiBMaW5lU2VnbWVudC5taWRQb2ludCh0aGlzLnAwLCB0aGlzLnAxKVxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5wcm9qZWN0aW9uRmFjdG9yID0gZnVuY3Rpb24gcHJvamVjdGlvbkZhY3RvciAocCkge1xuICBpZiAocC5lcXVhbHModGhpcy5wMCkpIHsgcmV0dXJuIDAuMCB9XG4gIGlmIChwLmVxdWFscyh0aGlzLnAxKSkgeyByZXR1cm4gMS4wIH1cbiAgdmFyIGR4ID0gdGhpcy5wMS54IC0gdGhpcy5wMC54O1xuICB2YXIgZHkgPSB0aGlzLnAxLnkgLSB0aGlzLnAwLnk7XG4gIHZhciBsZW4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgaWYgKGxlbiA8PSAwLjApIHsgcmV0dXJuIERvdWJsZS5OYU4gfVxuICB2YXIgciA9ICgocC54IC0gdGhpcy5wMC54KSAqIGR4ICsgKHAueSAtIHRoaXMucDAueSkgKiBkeSkgLyBsZW47XG4gIHJldHVybiByXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmNsb3Nlc3RQb2ludHMgPSBmdW5jdGlvbiBjbG9zZXN0UG9pbnRzIChsaW5lKSB7XG4gIHZhciBpbnRQdCA9IHRoaXMuaW50ZXJzZWN0aW9uKGxpbmUpO1xuICBpZiAoaW50UHQgIT09IG51bGwpIHtcbiAgICByZXR1cm4gW2ludFB0LCBpbnRQdF1cbiAgfVxuICB2YXIgY2xvc2VzdFB0ID0gbmV3IEFycmF5KDIpLmZpbGwobnVsbCk7XG4gIHZhciBtaW5EaXN0YW5jZSA9IERvdWJsZS5NQVhfVkFMVUU7XG4gIHZhciBkaXN0ID0gbnVsbDtcbiAgdmFyIGNsb3NlMDAgPSB0aGlzLmNsb3Nlc3RQb2ludChsaW5lLnAwKTtcbiAgbWluRGlzdGFuY2UgPSBjbG9zZTAwLmRpc3RhbmNlKGxpbmUucDApO1xuICBjbG9zZXN0UHRbMF0gPSBjbG9zZTAwO1xuICBjbG9zZXN0UHRbMV0gPSBsaW5lLnAwO1xuICB2YXIgY2xvc2UwMSA9IHRoaXMuY2xvc2VzdFBvaW50KGxpbmUucDEpO1xuICBkaXN0ID0gY2xvc2UwMS5kaXN0YW5jZShsaW5lLnAxKTtcbiAgaWYgKGRpc3QgPCBtaW5EaXN0YW5jZSkge1xuICAgIG1pbkRpc3RhbmNlID0gZGlzdDtcbiAgICBjbG9zZXN0UHRbMF0gPSBjbG9zZTAxO1xuICAgIGNsb3Nlc3RQdFsxXSA9IGxpbmUucDE7XG4gIH1cbiAgdmFyIGNsb3NlMTAgPSBsaW5lLmNsb3Nlc3RQb2ludCh0aGlzLnAwKTtcbiAgZGlzdCA9IGNsb3NlMTAuZGlzdGFuY2UodGhpcy5wMCk7XG4gIGlmIChkaXN0IDwgbWluRGlzdGFuY2UpIHtcbiAgICBtaW5EaXN0YW5jZSA9IGRpc3Q7XG4gICAgY2xvc2VzdFB0WzBdID0gdGhpcy5wMDtcbiAgICBjbG9zZXN0UHRbMV0gPSBjbG9zZTEwO1xuICB9XG4gIHZhciBjbG9zZTExID0gbGluZS5jbG9zZXN0UG9pbnQodGhpcy5wMSk7XG4gIGRpc3QgPSBjbG9zZTExLmRpc3RhbmNlKHRoaXMucDEpO1xuICBpZiAoZGlzdCA8IG1pbkRpc3RhbmNlKSB7XG4gICAgbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgIGNsb3Nlc3RQdFswXSA9IHRoaXMucDE7XG4gICAgY2xvc2VzdFB0WzFdID0gY2xvc2UxMTtcbiAgfVxuICByZXR1cm4gY2xvc2VzdFB0XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmNsb3Nlc3RQb2ludCA9IGZ1bmN0aW9uIGNsb3Nlc3RQb2ludCAocCkge1xuICB2YXIgZmFjdG9yID0gdGhpcy5wcm9qZWN0aW9uRmFjdG9yKHApO1xuICBpZiAoZmFjdG9yID4gMCAmJiBmYWN0b3IgPCAxKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvamVjdChwKVxuICB9XG4gIHZhciBkaXN0MCA9IHRoaXMucDAuZGlzdGFuY2UocCk7XG4gIHZhciBkaXN0MSA9IHRoaXMucDEuZGlzdGFuY2UocCk7XG4gIGlmIChkaXN0MCA8IGRpc3QxKSB7IHJldHVybiB0aGlzLnAwIH1cbiAgcmV0dXJuIHRoaXMucDFcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUubWF4WCA9IGZ1bmN0aW9uIG1heFggKCkge1xuICByZXR1cm4gTWF0aC5tYXgodGhpcy5wMC54LCB0aGlzLnAxLngpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uIGdldExlbmd0aCAoKSB7XG4gIHJldHVybiB0aGlzLnAwLmRpc3RhbmNlKHRoaXMucDEpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmNvbXBhcmVUbyA9IGZ1bmN0aW9uIGNvbXBhcmVUbyAobykge1xuICB2YXIgb3RoZXIgPSBvO1xuICB2YXIgY29tcDAgPSB0aGlzLnAwLmNvbXBhcmVUbyhvdGhlci5wMCk7XG4gIGlmIChjb21wMCAhPT0gMCkgeyByZXR1cm4gY29tcDAgfVxuICByZXR1cm4gdGhpcy5wMS5jb21wYXJlVG8ob3RoZXIucDEpXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlICgpIHtcbiAgdmFyIHRlbXAgPSB0aGlzLnAwO1xuICB0aGlzLnAwID0gdGhpcy5wMTtcbiAgdGhpcy5wMSA9IHRlbXA7XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmVxdWFsc1RvcG8gPSBmdW5jdGlvbiBlcXVhbHNUb3BvIChvdGhlcikge1xuICByZXR1cm4gdGhpcy5wMC5lcXVhbHMob3RoZXIucDApICYmXG4gICAgICAgICh0aGlzLnAxLmVxdWFscyhvdGhlci5wMSkgfHwgdGhpcy5wMC5lcXVhbHMob3RoZXIucDEpKSAmJlxuICAgICAgICAgdGhpcy5wMS5lcXVhbHMob3RoZXIucDApXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmxpbmVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0aW9uIChsaW5lKSB7XG4gIHRyeSB7XG4gICAgdmFyIGludFB0ID0gSENvb3JkaW5hdGUuaW50ZXJzZWN0aW9uKHRoaXMucDAsIHRoaXMucDEsIGxpbmUucDAsIGxpbmUucDEpO1xuICAgIHJldHVybiBpbnRQdFxuICB9IGNhdGNoIChleCkge1xuICAgIGlmIChleCBpbnN0YW5jZW9mIE5vdFJlcHJlc2VudGFibGVFeGNlcHRpb24pIHt9IGVsc2UgeyB0aHJvdyBleCB9XG4gIH0gZmluYWxseSB7fVxuICByZXR1cm4gbnVsbFxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5tYXhZID0gZnVuY3Rpb24gbWF4WSAoKSB7XG4gIHJldHVybiBNYXRoLm1heCh0aGlzLnAwLnksIHRoaXMucDEueSlcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUucG9pbnRBbG9uZ09mZnNldCA9IGZ1bmN0aW9uIHBvaW50QWxvbmdPZmZzZXQgKHNlZ21lbnRMZW5ndGhGcmFjdGlvbiwgb2Zmc2V0RGlzdGFuY2UpIHtcbiAgdmFyIHNlZ3ggPSB0aGlzLnAwLnggKyBzZWdtZW50TGVuZ3RoRnJhY3Rpb24gKiAodGhpcy5wMS54IC0gdGhpcy5wMC54KTtcbiAgdmFyIHNlZ3kgPSB0aGlzLnAwLnkgKyBzZWdtZW50TGVuZ3RoRnJhY3Rpb24gKiAodGhpcy5wMS55IC0gdGhpcy5wMC55KTtcbiAgdmFyIGR4ID0gdGhpcy5wMS54IC0gdGhpcy5wMC54O1xuICB2YXIgZHkgPSB0aGlzLnAxLnkgLSB0aGlzLnAwLnk7XG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB2YXIgdXggPSAwLjA7XG4gIHZhciB1eSA9IDAuMDtcbiAgaWYgKG9mZnNldERpc3RhbmNlICE9PSAwLjApIHtcbiAgICBpZiAobGVuIDw9IDAuMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudCcpIH1cbiAgICB1eCA9IG9mZnNldERpc3RhbmNlICogZHggLyBsZW47XG4gICAgdXkgPSBvZmZzZXREaXN0YW5jZSAqIGR5IC8gbGVuO1xuICB9XG4gIHZhciBvZmZzZXR4ID0gc2VneCAtIHV5O1xuICB2YXIgb2Zmc2V0eSA9IHNlZ3kgKyB1eDtcbiAgdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUob2Zmc2V0eCwgb2Zmc2V0eSk7XG4gIHJldHVybiBjb29yZFxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5zZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIHNldENvb3JkaW5hdGVzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgbHMgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRDb29yZGluYXRlcyhscy5wMCwgbHMucDEpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMucDAueCA9IHAwLng7XG4gICAgdGhpcy5wMC55ID0gcDAueTtcbiAgICB0aGlzLnAxLnggPSBwMS54O1xuICAgIHRoaXMucDEueSA9IHAxLnk7XG4gIH1cbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuc2VnbWVudEZyYWN0aW9uID0gZnVuY3Rpb24gc2VnbWVudEZyYWN0aW9uIChpbnB1dFB0KSB7XG4gIHZhciBzZWdGcmFjID0gdGhpcy5wcm9qZWN0aW9uRmFjdG9yKGlucHV0UHQpO1xuICBpZiAoc2VnRnJhYyA8IDAuMCkgeyBzZWdGcmFjID0gMC4wOyB9IGVsc2UgaWYgKHNlZ0ZyYWMgPiAxLjAgfHwgRG91YmxlLmlzTmFOKHNlZ0ZyYWMpKSB7IHNlZ0ZyYWMgPSAxLjA7IH1cbiAgcmV0dXJuIHNlZ0ZyYWNcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiAnTElORVNUUklORyggJyArIHRoaXMucDAueCArICcgJyArIHRoaXMucDAueSArICcsICcgKyB0aGlzLnAxLnggKyAnICcgKyB0aGlzLnAxLnkgKyAnKSdcbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuaXNIb3Jpem9udGFsID0gZnVuY3Rpb24gaXNIb3Jpem9udGFsICgpIHtcbiAgcmV0dXJuIHRoaXMucDAueSA9PT0gdGhpcy5wMS55XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVNlZ21lbnQpIHtcbiAgICB2YXIgbHMgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIENHQWxnb3JpdGhtcy5kaXN0YW5jZUxpbmVMaW5lKHRoaXMucDAsIHRoaXMucDEsIGxzLnAwLCBscy5wMSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwLCB0aGlzLnAwLCB0aGlzLnAxKVxuICB9XG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLnBvaW50QWxvbmcgPSBmdW5jdGlvbiBwb2ludEFsb25nIChzZWdtZW50TGVuZ3RoRnJhY3Rpb24pIHtcbiAgdmFyIGNvb3JkID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgY29vcmQueCA9IHRoaXMucDAueCArIHNlZ21lbnRMZW5ndGhGcmFjdGlvbiAqICh0aGlzLnAxLnggLSB0aGlzLnAwLngpO1xuICBjb29yZC55ID0gdGhpcy5wMC55ICsgc2VnbWVudExlbmd0aEZyYWN0aW9uICogKHRoaXMucDEueSAtIHRoaXMucDAueSk7XG4gIHJldHVybiBjb29yZFxufTtcbkxpbmVTZWdtZW50LnByb3RvdHlwZS5oYXNoQ29kZSA9IGZ1bmN0aW9uIGhhc2hDb2RlICgpIHtcbiAgdmFyIGJpdHMwID0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC54KTtcbiAgYml0czAgXj0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC55KSAqIDMxO1xuICB2YXIgaGFzaDAgPSBNYXRoLnRydW5jKGJpdHMwKSBeIE1hdGgudHJ1bmMoYml0czAgPj4gMzIpO1xuICB2YXIgYml0czEgPSBEb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO1xuICBiaXRzMSBePSBEb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLnkpICogMzE7XG4gIHZhciBoYXNoMSA9IE1hdGgudHJ1bmMoYml0czEpIF4gTWF0aC50cnVuYyhiaXRzMSA+PiAzMik7XG4gIHJldHVybiBoYXNoMCBeIGhhc2gxXG59O1xuTGluZVNlZ21lbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGUsIFNlcmlhbGl6YWJsZV1cbn07XG5MaW5lU2VnbWVudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMaW5lU2VnbWVudFxufTtcbkxpbmVTZWdtZW50Lm1pZFBvaW50ID0gZnVuY3Rpb24gbWlkUG9pbnQgKHAwLCBwMSkge1xuICByZXR1cm4gbmV3IENvb3JkaW5hdGUoKHAwLnggKyBwMS54KSAvIDIsIChwMC55ICsgcDEueSkgLyAyKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQyNC5zZXJpYWxWZXJzaW9uVUlELmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDMyNTIwMDU4MzM0NjYyNTYyMjcgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExpbmVTZWdtZW50LCBzdGF0aWNBY2Nlc3NvcnMkMjQgKTtcblxudmFyIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uID0gZnVuY3Rpb24gTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24gKCkge1xuICB0aGlzLnRlbXBFbnYxID0gbmV3IEVudmVsb3BlKCk7XG4gIHRoaXMudGVtcEVudjIgPSBuZXcgRW52ZWxvcGUoKTtcbiAgdGhpcy5fb3ZlcmxhcFNlZzEgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fb3ZlcmxhcFNlZzIgPSBuZXcgTGluZVNlZ21lbnQoKTtcbn07XG5Nb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUub3ZlcmxhcCA9IGZ1bmN0aW9uIG92ZXJsYXAgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIGNvbnN0IHNlZzEgPSBhcmd1bWVudHNbMF1cbiAgICAvLyBjb25zdCBzZWcyID0gYXJndW1lbnRzWzFdXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBtYzEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHN0YXJ0MSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWMyID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBzdGFydDIgPSBhcmd1bWVudHNbM107XG4gICAgbWMxLmdldExpbmVTZWdtZW50KHN0YXJ0MSwgdGhpcy5fb3ZlcmxhcFNlZzEpO1xuICAgIG1jMi5nZXRMaW5lU2VnbWVudChzdGFydDIsIHRoaXMuX292ZXJsYXBTZWcyKTtcbiAgICB0aGlzLm92ZXJsYXAodGhpcy5fb3ZlcmxhcFNlZzEsIHRoaXMuX292ZXJsYXBTZWcyKTtcbiAgfVxufTtcbk1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb25cbn07XG5cbnZhciBNb25vdG9uZUNoYWluID0gZnVuY3Rpb24gTW9ub3RvbmVDaGFpbiAoKSB7XG4gIHRoaXMuX3B0cyA9IG51bGw7XG4gIHRoaXMuX3N0YXJ0ID0gbnVsbDtcbiAgdGhpcy5fZW5kID0gbnVsbDtcbiAgdGhpcy5fZW52ID0gbnVsbDtcbiAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gIHRoaXMuX2lkID0gbnVsbDtcbiAgdmFyIHB0cyA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzWzFdO1xuICB2YXIgZW5kID0gYXJndW1lbnRzWzJdO1xuICB2YXIgY29udGV4dCA9IGFyZ3VtZW50c1szXTtcbiAgdGhpcy5fcHRzID0gcHRzO1xuICB0aGlzLl9zdGFydCA9IHN0YXJ0O1xuICB0aGlzLl9lbmQgPSBlbmQ7XG4gIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldExpbmVTZWdtZW50ID0gZnVuY3Rpb24gZ2V0TGluZVNlZ21lbnQgKGluZGV4LCBscykge1xuICBscy5wMCA9IHRoaXMuX3B0c1tpbmRleF07XG4gIGxzLnAxID0gdGhpcy5fcHRzW2luZGV4ICsgMV07XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuY29tcHV0ZVNlbGVjdCA9IGZ1bmN0aW9uIGNvbXB1dGVTZWxlY3QgKHNlYXJjaEVudiwgc3RhcnQwLCBlbmQwLCBtY3MpIHtcbiAgdmFyIHAwID0gdGhpcy5fcHRzW3N0YXJ0MF07XG4gIHZhciBwMSA9IHRoaXMuX3B0c1tlbmQwXTtcbiAgbWNzLnRlbXBFbnYxLmluaXQocDAsIHAxKTtcbiAgaWYgKGVuZDAgLSBzdGFydDAgPT09IDEpIHtcbiAgICBtY3Muc2VsZWN0KHRoaXMsIHN0YXJ0MCk7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBpZiAoIXNlYXJjaEVudi5pbnRlcnNlY3RzKG1jcy50ZW1wRW52MSkpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgbWlkID0gTWF0aC50cnVuYygoc3RhcnQwICsgZW5kMCkgLyAyKTtcbiAgaWYgKHN0YXJ0MCA8IG1pZCkge1xuICAgIHRoaXMuY29tcHV0ZVNlbGVjdChzZWFyY2hFbnYsIHN0YXJ0MCwgbWlkLCBtY3MpO1xuICB9XG4gIGlmIChtaWQgPCBlbmQwKSB7XG4gICAgdGhpcy5jb21wdXRlU2VsZWN0KHNlYXJjaEVudiwgbWlkLCBlbmQwLCBtY3MpO1xuICB9XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvb3JkID0gbmV3IEFycmF5KHRoaXMuX2VuZCAtIHRoaXMuX3N0YXJ0ICsgMSkuZmlsbChudWxsKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICh2YXIgaSA9IHRoaXMuX3N0YXJ0OyBpIDw9IHRoaXMuX2VuZDsgaSsrKSB7XG4gICAgY29vcmRbaW5kZXgrK10gPSB0aGlzJDEuX3B0c1tpXTtcbiAgfVxuICByZXR1cm4gY29vcmRcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5jb21wdXRlT3ZlcmxhcHMgPSBmdW5jdGlvbiBjb21wdXRlT3ZlcmxhcHMgKG1jLCBtY28pIHtcbiAgdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0aGlzLl9zdGFydCwgdGhpcy5fZW5kLCBtYywgbWMuX3N0YXJ0LCBtYy5fZW5kLCBtY28pO1xufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLnNldElkID0gZnVuY3Rpb24gc2V0SWQgKGlkKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0IChzZWFyY2hFbnYsIG1jcykge1xuICB0aGlzLmNvbXB1dGVTZWxlY3Qoc2VhcmNoRW52LCB0aGlzLl9zdGFydCwgdGhpcy5fZW5kLCBtY3MpO1xufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldEVudmVsb3BlID0gZnVuY3Rpb24gZ2V0RW52ZWxvcGUgKCkge1xuICBpZiAodGhpcy5fZW52ID09PSBudWxsKSB7XG4gICAgdmFyIHAwID0gdGhpcy5fcHRzW3RoaXMuX3N0YXJ0XTtcbiAgICB2YXIgcDEgPSB0aGlzLl9wdHNbdGhpcy5fZW5kXTtcbiAgICB0aGlzLl9lbnYgPSBuZXcgRW52ZWxvcGUocDAsIHAxKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZW52XG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuZ2V0RW5kSW5kZXggPSBmdW5jdGlvbiBnZXRFbmRJbmRleCAoKSB7XG4gIHJldHVybiB0aGlzLl9lbmRcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRTdGFydEluZGV4ID0gZnVuY3Rpb24gZ2V0U3RhcnRJbmRleCAoKSB7XG4gIHJldHVybiB0aGlzLl9zdGFydFxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmdldENvbnRleHQgPSBmdW5jdGlvbiBnZXRDb250ZXh0ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbnRleHRcbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRJZCA9IGZ1bmN0aW9uIGdldElkICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lkXG59O1xuTW9ub3RvbmVDaGFpbi5wcm90b3R5cGUuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwgPSBmdW5jdGlvbiBjb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCAoc3RhcnQwLCBlbmQwLCBtYywgc3RhcnQxLCBlbmQxLCBtY28pIHtcbiAgdmFyIHAwMCA9IHRoaXMuX3B0c1tzdGFydDBdO1xuICB2YXIgcDAxID0gdGhpcy5fcHRzW2VuZDBdO1xuICB2YXIgcDEwID0gbWMuX3B0c1tzdGFydDFdO1xuICB2YXIgcDExID0gbWMuX3B0c1tlbmQxXTtcbiAgaWYgKGVuZDAgLSBzdGFydDAgPT09IDEgJiYgZW5kMSAtIHN0YXJ0MSA9PT0gMSkge1xuICAgIG1jby5vdmVybGFwKHRoaXMsIHN0YXJ0MCwgbWMsIHN0YXJ0MSk7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBtY28udGVtcEVudjEuaW5pdChwMDAsIHAwMSk7XG4gIG1jby50ZW1wRW52Mi5pbml0KHAxMCwgcDExKTtcbiAgaWYgKCFtY28udGVtcEVudjEuaW50ZXJzZWN0cyhtY28udGVtcEVudjIpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIG1pZDAgPSBNYXRoLnRydW5jKChzdGFydDAgKyBlbmQwKSAvIDIpO1xuICB2YXIgbWlkMSA9IE1hdGgudHJ1bmMoKHN0YXJ0MSArIGVuZDEpIC8gMik7XG4gIGlmIChzdGFydDAgPCBtaWQwKSB7XG4gICAgaWYgKHN0YXJ0MSA8IG1pZDEpIHsgdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbChzdGFydDAsIG1pZDAsIG1jLCBzdGFydDEsIG1pZDEsIG1jbyk7IH1cbiAgICBpZiAobWlkMSA8IGVuZDEpIHsgdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbChzdGFydDAsIG1pZDAsIG1jLCBtaWQxLCBlbmQxLCBtY28pOyB9XG4gIH1cbiAgaWYgKG1pZDAgPCBlbmQwKSB7XG4gICAgaWYgKHN0YXJ0MSA8IG1pZDEpIHsgdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbChtaWQwLCBlbmQwLCBtYywgc3RhcnQxLCBtaWQxLCBtY28pOyB9XG4gICAgaWYgKG1pZDEgPCBlbmQxKSB7IHRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwobWlkMCwgZW5kMCwgbWMsIG1pZDEsIGVuZDEsIG1jbyk7IH1cbiAgfVxufTtcbk1vbm90b25lQ2hhaW4ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Nb25vdG9uZUNoYWluLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm90b25lQ2hhaW5cbn07XG5cbnZhciBNb25vdG9uZUNoYWluQnVpbGRlciA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW5CdWlsZGVyICgpIHt9O1xuXG5Nb25vdG9uZUNoYWluQnVpbGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1vbm90b25lQ2hhaW5CdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm90b25lQ2hhaW5CdWlsZGVyXG59O1xuTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZ2V0Q2hhaW5TdGFydEluZGljZXMgPSBmdW5jdGlvbiBnZXRDaGFpblN0YXJ0SW5kaWNlcyAocHRzKSB7XG4gIHZhciBzdGFydCA9IDA7XG4gIHZhciBzdGFydEluZGV4TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgc3RhcnRJbmRleExpc3QuYWRkKG5ldyBJbnRlZ2VyKHN0YXJ0KSk7XG4gIGRvIHtcbiAgICB2YXIgbGFzdCA9IE1vbm90b25lQ2hhaW5CdWlsZGVyLmZpbmRDaGFpbkVuZChwdHMsIHN0YXJ0KTtcbiAgICBzdGFydEluZGV4TGlzdC5hZGQobmV3IEludGVnZXIobGFzdCkpO1xuICAgIHN0YXJ0ID0gbGFzdDtcbiAgfSB3aGlsZSAoc3RhcnQgPCBwdHMubGVuZ3RoIC0gMSlcbiAgdmFyIHN0YXJ0SW5kZXggPSBNb25vdG9uZUNoYWluQnVpbGRlci50b0ludEFycmF5KHN0YXJ0SW5kZXhMaXN0KTtcbiAgcmV0dXJuIHN0YXJ0SW5kZXhcbn07XG5Nb25vdG9uZUNoYWluQnVpbGRlci5maW5kQ2hhaW5FbmQgPSBmdW5jdGlvbiBmaW5kQ2hhaW5FbmQgKHB0cywgc3RhcnQpIHtcbiAgdmFyIHNhZmVTdGFydCA9IHN0YXJ0O1xuICB3aGlsZSAoc2FmZVN0YXJ0IDwgcHRzLmxlbmd0aCAtIDEgJiYgcHRzW3NhZmVTdGFydF0uZXF1YWxzMkQocHRzW3NhZmVTdGFydCArIDFdKSkge1xuICAgIHNhZmVTdGFydCsrO1xuICB9XG4gIGlmIChzYWZlU3RhcnQgPj0gcHRzLmxlbmd0aCAtIDEpIHtcbiAgICByZXR1cm4gcHRzLmxlbmd0aCAtIDFcbiAgfVxuICB2YXIgY2hhaW5RdWFkID0gUXVhZHJhbnQucXVhZHJhbnQocHRzW3NhZmVTdGFydF0sIHB0c1tzYWZlU3RhcnQgKyAxXSk7XG4gIHZhciBsYXN0ID0gc3RhcnQgKyAxO1xuICB3aGlsZSAobGFzdCA8IHB0cy5sZW5ndGgpIHtcbiAgICBpZiAoIXB0c1tsYXN0IC0gMV0uZXF1YWxzMkQocHRzW2xhc3RdKSkge1xuICAgICAgdmFyIHF1YWQgPSBRdWFkcmFudC5xdWFkcmFudChwdHNbbGFzdCAtIDFdLCBwdHNbbGFzdF0pO1xuICAgICAgaWYgKHF1YWQgIT09IGNoYWluUXVhZCkgeyBicmVhayB9XG4gICAgfVxuICAgIGxhc3QrKztcbiAgfVxuICByZXR1cm4gbGFzdCAtIDFcbn07XG5Nb25vdG9uZUNoYWluQnVpbGRlci5nZXRDaGFpbnMgPSBmdW5jdGlvbiBnZXRDaGFpbnMgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIE1vbm90b25lQ2hhaW5CdWlsZGVyLmdldENoYWlucyhwdHMsIG51bGwpXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwdHMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgY29udGV4dCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWNMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHZhciBzdGFydEluZGV4ID0gTW9ub3RvbmVDaGFpbkJ1aWxkZXIuZ2V0Q2hhaW5TdGFydEluZGljZXMocHRzJDEpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhcnRJbmRleC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciBtYyA9IG5ldyBNb25vdG9uZUNoYWluKHB0cyQxLCBzdGFydEluZGV4W2ldLCBzdGFydEluZGV4W2kgKyAxXSwgY29udGV4dCk7XG4gICAgICBtY0xpc3QuYWRkKG1jKTtcbiAgICB9XG4gICAgcmV0dXJuIG1jTGlzdFxuICB9XG59O1xuTW9ub3RvbmVDaGFpbkJ1aWxkZXIudG9JbnRBcnJheSA9IGZ1bmN0aW9uIHRvSW50QXJyYXkgKGxpc3QpIHtcbiAgdmFyIGFycmF5ID0gbmV3IEFycmF5KGxpc3Quc2l6ZSgpKS5maWxsKG51bGwpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXlbaV0gPSBsaXN0LmdldChpKS5pbnRWYWx1ZSgpO1xuICB9XG4gIHJldHVybiBhcnJheVxufTtcblxudmFyIE5vZGVyID0gZnVuY3Rpb24gTm9kZXIgKCkge307XG5cbk5vZGVyLnByb3RvdHlwZS5jb21wdXRlTm9kZXMgPSBmdW5jdGlvbiBjb21wdXRlTm9kZXMgKHNlZ1N0cmluZ3MpIHt9O1xuTm9kZXIucHJvdG90eXBlLmdldE5vZGVkU3Vic3RyaW5ncyA9IGZ1bmN0aW9uIGdldE5vZGVkU3Vic3RyaW5ncyAoKSB7fTtcbk5vZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTm9kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kZXJcbn07XG5cbnZhciBTaW5nbGVQYXNzTm9kZXIgPSBmdW5jdGlvbiBTaW5nbGVQYXNzTm9kZXIgKCkge1xuICB0aGlzLl9zZWdJbnQgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge30gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzZWdJbnQgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRTZWdtZW50SW50ZXJzZWN0b3Ioc2VnSW50KTtcbiAgfVxufTtcblNpbmdsZVBhc3NOb2Rlci5wcm90b3R5cGUuc2V0U2VnbWVudEludGVyc2VjdG9yID0gZnVuY3Rpb24gc2V0U2VnbWVudEludGVyc2VjdG9yIChzZWdJbnQpIHtcbiAgdGhpcy5fc2VnSW50ID0gc2VnSW50O1xufTtcblNpbmdsZVBhc3NOb2Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbTm9kZXJdXG59O1xuU2luZ2xlUGFzc05vZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNpbmdsZVBhc3NOb2RlclxufTtcblxudmFyIE1DSW5kZXhOb2RlciA9IChmdW5jdGlvbiAoU2luZ2xlUGFzc05vZGVyJCQxKSB7XG4gIGZ1bmN0aW9uIE1DSW5kZXhOb2RlciAoc2kpIHtcbiAgICBpZiAoc2kpIHsgU2luZ2xlUGFzc05vZGVyJCQxLmNhbGwodGhpcywgc2kpOyB9XG4gICAgZWxzZSB7IFNpbmdsZVBhc3NOb2RlciQkMS5jYWxsKHRoaXMpOyB9XG4gICAgdGhpcy5fbW9ub0NoYWlucyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLl9pbmRleCA9IG5ldyBTVFJ0cmVlKCk7XG4gICAgdGhpcy5faWRDb3VudGVyID0gMDtcbiAgICB0aGlzLl9ub2RlZFNlZ1N0cmluZ3MgPSBudWxsO1xuICAgIHRoaXMuX25PdmVybGFwcyA9IDA7XG4gIH1cblxuICBpZiAoIFNpbmdsZVBhc3NOb2RlciQkMSApIE1DSW5kZXhOb2Rlci5fX3Byb3RvX18gPSBTaW5nbGVQYXNzTm9kZXIkJDE7XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBTaW5nbGVQYXNzTm9kZXIkJDEgJiYgU2luZ2xlUGFzc05vZGVyJCQxLnByb3RvdHlwZSApO1xuICBNQ0luZGV4Tm9kZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gTUNJbmRleE5vZGVyO1xuXG4gIHZhciBzdGF0aWNBY2Nlc3NvcnMgPSB7IFNlZ21lbnRPdmVybGFwQWN0aW9uOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG4gIE1DSW5kZXhOb2Rlci5wcm90b3R5cGUuZ2V0TW9ub3RvbmVDaGFpbnMgPSBmdW5jdGlvbiBnZXRNb25vdG9uZUNoYWlucyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vbm9DaGFpbnNcbiAgfTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5nZXROb2RlZFN1YnN0cmluZ3MgPSBmdW5jdGlvbiBnZXROb2RlZFN1YnN0cmluZ3MgKCkge1xuICAgIHJldHVybiBOb2RlZFNlZ21lbnRTdHJpbmcuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMuX25vZGVkU2VnU3RyaW5ncylcbiAgfTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5nZXRJbmRleCA9IGZ1bmN0aW9uIGdldEluZGV4ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5kZXhcbiAgfTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKHNlZ1N0cikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHNlZ0NoYWlucyA9IE1vbm90b25lQ2hhaW5CdWlsZGVyLmdldENoYWlucyhzZWdTdHIuZ2V0Q29vcmRpbmF0ZXMoKSwgc2VnU3RyKTtcbiAgICBmb3IgKHZhciBpID0gc2VnQ2hhaW5zLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG1jID0gaS5uZXh0KCk7XG4gICAgICBtYy5zZXRJZCh0aGlzJDEuX2lkQ291bnRlcisrKTtcbiAgICAgIHRoaXMkMS5faW5kZXguaW5zZXJ0KG1jLmdldEVudmVsb3BlKCksIG1jKTtcbiAgICAgIHRoaXMkMS5fbW9ub0NoYWlucy5hZGQobWMpO1xuICAgIH1cbiAgfTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5jb21wdXRlTm9kZXMgPSBmdW5jdGlvbiBjb21wdXRlTm9kZXMgKGlucHV0U2VnU3RyaW5ncykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdGhpcy5fbm9kZWRTZWdTdHJpbmdzID0gaW5wdXRTZWdTdHJpbmdzO1xuICAgIGZvciAodmFyIGkgPSBpbnB1dFNlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB0aGlzJDEuYWRkKGkubmV4dCgpKTtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnNlY3RDaGFpbnMoKTtcbiAgfTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5pbnRlcnNlY3RDaGFpbnMgPSBmdW5jdGlvbiBpbnRlcnNlY3RDaGFpbnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIG92ZXJsYXBBY3Rpb24gPSBuZXcgU2VnbWVudE92ZXJsYXBBY3Rpb24odGhpcy5fc2VnSW50KTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fbW9ub0NoYWlucy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBxdWVyeUNoYWluID0gaS5uZXh0KCk7XG4gICAgICB2YXIgb3ZlcmxhcENoYWlucyA9IHRoaXMkMS5faW5kZXgucXVlcnkocXVlcnlDaGFpbi5nZXRFbnZlbG9wZSgpKTtcbiAgICAgIGZvciAodmFyIGogPSBvdmVybGFwQ2hhaW5zLml0ZXJhdG9yKCk7IGouaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgdGVzdENoYWluID0gai5uZXh0KCk7XG4gICAgICAgIGlmICh0ZXN0Q2hhaW4uZ2V0SWQoKSA+IHF1ZXJ5Q2hhaW4uZ2V0SWQoKSkge1xuICAgICAgICAgIHF1ZXJ5Q2hhaW4uY29tcHV0ZU92ZXJsYXBzKHRlc3RDaGFpbiwgb3ZlcmxhcEFjdGlvbik7XG4gICAgICAgICAgdGhpcyQxLl9uT3ZlcmxhcHMrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyQxLl9zZWdJbnQuaXNEb25lKCkpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgTUNJbmRleE5vZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gTUNJbmRleE5vZGVyXG4gIH07XG4gIHN0YXRpY0FjY2Vzc29ycy5TZWdtZW50T3ZlcmxhcEFjdGlvbi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTZWdtZW50T3ZlcmxhcEFjdGlvbiB9O1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNQ0luZGV4Tm9kZXIsIHN0YXRpY0FjY2Vzc29ycyApO1xuXG4gIHJldHVybiBNQ0luZGV4Tm9kZXI7XG59KFNpbmdsZVBhc3NOb2RlcikpO1xuXG52YXIgU2VnbWVudE92ZXJsYXBBY3Rpb24gPSAoZnVuY3Rpb24gKE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxKSB7XG4gIGZ1bmN0aW9uIFNlZ21lbnRPdmVybGFwQWN0aW9uICgpIHtcbiAgICBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3NpID0gbnVsbDtcbiAgICB2YXIgc2kgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fc2kgPSBzaTtcbiAgfVxuXG4gIGlmICggTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDEgKSBTZWdtZW50T3ZlcmxhcEFjdGlvbi5fX3Byb3RvX18gPSBNb25vdG9uZUNoYWluT3ZlcmxhcEFjdGlvbiQkMTtcbiAgU2VnbWVudE92ZXJsYXBBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDEgJiYgTW9ub3RvbmVDaGFpbk92ZXJsYXBBY3Rpb24kJDEucHJvdG90eXBlICk7XG4gIFNlZ21lbnRPdmVybGFwQWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNlZ21lbnRPdmVybGFwQWN0aW9uO1xuICBTZWdtZW50T3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUub3ZlcmxhcCA9IGZ1bmN0aW9uIG92ZXJsYXAgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA0KSB7XG4gICAgICB2YXIgbWMxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHN0YXJ0MSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBtYzIgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgc3RhcnQyID0gYXJndW1lbnRzWzNdO1xuICAgICAgdmFyIHNzMSA9IG1jMS5nZXRDb250ZXh0KCk7XG4gICAgICB2YXIgc3MyID0gbWMyLmdldENvbnRleHQoKTtcbiAgICAgIHRoaXMuX3NpLnByb2Nlc3NJbnRlcnNlY3Rpb25zKHNzMSwgc3RhcnQxLCBzczIsIHN0YXJ0Mik7XG4gICAgfSBlbHNlIHsgcmV0dXJuIE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uJCQxLnByb3RvdHlwZS5vdmVybGFwLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICB9O1xuICBTZWdtZW50T3ZlcmxhcEFjdGlvbi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIFNlZ21lbnRPdmVybGFwQWN0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gU2VnbWVudE92ZXJsYXBBY3Rpb25cbiAgfTtcblxuICByZXR1cm4gU2VnbWVudE92ZXJsYXBBY3Rpb247XG59KE1vbm90b25lQ2hhaW5PdmVybGFwQWN0aW9uKSk7XG5cbnZhciBCdWZmZXJQYXJhbWV0ZXJzID0gZnVuY3Rpb24gQnVmZmVyUGFyYW1ldGVycyAoKSB7XG4gIHRoaXMuX3F1YWRyYW50U2VnbWVudHMgPSBCdWZmZXJQYXJhbWV0ZXJzLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM7XG4gIHRoaXMuX2VuZENhcFN0eWxlID0gQnVmZmVyUGFyYW1ldGVycy5DQVBfUk9VTkQ7XG4gIHRoaXMuX2pvaW5TdHlsZSA9IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9ST1VORDtcbiAgdGhpcy5fbWl0cmVMaW1pdCA9IEJ1ZmZlclBhcmFtZXRlcnMuREVGQVVMVF9NSVRSRV9MSU1JVDtcbiAgdGhpcy5faXNTaW5nbGVTaWRlZCA9IGZhbHNlO1xuICB0aGlzLl9zaW1wbGlmeUZhY3RvciA9IEJ1ZmZlclBhcmFtZXRlcnMuREVGQVVMVF9TSU1QTElGWV9GQUNUT1I7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHt9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcXVhZHJhbnRTZWdtZW50cyA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldFF1YWRyYW50U2VnbWVudHMocXVhZHJhbnRTZWdtZW50cyk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBxdWFkcmFudFNlZ21lbnRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGVuZENhcFN0eWxlID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhxdWFkcmFudFNlZ21lbnRzJDEpO1xuICAgIHRoaXMuc2V0RW5kQ2FwU3R5bGUoZW5kQ2FwU3R5bGUpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgcXVhZHJhbnRTZWdtZW50cyQyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBlbmRDYXBTdHlsZSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBqb2luU3R5bGUgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIG1pdHJlTGltaXQgPSBhcmd1bWVudHNbM107XG4gICAgdGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKHF1YWRyYW50U2VnbWVudHMkMik7XG4gICAgdGhpcy5zZXRFbmRDYXBTdHlsZShlbmRDYXBTdHlsZSQxKTtcbiAgICB0aGlzLnNldEpvaW5TdHlsZShqb2luU3R5bGUpO1xuICAgIHRoaXMuc2V0TWl0cmVMaW1pdChtaXRyZUxpbWl0KTtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyNSA9IHsgQ0FQX1JPVU5EOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENBUF9GTEFUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENBUF9TUVVBUkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sSk9JTl9ST1VORDogeyBjb25maWd1cmFibGU6IHRydWUgfSxKT0lOX01JVFJFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEpPSU5fQkVWRUw6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUzogeyBjb25maWd1cmFibGU6IHRydWUgfSxERUZBVUxUX01JVFJFX0xJTUlUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFRkFVTFRfU0lNUExJRllfRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRFbmRDYXBTdHlsZSA9IGZ1bmN0aW9uIGdldEVuZENhcFN0eWxlICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VuZENhcFN0eWxlXG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuaXNTaW5nbGVTaWRlZCA9IGZ1bmN0aW9uIGlzU2luZ2xlU2lkZWQgKCkge1xuICByZXR1cm4gdGhpcy5faXNTaW5nbGVTaWRlZFxufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLnNldFF1YWRyYW50U2VnbWVudHMgPSBmdW5jdGlvbiBzZXRRdWFkcmFudFNlZ21lbnRzIChxdWFkU2Vncykge1xuICB0aGlzLl9xdWFkcmFudFNlZ21lbnRzID0gcXVhZFNlZ3M7XG4gIGlmICh0aGlzLl9xdWFkcmFudFNlZ21lbnRzID09PSAwKSB7IHRoaXMuX2pvaW5TdHlsZSA9IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9CRVZFTDsgfVxuICBpZiAodGhpcy5fcXVhZHJhbnRTZWdtZW50cyA8IDApIHtcbiAgICB0aGlzLl9qb2luU3R5bGUgPSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fTUlUUkU7XG4gICAgdGhpcy5fbWl0cmVMaW1pdCA9IE1hdGguYWJzKHRoaXMuX3F1YWRyYW50U2VnbWVudHMpO1xuICB9XG4gIGlmIChxdWFkU2VncyA8PSAwKSB7XG4gICAgdGhpcy5fcXVhZHJhbnRTZWdtZW50cyA9IDE7XG4gIH1cbiAgaWYgKHRoaXMuX2pvaW5TdHlsZSAhPT0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX1JPVU5EKSB7XG4gICAgdGhpcy5fcXVhZHJhbnRTZWdtZW50cyA9IEJ1ZmZlclBhcmFtZXRlcnMuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUztcbiAgfVxufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmdldEpvaW5TdHlsZSA9IGZ1bmN0aW9uIGdldEpvaW5TdHlsZSAoKSB7XG4gIHJldHVybiB0aGlzLl9qb2luU3R5bGVcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5zZXRKb2luU3R5bGUgPSBmdW5jdGlvbiBzZXRKb2luU3R5bGUgKGpvaW5TdHlsZSkge1xuICB0aGlzLl9qb2luU3R5bGUgPSBqb2luU3R5bGU7XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuc2V0U2ltcGxpZnlGYWN0b3IgPSBmdW5jdGlvbiBzZXRTaW1wbGlmeUZhY3RvciAoc2ltcGxpZnlGYWN0b3IpIHtcbiAgdGhpcy5fc2ltcGxpZnlGYWN0b3IgPSBzaW1wbGlmeUZhY3RvciA8IDAgPyAwIDogc2ltcGxpZnlGYWN0b3I7XG59O1xuQnVmZmVyUGFyYW1ldGVycy5wcm90b3R5cGUuZ2V0U2ltcGxpZnlGYWN0b3IgPSBmdW5jdGlvbiBnZXRTaW1wbGlmeUZhY3RvciAoKSB7XG4gIHJldHVybiB0aGlzLl9zaW1wbGlmeUZhY3RvclxufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmdldFF1YWRyYW50U2VnbWVudHMgPSBmdW5jdGlvbiBnZXRRdWFkcmFudFNlZ21lbnRzICgpIHtcbiAgcmV0dXJuIHRoaXMuX3F1YWRyYW50U2VnbWVudHNcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5zZXRFbmRDYXBTdHlsZSA9IGZ1bmN0aW9uIHNldEVuZENhcFN0eWxlIChlbmRDYXBTdHlsZSkge1xuICB0aGlzLl9lbmRDYXBTdHlsZSA9IGVuZENhcFN0eWxlO1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmdldE1pdHJlTGltaXQgPSBmdW5jdGlvbiBnZXRNaXRyZUxpbWl0ICgpIHtcbiAgcmV0dXJuIHRoaXMuX21pdHJlTGltaXRcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5zZXRNaXRyZUxpbWl0ID0gZnVuY3Rpb24gc2V0TWl0cmVMaW1pdCAobWl0cmVMaW1pdCkge1xuICB0aGlzLl9taXRyZUxpbWl0ID0gbWl0cmVMaW1pdDtcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5zZXRTaW5nbGVTaWRlZCA9IGZ1bmN0aW9uIHNldFNpbmdsZVNpZGVkIChpc1NpbmdsZVNpZGVkKSB7XG4gIHRoaXMuX2lzU2luZ2xlU2lkZWQgPSBpc1NpbmdsZVNpZGVkO1xufTtcbkJ1ZmZlclBhcmFtZXRlcnMucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJQYXJhbWV0ZXJzLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlclBhcmFtZXRlcnNcbn07XG5CdWZmZXJQYXJhbWV0ZXJzLmJ1ZmZlckRpc3RhbmNlRXJyb3IgPSBmdW5jdGlvbiBidWZmZXJEaXN0YW5jZUVycm9yIChxdWFkU2Vncykge1xuICB2YXIgYWxwaGEgPSBNYXRoLlBJIC8gMi4wIC8gcXVhZFNlZ3M7XG4gIHJldHVybiAxIC0gTWF0aC5jb3MoYWxwaGEgLyAyLjApXG59O1xuc3RhdGljQWNjZXNzb3JzJDI1LkNBUF9ST1VORC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuQ0FQX0ZMQVQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkNBUF9TUVVBUkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMyB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkpPSU5fUk9VTkQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkpPSU5fTUlUUkUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMiB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkpPSU5fQkVWRUwuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMyB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gOCB9O1xuc3RhdGljQWNjZXNzb3JzJDI1LkRFRkFVTFRfTUlUUkVfTElNSVQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNS4wIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjUuREVGQVVMVF9TSU1QTElGWV9GQUNUT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMC4wMSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyUGFyYW1ldGVycywgc3RhdGljQWNjZXNzb3JzJDI1ICk7XG5cbnZhciBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyID0gZnVuY3Rpb24gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllciAoaW5wdXRMaW5lKSB7XG4gIHRoaXMuX2Rpc3RhbmNlVG9sID0gbnVsbDtcbiAgdGhpcy5faXNEZWxldGVkID0gbnVsbDtcbiAgdGhpcy5fYW5nbGVPcmllbnRhdGlvbiA9IENHQWxnb3JpdGhtcy5DT1VOVEVSQ0xPQ0tXSVNFO1xuICB0aGlzLl9pbnB1dExpbmUgPSBpbnB1dExpbmUgfHwgbnVsbDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMjYgPSB7IElOSVQ6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sREVMRVRFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LEtFRVA6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTlVNX1BUU19UT19DSEVDSzogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuaXNEZWxldGFibGUgPSBmdW5jdGlvbiBpc0RlbGV0YWJsZSAoaTAsIGkxLCBpMiwgZGlzdGFuY2VUb2wpIHtcbiAgdmFyIHAwID0gdGhpcy5faW5wdXRMaW5lW2kwXTtcbiAgdmFyIHAxID0gdGhpcy5faW5wdXRMaW5lW2kxXTtcbiAgdmFyIHAyID0gdGhpcy5faW5wdXRMaW5lW2kyXTtcbiAgaWYgKCF0aGlzLmlzQ29uY2F2ZShwMCwgcDEsIHAyKSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoIXRoaXMuaXNTaGFsbG93KHAwLCBwMSwgcDIsIGRpc3RhbmNlVG9sKSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gdGhpcy5pc1NoYWxsb3dTYW1wbGVkKHAwLCBwMSwgaTAsIGkyLCBkaXN0YW5jZVRvbClcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5kZWxldGVTaGFsbG93Q29uY2F2aXRpZXMgPSBmdW5jdGlvbiBkZWxldGVTaGFsbG93Q29uY2F2aXRpZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpbmRleCA9IDE7XG4gIC8vIGNvbnN0IG1heEluZGV4ID0gdGhpcy5faW5wdXRMaW5lLmxlbmd0aCAtIDFcbiAgdmFyIG1pZEluZGV4ID0gdGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChpbmRleCk7XG4gIHZhciBsYXN0SW5kZXggPSB0aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KG1pZEluZGV4KTtcbiAgdmFyIGlzQ2hhbmdlZCA9IGZhbHNlO1xuICB3aGlsZSAobGFzdEluZGV4IDwgdGhpcy5faW5wdXRMaW5lLmxlbmd0aCkge1xuICAgIHZhciBpc01pZGRsZVZlcnRleERlbGV0ZWQgPSBmYWxzZTtcbiAgICBpZiAodGhpcyQxLmlzRGVsZXRhYmxlKGluZGV4LCBtaWRJbmRleCwgbGFzdEluZGV4LCB0aGlzJDEuX2Rpc3RhbmNlVG9sKSkge1xuICAgICAgdGhpcyQxLl9pc0RlbGV0ZWRbbWlkSW5kZXhdID0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5ERUxFVEU7XG4gICAgICBpc01pZGRsZVZlcnRleERlbGV0ZWQgPSB0cnVlO1xuICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzTWlkZGxlVmVydGV4RGVsZXRlZCkgeyBpbmRleCA9IGxhc3RJbmRleDsgfSBlbHNlIHsgaW5kZXggPSBtaWRJbmRleDsgfVxuICAgIG1pZEluZGV4ID0gdGhpcyQxLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGluZGV4KTtcbiAgICBsYXN0SW5kZXggPSB0aGlzJDEuZmluZE5leHROb25EZWxldGVkSW5kZXgobWlkSW5kZXgpO1xuICB9XG4gIHJldHVybiBpc0NoYW5nZWRcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5pc1NoYWxsb3dDb25jYXZpdHkgPSBmdW5jdGlvbiBpc1NoYWxsb3dDb25jYXZpdHkgKHAwLCBwMSwgcDIsIGRpc3RhbmNlVG9sKSB7XG4gIHZhciBvcmllbnRhdGlvbiA9IENHQWxnb3JpdGhtcy5jb21wdXRlT3JpZW50YXRpb24ocDAsIHAxLCBwMik7XG4gIHZhciBpc0FuZ2xlVG9TaW1wbGlmeSA9IG9yaWVudGF0aW9uID09PSB0aGlzLl9hbmdsZU9yaWVudGF0aW9uO1xuICBpZiAoIWlzQW5nbGVUb1NpbXBsaWZ5KSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBkaXN0ID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKHAxLCBwMCwgcDIpO1xuICByZXR1cm4gZGlzdCA8IGRpc3RhbmNlVG9sXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuaXNTaGFsbG93U2FtcGxlZCA9IGZ1bmN0aW9uIGlzU2hhbGxvd1NhbXBsZWQgKHAwLCBwMiwgaTAsIGkyLCBkaXN0YW5jZVRvbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpbmMgPSBNYXRoLnRydW5jKChpMiAtIGkwKSAvIEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuTlVNX1BUU19UT19DSEVDSyk7XG4gIGlmIChpbmMgPD0gMCkgeyBpbmMgPSAxOyB9XG4gIGZvciAodmFyIGkgPSBpMDsgaSA8IGkyOyBpICs9IGluYykge1xuICAgIGlmICghdGhpcyQxLmlzU2hhbGxvdyhwMCwgcDIsIHRoaXMkMS5faW5wdXRMaW5lW2ldLCBkaXN0YW5jZVRvbCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmlzQ29uY2F2ZSA9IGZ1bmN0aW9uIGlzQ29uY2F2ZSAocDAsIHAxLCBwMikge1xuICB2YXIgb3JpZW50YXRpb24gPSBDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHAwLCBwMSwgcDIpO1xuICB2YXIgaXNDb25jYXZlID0gb3JpZW50YXRpb24gPT09IHRoaXMuX2FuZ2xlT3JpZW50YXRpb247XG4gIHJldHVybiBpc0NvbmNhdmVcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5zaW1wbGlmeSA9IGZ1bmN0aW9uIHNpbXBsaWZ5IChkaXN0YW5jZVRvbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHRoaXMuX2Rpc3RhbmNlVG9sID0gTWF0aC5hYnMoZGlzdGFuY2VUb2wpO1xuICBpZiAoZGlzdGFuY2VUb2wgPCAwKSB7IHRoaXMuX2FuZ2xlT3JpZW50YXRpb24gPSBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFOyB9XG4gIHRoaXMuX2lzRGVsZXRlZCA9IG5ldyBBcnJheSh0aGlzLl9pbnB1dExpbmUubGVuZ3RoKS5maWxsKG51bGwpO1xuICB2YXIgaXNDaGFuZ2VkID0gZmFsc2U7XG4gIGRvIHtcbiAgICBpc0NoYW5nZWQgPSB0aGlzJDEuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCk7XG4gIH0gd2hpbGUgKGlzQ2hhbmdlZClcbiAgcmV0dXJuIHRoaXMuY29sbGFwc2VMaW5lKClcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCA9IGZ1bmN0aW9uIGZpbmROZXh0Tm9uRGVsZXRlZEluZGV4IChpbmRleCkge1xuICB2YXIgbmV4dCA9IGluZGV4ICsgMTtcbiAgd2hpbGUgKG5leHQgPCB0aGlzLl9pbnB1dExpbmUubGVuZ3RoICYmIHRoaXMuX2lzRGVsZXRlZFtuZXh0XSA9PT0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5ERUxFVEUpIHsgbmV4dCsrOyB9XG4gIHJldHVybiBuZXh0XG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuaXNTaGFsbG93ID0gZnVuY3Rpb24gaXNTaGFsbG93IChwMCwgcDEsIHAyLCBkaXN0YW5jZVRvbCkge1xuICB2YXIgZGlzdCA9IENHQWxnb3JpdGhtcy5kaXN0YW5jZVBvaW50TGluZShwMSwgcDAsIHAyKTtcbiAgcmV0dXJuIGRpc3QgPCBkaXN0YW5jZVRvbFxufTtcbkJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIucHJvdG90eXBlLmNvbGxhcHNlTGluZSA9IGZ1bmN0aW9uIGNvbGxhcHNlTGluZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGNvb3JkTGlzdCA9IG5ldyBDb29yZGluYXRlTGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX2lucHV0TGluZS5sZW5ndGg7IGkrKykge1xuICAgIGlmICh0aGlzJDEuX2lzRGVsZXRlZFtpXSAhPT0gQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5ERUxFVEUpIHsgY29vcmRMaXN0LmFkZCh0aGlzJDEuX2lucHV0TGluZVtpXSk7IH1cbiAgfVxuICByZXR1cm4gY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KClcbn07XG5CdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyXG59O1xuQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllci5zaW1wbGlmeSA9IGZ1bmN0aW9uIHNpbXBsaWZ5IChpbnB1dExpbmUsIGRpc3RhbmNlVG9sKSB7XG4gIHZhciBzaW1wID0gbmV3IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIoaW5wdXRMaW5lKTtcbiAgcmV0dXJuIHNpbXAuc2ltcGxpZnkoZGlzdGFuY2VUb2wpXG59O1xuc3RhdGljQWNjZXNzb3JzJDI2LklOSVQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuc3RhdGljQWNjZXNzb3JzJDI2LkRFTEVURS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjYuS0VFUC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjYuTlVNX1BUU19UT19DSEVDSy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxMCB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVySW5wdXRMaW5lU2ltcGxpZmllciwgc3RhdGljQWNjZXNzb3JzJDI2ICk7XG5cbnZhciBPZmZzZXRTZWdtZW50U3RyaW5nID0gZnVuY3Rpb24gT2Zmc2V0U2VnbWVudFN0cmluZyAoKSB7XG4gIHRoaXMuX3B0TGlzdCA9IG51bGw7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gbnVsbDtcbiAgdGhpcy5fbWluaW1pbVZlcnRleERpc3RhbmNlID0gMC4wO1xuICB0aGlzLl9wdExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDI4ID0geyBDT09SRElOQVRFX0FSUkFZX1RZUEU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICB2YXIgY29vcmQgPSB0aGlzLl9wdExpc3QudG9BcnJheShPZmZzZXRTZWdtZW50U3RyaW5nLkNPT1JESU5BVEVfQVJSQVlfVFlQRSk7XG4gIHJldHVybiBjb29yZFxufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNldFByZWNpc2lvbk1vZGVsID0gZnVuY3Rpb24gc2V0UHJlY2lzaW9uTW9kZWwgKHByZWNpc2lvbk1vZGVsKSB7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gcHJlY2lzaW9uTW9kZWw7XG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuYWRkUHQgPSBmdW5jdGlvbiBhZGRQdCAocHQpIHtcbiAgdmFyIGJ1ZlB0ID0gbmV3IENvb3JkaW5hdGUocHQpO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShidWZQdCk7XG4gIGlmICh0aGlzLmlzUmVkdW5kYW50KGJ1ZlB0KSkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuX3B0TGlzdC5hZGQoYnVmUHQpO1xufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnJldmVyZSA9IGZ1bmN0aW9uIHJldmVyZSAoKSB7fTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmFkZFB0cyA9IGZ1bmN0aW9uIGFkZFB0cyAocHQsIGlzRm9yd2FyZCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChpc0ZvcndhcmQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzJDEuYWRkUHQocHRbaV0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpJDEgPSBwdC5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pIHtcbiAgICAgIHRoaXMkMS5hZGRQdChwdFtpJDFdKTtcbiAgICB9XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5pc1JlZHVuZGFudCA9IGZ1bmN0aW9uIGlzUmVkdW5kYW50IChwdCkge1xuICBpZiAodGhpcy5fcHRMaXN0LnNpemUoKSA8IDEpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGxhc3RQdCA9IHRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKSAtIDEpO1xuICB2YXIgcHREaXN0ID0gcHQuZGlzdGFuY2UobGFzdFB0KTtcbiAgaWYgKHB0RGlzdCA8IHRoaXMuX21pbmltaW1WZXJ0ZXhEaXN0YW5jZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgZmFjdCA9IG5ldyBHZW9tZXRyeUZhY3RvcnkoKTtcbiAgdmFyIGxpbmUgPSBmYWN0LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKTtcbiAgcmV0dXJuIGxpbmUudG9TdHJpbmcoKVxufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmNsb3NlUmluZyA9IGZ1bmN0aW9uIGNsb3NlUmluZyAoKSB7XG4gIGlmICh0aGlzLl9wdExpc3Quc2l6ZSgpIDwgMSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBzdGFydFB0ID0gbmV3IENvb3JkaW5hdGUodGhpcy5fcHRMaXN0LmdldCgwKSk7XG4gIHZhciBsYXN0UHQgPSB0aGlzLl9wdExpc3QuZ2V0KHRoaXMuX3B0TGlzdC5zaXplKCkgLSAxKTtcbiAgLy8gY29uc3QgbGFzdDJQdCA9IG51bGxcbiAgLy8gaWYgKHRoaXMuX3B0TGlzdC5zaXplKCkgPj0gMikgbGFzdDJQdCA9IHRoaXMuX3B0TGlzdC5nZXQodGhpcy5fcHRMaXN0LnNpemUoKSAtIDIpXG4gIGlmIChzdGFydFB0LmVxdWFscyhsYXN0UHQpKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5fcHRMaXN0LmFkZChzdGFydFB0KTtcbn07XG5PZmZzZXRTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UgPSBmdW5jdGlvbiBzZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UgKG1pbmltaW1WZXJ0ZXhEaXN0YW5jZSkge1xuICB0aGlzLl9taW5pbWltVmVydGV4RGlzdGFuY2UgPSBtaW5pbWltVmVydGV4RGlzdGFuY2U7XG59O1xuT2Zmc2V0U2VnbWVudFN0cmluZy5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk9mZnNldFNlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT2Zmc2V0U2VnbWVudFN0cmluZ1xufTtcbnN0YXRpY0FjY2Vzc29ycyQyOC5DT09SRElOQVRFX0FSUkFZX1RZUEUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEFycmF5KDApLmZpbGwobnVsbCkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE9mZnNldFNlZ21lbnRTdHJpbmcsIHN0YXRpY0FjY2Vzc29ycyQyOCApO1xuXG52YXIgQW5nbGUgPSBmdW5jdGlvbiBBbmdsZSAoKSB7fTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQyOSA9IHsgUElfVElNRVNfMjogeyBjb25maWd1cmFibGU6IHRydWUgfSxQSV9PVkVSXzI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sUElfT1ZFUl80OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENPVU5URVJDTE9DS1dJU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ0xPQ0tXSVNFOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE5PTkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcblxuQW5nbGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5BbmdsZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBBbmdsZVxufTtcbkFuZ2xlLnRvRGVncmVlcyA9IGZ1bmN0aW9uIHRvRGVncmVlcyAocmFkaWFucykge1xuICByZXR1cm4gcmFkaWFucyAqIDE4MCAvIE1hdGguUElcbn07XG5BbmdsZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKGFuZ2xlKSB7XG4gIHdoaWxlIChhbmdsZSA+IE1hdGguUEkpIHsgYW5nbGUgLT0gQW5nbGUuUElfVElNRVNfMjsgfVxuICB3aGlsZSAoYW5nbGUgPD0gLU1hdGguUEkpIHsgYW5nbGUgKz0gQW5nbGUuUElfVElNRVNfMjsgfVxuICByZXR1cm4gYW5nbGVcbn07XG5BbmdsZS5hbmdsZSA9IGZ1bmN0aW9uIGFuZ2xlICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihwLnksIHAueClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZHggPSBwMS54IC0gcDAueDtcbiAgICB2YXIgZHkgPSBwMS55IC0gcDAueTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihkeSwgZHgpXG4gIH1cbn07XG5BbmdsZS5pc0FjdXRlID0gZnVuY3Rpb24gaXNBY3V0ZSAocDAsIHAxLCBwMikge1xuICB2YXIgZHgwID0gcDAueCAtIHAxLng7XG4gIHZhciBkeTAgPSBwMC55IC0gcDEueTtcbiAgdmFyIGR4MSA9IHAyLnggLSBwMS54O1xuICB2YXIgZHkxID0gcDIueSAtIHAxLnk7XG4gIHZhciBkb3Rwcm9kID0gZHgwICogZHgxICsgZHkwICogZHkxO1xuICByZXR1cm4gZG90cHJvZCA+IDBcbn07XG5BbmdsZS5pc09idHVzZSA9IGZ1bmN0aW9uIGlzT2J0dXNlIChwMCwgcDEsIHAyKSB7XG4gIHZhciBkeDAgPSBwMC54IC0gcDEueDtcbiAgdmFyIGR5MCA9IHAwLnkgLSBwMS55O1xuICB2YXIgZHgxID0gcDIueCAtIHAxLng7XG4gIHZhciBkeTEgPSBwMi55IC0gcDEueTtcbiAgdmFyIGRvdHByb2QgPSBkeDAgKiBkeDEgKyBkeTAgKiBkeTE7XG4gIHJldHVybiBkb3Rwcm9kIDwgMFxufTtcbkFuZ2xlLmludGVyaW9yQW5nbGUgPSBmdW5jdGlvbiBpbnRlcmlvckFuZ2xlIChwMCwgcDEsIHAyKSB7XG4gIHZhciBhbmdsZVByZXYgPSBBbmdsZS5hbmdsZShwMSwgcDApO1xuICB2YXIgYW5nbGVOZXh0ID0gQW5nbGUuYW5nbGUocDEsIHAyKTtcbiAgcmV0dXJuIE1hdGguYWJzKGFuZ2xlTmV4dCAtIGFuZ2xlUHJldilcbn07XG5BbmdsZS5ub3JtYWxpemVQb3NpdGl2ZSA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBvc2l0aXZlIChhbmdsZSkge1xuICBpZiAoYW5nbGUgPCAwLjApIHtcbiAgICB3aGlsZSAoYW5nbGUgPCAwLjApIHsgYW5nbGUgKz0gQW5nbGUuUElfVElNRVNfMjsgfVxuICAgIGlmIChhbmdsZSA+PSBBbmdsZS5QSV9USU1FU18yKSB7IGFuZ2xlID0gMC4wOyB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKGFuZ2xlID49IEFuZ2xlLlBJX1RJTUVTXzIpIHsgYW5nbGUgLT0gQW5nbGUuUElfVElNRVNfMjsgfVxuICAgIGlmIChhbmdsZSA8IDAuMCkgeyBhbmdsZSA9IDAuMDsgfVxuICB9XG4gIHJldHVybiBhbmdsZVxufTtcbkFuZ2xlLmFuZ2xlQmV0d2VlbiA9IGZ1bmN0aW9uIGFuZ2xlQmV0d2VlbiAodGlwMSwgdGFpbCwgdGlwMikge1xuICB2YXIgYTEgPSBBbmdsZS5hbmdsZSh0YWlsLCB0aXAxKTtcbiAgdmFyIGEyID0gQW5nbGUuYW5nbGUodGFpbCwgdGlwMik7XG4gIHJldHVybiBBbmdsZS5kaWZmKGExLCBhMilcbn07XG5BbmdsZS5kaWZmID0gZnVuY3Rpb24gZGlmZiAoYW5nMSwgYW5nMikge1xuICB2YXIgZGVsQW5nbGUgPSBudWxsO1xuICBpZiAoYW5nMSA8IGFuZzIpIHtcbiAgICBkZWxBbmdsZSA9IGFuZzIgLSBhbmcxO1xuICB9IGVsc2Uge1xuICAgIGRlbEFuZ2xlID0gYW5nMSAtIGFuZzI7XG4gIH1cbiAgaWYgKGRlbEFuZ2xlID4gTWF0aC5QSSkge1xuICAgIGRlbEFuZ2xlID0gMiAqIE1hdGguUEkgLSBkZWxBbmdsZTtcbiAgfVxuICByZXR1cm4gZGVsQW5nbGVcbn07XG5BbmdsZS50b1JhZGlhbnMgPSBmdW5jdGlvbiB0b1JhZGlhbnMgKGFuZ2xlRGVncmVlcykge1xuICByZXR1cm4gYW5nbGVEZWdyZWVzICogTWF0aC5QSSAvIDE4MC4wXG59O1xuQW5nbGUuZ2V0VHVybiA9IGZ1bmN0aW9uIGdldFR1cm4gKGFuZzEsIGFuZzIpIHtcbiAgdmFyIGNyb3NzcHJvZHVjdCA9IE1hdGguc2luKGFuZzIgLSBhbmcxKTtcbiAgaWYgKGNyb3NzcHJvZHVjdCA+IDApIHtcbiAgICByZXR1cm4gQW5nbGUuQ09VTlRFUkNMT0NLV0lTRVxuICB9XG4gIGlmIChjcm9zc3Byb2R1Y3QgPCAwKSB7XG4gICAgcmV0dXJuIEFuZ2xlLkNMT0NLV0lTRVxuICB9XG4gIHJldHVybiBBbmdsZS5OT05FXG59O1xuQW5nbGUuYW5nbGVCZXR3ZWVuT3JpZW50ZWQgPSBmdW5jdGlvbiBhbmdsZUJldHdlZW5PcmllbnRlZCAodGlwMSwgdGFpbCwgdGlwMikge1xuICB2YXIgYTEgPSBBbmdsZS5hbmdsZSh0YWlsLCB0aXAxKTtcbiAgdmFyIGEyID0gQW5nbGUuYW5nbGUodGFpbCwgdGlwMik7XG4gIHZhciBhbmdEZWwgPSBhMiAtIGExO1xuICBpZiAoYW5nRGVsIDw9IC1NYXRoLlBJKSB7IHJldHVybiBhbmdEZWwgKyBBbmdsZS5QSV9USU1FU18yIH1cbiAgaWYgKGFuZ0RlbCA+IE1hdGguUEkpIHsgcmV0dXJuIGFuZ0RlbCAtIEFuZ2xlLlBJX1RJTUVTXzIgfVxuICByZXR1cm4gYW5nRGVsXG59O1xuc3RhdGljQWNjZXNzb3JzJDI5LlBJX1RJTUVTXzIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMi4wICogTWF0aC5QSSB9O1xuc3RhdGljQWNjZXNzb3JzJDI5LlBJX09WRVJfMi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXRoLlBJIC8gMi4wIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjkuUElfT1ZFUl80LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1hdGguUEkgLyA0LjAgfTtcbnN0YXRpY0FjY2Vzc29ycyQyOS5DT1VOVEVSQ0xPQ0tXSVNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5DT1VOVEVSQ0xPQ0tXSVNFIH07XG5zdGF0aWNBY2Nlc3NvcnMkMjkuQ0xPQ0tXSVNFLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5DTE9DS1dJU0UgfTtcbnN0YXRpY0FjY2Vzc29ycyQyOS5OT05FLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENHQWxnb3JpdGhtcy5DT0xMSU5FQVIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEFuZ2xlLCBzdGF0aWNBY2Nlc3NvcnMkMjkgKTtcblxudmFyIE9mZnNldFNlZ21lbnRHZW5lcmF0b3IgPSBmdW5jdGlvbiBPZmZzZXRTZWdtZW50R2VuZXJhdG9yICgpIHtcbiAgdGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3IgPSAwLjA7XG4gIHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bSA9IG51bGw7XG4gIHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgPSAxO1xuICB0aGlzLl9zZWdMaXN0ID0gbnVsbDtcbiAgdGhpcy5fZGlzdGFuY2UgPSAwLjA7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gbnVsbDtcbiAgdGhpcy5fYnVmUGFyYW1zID0gbnVsbDtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9zMCA9IG51bGw7XG4gIHRoaXMuX3MxID0gbnVsbDtcbiAgdGhpcy5fczIgPSBudWxsO1xuICB0aGlzLl9zZWcwID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX3NlZzEgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fb2Zmc2V0MCA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9vZmZzZXQxID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHRoaXMuX3NpZGUgPSAwO1xuICB0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGUgPSBmYWxzZTtcbiAgdmFyIHByZWNpc2lvbk1vZGVsID0gYXJndW1lbnRzWzBdO1xuICB2YXIgYnVmUGFyYW1zID0gYXJndW1lbnRzWzFdO1xuICB2YXIgZGlzdGFuY2UgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gcHJlY2lzaW9uTW9kZWw7XG4gIHRoaXMuX2J1ZlBhcmFtcyA9IGJ1ZlBhcmFtcztcbiAgdGhpcy5fbGkgPSBuZXcgUm9idXN0TGluZUludGVyc2VjdG9yKCk7XG4gIHRoaXMuX2ZpbGxldEFuZ2xlUXVhbnR1bSA9IE1hdGguUEkgLyAyLjAgLyBidWZQYXJhbXMuZ2V0UXVhZHJhbnRTZWdtZW50cygpO1xuICBpZiAoYnVmUGFyYW1zLmdldFF1YWRyYW50U2VnbWVudHMoKSA+PSA4ICYmIGJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKSA9PT0gQnVmZmVyUGFyYW1ldGVycy5KT0lOX1JPVU5EKSB7IHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgPSBPZmZzZXRTZWdtZW50R2VuZXJhdG9yLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SOyB9XG4gIHRoaXMuaW5pdChkaXN0YW5jZSk7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDI3ID0geyBPRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUjogeyBjb25maWd1cmFibGU6IHRydWUgfSxJTlNJREVfVFVSTl9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LE1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGROZXh0U2VnbWVudCA9IGZ1bmN0aW9uIGFkZE5leHRTZWdtZW50IChwLCBhZGRTdGFydFBvaW50KSB7XG4gIHRoaXMuX3MwID0gdGhpcy5fczE7XG4gIHRoaXMuX3MxID0gdGhpcy5fczI7XG4gIHRoaXMuX3MyID0gcDtcbiAgdGhpcy5fc2VnMC5zZXRDb29yZGluYXRlcyh0aGlzLl9zMCwgdGhpcy5fczEpO1xuICB0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzAsIHRoaXMuX3NpZGUsIHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl9vZmZzZXQwKTtcbiAgdGhpcy5fc2VnMS5zZXRDb29yZGluYXRlcyh0aGlzLl9zMSwgdGhpcy5fczIpO1xuICB0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuX3NlZzEsIHRoaXMuX3NpZGUsIHRoaXMuX2Rpc3RhbmNlLCB0aGlzLl9vZmZzZXQxKTtcbiAgaWYgKHRoaXMuX3MxLmVxdWFscyh0aGlzLl9zMikpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgb3JpZW50YXRpb24gPSBDR0FsZ29yaXRobXMuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMuX3MwLCB0aGlzLl9zMSwgdGhpcy5fczIpO1xuICB2YXIgb3V0c2lkZVR1cm4gPSAob3JpZW50YXRpb24gPT09IENHQWxnb3JpdGhtcy5DTE9DS1dJU0UgJiYgdGhpcy5fc2lkZSA9PT0gUG9zaXRpb24uTEVGVCkgfHwgKG9yaWVudGF0aW9uID09PSBDR0FsZ29yaXRobXMuQ09VTlRFUkNMT0NLV0lTRSAmJiB0aGlzLl9zaWRlID09PSBQb3NpdGlvbi5SSUdIVCk7XG4gIGlmIChvcmllbnRhdGlvbiA9PT0gMCkge1xuICAgIHRoaXMuYWRkQ29sbGluZWFyKGFkZFN0YXJ0UG9pbnQpO1xuICB9IGVsc2UgaWYgKG91dHNpZGVUdXJuKSB7XG4gICAgdGhpcy5hZGRPdXRzaWRlVHVybihvcmllbnRhdGlvbiwgYWRkU3RhcnRQb2ludCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5hZGRJbnNpZGVUdXJuKG9yaWVudGF0aW9uLCBhZGRTdGFydFBvaW50KTtcbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZExpbmVFbmRDYXAgPSBmdW5jdGlvbiBhZGRMaW5lRW5kQ2FwIChwMCwgcDEpIHtcbiAgdmFyIHNlZyA9IG5ldyBMaW5lU2VnbWVudChwMCwgcDEpO1xuICB2YXIgb2Zmc2V0TCA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHNlZywgUG9zaXRpb24uTEVGVCwgdGhpcy5fZGlzdGFuY2UsIG9mZnNldEwpO1xuICB2YXIgb2Zmc2V0UiA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHNlZywgUG9zaXRpb24uUklHSFQsIHRoaXMuX2Rpc3RhbmNlLCBvZmZzZXRSKTtcbiAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gIHN3aXRjaCAodGhpcy5fYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpIHtcbiAgICBjYXNlIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX1JPVU5EOlxuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChvZmZzZXRMLnAxKTtcbiAgICAgIHRoaXMuYWRkRmlsbGV0QXJjKHAxLCBhbmdsZSArIE1hdGguUEkgLyAyLCBhbmdsZSAtIE1hdGguUEkgLyAyLCBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFLCB0aGlzLl9kaXN0YW5jZSk7XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KG9mZnNldFIucDEpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX0ZMQVQ6XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KG9mZnNldEwucDEpO1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChvZmZzZXRSLnAxKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9TUVVBUkU6XG4gICAgICB2YXIgc3F1YXJlQ2FwU2lkZU9mZnNldCA9IG5ldyBDb29yZGluYXRlKCk7XG4gICAgICBzcXVhcmVDYXBTaWRlT2Zmc2V0LnggPSBNYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICBzcXVhcmVDYXBTaWRlT2Zmc2V0LnkgPSBNYXRoLmFicyh0aGlzLl9kaXN0YW5jZSkgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgc3F1YXJlQ2FwTE9mZnNldCA9IG5ldyBDb29yZGluYXRlKG9mZnNldEwucDEueCArIHNxdWFyZUNhcFNpZGVPZmZzZXQueCwgb2Zmc2V0TC5wMS55ICsgc3F1YXJlQ2FwU2lkZU9mZnNldC55KTtcbiAgICAgIHZhciBzcXVhcmVDYXBST2Zmc2V0ID0gbmV3IENvb3JkaW5hdGUob2Zmc2V0Ui5wMS54ICsgc3F1YXJlQ2FwU2lkZU9mZnNldC54LCBvZmZzZXRSLnAxLnkgKyBzcXVhcmVDYXBTaWRlT2Zmc2V0LnkpO1xuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChzcXVhcmVDYXBMT2Zmc2V0KTtcbiAgICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoc3F1YXJlQ2FwUk9mZnNldCk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgdmFyIHB0cyA9IHRoaXMuX3NlZ0xpc3QuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgcmV0dXJuIHB0c1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZE1pdHJlSm9pbiA9IGZ1bmN0aW9uIGFkZE1pdHJlSm9pbiAocCwgb2Zmc2V0MCwgb2Zmc2V0MSwgZGlzdGFuY2UpIHtcbiAgdmFyIGlzTWl0cmVXaXRoaW5MaW1pdCA9IHRydWU7XG4gIHZhciBpbnRQdCA9IG51bGw7XG4gIHRyeSB7XG4gICAgaW50UHQgPSBIQ29vcmRpbmF0ZS5pbnRlcnNlY3Rpb24ob2Zmc2V0MC5wMCwgb2Zmc2V0MC5wMSwgb2Zmc2V0MS5wMCwgb2Zmc2V0MS5wMSk7XG4gICAgdmFyIG1pdHJlUmF0aW8gPSBkaXN0YW5jZSA8PSAwLjAgPyAxLjAgOiBpbnRQdC5kaXN0YW5jZShwKSAvIE1hdGguYWJzKGRpc3RhbmNlKTtcbiAgICBpZiAobWl0cmVSYXRpbyA+IHRoaXMuX2J1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkpIHsgaXNNaXRyZVdpdGhpbkxpbWl0ID0gZmFsc2U7IH1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZXggaW5zdGFuY2VvZiBOb3RSZXByZXNlbnRhYmxlRXhjZXB0aW9uKSB7XG4gICAgICBpbnRQdCA9IG5ldyBDb29yZGluYXRlKDAsIDApO1xuICAgICAgaXNNaXRyZVdpdGhpbkxpbWl0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHsgdGhyb3cgZXggfVxuICB9IGZpbmFsbHkge31cbiAgaWYgKGlzTWl0cmVXaXRoaW5MaW1pdCkge1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoaW50UHQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuYWRkTGltaXRlZE1pdHJlSm9pbihvZmZzZXQwLCBvZmZzZXQxLCBkaXN0YW5jZSwgdGhpcy5fYnVmUGFyYW1zLmdldE1pdHJlTGltaXQoKSk7XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRGaWxsZXRDb3JuZXIgPSBmdW5jdGlvbiBhZGRGaWxsZXRDb3JuZXIgKHAsIHAwLCBwMSwgZGlyZWN0aW9uLCByYWRpdXMpIHtcbiAgdmFyIGR4MCA9IHAwLnggLSBwLng7XG4gIHZhciBkeTAgPSBwMC55IC0gcC55O1xuICB2YXIgc3RhcnRBbmdsZSA9IE1hdGguYXRhbjIoZHkwLCBkeDApO1xuICB2YXIgZHgxID0gcDEueCAtIHAueDtcbiAgdmFyIGR5MSA9IHAxLnkgLSBwLnk7XG4gIHZhciBlbmRBbmdsZSA9IE1hdGguYXRhbjIoZHkxLCBkeDEpO1xuICBpZiAoZGlyZWN0aW9uID09PSBDR0FsZ29yaXRobXMuQ0xPQ0tXSVNFKSB7XG4gICAgaWYgKHN0YXJ0QW5nbGUgPD0gZW5kQW5nbGUpIHsgc3RhcnRBbmdsZSArPSAyLjAgKiBNYXRoLlBJOyB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHN0YXJ0QW5nbGUgPj0gZW5kQW5nbGUpIHsgc3RhcnRBbmdsZSAtPSAyLjAgKiBNYXRoLlBJOyB9XG4gIH1cbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChwMCk7XG4gIHRoaXMuYWRkRmlsbGV0QXJjKHAsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBkaXJlY3Rpb24sIHJhZGl1cyk7XG4gIHRoaXMuX3NlZ0xpc3QuYWRkUHQocDEpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZE91dHNpZGVUdXJuID0gZnVuY3Rpb24gYWRkT3V0c2lkZVR1cm4gKG9yaWVudGF0aW9uLCBhZGRTdGFydFBvaW50KSB7XG4gIGlmICh0aGlzLl9vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMuX29mZnNldDEucDApIDwgdGhpcy5fZGlzdGFuY2UgKiBPZmZzZXRTZWdtZW50R2VuZXJhdG9yLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SKSB7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGlmICh0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCkgPT09IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9NSVRSRSkge1xuICAgIHRoaXMuYWRkTWl0cmVKb2luKHRoaXMuX3MxLCB0aGlzLl9vZmZzZXQwLCB0aGlzLl9vZmZzZXQxLCB0aGlzLl9kaXN0YW5jZSk7XG4gIH0gZWxzZSBpZiAodGhpcy5fYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpID09PSBCdWZmZXJQYXJhbWV0ZXJzLkpPSU5fQkVWRUwpIHtcbiAgICB0aGlzLmFkZEJldmVsSm9pbih0aGlzLl9vZmZzZXQwLCB0aGlzLl9vZmZzZXQxKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoYWRkU3RhcnRQb2ludCkgeyB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpOyB9XG4gICAgdGhpcy5hZGRGaWxsZXRDb3JuZXIodGhpcy5fczEsIHRoaXMuX29mZnNldDAucDEsIHRoaXMuX29mZnNldDEucDAsIG9yaWVudGF0aW9uLCB0aGlzLl9kaXN0YW5jZSk7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKTtcbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmNyZWF0ZVNxdWFyZSA9IGZ1bmN0aW9uIGNyZWF0ZVNxdWFyZSAocCkge1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBDb29yZGluYXRlKHAueCArIHRoaXMuX2Rpc3RhbmNlLCBwLnkgKyB0aGlzLl9kaXN0YW5jZSkpO1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBDb29yZGluYXRlKHAueCArIHRoaXMuX2Rpc3RhbmNlLCBwLnkgLSB0aGlzLl9kaXN0YW5jZSkpO1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBDb29yZGluYXRlKHAueCAtIHRoaXMuX2Rpc3RhbmNlLCBwLnkgLSB0aGlzLl9kaXN0YW5jZSkpO1xuICB0aGlzLl9zZWdMaXN0LmFkZFB0KG5ldyBDb29yZGluYXRlKHAueCAtIHRoaXMuX2Rpc3RhbmNlLCBwLnkgKyB0aGlzLl9kaXN0YW5jZSkpO1xuICB0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZFNlZ21lbnRzID0gZnVuY3Rpb24gYWRkU2VnbWVudHMgKHB0LCBpc0ZvcndhcmQpIHtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdHMocHQsIGlzRm9yd2FyZCk7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkRmlyc3RTZWdtZW50ID0gZnVuY3Rpb24gYWRkRmlyc3RTZWdtZW50ICgpIHtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRMYXN0U2VnbWVudCA9IGZ1bmN0aW9uIGFkZExhc3RTZWdtZW50ICgpIHtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAxKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5pbml0U2lkZVNlZ21lbnRzID0gZnVuY3Rpb24gaW5pdFNpZGVTZWdtZW50cyAoczEsIHMyLCBzaWRlKSB7XG4gIHRoaXMuX3MxID0gczE7XG4gIHRoaXMuX3MyID0gczI7XG4gIHRoaXMuX3NpZGUgPSBzaWRlO1xuICB0aGlzLl9zZWcxLnNldENvb3JkaW5hdGVzKHMxLCBzMik7XG4gIHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5fc2VnMSwgc2lkZSwgdGhpcy5fZGlzdGFuY2UsIHRoaXMuX29mZnNldDEpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZExpbWl0ZWRNaXRyZUpvaW4gPSBmdW5jdGlvbiBhZGRMaW1pdGVkTWl0cmVKb2luIChvZmZzZXQwLCBvZmZzZXQxLCBkaXN0YW5jZSwgbWl0cmVMaW1pdCkge1xuICB2YXIgYmFzZVB0ID0gdGhpcy5fc2VnMC5wMTtcbiAgdmFyIGFuZzAgPSBBbmdsZS5hbmdsZShiYXNlUHQsIHRoaXMuX3NlZzAucDApO1xuICAvLyBjb25zdCBhbmcxID0gQW5nbGUuYW5nbGUoYmFzZVB0LCB0aGlzLl9zZWcxLnAxKVxuICB2YXIgYW5nRGlmZiA9IEFuZ2xlLmFuZ2xlQmV0d2Vlbk9yaWVudGVkKHRoaXMuX3NlZzAucDAsIGJhc2VQdCwgdGhpcy5fc2VnMS5wMSk7XG4gIHZhciBhbmdEaWZmSGFsZiA9IGFuZ0RpZmYgLyAyO1xuICB2YXIgbWlkQW5nID0gQW5nbGUubm9ybWFsaXplKGFuZzAgKyBhbmdEaWZmSGFsZik7XG4gIHZhciBtaXRyZU1pZEFuZyA9IEFuZ2xlLm5vcm1hbGl6ZShtaWRBbmcgKyBNYXRoLlBJKTtcbiAgdmFyIG1pdHJlRGlzdCA9IG1pdHJlTGltaXQgKiBkaXN0YW5jZTtcbiAgdmFyIGJldmVsRGVsdGEgPSBtaXRyZURpc3QgKiBNYXRoLmFicyhNYXRoLnNpbihhbmdEaWZmSGFsZikpO1xuICB2YXIgYmV2ZWxIYWxmTGVuID0gZGlzdGFuY2UgLSBiZXZlbERlbHRhO1xuICB2YXIgYmV2ZWxNaWRYID0gYmFzZVB0LnggKyBtaXRyZURpc3QgKiBNYXRoLmNvcyhtaXRyZU1pZEFuZyk7XG4gIHZhciBiZXZlbE1pZFkgPSBiYXNlUHQueSArIG1pdHJlRGlzdCAqIE1hdGguc2luKG1pdHJlTWlkQW5nKTtcbiAgdmFyIGJldmVsTWlkUHQgPSBuZXcgQ29vcmRpbmF0ZShiZXZlbE1pZFgsIGJldmVsTWlkWSk7XG4gIHZhciBtaXRyZU1pZExpbmUgPSBuZXcgTGluZVNlZ21lbnQoYmFzZVB0LCBiZXZlbE1pZFB0KTtcbiAgdmFyIGJldmVsRW5kTGVmdCA9IG1pdHJlTWlkTGluZS5wb2ludEFsb25nT2Zmc2V0KDEuMCwgYmV2ZWxIYWxmTGVuKTtcbiAgdmFyIGJldmVsRW5kUmlnaHQgPSBtaXRyZU1pZExpbmUucG9pbnRBbG9uZ09mZnNldCgxLjAsIC1iZXZlbEhhbGZMZW4pO1xuICBpZiAodGhpcy5fc2lkZSA9PT0gUG9zaXRpb24uTEVGVCkge1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoYmV2ZWxFbmRMZWZ0KTtcbiAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KGJldmVsRW5kUmlnaHQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX3NlZ0xpc3QuYWRkUHQoYmV2ZWxFbmRSaWdodCk7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdChiZXZlbEVuZExlZnQpO1xuICB9XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuY29tcHV0ZU9mZnNldFNlZ21lbnQgPSBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0U2VnbWVudCAoc2VnLCBzaWRlLCBkaXN0YW5jZSwgb2Zmc2V0KSB7XG4gIHZhciBzaWRlU2lnbiA9IHNpZGUgPT09IFBvc2l0aW9uLkxFRlQgPyAxIDogLTE7XG4gIHZhciBkeCA9IHNlZy5wMS54IC0gc2VnLnAwLng7XG4gIHZhciBkeSA9IHNlZy5wMS55IC0gc2VnLnAwLnk7XG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICB2YXIgdXggPSBzaWRlU2lnbiAqIGRpc3RhbmNlICogZHggLyBsZW47XG4gIHZhciB1eSA9IHNpZGVTaWduICogZGlzdGFuY2UgKiBkeSAvIGxlbjtcbiAgb2Zmc2V0LnAwLnggPSBzZWcucDAueCAtIHV5O1xuICBvZmZzZXQucDAueSA9IHNlZy5wMC55ICsgdXg7XG4gIG9mZnNldC5wMS54ID0gc2VnLnAxLnggLSB1eTtcbiAgb2Zmc2V0LnAxLnkgPSBzZWcucDEueSArIHV4O1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmFkZEZpbGxldEFyYyA9IGZ1bmN0aW9uIGFkZEZpbGxldEFyYyAocCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGRpcmVjdGlvbiwgcmFkaXVzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGRpcmVjdGlvbkZhY3RvciA9IGRpcmVjdGlvbiA9PT0gQ0dBbGdvcml0aG1zLkNMT0NLV0lTRSA/IC0xIDogMTtcbiAgdmFyIHRvdGFsQW5nbGUgPSBNYXRoLmFicyhzdGFydEFuZ2xlIC0gZW5kQW5nbGUpO1xuICB2YXIgblNlZ3MgPSBNYXRoLnRydW5jKHRvdGFsQW5nbGUgLyB0aGlzLl9maWxsZXRBbmdsZVF1YW50dW0gKyAwLjUpO1xuICBpZiAoblNlZ3MgPCAxKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGluaXRBbmdsZSA9IDAuMDtcbiAgdmFyIGN1cnJBbmdsZUluYyA9IHRvdGFsQW5nbGUgLyBuU2VncztcbiAgdmFyIGN1cnJBbmdsZSA9IGluaXRBbmdsZTtcbiAgdmFyIHB0ID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgd2hpbGUgKGN1cnJBbmdsZSA8IHRvdGFsQW5nbGUpIHtcbiAgICB2YXIgYW5nbGUgPSBzdGFydEFuZ2xlICsgZGlyZWN0aW9uRmFjdG9yICogY3VyckFuZ2xlO1xuICAgIHB0LnggPSBwLnggKyByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgcHQueSA9IHAueSArIHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICB0aGlzJDEuX3NlZ0xpc3QuYWRkUHQocHQpO1xuICAgIGN1cnJBbmdsZSArPSBjdXJyQW5nbGVJbmM7XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRJbnNpZGVUdXJuID0gZnVuY3Rpb24gYWRkSW5zaWRlVHVybiAob3JpZW50YXRpb24sIGFkZFN0YXJ0UG9pbnQpIHtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLl9vZmZzZXQwLnAwLCB0aGlzLl9vZmZzZXQwLnAxLCB0aGlzLl9vZmZzZXQxLnAwLCB0aGlzLl9vZmZzZXQxLnAxKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb24oMCkpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX29mZnNldDAucDEuZGlzdGFuY2UodGhpcy5fb2Zmc2V0MS5wMCkgPCB0aGlzLl9kaXN0YW5jZSAqIE9mZnNldFNlZ21lbnRHZW5lcmF0b3IuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKSB7XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDAucDEpO1xuICAgICAgaWYgKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgPiAwKSB7XG4gICAgICAgIHZhciBtaWQwID0gbmV3IENvb3JkaW5hdGUoKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKiB0aGlzLl9vZmZzZXQwLnAxLnggKyB0aGlzLl9zMS54KSAvICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICsgMSksICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICogdGhpcy5fb2Zmc2V0MC5wMS55ICsgdGhpcy5fczEueSkgLyAodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciArIDEpKTtcbiAgICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdChtaWQwKTtcbiAgICAgICAgdmFyIG1pZDEgPSBuZXcgQ29vcmRpbmF0ZSgodGhpcy5fY2xvc2luZ1NlZ0xlbmd0aEZhY3RvciAqIHRoaXMuX29mZnNldDEucDAueCArIHRoaXMuX3MxLngpIC8gKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKyAxKSwgKHRoaXMuX2Nsb3NpbmdTZWdMZW5ndGhGYWN0b3IgKiB0aGlzLl9vZmZzZXQxLnAwLnkgKyB0aGlzLl9zMS55KSAvICh0aGlzLl9jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yICsgMSkpO1xuICAgICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KG1pZDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9zMSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zZWdMaXN0LmFkZFB0KHRoaXMuX29mZnNldDEucDApO1xuICAgIH1cbiAgfVxufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmNyZWF0ZUNpcmNsZSA9IGZ1bmN0aW9uIGNyZWF0ZUNpcmNsZSAocCkge1xuICB2YXIgcHQgPSBuZXcgQ29vcmRpbmF0ZShwLnggKyB0aGlzLl9kaXN0YW5jZSwgcC55KTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChwdCk7XG4gIHRoaXMuYWRkRmlsbGV0QXJjKHAsIDAuMCwgMi4wICogTWF0aC5QSSwgLTEsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgdGhpcy5fc2VnTGlzdC5jbG9zZVJpbmcoKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5hZGRCZXZlbEpvaW4gPSBmdW5jdGlvbiBhZGRCZXZlbEpvaW4gKG9mZnNldDAsIG9mZnNldDEpIHtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChvZmZzZXQwLnAxKTtcbiAgdGhpcy5fc2VnTGlzdC5hZGRQdChvZmZzZXQxLnAwKTtcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoZGlzdGFuY2UpIHtcbiAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgdGhpcy5fbWF4Q3VydmVTZWdtZW50RXJyb3IgPSBkaXN0YW5jZSAqICgxIC0gTWF0aC5jb3ModGhpcy5fZmlsbGV0QW5nbGVRdWFudHVtIC8gMi4wKSk7XG4gIHRoaXMuX3NlZ0xpc3QgPSBuZXcgT2Zmc2V0U2VnbWVudFN0cmluZygpO1xuICB0aGlzLl9zZWdMaXN0LnNldFByZWNpc2lvbk1vZGVsKHRoaXMuX3ByZWNpc2lvbk1vZGVsKTtcbiAgdGhpcy5fc2VnTGlzdC5zZXRNaW5pbXVtVmVydGV4RGlzdGFuY2UoZGlzdGFuY2UgKiBPZmZzZXRTZWdtZW50R2VuZXJhdG9yLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUik7XG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuYWRkQ29sbGluZWFyID0gZnVuY3Rpb24gYWRkQ29sbGluZWFyIChhZGRTdGFydFBvaW50KSB7XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5fczAsIHRoaXMuX3MxLCB0aGlzLl9zMSwgdGhpcy5fczIpO1xuICB2YXIgbnVtSW50ID0gdGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7XG4gIGlmIChudW1JbnQgPj0gMikge1xuICAgIGlmICh0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCkgPT09IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9CRVZFTCB8fCB0aGlzLl9idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCkgPT09IEJ1ZmZlclBhcmFtZXRlcnMuSk9JTl9NSVRSRSkge1xuICAgICAgaWYgKGFkZFN0YXJ0UG9pbnQpIHsgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQwLnAxKTsgfVxuICAgICAgdGhpcy5fc2VnTGlzdC5hZGRQdCh0aGlzLl9vZmZzZXQxLnAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRGaWxsZXRDb3JuZXIodGhpcy5fczEsIHRoaXMuX29mZnNldDAucDEsIHRoaXMuX29mZnNldDEucDAsIENHQWxnb3JpdGhtcy5DTE9DS1dJU0UsIHRoaXMuX2Rpc3RhbmNlKTtcbiAgICB9XG4gIH1cbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5jbG9zZVJpbmcgPSBmdW5jdGlvbiBjbG9zZVJpbmcgKCkge1xuICB0aGlzLl9zZWdMaXN0LmNsb3NlUmluZygpO1xufTtcbk9mZnNldFNlZ21lbnRHZW5lcmF0b3IucHJvdG90eXBlLmhhc05hcnJvd0NvbmNhdmVBbmdsZSA9IGZ1bmN0aW9uIGhhc05hcnJvd0NvbmNhdmVBbmdsZSAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGVcbn07XG5PZmZzZXRTZWdtZW50R2VuZXJhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT2Zmc2V0U2VnbWVudEdlbmVyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPZmZzZXRTZWdtZW50R2VuZXJhdG9yXG59O1xuc3RhdGljQWNjZXNzb3JzJDI3Lk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDEuMEUtMyB9O1xuc3RhdGljQWNjZXNzb3JzJDI3LklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUi5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxLjBFLTMgfTtcbnN0YXRpY0FjY2Vzc29ycyQyNy5DVVJWRV9WRVJURVhfU05BUF9ESVNUQU5DRV9GQUNUT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMS4wRS02IH07XG5zdGF0aWNBY2Nlc3NvcnMkMjcuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gODAgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE9mZnNldFNlZ21lbnRHZW5lcmF0b3IsIHN0YXRpY0FjY2Vzc29ycyQyNyApO1xuXG52YXIgT2Zmc2V0Q3VydmVCdWlsZGVyID0gZnVuY3Rpb24gT2Zmc2V0Q3VydmVCdWlsZGVyICgpIHtcbiAgdGhpcy5fZGlzdGFuY2UgPSAwLjA7XG4gIHRoaXMuX3ByZWNpc2lvbk1vZGVsID0gbnVsbDtcbiAgdGhpcy5fYnVmUGFyYW1zID0gbnVsbDtcbiAgdmFyIHByZWNpc2lvbk1vZGVsID0gYXJndW1lbnRzWzBdO1xuICB2YXIgYnVmUGFyYW1zID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl9wcmVjaXNpb25Nb2RlbCA9IHByZWNpc2lvbk1vZGVsO1xuICB0aGlzLl9idWZQYXJhbXMgPSBidWZQYXJhbXM7XG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5nZXRPZmZzZXRDdXJ2ZSA9IGZ1bmN0aW9uIGdldE9mZnNldEN1cnZlIChpbnB1dFB0cywgZGlzdGFuY2UpIHtcbiAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgaWYgKGRpc3RhbmNlID09PSAwLjApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgaXNSaWdodFNpZGUgPSBkaXN0YW5jZSA8IDAuMDtcbiAgdmFyIHBvc0Rpc3RhbmNlID0gTWF0aC5hYnMoZGlzdGFuY2UpO1xuICB2YXIgc2VnR2VuID0gdGhpcy5nZXRTZWdHZW4ocG9zRGlzdGFuY2UpO1xuICBpZiAoaW5wdXRQdHMubGVuZ3RoIDw9IDEpIHtcbiAgICB0aGlzLmNvbXB1dGVQb2ludEN1cnZlKGlucHV0UHRzWzBdLCBzZWdHZW4pO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY29tcHV0ZU9mZnNldEN1cnZlKGlucHV0UHRzLCBpc1JpZ2h0U2lkZSwgc2VnR2VuKTtcbiAgfVxuICB2YXIgY3VydmVQdHMgPSBzZWdHZW4uZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgaWYgKGlzUmlnaHRTaWRlKSB7IENvb3JkaW5hdGVBcnJheXMucmV2ZXJzZShjdXJ2ZVB0cyk7IH1cbiAgcmV0dXJuIGN1cnZlUHRzXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSA9IGZ1bmN0aW9uIGNvbXB1dGVTaW5nbGVTaWRlZEJ1ZmZlckN1cnZlIChpbnB1dFB0cywgaXNSaWdodFNpZGUsIHNlZ0dlbikge1xuICB2YXIgZGlzdFRvbCA9IHRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO1xuICBpZiAoaXNSaWdodFNpZGUpIHtcbiAgICBzZWdHZW4uYWRkU2VnbWVudHMoaW5wdXRQdHMsIHRydWUpO1xuICAgIHZhciBzaW1wMiA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkoaW5wdXRQdHMsIC1kaXN0VG9sKTtcbiAgICB2YXIgbjIgPSBzaW1wMi5sZW5ndGggLSAxO1xuICAgIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXAyW24yXSwgc2ltcDJbbjIgLSAxXSwgUG9zaXRpb24uTEVGVCk7XG4gICAgc2VnR2VuLmFkZEZpcnN0U2VnbWVudCgpO1xuICAgIGZvciAodmFyIGkgPSBuMiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDJbaV0sIHRydWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZWdHZW4uYWRkU2VnbWVudHMoaW5wdXRQdHMsIGZhbHNlKTtcbiAgICB2YXIgc2ltcDEgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCBkaXN0VG9sKTtcbiAgICB2YXIgbjEgPSBzaW1wMS5sZW5ndGggLSAxO1xuICAgIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXAxWzBdLCBzaW1wMVsxXSwgUG9zaXRpb24uTEVGVCk7XG4gICAgc2VnR2VuLmFkZEZpcnN0U2VnbWVudCgpO1xuICAgIGZvciAodmFyIGkkMSA9IDI7IGkkMSA8PSBuMTsgaSQxKyspIHtcbiAgICAgIHNlZ0dlbi5hZGROZXh0U2VnbWVudChzaW1wMVtpJDFdLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgc2VnR2VuLmFkZExhc3RTZWdtZW50KCk7XG4gIHNlZ0dlbi5jbG9zZVJpbmcoKTtcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUgPSBmdW5jdGlvbiBjb21wdXRlUmluZ0J1ZmZlckN1cnZlIChpbnB1dFB0cywgc2lkZSwgc2VnR2VuKSB7XG4gIHZhciBkaXN0VG9sID0gdGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7XG4gIGlmIChzaWRlID09PSBQb3NpdGlvbi5SSUdIVCkgeyBkaXN0VG9sID0gLWRpc3RUb2w7IH1cbiAgdmFyIHNpbXAgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCBkaXN0VG9sKTtcbiAgdmFyIG4gPSBzaW1wLmxlbmd0aCAtIDE7XG4gIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXBbbiAtIDFdLCBzaW1wWzBdLCBzaWRlKTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbjsgaSsrKSB7XG4gICAgdmFyIGFkZFN0YXJ0UG9pbnQgPSBpICE9PSAxO1xuICAgIHNlZ0dlbi5hZGROZXh0U2VnbWVudChzaW1wW2ldLCBhZGRTdGFydFBvaW50KTtcbiAgfVxuICBzZWdHZW4uY2xvc2VSaW5nKCk7XG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlTGluZUJ1ZmZlckN1cnZlID0gZnVuY3Rpb24gY29tcHV0ZUxpbmVCdWZmZXJDdXJ2ZSAoaW5wdXRQdHMsIHNlZ0dlbikge1xuICB2YXIgZGlzdFRvbCA9IHRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5fZGlzdGFuY2UpO1xuICB2YXIgc2ltcDEgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCBkaXN0VG9sKTtcbiAgdmFyIG4xID0gc2ltcDEubGVuZ3RoIC0gMTtcbiAgc2VnR2VuLmluaXRTaWRlU2VnbWVudHMoc2ltcDFbMF0sIHNpbXAxWzFdLCBQb3NpdGlvbi5MRUZUKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPD0gbjE7IGkrKykge1xuICAgIHNlZ0dlbi5hZGROZXh0U2VnbWVudChzaW1wMVtpXSwgdHJ1ZSk7XG4gIH1cbiAgc2VnR2VuLmFkZExhc3RTZWdtZW50KCk7XG4gIHNlZ0dlbi5hZGRMaW5lRW5kQ2FwKHNpbXAxW24xIC0gMV0sIHNpbXAxW24xXSk7XG4gIHZhciBzaW1wMiA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkoaW5wdXRQdHMsIC1kaXN0VG9sKTtcbiAgdmFyIG4yID0gc2ltcDIubGVuZ3RoIC0gMTtcbiAgc2VnR2VuLmluaXRTaWRlU2VnbWVudHMoc2ltcDJbbjJdLCBzaW1wMltuMiAtIDFdLCBQb3NpdGlvbi5MRUZUKTtcbiAgZm9yICh2YXIgaSQxID0gbjIgLSAyOyBpJDEgPj0gMDsgaSQxLS0pIHtcbiAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDJbaSQxXSwgdHJ1ZSk7XG4gIH1cbiAgc2VnR2VuLmFkZExhc3RTZWdtZW50KCk7XG4gIHNlZ0dlbi5hZGRMaW5lRW5kQ2FwKHNpbXAyWzFdLCBzaW1wMlswXSk7XG4gIHNlZ0dlbi5jbG9zZVJpbmcoKTtcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmNvbXB1dGVQb2ludEN1cnZlID0gZnVuY3Rpb24gY29tcHV0ZVBvaW50Q3VydmUgKHB0LCBzZWdHZW4pIHtcbiAgc3dpdGNoICh0aGlzLl9idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSkge1xuICAgIGNhc2UgQnVmZmVyUGFyYW1ldGVycy5DQVBfUk9VTkQ6XG4gICAgICBzZWdHZW4uY3JlYXRlQ2lyY2xlKHB0KTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9TUVVBUkU6XG4gICAgICBzZWdHZW4uY3JlYXRlU3F1YXJlKHB0KTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgfVxufTtcbk9mZnNldEN1cnZlQnVpbGRlci5wcm90b3R5cGUuZ2V0TGluZUN1cnZlID0gZnVuY3Rpb24gZ2V0TGluZUN1cnZlIChpbnB1dFB0cywgZGlzdGFuY2UpIHtcbiAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgaWYgKGRpc3RhbmNlIDwgMC4wICYmICF0aGlzLl9idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGRpc3RhbmNlID09PSAwLjApIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgcG9zRGlzdGFuY2UgPSBNYXRoLmFicyhkaXN0YW5jZSk7XG4gIHZhciBzZWdHZW4gPSB0aGlzLmdldFNlZ0dlbihwb3NEaXN0YW5jZSk7XG4gIGlmIChpbnB1dFB0cy5sZW5ndGggPD0gMSkge1xuICAgIHRoaXMuY29tcHV0ZVBvaW50Q3VydmUoaW5wdXRQdHNbMF0sIHNlZ0dlbik7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHRoaXMuX2J1ZlBhcmFtcy5pc1NpbmdsZVNpZGVkKCkpIHtcbiAgICAgIHZhciBpc1JpZ2h0U2lkZSA9IGRpc3RhbmNlIDwgMC4wO1xuICAgICAgdGhpcy5jb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZShpbnB1dFB0cywgaXNSaWdodFNpZGUsIHNlZ0dlbik7XG4gICAgfSBlbHNlIHsgdGhpcy5jb21wdXRlTGluZUJ1ZmZlckN1cnZlKGlucHV0UHRzLCBzZWdHZW4pOyB9XG4gIH1cbiAgdmFyIGxpbmVDb29yZCA9IHNlZ0dlbi5nZXRDb29yZGluYXRlcygpO1xuICByZXR1cm4gbGluZUNvb3JkXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5nZXRCdWZmZXJQYXJhbWV0ZXJzID0gZnVuY3Rpb24gZ2V0QnVmZmVyUGFyYW1ldGVycyAoKSB7XG4gIHJldHVybiB0aGlzLl9idWZQYXJhbXNcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLnNpbXBsaWZ5VG9sZXJhbmNlID0gZnVuY3Rpb24gc2ltcGxpZnlUb2xlcmFuY2UgKGJ1ZkRpc3RhbmNlKSB7XG4gIHJldHVybiBidWZEaXN0YW5jZSAqIHRoaXMuX2J1ZlBhcmFtcy5nZXRTaW1wbGlmeUZhY3RvcigpXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5nZXRSaW5nQ3VydmUgPSBmdW5jdGlvbiBnZXRSaW5nQ3VydmUgKGlucHV0UHRzLCBzaWRlLCBkaXN0YW5jZSkge1xuICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICBpZiAoaW5wdXRQdHMubGVuZ3RoIDw9IDIpIHsgcmV0dXJuIHRoaXMuZ2V0TGluZUN1cnZlKGlucHV0UHRzLCBkaXN0YW5jZSkgfVxuICBpZiAoZGlzdGFuY2UgPT09IDAuMCkge1xuICAgIHJldHVybiBPZmZzZXRDdXJ2ZUJ1aWxkZXIuY29weUNvb3JkaW5hdGVzKGlucHV0UHRzKVxuICB9XG4gIHZhciBzZWdHZW4gPSB0aGlzLmdldFNlZ0dlbihkaXN0YW5jZSk7XG4gIHRoaXMuY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZShpbnB1dFB0cywgc2lkZSwgc2VnR2VuKTtcbiAgcmV0dXJuIHNlZ0dlbi5nZXRDb29yZGluYXRlcygpXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlT2Zmc2V0Q3VydmUgPSBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0Q3VydmUgKGlucHV0UHRzLCBpc1JpZ2h0U2lkZSwgc2VnR2VuKSB7XG4gIHZhciBkaXN0VG9sID0gdGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLl9kaXN0YW5jZSk7XG4gIGlmIChpc1JpZ2h0U2lkZSkge1xuICAgIHZhciBzaW1wMiA9IEJ1ZmZlcklucHV0TGluZVNpbXBsaWZpZXIuc2ltcGxpZnkoaW5wdXRQdHMsIC1kaXN0VG9sKTtcbiAgICB2YXIgbjIgPSBzaW1wMi5sZW5ndGggLSAxO1xuICAgIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXAyW24yXSwgc2ltcDJbbjIgLSAxXSwgUG9zaXRpb24uTEVGVCk7XG4gICAgc2VnR2VuLmFkZEZpcnN0U2VnbWVudCgpO1xuICAgIGZvciAodmFyIGkgPSBuMiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBzZWdHZW4uYWRkTmV4dFNlZ21lbnQoc2ltcDJbaV0sIHRydWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2ltcDEgPSBCdWZmZXJJbnB1dExpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KGlucHV0UHRzLCBkaXN0VG9sKTtcbiAgICB2YXIgbjEgPSBzaW1wMS5sZW5ndGggLSAxO1xuICAgIHNlZ0dlbi5pbml0U2lkZVNlZ21lbnRzKHNpbXAxWzBdLCBzaW1wMVsxXSwgUG9zaXRpb24uTEVGVCk7XG4gICAgc2VnR2VuLmFkZEZpcnN0U2VnbWVudCgpO1xuICAgIGZvciAodmFyIGkkMSA9IDI7IGkkMSA8PSBuMTsgaSQxKyspIHtcbiAgICAgIHNlZ0dlbi5hZGROZXh0U2VnbWVudChzaW1wMVtpJDFdLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgc2VnR2VuLmFkZExhc3RTZWdtZW50KCk7XG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLnByb3RvdHlwZS5nZXRTZWdHZW4gPSBmdW5jdGlvbiBnZXRTZWdHZW4gKGRpc3RhbmNlKSB7XG4gIHJldHVybiBuZXcgT2Zmc2V0U2VnbWVudEdlbmVyYXRvcih0aGlzLl9wcmVjaXNpb25Nb2RlbCwgdGhpcy5fYnVmUGFyYW1zLCBkaXN0YW5jZSlcbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5PZmZzZXRDdXJ2ZUJ1aWxkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gT2Zmc2V0Q3VydmVCdWlsZGVyXG59O1xuT2Zmc2V0Q3VydmVCdWlsZGVyLmNvcHlDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGNvcHlDb29yZGluYXRlcyAocHRzKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KHB0cy5sZW5ndGgpLmZpbGwobnVsbCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29weS5sZW5ndGg7IGkrKykge1xuICAgIGNvcHlbaV0gPSBuZXcgQ29vcmRpbmF0ZShwdHNbaV0pO1xuICB9XG4gIHJldHVybiBjb3B5XG59O1xuXG52YXIgU3ViZ3JhcGhEZXB0aExvY2F0ZXIgPSBmdW5jdGlvbiBTdWJncmFwaERlcHRoTG9jYXRlciAoKSB7XG4gIHRoaXMuX3N1YmdyYXBocyA9IG51bGw7XG4gIHRoaXMuX3NlZyA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICB0aGlzLl9jZ2EgPSBuZXcgQ0dBbGdvcml0aG1zKCk7XG4gIHZhciBzdWJncmFwaHMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3N1YmdyYXBocyA9IHN1YmdyYXBocztcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzAgPSB7IERlcHRoU2VnbWVudDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuU3ViZ3JhcGhEZXB0aExvY2F0ZXIucHJvdG90eXBlLmZpbmRTdGFiYmVkU2VnbWVudHMgPSBmdW5jdGlvbiBmaW5kU3RhYmJlZFNlZ21lbnRzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzdGFiYmluZ1JheUxlZnRQdCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc3RhYmJlZFNlZ21lbnRzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9zdWJncmFwaHMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgYnNnID0gaS5uZXh0KCk7XG4gICAgICB2YXIgZW52ID0gYnNnLmdldEVudmVsb3BlKCk7XG4gICAgICBpZiAoc3RhYmJpbmdSYXlMZWZ0UHQueSA8IGVudi5nZXRNaW5ZKCkgfHwgc3RhYmJpbmdSYXlMZWZ0UHQueSA+IGVudi5nZXRNYXhZKCkpIHsgY29udGludWUgfVxuICAgICAgdGhpcyQxLmZpbmRTdGFiYmVkU2VnbWVudHMoc3RhYmJpbmdSYXlMZWZ0UHQsIGJzZy5nZXREaXJlY3RlZEVkZ2VzKCksIHN0YWJiZWRTZWdtZW50cyk7XG4gICAgfVxuICAgIHJldHVybiBzdGFiYmVkU2VnbWVudHNcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMl0sIExpc3QpICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIERpcmVjdGVkRWRnZSkpIHtcbiAgICAgIHZhciBzdGFiYmluZ1JheUxlZnRQdCQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRpckVkZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgc3RhYmJlZFNlZ21lbnRzJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgcHRzID0gZGlyRWRnZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHB0cy5sZW5ndGggLSAxOyBpJDErKykge1xuICAgICAgICB0aGlzJDEuX3NlZy5wMCA9IHB0c1tpJDFdO1xuICAgICAgICB0aGlzJDEuX3NlZy5wMSA9IHB0c1tpJDEgKyAxXTtcbiAgICAgICAgaWYgKHRoaXMkMS5fc2VnLnAwLnkgPiB0aGlzJDEuX3NlZy5wMS55KSB7IHRoaXMkMS5fc2VnLnJldmVyc2UoKTsgfVxuICAgICAgICB2YXIgbWF4eCA9IE1hdGgubWF4KHRoaXMkMS5fc2VnLnAwLngsIHRoaXMkMS5fc2VnLnAxLngpO1xuICAgICAgICBpZiAobWF4eCA8IHN0YWJiaW5nUmF5TGVmdFB0JDEueCkgeyBjb250aW51ZSB9XG4gICAgICAgIGlmICh0aGlzJDEuX3NlZy5pc0hvcml6b250YWwoKSkgeyBjb250aW51ZSB9XG4gICAgICAgIGlmIChzdGFiYmluZ1JheUxlZnRQdCQxLnkgPCB0aGlzJDEuX3NlZy5wMC55IHx8IHN0YWJiaW5nUmF5TGVmdFB0JDEueSA+IHRoaXMkMS5fc2VnLnAxLnkpIHsgY29udGludWUgfVxuICAgICAgICBpZiAoQ0dBbGdvcml0aG1zLmNvbXB1dGVPcmllbnRhdGlvbih0aGlzJDEuX3NlZy5wMCwgdGhpcyQxLl9zZWcucDEsIHN0YWJiaW5nUmF5TGVmdFB0JDEpID09PSBDR0FsZ29yaXRobXMuUklHSFQpIHsgY29udGludWUgfVxuICAgICAgICB2YXIgZGVwdGggPSBkaXJFZGdlLmdldERlcHRoKFBvc2l0aW9uLkxFRlQpO1xuICAgICAgICBpZiAoIXRoaXMkMS5fc2VnLnAwLmVxdWFscyhwdHNbaSQxXSkpIHsgZGVwdGggPSBkaXJFZGdlLmdldERlcHRoKFBvc2l0aW9uLlJJR0hUKTsgfVxuICAgICAgICB2YXIgZHMgPSBuZXcgRGVwdGhTZWdtZW50KHRoaXMkMS5fc2VnLCBkZXB0aCk7XG4gICAgICAgIHN0YWJiZWRTZWdtZW50cyQxLmFkZChkcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzJdLCBMaXN0KSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBMaXN0KSkpIHtcbiAgICAgIHZhciBzdGFiYmluZ1JheUxlZnRQdCQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGRpckVkZ2VzID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHN0YWJiZWRTZWdtZW50cyQyID0gYXJndW1lbnRzWzJdO1xuICAgICAgZm9yICh2YXIgaSQyID0gZGlyRWRnZXMuaXRlcmF0b3IoKTsgaSQyLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGRlID0gaSQyLm5leHQoKTtcbiAgICAgICAgaWYgKCFkZS5pc0ZvcndhcmQoKSkgeyBjb250aW51ZSB9XG4gICAgICAgIHRoaXMkMS5maW5kU3RhYmJlZFNlZ21lbnRzKHN0YWJiaW5nUmF5TGVmdFB0JDIsIGRlLCBzdGFiYmVkU2VnbWVudHMkMik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuU3ViZ3JhcGhEZXB0aExvY2F0ZXIucHJvdG90eXBlLmdldERlcHRoID0gZnVuY3Rpb24gZ2V0RGVwdGggKHApIHtcbiAgdmFyIHN0YWJiZWRTZWdtZW50cyA9IHRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyhwKTtcbiAgaWYgKHN0YWJiZWRTZWdtZW50cy5zaXplKCkgPT09IDApIHsgcmV0dXJuIDAgfVxuICB2YXIgZHMgPSBDb2xsZWN0aW9ucy5taW4oc3RhYmJlZFNlZ21lbnRzKTtcbiAgcmV0dXJuIGRzLl9sZWZ0RGVwdGhcbn07XG5TdWJncmFwaERlcHRoTG9jYXRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblN1YmdyYXBoRGVwdGhMb2NhdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFN1YmdyYXBoRGVwdGhMb2NhdGVyXG59O1xuc3RhdGljQWNjZXNzb3JzJDMwLkRlcHRoU2VnbWVudC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBEZXB0aFNlZ21lbnQgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFN1YmdyYXBoRGVwdGhMb2NhdGVyLCBzdGF0aWNBY2Nlc3NvcnMkMzAgKTtcblxudmFyIERlcHRoU2VnbWVudCA9IGZ1bmN0aW9uIERlcHRoU2VnbWVudCAoKSB7XG4gIHRoaXMuX3Vwd2FyZFNlZyA9IG51bGw7XG4gIHRoaXMuX2xlZnREZXB0aCA9IG51bGw7XG4gIHZhciBzZWcgPSBhcmd1bWVudHNbMF07XG4gIHZhciBkZXB0aCA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fdXB3YXJkU2VnID0gbmV3IExpbmVTZWdtZW50KHNlZyk7XG4gIHRoaXMuX2xlZnREZXB0aCA9IGRlcHRoO1xufTtcbkRlcHRoU2VnbWVudC5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvYmopIHtcbiAgdmFyIG90aGVyID0gb2JqO1xuICBpZiAodGhpcy5fdXB3YXJkU2VnLm1pblgoKSA+PSBvdGhlci5fdXB3YXJkU2VnLm1heFgoKSkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLl91cHdhcmRTZWcubWF4WCgpIDw9IG90aGVyLl91cHdhcmRTZWcubWluWCgpKSB7IHJldHVybiAtMSB9XG4gIHZhciBvcmllbnRJbmRleCA9IHRoaXMuX3Vwd2FyZFNlZy5vcmllbnRhdGlvbkluZGV4KG90aGVyLl91cHdhcmRTZWcpO1xuICBpZiAob3JpZW50SW5kZXggIT09IDApIHsgcmV0dXJuIG9yaWVudEluZGV4IH1cbiAgb3JpZW50SW5kZXggPSAtMSAqIG90aGVyLl91cHdhcmRTZWcub3JpZW50YXRpb25JbmRleCh0aGlzLl91cHdhcmRTZWcpO1xuICBpZiAob3JpZW50SW5kZXggIT09IDApIHsgcmV0dXJuIG9yaWVudEluZGV4IH1cbiAgcmV0dXJuIHRoaXMuX3Vwd2FyZFNlZy5jb21wYXJlVG8ob3RoZXIuX3Vwd2FyZFNlZylcbn07XG5EZXB0aFNlZ21lbnQucHJvdG90eXBlLmNvbXBhcmVYID0gZnVuY3Rpb24gY29tcGFyZVggKHNlZzAsIHNlZzEpIHtcbiAgdmFyIGNvbXBhcmUwID0gc2VnMC5wMC5jb21wYXJlVG8oc2VnMS5wMCk7XG4gIGlmIChjb21wYXJlMCAhPT0gMCkgeyByZXR1cm4gY29tcGFyZTAgfVxuICByZXR1cm4gc2VnMC5wMS5jb21wYXJlVG8oc2VnMS5wMSlcbn07XG5EZXB0aFNlZ21lbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gdGhpcy5fdXB3YXJkU2VnLnRvU3RyaW5nKClcbn07XG5EZXB0aFNlZ21lbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0NvbXBhcmFibGVdXG59O1xuRGVwdGhTZWdtZW50LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERlcHRoU2VnbWVudFxufTtcblxudmFyIFRyaWFuZ2xlID0gZnVuY3Rpb24gVHJpYW5nbGUgKHAwLCBwMSwgcDIpIHtcbiAgdGhpcy5wMCA9IHAwIHx8IG51bGw7XG4gIHRoaXMucDEgPSBwMSB8fCBudWxsO1xuICB0aGlzLnAyID0gcDIgfHwgbnVsbDtcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuYXJlYSA9IGZ1bmN0aW9uIGFyZWEgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuYXJlYSh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5zaWduZWRBcmVhID0gZnVuY3Rpb24gc2lnbmVkQXJlYSAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5zaWduZWRBcmVhKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmludGVycG9sYXRlWiA9IGZ1bmN0aW9uIGludGVycG9sYXRlWiAocCkge1xuICBpZiAocCA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdTdXBwbGllZCBwb2ludCBpcyBudWxsLicpIH1cbiAgcmV0dXJuIFRyaWFuZ2xlLmludGVycG9sYXRlWihwLCB0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5sb25nZXN0U2lkZUxlbmd0aCA9IGZ1bmN0aW9uIGxvbmdlc3RTaWRlTGVuZ3RoICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmxvbmdlc3RTaWRlTGVuZ3RoKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmlzQWN1dGUgPSBmdW5jdGlvbiBpc0FjdXRlICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmlzQWN1dGUodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuY2lyY3VtY2VudHJlID0gZnVuY3Rpb24gY2lyY3VtY2VudHJlICgpIHtcbiAgcmV0dXJuIFRyaWFuZ2xlLmNpcmN1bWNlbnRyZSh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5hcmVhM0QgPSBmdW5jdGlvbiBhcmVhM0QgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuYXJlYTNEKHRoaXMucDAsIHRoaXMucDEsIHRoaXMucDIpXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmNlbnRyb2lkID0gZnVuY3Rpb24gY2VudHJvaWQgKCkge1xuICByZXR1cm4gVHJpYW5nbGUuY2VudHJvaWQodGhpcy5wMCwgdGhpcy5wMSwgdGhpcy5wMilcbn07XG5UcmlhbmdsZS5wcm90b3R5cGUuaW5DZW50cmUgPSBmdW5jdGlvbiBpbkNlbnRyZSAoKSB7XG4gIHJldHVybiBUcmlhbmdsZS5pbkNlbnRyZSh0aGlzLnAwLCB0aGlzLnAxLCB0aGlzLnAyKVxufTtcblRyaWFuZ2xlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuVHJpYW5nbGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gVHJpYW5nbGVcbn07XG5UcmlhbmdsZS5hcmVhID0gZnVuY3Rpb24gYXJlYSAoYSwgYiwgYykge1xuICByZXR1cm4gTWF0aC5hYnMoKChjLnggLSBhLngpICogKGIueSAtIGEueSkgLSAoYi54IC0gYS54KSAqIChjLnkgLSBhLnkpKSAvIDIpXG59O1xuVHJpYW5nbGUuc2lnbmVkQXJlYSA9IGZ1bmN0aW9uIHNpZ25lZEFyZWEgKGEsIGIsIGMpIHtcbiAgcmV0dXJuICgoYy54IC0gYS54KSAqIChiLnkgLSBhLnkpIC0gKGIueCAtIGEueCkgKiAoYy55IC0gYS55KSkgLyAyXG59O1xuVHJpYW5nbGUuZGV0ID0gZnVuY3Rpb24gZGV0IChtMDAsIG0wMSwgbTEwLCBtMTEpIHtcbiAgcmV0dXJuIG0wMCAqIG0xMSAtIG0wMSAqIG0xMFxufTtcblRyaWFuZ2xlLmludGVycG9sYXRlWiA9IGZ1bmN0aW9uIGludGVycG9sYXRlWiAocCwgdjAsIHYxLCB2Mikge1xuICB2YXIgeDAgPSB2MC54O1xuICB2YXIgeTAgPSB2MC55O1xuICB2YXIgYSA9IHYxLnggLSB4MDtcbiAgdmFyIGIgPSB2Mi54IC0geDA7XG4gIHZhciBjID0gdjEueSAtIHkwO1xuICB2YXIgZCA9IHYyLnkgLSB5MDtcbiAgdmFyIGRldCA9IGEgKiBkIC0gYiAqIGM7XG4gIHZhciBkeCA9IHAueCAtIHgwO1xuICB2YXIgZHkgPSBwLnkgLSB5MDtcbiAgdmFyIHQgPSAoZCAqIGR4IC0gYiAqIGR5KSAvIGRldDtcbiAgdmFyIHUgPSAoLWMgKiBkeCArIGEgKiBkeSkgLyBkZXQ7XG4gIHZhciB6ID0gdjAueiArIHQgKiAodjEueiAtIHYwLnopICsgdSAqICh2Mi56IC0gdjAueik7XG4gIHJldHVybiB6XG59O1xuVHJpYW5nbGUubG9uZ2VzdFNpZGVMZW5ndGggPSBmdW5jdGlvbiBsb25nZXN0U2lkZUxlbmd0aCAoYSwgYiwgYykge1xuICB2YXIgbGVuQUIgPSBhLmRpc3RhbmNlKGIpO1xuICB2YXIgbGVuQkMgPSBiLmRpc3RhbmNlKGMpO1xuICB2YXIgbGVuQ0EgPSBjLmRpc3RhbmNlKGEpO1xuICB2YXIgbWF4TGVuID0gbGVuQUI7XG4gIGlmIChsZW5CQyA+IG1heExlbikgeyBtYXhMZW4gPSBsZW5CQzsgfVxuICBpZiAobGVuQ0EgPiBtYXhMZW4pIHsgbWF4TGVuID0gbGVuQ0E7IH1cbiAgcmV0dXJuIG1heExlblxufTtcblRyaWFuZ2xlLmlzQWN1dGUgPSBmdW5jdGlvbiBpc0FjdXRlIChhLCBiLCBjKSB7XG4gIGlmICghQW5nbGUuaXNBY3V0ZShhLCBiLCBjKSkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAoIUFuZ2xlLmlzQWN1dGUoYiwgYywgYSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgaWYgKCFBbmdsZS5pc0FjdXRlKGMsIGEsIGIpKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0cnVlXG59O1xuVHJpYW5nbGUuY2lyY3VtY2VudHJlID0gZnVuY3Rpb24gY2lyY3VtY2VudHJlIChhLCBiLCBjKSB7XG4gIHZhciBjeCA9IGMueDtcbiAgdmFyIGN5ID0gYy55O1xuICB2YXIgYXggPSBhLnggLSBjeDtcbiAgdmFyIGF5ID0gYS55IC0gY3k7XG4gIHZhciBieCA9IGIueCAtIGN4O1xuICB2YXIgYnkgPSBiLnkgLSBjeTtcbiAgdmFyIGRlbm9tID0gMiAqIFRyaWFuZ2xlLmRldChheCwgYXksIGJ4LCBieSk7XG4gIHZhciBudW14ID0gVHJpYW5nbGUuZGV0KGF5LCBheCAqIGF4ICsgYXkgKiBheSwgYnksIGJ4ICogYnggKyBieSAqIGJ5KTtcbiAgdmFyIG51bXkgPSBUcmlhbmdsZS5kZXQoYXgsIGF4ICogYXggKyBheSAqIGF5LCBieCwgYnggKiBieCArIGJ5ICogYnkpO1xuICB2YXIgY2N4ID0gY3ggLSBudW14IC8gZGVub207XG4gIHZhciBjY3kgPSBjeSArIG51bXkgLyBkZW5vbTtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKGNjeCwgY2N5KVxufTtcblRyaWFuZ2xlLnBlcnBlbmRpY3VsYXJCaXNlY3RvciA9IGZ1bmN0aW9uIHBlcnBlbmRpY3VsYXJCaXNlY3RvciAoYSwgYikge1xuICB2YXIgZHggPSBiLnggLSBhLng7XG4gIHZhciBkeSA9IGIueSAtIGEueTtcbiAgdmFyIGwxID0gbmV3IEhDb29yZGluYXRlKGEueCArIGR4IC8gMi4wLCBhLnkgKyBkeSAvIDIuMCwgMS4wKTtcbiAgdmFyIGwyID0gbmV3IEhDb29yZGluYXRlKGEueCAtIGR5ICsgZHggLyAyLjAsIGEueSArIGR4ICsgZHkgLyAyLjAsIDEuMCk7XG4gIHJldHVybiBuZXcgSENvb3JkaW5hdGUobDEsIGwyKVxufTtcblRyaWFuZ2xlLmFuZ2xlQmlzZWN0b3IgPSBmdW5jdGlvbiBhbmdsZUJpc2VjdG9yIChhLCBiLCBjKSB7XG4gIHZhciBsZW4wID0gYi5kaXN0YW5jZShhKTtcbiAgdmFyIGxlbjIgPSBiLmRpc3RhbmNlKGMpO1xuICB2YXIgZnJhYyA9IGxlbjAgLyAobGVuMCArIGxlbjIpO1xuICB2YXIgZHggPSBjLnggLSBhLng7XG4gIHZhciBkeSA9IGMueSAtIGEueTtcbiAgdmFyIHNwbGl0UHQgPSBuZXcgQ29vcmRpbmF0ZShhLnggKyBmcmFjICogZHgsIGEueSArIGZyYWMgKiBkeSk7XG4gIHJldHVybiBzcGxpdFB0XG59O1xuVHJpYW5nbGUuYXJlYTNEID0gZnVuY3Rpb24gYXJlYTNEIChhLCBiLCBjKSB7XG4gIHZhciB1eCA9IGIueCAtIGEueDtcbiAgdmFyIHV5ID0gYi55IC0gYS55O1xuICB2YXIgdXogPSBiLnogLSBhLno7XG4gIHZhciB2eCA9IGMueCAtIGEueDtcbiAgdmFyIHZ5ID0gYy55IC0gYS55O1xuICB2YXIgdnogPSBjLnogLSBhLno7XG4gIHZhciBjcm9zc3ggPSB1eSAqIHZ6IC0gdXogKiB2eTtcbiAgdmFyIGNyb3NzeSA9IHV6ICogdnggLSB1eCAqIHZ6O1xuICB2YXIgY3Jvc3N6ID0gdXggKiB2eSAtIHV5ICogdng7XG4gIHZhciBhYnNTcSA9IGNyb3NzeCAqIGNyb3NzeCArIGNyb3NzeSAqIGNyb3NzeSArIGNyb3NzeiAqIGNyb3NzejtcbiAgdmFyIGFyZWEzRCA9IE1hdGguc3FydChhYnNTcSkgLyAyO1xuICByZXR1cm4gYXJlYTNEXG59O1xuVHJpYW5nbGUuY2VudHJvaWQgPSBmdW5jdGlvbiBjZW50cm9pZCAoYSwgYiwgYykge1xuICB2YXIgeCA9IChhLnggKyBiLnggKyBjLngpIC8gMztcbiAgdmFyIHkgPSAoYS55ICsgYi55ICsgYy55KSAvIDM7XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZSh4LCB5KVxufTtcblRyaWFuZ2xlLmluQ2VudHJlID0gZnVuY3Rpb24gaW5DZW50cmUgKGEsIGIsIGMpIHtcbiAgdmFyIGxlbjAgPSBiLmRpc3RhbmNlKGMpO1xuICB2YXIgbGVuMSA9IGEuZGlzdGFuY2UoYyk7XG4gIHZhciBsZW4yID0gYS5kaXN0YW5jZShiKTtcbiAgdmFyIGNpcmN1bSA9IGxlbjAgKyBsZW4xICsgbGVuMjtcbiAgdmFyIGluQ2VudHJlWCA9IChsZW4wICogYS54ICsgbGVuMSAqIGIueCArIGxlbjIgKiBjLngpIC8gY2lyY3VtO1xuICB2YXIgaW5DZW50cmVZID0gKGxlbjAgKiBhLnkgKyBsZW4xICogYi55ICsgbGVuMiAqIGMueSkgLyBjaXJjdW07XG4gIHJldHVybiBuZXcgQ29vcmRpbmF0ZShpbkNlbnRyZVgsIGluQ2VudHJlWSlcbn07XG5cbnZhciBPZmZzZXRDdXJ2ZVNldEJ1aWxkZXIgPSBmdW5jdGlvbiBPZmZzZXRDdXJ2ZVNldEJ1aWxkZXIgKCkge1xuICB0aGlzLl9pbnB1dEdlb20gPSBudWxsO1xuICB0aGlzLl9kaXN0YW5jZSA9IG51bGw7XG4gIHRoaXMuX2N1cnZlQnVpbGRlciA9IG51bGw7XG4gIHRoaXMuX2N1cnZlTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIGlucHV0R2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzFdO1xuICB2YXIgY3VydmVCdWlsZGVyID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9pbnB1dEdlb20gPSBpbnB1dEdlb207XG4gIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gIHRoaXMuX2N1cnZlQnVpbGRlciA9IGN1cnZlQnVpbGRlcjtcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24gYWRkUG9pbnQgKHApIHtcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDw9IDAuMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBjb29yZCA9IHAuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgdmFyIGN1cnZlID0gdGhpcy5fY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShjb29yZCwgdGhpcy5fZGlzdGFuY2UpO1xuICB0aGlzLmFkZEN1cnZlKGN1cnZlLCBMb2NhdGlvbi5FWFRFUklPUiwgTG9jYXRpb24uSU5URVJJT1IpO1xufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuYWRkUG9seWdvbiA9IGZ1bmN0aW9uIGFkZFBvbHlnb24gKHApIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgb2Zmc2V0RGlzdGFuY2UgPSB0aGlzLl9kaXN0YW5jZTtcbiAgdmFyIG9mZnNldFNpZGUgPSBQb3NpdGlvbi5MRUZUO1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPCAwLjApIHtcbiAgICBvZmZzZXREaXN0YW5jZSA9IC10aGlzLl9kaXN0YW5jZTtcbiAgICBvZmZzZXRTaWRlID0gUG9zaXRpb24uUklHSFQ7XG4gIH1cbiAgdmFyIHNoZWxsID0gcC5nZXRFeHRlcmlvclJpbmcoKTtcbiAgdmFyIHNoZWxsQ29vcmQgPSBDb29yZGluYXRlQXJyYXlzLnJlbW92ZVJlcGVhdGVkUG9pbnRzKHNoZWxsLmdldENvb3JkaW5hdGVzKCkpO1xuICBpZiAodGhpcy5fZGlzdGFuY2UgPCAwLjAgJiYgdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkoc2hlbGwsIHRoaXMuX2Rpc3RhbmNlKSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8PSAwLjAgJiYgc2hlbGxDb29yZC5sZW5ndGggPCAzKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5hZGRQb2x5Z29uUmluZyhzaGVsbENvb3JkLCBvZmZzZXREaXN0YW5jZSwgb2Zmc2V0U2lkZSwgTG9jYXRpb24uRVhURVJJT1IsIExvY2F0aW9uLklOVEVSSU9SKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwLmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICB2YXIgaG9sZSA9IHAuZ2V0SW50ZXJpb3JSaW5nTihpKTtcbiAgICB2YXIgaG9sZUNvb3JkID0gQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVSZXBlYXRlZFBvaW50cyhob2xlLmdldENvb3JkaW5hdGVzKCkpO1xuICAgIGlmICh0aGlzJDEuX2Rpc3RhbmNlID4gMC4wICYmIHRoaXMkMS5pc0Vyb2RlZENvbXBsZXRlbHkoaG9sZSwgLXRoaXMkMS5fZGlzdGFuY2UpKSB7IGNvbnRpbnVlIH1cbiAgICB0aGlzJDEuYWRkUG9seWdvblJpbmcoaG9sZUNvb3JkLCBvZmZzZXREaXN0YW5jZSwgUG9zaXRpb24ub3Bwb3NpdGUob2Zmc2V0U2lkZSksIExvY2F0aW9uLklOVEVSSU9SLCBMb2NhdGlvbi5FWFRFUklPUik7XG4gIH1cbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5ID0gZnVuY3Rpb24gaXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkgKHRyaWFuZ2xlQ29vcmQsIGJ1ZmZlckRpc3RhbmNlKSB7XG4gIHZhciB0cmkgPSBuZXcgVHJpYW5nbGUodHJpYW5nbGVDb29yZFswXSwgdHJpYW5nbGVDb29yZFsxXSwgdHJpYW5nbGVDb29yZFsyXSk7XG4gIHZhciBpbkNlbnRyZSA9IHRyaS5pbkNlbnRyZSgpO1xuICB2YXIgZGlzdFRvQ2VudHJlID0gQ0dBbGdvcml0aG1zLmRpc3RhbmNlUG9pbnRMaW5lKGluQ2VudHJlLCB0cmkucDAsIHRyaS5wMSk7XG4gIHJldHVybiBkaXN0VG9DZW50cmUgPCBNYXRoLmFicyhidWZmZXJEaXN0YW5jZSlcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmFkZExpbmVTdHJpbmcgPSBmdW5jdGlvbiBhZGRMaW5lU3RyaW5nIChsaW5lKSB7XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA8PSAwLjAgJiYgIXRoaXMuX2N1cnZlQnVpbGRlci5nZXRCdWZmZXJQYXJhbWV0ZXJzKCkuaXNTaW5nbGVTaWRlZCgpKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGNvb3JkID0gQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVSZXBlYXRlZFBvaW50cyhsaW5lLmdldENvb3JkaW5hdGVzKCkpO1xuICB2YXIgY3VydmUgPSB0aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGNvb3JkLCB0aGlzLl9kaXN0YW5jZSk7XG4gIHRoaXMuYWRkQ3VydmUoY3VydmUsIExvY2F0aW9uLkVYVEVSSU9SLCBMb2NhdGlvbi5JTlRFUklPUik7XG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRDdXJ2ZSA9IGZ1bmN0aW9uIGFkZEN1cnZlIChjb29yZCwgbGVmdExvYywgcmlnaHRMb2MpIHtcbiAgaWYgKGNvb3JkID09PSBudWxsIHx8IGNvb3JkLmxlbmd0aCA8IDIpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgZSA9IG5ldyBOb2RlZFNlZ21lbnRTdHJpbmcoY29vcmQsIG5ldyBMYWJlbCgwLCBMb2NhdGlvbi5CT1VOREFSWSwgbGVmdExvYywgcmlnaHRMb2MpKTtcbiAgdGhpcy5fY3VydmVMaXN0LmFkZChlKTtcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmdldEN1cnZlcyA9IGZ1bmN0aW9uIGdldEN1cnZlcyAoKSB7XG4gIHRoaXMuYWRkKHRoaXMuX2lucHV0R2VvbSk7XG4gIHJldHVybiB0aGlzLl9jdXJ2ZUxpc3Rcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmFkZFBvbHlnb25SaW5nID0gZnVuY3Rpb24gYWRkUG9seWdvblJpbmcgKGNvb3JkLCBvZmZzZXREaXN0YW5jZSwgc2lkZSwgY3dMZWZ0TG9jLCBjd1JpZ2h0TG9jKSB7XG4gIGlmIChvZmZzZXREaXN0YW5jZSA9PT0gMC4wICYmIGNvb3JkLmxlbmd0aCA8IExpbmVhclJpbmcuTUlOSU1VTV9WQUxJRF9TSVpFKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIGxlZnRMb2MgPSBjd0xlZnRMb2M7XG4gIHZhciByaWdodExvYyA9IGN3UmlnaHRMb2M7XG4gIGlmIChjb29yZC5sZW5ndGggPj0gTGluZWFyUmluZy5NSU5JTVVNX1ZBTElEX1NJWkUgJiYgQ0dBbGdvcml0aG1zLmlzQ0NXKGNvb3JkKSkge1xuICAgIGxlZnRMb2MgPSBjd1JpZ2h0TG9jO1xuICAgIHJpZ2h0TG9jID0gY3dMZWZ0TG9jO1xuICAgIHNpZGUgPSBQb3NpdGlvbi5vcHBvc2l0ZShzaWRlKTtcbiAgfVxuICB2YXIgY3VydmUgPSB0aGlzLl9jdXJ2ZUJ1aWxkZXIuZ2V0UmluZ0N1cnZlKGNvb3JkLCBzaWRlLCBvZmZzZXREaXN0YW5jZSk7XG4gIHRoaXMuYWRkQ3VydmUoY3VydmUsIGxlZnRMb2MsIHJpZ2h0TG9jKTtcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoZykge1xuICBpZiAoZy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAoZyBpbnN0YW5jZW9mIFBvbHlnb24pIHsgdGhpcy5hZGRQb2x5Z29uKGcpOyB9XG4gIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7IHRoaXMuYWRkTGluZVN0cmluZyhnKTsgfVxuICBlbHNlIGlmIChnIGluc3RhbmNlb2YgUG9pbnQpIHsgdGhpcy5hZGRQb2ludChnKTsgfVxuICBlbHNlIGlmIChnIGluc3RhbmNlb2YgTXVsdGlQb2ludCkgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIE11bHRpTGluZVN0cmluZykgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIE11bHRpUG9seWdvbikgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgLy8gZWxzZSB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24oZy5nZXRDbGFzcygpLmdldE5hbWUoKSlcbn07XG5PZmZzZXRDdXJ2ZVNldEJ1aWxkZXIucHJvdG90eXBlLmlzRXJvZGVkQ29tcGxldGVseSA9IGZ1bmN0aW9uIGlzRXJvZGVkQ29tcGxldGVseSAocmluZywgYnVmZmVyRGlzdGFuY2UpIHtcbiAgdmFyIHJpbmdDb29yZCA9IHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgLy8gY29uc3QgbWluRGlhbSA9IDAuMFxuICBpZiAocmluZ0Nvb3JkLmxlbmd0aCA8IDQpIHsgcmV0dXJuIGJ1ZmZlckRpc3RhbmNlIDwgMCB9XG4gIGlmIChyaW5nQ29vcmQubGVuZ3RoID09PSA0KSB7IHJldHVybiB0aGlzLmlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KHJpbmdDb29yZCwgYnVmZmVyRGlzdGFuY2UpIH1cbiAgdmFyIGVudiA9IHJpbmcuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICB2YXIgZW52TWluRGltZW5zaW9uID0gTWF0aC5taW4oZW52LmdldEhlaWdodCgpLCBlbnYuZ2V0V2lkdGgoKSk7XG4gIGlmIChidWZmZXJEaXN0YW5jZSA8IDAuMCAmJiAyICogTWF0aC5hYnMoYnVmZmVyRGlzdGFuY2UpID4gZW52TWluRGltZW5zaW9uKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuT2Zmc2V0Q3VydmVTZXRCdWlsZGVyLnByb3RvdHlwZS5hZGRDb2xsZWN0aW9uID0gZnVuY3Rpb24gYWRkQ29sbGVjdGlvbiAoZ2MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdjLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIGcgPSBnYy5nZXRHZW9tZXRyeU4oaSk7XG4gICAgdGhpcyQxLmFkZChnKTtcbiAgfVxufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk9mZnNldEN1cnZlU2V0QnVpbGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPZmZzZXRDdXJ2ZVNldEJ1aWxkZXJcbn07XG5cbnZhciBQb2ludE9uR2VvbWV0cnlMb2NhdG9yID0gZnVuY3Rpb24gUG9pbnRPbkdlb21ldHJ5TG9jYXRvciAoKSB7fTtcblxuUG9pbnRPbkdlb21ldHJ5TG9jYXRvci5wcm90b3R5cGUubG9jYXRlID0gZnVuY3Rpb24gbG9jYXRlIChwKSB7fTtcblBvaW50T25HZW9tZXRyeUxvY2F0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb2ludE9uR2VvbWV0cnlMb2NhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvaW50T25HZW9tZXRyeUxvY2F0b3Jcbn07XG5cbnZhciBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvciA9IGZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yICgpIHtcbiAgdGhpcy5fcGFyZW50ID0gbnVsbDtcbiAgdGhpcy5fYXRTdGFydCA9IG51bGw7XG4gIHRoaXMuX21heCA9IG51bGw7XG4gIHRoaXMuX2luZGV4ID0gbnVsbDtcbiAgdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yID0gbnVsbDtcbiAgdmFyIHBhcmVudCA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xuICB0aGlzLl9hdFN0YXJ0ID0gdHJ1ZTtcbiAgdGhpcy5faW5kZXggPSAwO1xuICB0aGlzLl9tYXggPSBwYXJlbnQuZ2V0TnVtR2VvbWV0cmllcygpO1xufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gbmV4dCAoKSB7XG4gIGlmICh0aGlzLl9hdFN0YXJ0KSB7XG4gICAgdGhpcy5fYXRTdGFydCA9IGZhbHNlO1xuICAgIGlmIChHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvci5pc0F0b21pYyh0aGlzLl9wYXJlbnQpKSB7IHRoaXMuX2luZGV4Kys7IH1cbiAgICByZXR1cm4gdGhpcy5fcGFyZW50XG4gIH1cbiAgaWYgKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciAhPT0gbnVsbCkge1xuICAgIGlmICh0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdWJjb2xsZWN0aW9uSXRlcmF0b3IgPSBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbWF4KSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaEVsZW1lbnRFeGNlcHRpb24oKVxuICB9XG4gIHZhciBvYmogPSB0aGlzLl9wYXJlbnQuZ2V0R2VvbWV0cnlOKHRoaXMuX2luZGV4KyspO1xuICBpZiAob2JqIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgdGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yKG9iaik7XG4gICAgcmV0dXJuIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KClcbiAgfVxuICByZXR1cm4gb2JqXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSAoKSB7XG4gIHRocm93IG5ldyBFcnJvcih0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKVxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZS5oYXNOZXh0ID0gZnVuY3Rpb24gaGFzTmV4dCAoKSB7XG4gIGlmICh0aGlzLl9hdFN0YXJ0KSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAodGhpcy5fc3ViY29sbGVjdGlvbkl0ZXJhdG9yICE9PSBudWxsKSB7XG4gICAgaWYgKHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHRoaXMuX3N1YmNvbGxlY3Rpb25JdGVyYXRvciA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuX2luZGV4ID49IHRoaXMuX21heCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0l0ZXJhdG9yXVxufTtcbkdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uSXRlcmF0b3IuaXNBdG9taWMgPSBmdW5jdGlvbiBpc0F0b21pYyAoZ2VvbSkge1xuICByZXR1cm4gIShnZW9tIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKVxufTtcblxudmFyIFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvciA9IGZ1bmN0aW9uIFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvciAoKSB7XG4gIHRoaXMuX2dlb20gPSBudWxsO1xuICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fZ2VvbSA9IGdlb207XG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5sb2NhdGUgPSBmdW5jdGlvbiBsb2NhdGUgKHApIHtcbiAgcmV0dXJuIFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5sb2NhdGUocCwgdGhpcy5fZ2VvbSlcbn07XG5TaW1wbGVQb2ludEluQXJlYUxvY2F0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1BvaW50T25HZW9tZXRyeUxvY2F0b3JdXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvclxufTtcblNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5pc1BvaW50SW5SaW5nID0gZnVuY3Rpb24gaXNQb2ludEluUmluZyAocCwgcmluZykge1xuICBpZiAoIXJpbmcuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMocCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgcmV0dXJuIENHQWxnb3JpdGhtcy5pc1BvaW50SW5SaW5nKHAsIHJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSlcbn07XG5TaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuY29udGFpbnNQb2ludEluUG9seWdvbiA9IGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnRJblBvbHlnb24gKHAsIHBvbHkpIHtcbiAgaWYgKHBvbHkuaXNFbXB0eSgpKSB7IHJldHVybiBmYWxzZSB9XG4gIHZhciBzaGVsbCA9IHBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCk7XG4gIGlmICghU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmlzUG9pbnRJblJpbmcocCwgc2hlbGwpKSB7IHJldHVybiBmYWxzZSB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seS5nZXROdW1JbnRlcmlvclJpbmcoKTsgaSsrKSB7XG4gICAgdmFyIGhvbGUgPSBwb2x5LmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgaWYgKFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5pc1BvaW50SW5SaW5nKHAsIGhvbGUpKSB7IHJldHVybiBmYWxzZSB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn07XG5TaW1wbGVQb2ludEluQXJlYUxvY2F0b3IuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uIGNvbnRhaW5zUG9pbnQgKHAsIGdlb20pIHtcbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgcmV0dXJuIFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5jb250YWluc1BvaW50SW5Qb2x5Z29uKHAsIGdlb20pXG4gIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgIHZhciBnZW9taSA9IG5ldyBHZW9tZXRyeUNvbGxlY3Rpb25JdGVyYXRvcihnZW9tKTtcbiAgICB3aGlsZSAoZ2VvbWkuaGFzTmV4dCgpKSB7XG4gICAgICB2YXIgZzIgPSBnZW9taS5uZXh0KCk7XG4gICAgICBpZiAoZzIgIT09IGdlb20pIHsgaWYgKFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5jb250YWluc1BvaW50KHAsIGcyKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuU2ltcGxlUG9pbnRJbkFyZWFMb2NhdG9yLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocCwgZ2VvbSkge1xuICBpZiAoZ2VvbS5pc0VtcHR5KCkpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgaWYgKFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5jb250YWluc1BvaW50KHAsIGdlb20pKSB7IHJldHVybiBMb2NhdGlvbi5JTlRFUklPUiB9XG4gIHJldHVybiBMb2NhdGlvbi5FWFRFUklPUlxufTtcblxudmFyIEVkZ2VFbmRTdGFyID0gZnVuY3Rpb24gRWRnZUVuZFN0YXIgKCkge1xuICB0aGlzLl9lZGdlTWFwID0gbmV3IFRyZWVNYXAoKTtcbiAgdGhpcy5fZWRnZUxpc3QgPSBudWxsO1xuICB0aGlzLl9wdEluQXJlYUxvY2F0aW9uID0gW0xvY2F0aW9uLk5PTkUsIExvY2F0aW9uLk5PTkVdO1xufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5nZXROZXh0Q1cgPSBmdW5jdGlvbiBnZXROZXh0Q1cgKGVlKSB7XG4gIHRoaXMuZ2V0RWRnZXMoKTtcbiAgdmFyIGkgPSB0aGlzLl9lZGdlTGlzdC5pbmRleE9mKGVlKTtcbiAgdmFyIGlOZXh0Q1cgPSBpIC0gMTtcbiAgaWYgKGkgPT09IDApIHsgaU5leHRDVyA9IHRoaXMuX2VkZ2VMaXN0LnNpemUoKSAtIDE7IH1cbiAgcmV0dXJuIHRoaXMuX2VkZ2VMaXN0LmdldChpTmV4dENXKVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5wcm9wYWdhdGVTaWRlTGFiZWxzID0gZnVuY3Rpb24gcHJvcGFnYXRlU2lkZUxhYmVscyAoZ2VvbUluZGV4KSB7XG4gIHZhciBzdGFydExvYyA9IExvY2F0aW9uLk5PTkU7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGxhYmVsID0gZS5nZXRMYWJlbCgpO1xuICAgIGlmIChsYWJlbC5pc0FyZWEoZ2VvbUluZGV4KSAmJiBsYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQpICE9PSBMb2NhdGlvbi5OT05FKSB7IHN0YXJ0TG9jID0gbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZUKTsgfVxuICB9XG4gIGlmIChzdGFydExvYyA9PT0gTG9jYXRpb24uTk9ORSkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBjdXJyTG9jID0gc3RhcnRMb2M7XG4gIGZvciAodmFyIGl0JDEgPSB0aGlzLml0ZXJhdG9yKCk7IGl0JDEuaGFzTmV4dCgpOykge1xuICAgIHZhciBlJDEgPSBpdCQxLm5leHQoKTtcbiAgICB2YXIgbGFiZWwkMSA9IGUkMS5nZXRMYWJlbCgpO1xuICAgIGlmIChsYWJlbCQxLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uT04pID09PSBMb2NhdGlvbi5OT05FKSB7IGxhYmVsJDEuc2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5PTiwgY3VyckxvYyk7IH1cbiAgICBpZiAobGFiZWwkMS5pc0FyZWEoZ2VvbUluZGV4KSkge1xuICAgICAgdmFyIGxlZnRMb2MgPSBsYWJlbCQxLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCk7XG4gICAgICB2YXIgcmlnaHRMb2MgPSBsYWJlbCQxLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uUklHSFQpO1xuICAgICAgaWYgKHJpZ2h0TG9jICE9PSBMb2NhdGlvbi5OT05FKSB7XG4gICAgICAgIGlmIChyaWdodExvYyAhPT0gY3VyckxvYykgeyB0aHJvdyBuZXcgVG9wb2xvZ3lFeGNlcHRpb24oJ3NpZGUgbG9jYXRpb24gY29uZmxpY3QnLCBlJDEuZ2V0Q29vcmRpbmF0ZSgpKSB9XG4gICAgICAgIGlmIChsZWZ0TG9jID09PSBMb2NhdGlvbi5OT05FKSB7XG4gICAgICAgICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCdmb3VuZCBzaW5nbGUgbnVsbCBzaWRlIChhdCAnICsgZSQxLmdldENvb3JkaW5hdGUoKSArICcpJyk7XG4gICAgICAgIH1cbiAgICAgICAgY3VyckxvYyA9IGxlZnRMb2M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBc3NlcnQuaXNUcnVlKGxhYmVsJDEuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZUKSA9PT0gTG9jYXRpb24uTk9ORSwgJ2ZvdW5kIHNpbmdsZSBudWxsIHNpZGUnKTtcbiAgICAgICAgbGFiZWwkMS5zZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLlJJR0hULCBjdXJyTG9jKTtcbiAgICAgICAgbGFiZWwkMS5zZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLkxFRlQsIGN1cnJMb2MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5nZXRDb29yZGluYXRlID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZSAoKSB7XG4gIHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgaWYgKCFpdC5oYXNOZXh0KCkpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgZSA9IGl0Lm5leHQoKTtcbiAgcmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICBTeXN0ZW0ub3V0LnByaW50bG4oJ0VkZ2VFbmRTdGFyOiAgICcgKyB0aGlzLmdldENvb3JkaW5hdGUoKSk7XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgZS5wcmludChvdXQpO1xuICB9XG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmlzQXJlYUxhYmVsc0NvbnNpc3RlbnQgPSBmdW5jdGlvbiBpc0FyZWFMYWJlbHNDb25zaXN0ZW50IChnZW9tR3JhcGgpIHtcbiAgdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyhnZW9tR3JhcGguZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKTtcbiAgcmV0dXJuIHRoaXMuY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCgwKVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50ID0gZnVuY3Rpb24gY2hlY2tBcmVhTGFiZWxzQ29uc2lzdGVudCAoZ2VvbUluZGV4KSB7XG4gIHZhciBlZGdlcyA9IHRoaXMuZ2V0RWRnZXMoKTtcbiAgaWYgKGVkZ2VzLnNpemUoKSA8PSAwKSB7IHJldHVybiB0cnVlIH1cbiAgdmFyIGxhc3RFZGdlSW5kZXggPSBlZGdlcy5zaXplKCkgLSAxO1xuICB2YXIgc3RhcnRMYWJlbCA9IGVkZ2VzLmdldChsYXN0RWRnZUluZGV4KS5nZXRMYWJlbCgpO1xuICB2YXIgc3RhcnRMb2MgPSBzdGFydExhYmVsLmdldExvY2F0aW9uKGdlb21JbmRleCwgUG9zaXRpb24uTEVGVCk7XG4gIEFzc2VydC5pc1RydWUoc3RhcnRMb2MgIT09IExvY2F0aW9uLk5PTkUsICdGb3VuZCB1bmxhYmVsbGVkIGFyZWEgZWRnZScpO1xuICB2YXIgY3VyckxvYyA9IHN0YXJ0TG9jO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIHZhciBsYWJlbCA9IGUuZ2V0TGFiZWwoKTtcbiAgICBBc3NlcnQuaXNUcnVlKGxhYmVsLmlzQXJlYShnZW9tSW5kZXgpLCAnRm91bmQgbm9uLWFyZWEgZWRnZScpO1xuICAgIHZhciBsZWZ0TG9jID0gbGFiZWwuZ2V0TG9jYXRpb24oZ2VvbUluZGV4LCBQb3NpdGlvbi5MRUZUKTtcbiAgICB2YXIgcmlnaHRMb2MgPSBsYWJlbC5nZXRMb2NhdGlvbihnZW9tSW5kZXgsIFBvc2l0aW9uLlJJR0hUKTtcbiAgICBpZiAobGVmdExvYyA9PT0gcmlnaHRMb2MpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBpZiAocmlnaHRMb2MgIT09IGN1cnJMb2MpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBjdXJyTG9jID0gbGVmdExvYztcbiAgfVxuICByZXR1cm4gdHJ1ZVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5maW5kSW5kZXggPSBmdW5jdGlvbiBmaW5kSW5kZXggKGVTZWFyY2gpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLml0ZXJhdG9yKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZWRnZUxpc3Quc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgZSA9IHRoaXMkMS5fZWRnZUxpc3QuZ2V0KGkpO1xuICAgIGlmIChlID09PSBlU2VhcmNoKSB7IHJldHVybiBpIH1cbiAgfVxuICByZXR1cm4gLTFcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuaXRlcmF0b3IgPSBmdW5jdGlvbiBpdGVyYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLmdldEVkZ2VzKCkuaXRlcmF0b3IoKVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5nZXRFZGdlcyA9IGZ1bmN0aW9uIGdldEVkZ2VzICgpIHtcbiAgaWYgKHRoaXMuX2VkZ2VMaXN0ID09PSBudWxsKSB7XG4gICAgdGhpcy5fZWRnZUxpc3QgPSBuZXcgQXJyYXlMaXN0KHRoaXMuX2VkZ2VNYXAudmFsdWVzKCkpO1xuICB9XG4gIHJldHVybiB0aGlzLl9lZGdlTGlzdFxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5nZXRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uIChnZW9tSW5kZXgsIHAsIGdlb20pIHtcbiAgaWYgKHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bZ2VvbUluZGV4XSA9PT0gTG9jYXRpb24uTk9ORSkge1xuICAgIHRoaXMuX3B0SW5BcmVhTG9jYXRpb25bZ2VvbUluZGV4XSA9IFNpbXBsZVBvaW50SW5BcmVhTG9jYXRvci5sb2NhdGUocCwgZ2VvbVtnZW9tSW5kZXhdLmdldEdlb21ldHJ5KCkpO1xuICB9XG4gIHJldHVybiB0aGlzLl9wdEluQXJlYUxvY2F0aW9uW2dlb21JbmRleF1cbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBidWYgPSBuZXcgU3RyaW5nQnVmZmVyKCk7XG4gIGJ1Zi5hcHBlbmQoJ0VkZ2VFbmRTdGFyOiAgICcgKyB0aGlzLmdldENvb3JkaW5hdGUoKSk7XG4gIGJ1Zi5hcHBlbmQoJ1xcbicpO1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIGJ1Zi5hcHBlbmQoZSk7XG4gICAgYnVmLmFwcGVuZCgnXFxuJyk7XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygpXG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmNvbXB1dGVFZGdlRW5kTGFiZWxzID0gZnVuY3Rpb24gY29tcHV0ZUVkZ2VFbmRMYWJlbHMgKGJvdW5kYXJ5Tm9kZVJ1bGUpIHtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZWUgPSBpdC5uZXh0KCk7XG4gICAgZWUuY29tcHV0ZUxhYmVsKGJvdW5kYXJ5Tm9kZVJ1bGUpO1xuICB9XG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmNvbXB1dGVMYWJlbGxpbmcgPSBmdW5jdGlvbiBjb21wdXRlTGFiZWxsaW5nIChnZW9tR3JhcGgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKGdlb21HcmFwaFswXS5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpO1xuICB0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMCk7XG4gIHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygxKTtcbiAgdmFyIGhhc0RpbWVuc2lvbmFsQ29sbGFwc2VFZGdlID0gW2ZhbHNlLCBmYWxzZV07XG4gIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGxhYmVsID0gZS5nZXRMYWJlbCgpO1xuICAgIGZvciAodmFyIGdlb21pID0gMDsgZ2VvbWkgPCAyOyBnZW9taSsrKSB7XG4gICAgICBpZiAobGFiZWwuaXNMaW5lKGdlb21pKSAmJiBsYWJlbC5nZXRMb2NhdGlvbihnZW9taSkgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IGhhc0RpbWVuc2lvbmFsQ29sbGFwc2VFZGdlW2dlb21pXSA9IHRydWU7IH1cbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaXQkMSA9IHRoaXMuaXRlcmF0b3IoKTsgaXQkMS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUkMSA9IGl0JDEubmV4dCgpO1xuICAgIHZhciBsYWJlbCQxID0gZSQxLmdldExhYmVsKCk7XG4gICAgZm9yICh2YXIgZ2VvbWkkMSA9IDA7IGdlb21pJDEgPCAyOyBnZW9taSQxKyspIHtcbiAgICAgIGlmIChsYWJlbCQxLmlzQW55TnVsbChnZW9taSQxKSkge1xuICAgICAgICB2YXIgbG9jID0gTG9jYXRpb24uTk9ORTtcbiAgICAgICAgaWYgKGhhc0RpbWVuc2lvbmFsQ29sbGFwc2VFZGdlW2dlb21pJDFdKSB7XG4gICAgICAgICAgbG9jID0gTG9jYXRpb24uRVhURVJJT1I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHAgPSBlJDEuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgICAgICAgIGxvYyA9IHRoaXMkMS5nZXRMb2NhdGlvbihnZW9taSQxLCBwLCBnZW9tR3JhcGgpO1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsJDEuc2V0QWxsTG9jYXRpb25zSWZOdWxsKGdlb21pJDEsIGxvYyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuRWRnZUVuZFN0YXIucHJvdG90eXBlLmdldERlZ3JlZSA9IGZ1bmN0aW9uIGdldERlZ3JlZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlTWFwLnNpemUoKVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5pbnNlcnRFZGdlRW5kID0gZnVuY3Rpb24gaW5zZXJ0RWRnZUVuZCAoZSwgb2JqKSB7XG4gIHRoaXMuX2VkZ2VNYXAucHV0KGUsIG9iaik7XG4gIHRoaXMuX2VkZ2VMaXN0ID0gbnVsbDtcbn07XG5FZGdlRW5kU3Rhci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkVkZ2VFbmRTdGFyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEVkZ2VFbmRTdGFyXG59O1xuXG52YXIgRGlyZWN0ZWRFZGdlU3RhciA9IChmdW5jdGlvbiAoRWRnZUVuZFN0YXIkJDEpIHtcbiAgZnVuY3Rpb24gRGlyZWN0ZWRFZGdlU3RhciAoKSB7XG4gICAgRWRnZUVuZFN0YXIkJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QgPSBudWxsO1xuICAgIHRoaXMuX2xhYmVsID0gbnVsbDtcbiAgICB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkcgPSAxO1xuICAgIHRoaXMuX0xJTktJTkdfVE9fT1VUR09JTkcgPSAyO1xuICB9XG5cbiAgaWYgKCBFZGdlRW5kU3RhciQkMSApIERpcmVjdGVkRWRnZVN0YXIuX19wcm90b19fID0gRWRnZUVuZFN0YXIkJDE7XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWRnZUVuZFN0YXIkJDEgJiYgRWRnZUVuZFN0YXIkJDEucHJvdG90eXBlICk7XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGlyZWN0ZWRFZGdlU3RhcjtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiBsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB0aGlzLmdldFJlc3VsdEFyZWFFZGdlcygpO1xuICAgIHZhciBmaXJzdE91dCA9IG51bGw7XG4gICAgdmFyIGluY29taW5nID0gbnVsbDtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpOyBpKyspIHtcbiAgICAgIHZhciBuZXh0T3V0ID0gdGhpcyQxLl9yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KGkpO1xuICAgICAgdmFyIG5leHRJbiA9IG5leHRPdXQuZ2V0U3ltKCk7XG4gICAgICBpZiAoIW5leHRPdXQuZ2V0TGFiZWwoKS5pc0FyZWEoKSkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoZmlyc3RPdXQgPT09IG51bGwgJiYgbmV4dE91dC5pc0luUmVzdWx0KCkpIHsgZmlyc3RPdXQgPSBuZXh0T3V0OyB9XG4gICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgIGNhc2UgdGhpcyQxLl9TQ0FOTklOR19GT1JfSU5DT01JTkc6XG4gICAgICAgICAgaWYgKCFuZXh0SW4uaXNJblJlc3VsdCgpKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgICBpbmNvbWluZyA9IG5leHRJbjtcbiAgICAgICAgICBzdGF0ZSA9IHRoaXMkMS5fTElOS0lOR19UT19PVVRHT0lORztcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIHRoaXMkMS5fTElOS0lOR19UT19PVVRHT0lORzpcbiAgICAgICAgICBpZiAoIW5leHRPdXQuaXNJblJlc3VsdCgpKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgICBpbmNvbWluZy5zZXROZXh0KG5leHRPdXQpO1xuICAgICAgICAgIHN0YXRlID0gdGhpcyQxLl9TQ0FOTklOR19GT1JfSU5DT01JTkc7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHN0YXRlID09PSB0aGlzLl9MSU5LSU5HX1RPX09VVEdPSU5HKSB7XG4gICAgICBpZiAoZmlyc3RPdXQgPT09IG51bGwpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKCdubyBvdXRnb2luZyBkaXJFZGdlIGZvdW5kJywgdGhpcy5nZXRDb29yZGluYXRlKCkpIH1cbiAgICAgIEFzc2VydC5pc1RydWUoZmlyc3RPdXQuaXNJblJlc3VsdCgpLCAndW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlJyk7XG4gICAgICBpbmNvbWluZy5zZXROZXh0KGZpcnN0T3V0KTtcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydCAoZWUpIHtcbiAgICB2YXIgZGUgPSBlZTtcbiAgICB0aGlzLmluc2VydEVkZ2VFbmQoZGUsIGRlKTtcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuZ2V0UmlnaHRtb3N0RWRnZSA9IGZ1bmN0aW9uIGdldFJpZ2h0bW9zdEVkZ2UgKCkge1xuICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0RWRnZXMoKTtcbiAgICB2YXIgc2l6ZSA9IGVkZ2VzLnNpemUoKTtcbiAgICBpZiAoc2l6ZSA8IDEpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBkZTAgPSBlZGdlcy5nZXQoMCk7XG4gICAgaWYgKHNpemUgPT09IDEpIHsgcmV0dXJuIGRlMCB9XG4gICAgdmFyIGRlTGFzdCA9IGVkZ2VzLmdldChzaXplIC0gMSk7XG4gICAgdmFyIHF1YWQwID0gZGUwLmdldFF1YWRyYW50KCk7XG4gICAgdmFyIHF1YWQxID0gZGVMYXN0LmdldFF1YWRyYW50KCk7XG4gICAgaWYgKFF1YWRyYW50LmlzTm9ydGhlcm4ocXVhZDApICYmIFF1YWRyYW50LmlzTm9ydGhlcm4ocXVhZDEpKSB7IHJldHVybiBkZTA7IH0gZWxzZSBpZiAoIVF1YWRyYW50LmlzTm9ydGhlcm4ocXVhZDApICYmICFRdWFkcmFudC5pc05vcnRoZXJuKHF1YWQxKSkgeyByZXR1cm4gZGVMYXN0OyB9IGVsc2Uge1xuICAgICAgLy8gY29uc3Qgbm9uSG9yaXpvbnRhbEVkZ2UgPSBudWxsXG4gICAgICBpZiAoZGUwLmdldER5KCkgIT09IDApIHsgcmV0dXJuIGRlMDsgfSBlbHNlIGlmIChkZUxhc3QuZ2V0RHkoKSAhPT0gMCkgeyByZXR1cm4gZGVMYXN0IH1cbiAgICB9XG4gICAgQXNzZXJ0LnNob3VsZE5ldmVyUmVhY2hIZXJlKCdmb3VuZCB0d28gaG9yaXpvbnRhbCBlZGdlcyBpbmNpZGVudCBvbiBub2RlJyk7XG4gICAgcmV0dXJuIG51bGxcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUucHJpbnQgPSBmdW5jdGlvbiBwcmludCAob3V0KSB7XG4gICAgU3lzdGVtLm91dC5wcmludGxuKCdEaXJlY3RlZEVkZ2VTdGFyOiAnICsgdGhpcy5nZXRDb29yZGluYXRlKCkpO1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICBvdXQucHJpbnQoJ291dCAnKTtcbiAgICAgIGRlLnByaW50KG91dCk7XG4gICAgICBvdXQucHJpbnRsbigpO1xuICAgICAgb3V0LnByaW50KCdpbiAnKTtcbiAgICAgIGRlLmdldFN5bSgpLnByaW50KG91dCk7XG4gICAgICBvdXQucHJpbnRsbigpO1xuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuZ2V0UmVzdWx0QXJlYUVkZ2VzID0gZnVuY3Rpb24gZ2V0UmVzdWx0QXJlYUVkZ2VzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3QgIT09IG51bGwpIHsgcmV0dXJuIHRoaXMuX3Jlc3VsdEFyZWFFZGdlTGlzdCB9XG4gICAgdGhpcy5fcmVzdWx0QXJlYUVkZ2VMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICBpZiAoZGUuaXNJblJlc3VsdCgpIHx8IGRlLmdldFN5bSgpLmlzSW5SZXN1bHQoKSkgeyB0aGlzJDEuX3Jlc3VsdEFyZWFFZGdlTGlzdC5hZGQoZGUpOyB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3RcbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUudXBkYXRlTGFiZWxsaW5nID0gZnVuY3Rpb24gdXBkYXRlTGFiZWxsaW5nIChub2RlTGFiZWwpIHtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIGxhYmVsID0gZGUuZ2V0TGFiZWwoKTtcbiAgICAgIGxhYmVsLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLCBub2RlTGFiZWwuZ2V0TG9jYXRpb24oMCkpO1xuICAgICAgbGFiZWwuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsIG5vZGVMYWJlbC5nZXRMb2NhdGlvbigxKSk7XG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5saW5rQWxsRGlyZWN0ZWRFZGdlcyA9IGZ1bmN0aW9uIGxpbmtBbGxEaXJlY3RlZEVkZ2VzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuZ2V0RWRnZXMoKTtcbiAgICB2YXIgcHJldk91dCA9IG51bGw7XG4gICAgdmFyIGZpcnN0SW4gPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9lZGdlTGlzdC5zaXplKCkgLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIG5leHRPdXQgPSB0aGlzJDEuX2VkZ2VMaXN0LmdldChpKTtcbiAgICAgIHZhciBuZXh0SW4gPSBuZXh0T3V0LmdldFN5bSgpO1xuICAgICAgaWYgKGZpcnN0SW4gPT09IG51bGwpIHsgZmlyc3RJbiA9IG5leHRJbjsgfVxuICAgICAgaWYgKHByZXZPdXQgIT09IG51bGwpIHsgbmV4dEluLnNldE5leHQocHJldk91dCk7IH1cbiAgICAgIHByZXZPdXQgPSBuZXh0T3V0O1xuICAgIH1cbiAgICBmaXJzdEluLnNldE5leHQocHJldk91dCk7XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmNvbXB1dGVEZXB0aHMgPSBmdW5jdGlvbiBjb21wdXRlRGVwdGhzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgZGUgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZWRnZUluZGV4ID0gdGhpcy5maW5kSW5kZXgoZGUpO1xuICAgICAgLy8gY29uc3QgbGFiZWwgPSBkZS5nZXRMYWJlbCgpXG4gICAgICB2YXIgc3RhcnREZXB0aCA9IGRlLmdldERlcHRoKFBvc2l0aW9uLkxFRlQpO1xuICAgICAgdmFyIHRhcmdldExhc3REZXB0aCA9IGRlLmdldERlcHRoKFBvc2l0aW9uLlJJR0hUKTtcbiAgICAgIHZhciBuZXh0RGVwdGggPSB0aGlzLmNvbXB1dGVEZXB0aHMoZWRnZUluZGV4ICsgMSwgdGhpcy5fZWRnZUxpc3Quc2l6ZSgpLCBzdGFydERlcHRoKTtcbiAgICAgIHZhciBsYXN0RGVwdGggPSB0aGlzLmNvbXB1dGVEZXB0aHMoMCwgZWRnZUluZGV4LCBuZXh0RGVwdGgpO1xuICAgICAgaWYgKGxhc3REZXB0aCAhPT0gdGFyZ2V0TGFzdERlcHRoKSB7IHRocm93IG5ldyBUb3BvbG9neUV4Y2VwdGlvbignZGVwdGggbWlzbWF0Y2ggYXQgJyArIGRlLmdldENvb3JkaW5hdGUoKSkgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgdmFyIHN0YXJ0SW5kZXggPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZW5kSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgc3RhcnREZXB0aCQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIGN1cnJEZXB0aCA9IHN0YXJ0RGVwdGgkMTtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkrKykge1xuICAgICAgICB2YXIgbmV4dERlID0gdGhpcyQxLl9lZGdlTGlzdC5nZXQoaSk7XG4gICAgICAgIC8vIGNvbnN0IGxhYmVsID0gbmV4dERlLmdldExhYmVsKClcbiAgICAgICAgbmV4dERlLnNldEVkZ2VEZXB0aHMoUG9zaXRpb24uUklHSFQsIGN1cnJEZXB0aCk7XG4gICAgICAgIGN1cnJEZXB0aCA9IG5leHREZS5nZXREZXB0aChQb3NpdGlvbi5MRUZUKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJyRGVwdGhcbiAgICB9XG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLm1lcmdlU3ltTGFiZWxzID0gZnVuY3Rpb24gbWVyZ2VTeW1MYWJlbHMgKCkge1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgbGFiZWwgPSBkZS5nZXRMYWJlbCgpO1xuICAgICAgbGFiZWwubWVyZ2UoZGUuZ2V0U3ltKCkuZ2V0TGFiZWwoKSk7XG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5saW5rTWluaW1hbERpcmVjdGVkRWRnZXMgPSBmdW5jdGlvbiBsaW5rTWluaW1hbERpcmVjdGVkRWRnZXMgKGVyKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgZmlyc3RPdXQgPSBudWxsO1xuICAgIHZhciBpbmNvbWluZyA9IG51bGw7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLl9yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBuZXh0T3V0ID0gdGhpcyQxLl9yZXN1bHRBcmVhRWRnZUxpc3QuZ2V0KGkpO1xuICAgICAgdmFyIG5leHRJbiA9IG5leHRPdXQuZ2V0U3ltKCk7XG4gICAgICBpZiAoZmlyc3RPdXQgPT09IG51bGwgJiYgbmV4dE91dC5nZXRFZGdlUmluZygpID09PSBlcikgeyBmaXJzdE91dCA9IG5leHRPdXQ7IH1cbiAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgY2FzZSB0aGlzJDEuX1NDQU5OSU5HX0ZPUl9JTkNPTUlORzpcbiAgICAgICAgICBpZiAobmV4dEluLmdldEVkZ2VSaW5nKCkgIT09IGVyKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgICBpbmNvbWluZyA9IG5leHRJbjtcbiAgICAgICAgICBzdGF0ZSA9IHRoaXMkMS5fTElOS0lOR19UT19PVVRHT0lORztcbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIHRoaXMkMS5fTElOS0lOR19UT19PVVRHT0lORzpcbiAgICAgICAgICBpZiAobmV4dE91dC5nZXRFZGdlUmluZygpICE9PSBlcikgeyBjb250aW51ZSB9XG4gICAgICAgICAgaW5jb21pbmcuc2V0TmV4dE1pbihuZXh0T3V0KTtcbiAgICAgICAgICBzdGF0ZSA9IHRoaXMkMS5fU0NBTk5JTkdfRk9SX0lOQ09NSU5HO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5fTElOS0lOR19UT19PVVRHT0lORykge1xuICAgICAgQXNzZXJ0LmlzVHJ1ZShmaXJzdE91dCAhPT0gbnVsbCwgJ2ZvdW5kIG51bGwgZm9yIGZpcnN0IG91dGdvaW5nIGRpckVkZ2UnKTtcbiAgICAgIEFzc2VydC5pc1RydWUoZmlyc3RPdXQuZ2V0RWRnZVJpbmcoKSA9PT0gZXIsICd1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2UnKTtcbiAgICAgIGluY29taW5nLnNldE5leHRNaW4oZmlyc3RPdXQpO1xuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuZ2V0T3V0Z29pbmdEZWdyZWUgPSBmdW5jdGlvbiBnZXRPdXRnb2luZ0RlZ3JlZSAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHZhciBkZWdyZWUgPSAwO1xuICAgICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgICAgICBpZiAoZGUuaXNJblJlc3VsdCgpKSB7IGRlZ3JlZSsrOyB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVncmVlXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgZXIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGVncmVlJDEgPSAwO1xuICAgICAgZm9yICh2YXIgaXQkMSA9IHRoaXMuaXRlcmF0b3IoKTsgaXQkMS5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBkZSQxID0gaXQkMS5uZXh0KCk7XG4gICAgICAgIGlmIChkZSQxLmdldEVkZ2VSaW5nKCkgPT09IGVyKSB7IGRlZ3JlZSQxKys7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWdyZWUkMVxuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuZ2V0TGFiZWwgPSBmdW5jdGlvbiBnZXRMYWJlbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xhYmVsXG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmZpbmRDb3ZlcmVkTGluZUVkZ2VzID0gZnVuY3Rpb24gZmluZENvdmVyZWRMaW5lRWRnZXMgKCkge1xuICAgIHZhciBzdGFydExvYyA9IExvY2F0aW9uLk5PTkU7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBuZXh0T3V0ID0gaXQubmV4dCgpO1xuICAgICAgdmFyIG5leHRJbiA9IG5leHRPdXQuZ2V0U3ltKCk7XG4gICAgICBpZiAoIW5leHRPdXQuaXNMaW5lRWRnZSgpKSB7XG4gICAgICAgIGlmIChuZXh0T3V0LmlzSW5SZXN1bHQoKSkge1xuICAgICAgICAgIHN0YXJ0TG9jID0gTG9jYXRpb24uSU5URVJJT1I7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV4dEluLmlzSW5SZXN1bHQoKSkge1xuICAgICAgICAgIHN0YXJ0TG9jID0gTG9jYXRpb24uRVhURVJJT1I7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnRMb2MgPT09IExvY2F0aW9uLk5PTkUpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBjdXJyTG9jID0gc3RhcnRMb2M7XG4gICAgZm9yICh2YXIgaXQkMSA9IHRoaXMuaXRlcmF0b3IoKTsgaXQkMS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbmV4dE91dCQxID0gaXQkMS5uZXh0KCk7XG4gICAgICB2YXIgbmV4dEluJDEgPSBuZXh0T3V0JDEuZ2V0U3ltKCk7XG4gICAgICBpZiAobmV4dE91dCQxLmlzTGluZUVkZ2UoKSkge1xuICAgICAgICBuZXh0T3V0JDEuZ2V0RWRnZSgpLnNldENvdmVyZWQoY3VyckxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG5leHRPdXQkMS5pc0luUmVzdWx0KCkpIHsgY3VyckxvYyA9IExvY2F0aW9uLkVYVEVSSU9SOyB9XG4gICAgICAgIGlmIChuZXh0SW4kMS5pc0luUmVzdWx0KCkpIHsgY3VyckxvYyA9IExvY2F0aW9uLklOVEVSSU9SOyB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBEaXJlY3RlZEVkZ2VTdGFyLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nID0gZnVuY3Rpb24gY29tcHV0ZUxhYmVsbGluZyAoZ2VvbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgRWRnZUVuZFN0YXIkJDEucHJvdG90eXBlLmNvbXB1dGVMYWJlbGxpbmcuY2FsbCh0aGlzLCBnZW9tKTtcbiAgICB0aGlzLl9sYWJlbCA9IG5ldyBMYWJlbChMb2NhdGlvbi5OT05FKTtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGVlID0gaXQubmV4dCgpO1xuICAgICAgdmFyIGUgPSBlZS5nZXRFZGdlKCk7XG4gICAgICB2YXIgZUxhYmVsID0gZS5nZXRMYWJlbCgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgdmFyIGVMb2MgPSBlTGFiZWwuZ2V0TG9jYXRpb24oaSk7XG4gICAgICAgIGlmIChlTG9jID09PSBMb2NhdGlvbi5JTlRFUklPUiB8fCBlTG9jID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyB0aGlzJDEuX2xhYmVsLnNldExvY2F0aW9uKGksIExvY2F0aW9uLklOVEVSSU9SKTsgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgRGlyZWN0ZWRFZGdlU3Rhci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIERpcmVjdGVkRWRnZVN0YXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBEaXJlY3RlZEVkZ2VTdGFyXG4gIH07XG5cbiAgcmV0dXJuIERpcmVjdGVkRWRnZVN0YXI7XG59KEVkZ2VFbmRTdGFyKSk7XG5cbnZhciBPdmVybGF5Tm9kZUZhY3RvcnkgPSAoZnVuY3Rpb24gKE5vZGVGYWN0b3J5JCQxKSB7XG4gIGZ1bmN0aW9uIE92ZXJsYXlOb2RlRmFjdG9yeSAoKSB7XG4gICAgTm9kZUZhY3RvcnkkJDEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGlmICggTm9kZUZhY3RvcnkkJDEgKSBPdmVybGF5Tm9kZUZhY3RvcnkuX19wcm90b19fID0gTm9kZUZhY3RvcnkkJDE7XG4gIE92ZXJsYXlOb2RlRmFjdG9yeS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBOb2RlRmFjdG9yeSQkMSAmJiBOb2RlRmFjdG9yeSQkMS5wcm90b3R5cGUgKTtcbiAgT3ZlcmxheU5vZGVGYWN0b3J5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE92ZXJsYXlOb2RlRmFjdG9yeTtcblxuICBPdmVybGF5Tm9kZUZhY3RvcnkucHJvdG90eXBlLmNyZWF0ZU5vZGUgPSBmdW5jdGlvbiBjcmVhdGVOb2RlIChjb29yZCkge1xuICAgIHJldHVybiBuZXcgTm9kZShjb29yZCwgbmV3IERpcmVjdGVkRWRnZVN0YXIoKSlcbiAgfTtcbiAgT3ZlcmxheU5vZGVGYWN0b3J5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgT3ZlcmxheU5vZGVGYWN0b3J5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gT3ZlcmxheU5vZGVGYWN0b3J5XG4gIH07XG5cbiAgcmV0dXJuIE92ZXJsYXlOb2RlRmFjdG9yeTtcbn0oTm9kZUZhY3RvcnkpKTtcblxudmFyIE9yaWVudGVkQ29vcmRpbmF0ZUFycmF5ID0gZnVuY3Rpb24gT3JpZW50ZWRDb29yZGluYXRlQXJyYXkgKCkge1xuICB0aGlzLl9wdHMgPSBudWxsO1xuICB0aGlzLl9vcmllbnRhdGlvbiA9IG51bGw7XG4gIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3B0cyA9IHB0cztcbiAgdGhpcy5fb3JpZW50YXRpb24gPSBPcmllbnRlZENvb3JkaW5hdGVBcnJheS5vcmllbnRhdGlvbihwdHMpO1xufTtcbk9yaWVudGVkQ29vcmRpbmF0ZUFycmF5LnByb3RvdHlwZS5jb21wYXJlVG8gPSBmdW5jdGlvbiBjb21wYXJlVG8gKG8xKSB7XG4gIHZhciBvY2EgPSBvMTtcbiAgdmFyIGNvbXAgPSBPcmllbnRlZENvb3JkaW5hdGVBcnJheS5jb21wYXJlT3JpZW50ZWQodGhpcy5fcHRzLCB0aGlzLl9vcmllbnRhdGlvbiwgb2NhLl9wdHMsIG9jYS5fb3JpZW50YXRpb24pO1xuICByZXR1cm4gY29tcFxufTtcbk9yaWVudGVkQ29vcmRpbmF0ZUFycmF5LnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbk9yaWVudGVkQ29vcmRpbmF0ZUFycmF5LnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9yaWVudGVkQ29vcmRpbmF0ZUFycmF5XG59O1xuT3JpZW50ZWRDb29yZGluYXRlQXJyYXkub3JpZW50YXRpb24gPSBmdW5jdGlvbiBvcmllbnRhdGlvbiAocHRzKSB7XG4gIHJldHVybiBDb29yZGluYXRlQXJyYXlzLmluY3JlYXNpbmdEaXJlY3Rpb24ocHRzKSA9PT0gMVxufTtcbk9yaWVudGVkQ29vcmRpbmF0ZUFycmF5LmNvbXBhcmVPcmllbnRlZCA9IGZ1bmN0aW9uIGNvbXBhcmVPcmllbnRlZCAocHRzMSwgb3JpZW50YXRpb24xLCBwdHMyLCBvcmllbnRhdGlvbjIpIHtcbiAgdmFyIGRpcjEgPSBvcmllbnRhdGlvbjEgPyAxIDogLTE7XG4gIHZhciBkaXIyID0gb3JpZW50YXRpb24yID8gMSA6IC0xO1xuICB2YXIgbGltaXQxID0gb3JpZW50YXRpb24xID8gcHRzMS5sZW5ndGggOiAtMTtcbiAgdmFyIGxpbWl0MiA9IG9yaWVudGF0aW9uMiA/IHB0czIubGVuZ3RoIDogLTE7XG4gIHZhciBpMSA9IG9yaWVudGF0aW9uMSA/IDAgOiBwdHMxLmxlbmd0aCAtIDE7XG4gIHZhciBpMiA9IG9yaWVudGF0aW9uMiA/IDAgOiBwdHMyLmxlbmd0aCAtIDE7XG4gIC8vIGNvbnN0IGNvbXAgPSAwXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIGNvbXBQdCA9IHB0czFbaTFdLmNvbXBhcmVUbyhwdHMyW2kyXSk7XG4gICAgaWYgKGNvbXBQdCAhPT0gMCkgeyByZXR1cm4gY29tcFB0IH1cbiAgICBpMSArPSBkaXIxO1xuICAgIGkyICs9IGRpcjI7XG4gICAgdmFyIGRvbmUxID0gaTEgPT09IGxpbWl0MTtcbiAgICB2YXIgZG9uZTIgPSBpMiA9PT0gbGltaXQyO1xuICAgIGlmIChkb25lMSAmJiAhZG9uZTIpIHsgcmV0dXJuIC0xIH1cbiAgICBpZiAoIWRvbmUxICYmIGRvbmUyKSB7IHJldHVybiAxIH1cbiAgICBpZiAoZG9uZTEgJiYgZG9uZTIpIHsgcmV0dXJuIDAgfVxuICB9XG59O1xuXG52YXIgRWRnZUxpc3QgPSBmdW5jdGlvbiBFZGdlTGlzdCAoKSB7XG4gIHRoaXMuX2VkZ2VzID0gbmV3IEFycmF5TGlzdCgpO1xuICB0aGlzLl9vY2FNYXAgPSBuZXcgVHJlZU1hcCgpO1xufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBvdXQucHJpbnQoJ01VTFRJTElORVNUUklORyAoICcpO1xuICBmb3IgKHZhciBqID0gMDsgaiA8IHRoaXMuX2VkZ2VzLnNpemUoKTsgaisrKSB7XG4gICAgdmFyIGUgPSB0aGlzJDEuX2VkZ2VzLmdldChqKTtcbiAgICBpZiAoaiA+IDApIHsgb3V0LnByaW50KCcsJyk7IH1cbiAgICBvdXQucHJpbnQoJygnKTtcbiAgICB2YXIgcHRzID0gZS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaSA+IDApIHsgb3V0LnByaW50KCcsJyk7IH1cbiAgICAgIG91dC5wcmludChwdHNbaV0ueCArICcgJyArIHB0c1tpXS55KTtcbiAgICB9XG4gICAgb3V0LnByaW50bG4oJyknKTtcbiAgfVxuICBvdXQucHJpbnQoJykgICcpO1xufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiBhZGRBbGwgKGVkZ2VDb2xsKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IGVkZ2VDb2xsLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHRoaXMkMS5hZGQoaS5uZXh0KCkpO1xuICB9XG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmZpbmRFZGdlSW5kZXggPSBmdW5jdGlvbiBmaW5kRWRnZUluZGV4IChlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lZGdlcy5zaXplKCk7IGkrKykge1xuICAgIGlmICh0aGlzJDEuX2VkZ2VzLmdldChpKS5lcXVhbHMoZSkpIHsgcmV0dXJuIGkgfVxuICB9XG4gIHJldHVybiAtMVxufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VzLml0ZXJhdG9yKClcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuZ2V0RWRnZXMgPSBmdW5jdGlvbiBnZXRFZGdlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9lZGdlc1xufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGkpIHtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VzLmdldChpKVxufTtcbkVkZ2VMaXN0LnByb3RvdHlwZS5maW5kRXF1YWxFZGdlID0gZnVuY3Rpb24gZmluZEVxdWFsRWRnZSAoZSkge1xuICB2YXIgb2NhID0gbmV3IE9yaWVudGVkQ29vcmRpbmF0ZUFycmF5KGUuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gIHZhciBtYXRjaEVkZ2UgPSB0aGlzLl9vY2FNYXAuZ2V0KG9jYSk7XG4gIHJldHVybiBtYXRjaEVkZ2Vcbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChlKSB7XG4gIHRoaXMuX2VkZ2VzLmFkZChlKTtcbiAgdmFyIG9jYSA9IG5ldyBPcmllbnRlZENvb3JkaW5hdGVBcnJheShlLmdldENvb3JkaW5hdGVzKCkpO1xuICB0aGlzLl9vY2FNYXAucHV0KG9jYSwgZSk7XG59O1xuRWRnZUxpc3QucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5FZGdlTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlTGlzdFxufTtcblxudmFyIFNlZ21lbnRJbnRlcnNlY3RvciA9IGZ1bmN0aW9uIFNlZ21lbnRJbnRlcnNlY3RvciAoKSB7fTtcblxuU2VnbWVudEludGVyc2VjdG9yLnByb3RvdHlwZS5wcm9jZXNzSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIHByb2Nlc3NJbnRlcnNlY3Rpb25zIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7fTtcblNlZ21lbnRJbnRlcnNlY3Rvci5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHt9O1xuU2VnbWVudEludGVyc2VjdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU2VnbWVudEludGVyc2VjdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNlZ21lbnRJbnRlcnNlY3RvclxufTtcblxudmFyIEludGVyc2VjdGlvbkFkZGVyID0gZnVuY3Rpb24gSW50ZXJzZWN0aW9uQWRkZXIgKCkge1xuICB0aGlzLl9oYXNJbnRlcnNlY3Rpb24gPSBmYWxzZTtcbiAgdGhpcy5faGFzUHJvcGVyID0gZmFsc2U7XG4gIHRoaXMuX2hhc1Byb3BlckludGVyaW9yID0gZmFsc2U7XG4gIHRoaXMuX2hhc0ludGVyaW9yID0gZmFsc2U7XG4gIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50ID0gbnVsbDtcbiAgdGhpcy5fbGkgPSBudWxsO1xuICB0aGlzLl9pc1NlbGZJbnRlcnNlY3Rpb24gPSBudWxsO1xuICB0aGlzLm51bUludGVyc2VjdGlvbnMgPSAwO1xuICB0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucyA9IDA7XG4gIHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucyA9IDA7XG4gIHRoaXMubnVtVGVzdHMgPSAwO1xuICB2YXIgbGkgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2xpID0gbGk7XG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmlzVHJpdmlhbEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGlzVHJpdmlhbEludGVyc2VjdGlvbiAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge1xuICBpZiAoZTAgPT09IGUxKSB7XG4gICAgaWYgKHRoaXMuX2xpLmdldEludGVyc2VjdGlvbk51bSgpID09PSAxKSB7XG4gICAgICBpZiAoSW50ZXJzZWN0aW9uQWRkZXIuaXNBZGphY2VudFNlZ21lbnRzKHNlZ0luZGV4MCwgc2VnSW5kZXgxKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAoZTAuaXNDbG9zZWQoKSkge1xuICAgICAgICB2YXIgbWF4U2VnSW5kZXggPSBlMC5zaXplKCkgLSAxO1xuICAgICAgICBpZiAoKHNlZ0luZGV4MCA9PT0gMCAmJiBzZWdJbmRleDEgPT09IG1heFNlZ0luZGV4KSB8fFxuICAgICAgICAgICAgKHNlZ0luZGV4MSA9PT0gMCAmJiBzZWdJbmRleDAgPT09IG1heFNlZ0luZGV4KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmdldFByb3BlckludGVyc2VjdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQgKCkge1xuICByZXR1cm4gdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnRcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvclxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5nZXRMaW5lSW50ZXJzZWN0b3IgPSBmdW5jdGlvbiBnZXRMaW5lSW50ZXJzZWN0b3IgKCkge1xuICByZXR1cm4gdGhpcy5fbGlcbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuaGFzUHJvcGVySW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzUHJvcGVySW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlclxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5wcm9jZXNzSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIHByb2Nlc3NJbnRlcnNlY3Rpb25zIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7XG4gIGlmIChlMCA9PT0gZTEgJiYgc2VnSW5kZXgwID09PSBzZWdJbmRleDEpIHsgcmV0dXJuIG51bGwgfVxuICB0aGlzLm51bVRlc3RzKys7XG4gIHZhciBwMDAgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MF07XG4gIHZhciBwMDEgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MCArIDFdO1xuICB2YXIgcDEwID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDFdO1xuICB2YXIgcDExID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDEgKyAxXTtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMDAsIHAwMSwgcDEwLCBwMTEpO1xuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHtcbiAgICB0aGlzLm51bUludGVyc2VjdGlvbnMrKztcbiAgICBpZiAodGhpcy5fbGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpKSB7XG4gICAgICB0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucysrO1xuICAgICAgdGhpcy5faGFzSW50ZXJpb3IgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpKSB7XG4gICAgICB0aGlzLl9oYXNJbnRlcnNlY3Rpb24gPSB0cnVlO1xuICAgICAgZTAuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSwgc2VnSW5kZXgwLCAwKTtcbiAgICAgIGUxLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MSwgMSk7XG4gICAgICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSkge1xuICAgICAgICB0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnMrKztcbiAgICAgICAgdGhpcy5faGFzUHJvcGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5faGFzUHJvcGVySW50ZXJpb3IgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5oYXNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9uXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcbkludGVyc2VjdGlvbkFkZGVyLnByb3RvdHlwZS5oYXNJbnRlcmlvckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc0ludGVyaW9ySW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc0ludGVyaW9yXG59O1xuSW50ZXJzZWN0aW9uQWRkZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlZ21lbnRJbnRlcnNlY3Rvcl1cbn07XG5JbnRlcnNlY3Rpb25BZGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJbnRlcnNlY3Rpb25BZGRlclxufTtcbkludGVyc2VjdGlvbkFkZGVyLmlzQWRqYWNlbnRTZWdtZW50cyA9IGZ1bmN0aW9uIGlzQWRqYWNlbnRTZWdtZW50cyAoaTEsIGkyKSB7XG4gIHJldHVybiBNYXRoLmFicyhpMSAtIGkyKSA9PT0gMVxufTtcblxudmFyIEVkZ2VJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBFZGdlSW50ZXJzZWN0aW9uICgpIHtcbiAgdGhpcy5jb29yZCA9IG51bGw7XG4gIHRoaXMuc2VnbWVudEluZGV4ID0gbnVsbDtcbiAgdGhpcy5kaXN0ID0gbnVsbDtcbiAgdmFyIGNvb3JkID0gYXJndW1lbnRzWzBdO1xuICB2YXIgc2VnbWVudEluZGV4ID0gYXJndW1lbnRzWzFdO1xuICB2YXIgZGlzdCA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5jb29yZCA9IG5ldyBDb29yZGluYXRlKGNvb3JkKTtcbiAgdGhpcy5zZWdtZW50SW5kZXggPSBzZWdtZW50SW5kZXg7XG4gIHRoaXMuZGlzdCA9IGRpc3Q7XG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuZ2V0U2VnbWVudEluZGV4ID0gZnVuY3Rpb24gZ2V0U2VnbWVudEluZGV4ICgpIHtcbiAgcmV0dXJuIHRoaXMuc2VnbWVudEluZGV4XG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5jb29yZFxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICBvdXQucHJpbnQodGhpcy5jb29yZCk7XG4gIG91dC5wcmludCgnIHNlZyAjID0gJyArIHRoaXMuc2VnbWVudEluZGV4KTtcbiAgb3V0LnByaW50bG4oJyBkaXN0ID0gJyArIHRoaXMuZGlzdCk7XG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvYmopIHtcbiAgdmFyIG90aGVyID0gb2JqO1xuICByZXR1cm4gdGhpcy5jb21wYXJlKG90aGVyLnNlZ21lbnRJbmRleCwgb3RoZXIuZGlzdClcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5pc0VuZFBvaW50ID0gZnVuY3Rpb24gaXNFbmRQb2ludCAobWF4U2VnbWVudEluZGV4KSB7XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA9PT0gMCAmJiB0aGlzLmRpc3QgPT09IDAuMCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA9PT0gbWF4U2VnbWVudEluZGV4KSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuRWRnZUludGVyc2VjdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiB0aGlzLmNvb3JkICsgJyBzZWcgIyA9ICcgKyB0aGlzLnNlZ21lbnRJbmRleCArICcgZGlzdCA9ICcgKyB0aGlzLmRpc3Rcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5nZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldERpc3RhbmNlICgpIHtcbiAgcmV0dXJuIHRoaXMuZGlzdFxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChzZWdtZW50SW5kZXgsIGRpc3QpIHtcbiAgaWYgKHRoaXMuc2VnbWVudEluZGV4IDwgc2VnbWVudEluZGV4KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLnNlZ21lbnRJbmRleCA+IHNlZ21lbnRJbmRleCkgeyByZXR1cm4gMSB9XG4gIGlmICh0aGlzLmRpc3QgPCBkaXN0KSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLmRpc3QgPiBkaXN0KSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5FZGdlSW50ZXJzZWN0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb21wYXJhYmxlXVxufTtcbkVkZ2VJbnRlcnNlY3Rpb24ucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRWRnZUludGVyc2VjdGlvblxufTtcblxudmFyIEVkZ2VJbnRlcnNlY3Rpb25MaXN0ID0gZnVuY3Rpb24gRWRnZUludGVyc2VjdGlvbkxpc3QgKCkge1xuICB0aGlzLl9ub2RlTWFwID0gbmV3IFRyZWVNYXAoKTtcbiAgdGhpcy5lZGdlID0gbnVsbDtcbiAgdmFyIGVkZ2UgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuZWRnZSA9IGVkZ2U7XG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gcHJpbnQgKG91dCkge1xuICBvdXQucHJpbnRsbignSW50ZXJzZWN0aW9uczonKTtcbiAgZm9yICh2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgZWkucHJpbnQob3V0KTtcbiAgfVxufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5pdGVyYXRvciA9IGZ1bmN0aW9uIGl0ZXJhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKVxufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5hZGRTcGxpdEVkZ2VzID0gZnVuY3Rpb24gYWRkU3BsaXRFZGdlcyAoZWRnZUxpc3QpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLmFkZEVuZHBvaW50cygpO1xuICB2YXIgaXQgPSB0aGlzLml0ZXJhdG9yKCk7XG4gIHZhciBlaVByZXYgPSBpdC5uZXh0KCk7XG4gIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICB2YXIgZWkgPSBpdC5uZXh0KCk7XG4gICAgdmFyIG5ld0VkZ2UgPSB0aGlzJDEuY3JlYXRlU3BsaXRFZGdlKGVpUHJldiwgZWkpO1xuICAgIGVkZ2VMaXN0LmFkZChuZXdFZGdlKTtcbiAgICBlaVByZXYgPSBlaTtcbiAgfVxufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5hZGRFbmRwb2ludHMgPSBmdW5jdGlvbiBhZGRFbmRwb2ludHMgKCkge1xuICB2YXIgbWF4U2VnSW5kZXggPSB0aGlzLmVkZ2UucHRzLmxlbmd0aCAtIDE7XG4gIHRoaXMuYWRkKHRoaXMuZWRnZS5wdHNbMF0sIDAsIDAuMCk7XG4gIHRoaXMuYWRkKHRoaXMuZWRnZS5wdHNbbWF4U2VnSW5kZXhdLCBtYXhTZWdJbmRleCwgMC4wKTtcbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuY3JlYXRlU3BsaXRFZGdlID0gZnVuY3Rpb24gY3JlYXRlU3BsaXRFZGdlIChlaTAsIGVpMSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBucHRzID0gZWkxLnNlZ21lbnRJbmRleCAtIGVpMC5zZWdtZW50SW5kZXggKyAyO1xuICB2YXIgbGFzdFNlZ1N0YXJ0UHQgPSB0aGlzLmVkZ2UucHRzW2VpMS5zZWdtZW50SW5kZXhdO1xuICB2YXIgdXNlSW50UHQxID0gZWkxLmRpc3QgPiAwLjAgfHwgIWVpMS5jb29yZC5lcXVhbHMyRChsYXN0U2VnU3RhcnRQdCk7XG4gIGlmICghdXNlSW50UHQxKSB7XG4gICAgbnB0cy0tO1xuICB9XG4gIHZhciBwdHMgPSBuZXcgQXJyYXkobnB0cykuZmlsbChudWxsKTtcbiAgdmFyIGlwdCA9IDA7XG4gIHB0c1tpcHQrK10gPSBuZXcgQ29vcmRpbmF0ZShlaTAuY29vcmQpO1xuICBmb3IgKHZhciBpID0gZWkwLnNlZ21lbnRJbmRleCArIDE7IGkgPD0gZWkxLnNlZ21lbnRJbmRleDsgaSsrKSB7XG4gICAgcHRzW2lwdCsrXSA9IHRoaXMkMS5lZGdlLnB0c1tpXTtcbiAgfVxuICBpZiAodXNlSW50UHQxKSB7IHB0c1tpcHRdID0gZWkxLmNvb3JkOyB9XG4gIHJldHVybiBuZXcgRWRnZShwdHMsIG5ldyBMYWJlbCh0aGlzLmVkZ2UuX2xhYmVsKSlcbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChpbnRQdCwgc2VnbWVudEluZGV4LCBkaXN0KSB7XG4gIHZhciBlaU5ldyA9IG5ldyBFZGdlSW50ZXJzZWN0aW9uKGludFB0LCBzZWdtZW50SW5kZXgsIGRpc3QpO1xuICB2YXIgZWkgPSB0aGlzLl9ub2RlTWFwLmdldChlaU5ldyk7XG4gIGlmIChlaSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBlaVxuICB9XG4gIHRoaXMuX25vZGVNYXAucHV0KGVpTmV3LCBlaU5ldyk7XG4gIHJldHVybiBlaU5ld1xufTtcbkVkZ2VJbnRlcnNlY3Rpb25MaXN0LnByb3RvdHlwZS5pc0ludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGlzSW50ZXJzZWN0aW9uIChwdCkge1xuICBmb3IgKHZhciBpdCA9IHRoaXMuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlaSA9IGl0Lm5leHQoKTtcbiAgICBpZiAoZWkuY29vcmQuZXF1YWxzKHB0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuRWRnZUludGVyc2VjdGlvbkxpc3QucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5FZGdlSW50ZXJzZWN0aW9uTGlzdC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlSW50ZXJzZWN0aW9uTGlzdFxufTtcblxudmFyIE1vbm90b25lQ2hhaW5JbmRleGVyID0gZnVuY3Rpb24gTW9ub3RvbmVDaGFpbkluZGV4ZXIgKCkge307XG5cbk1vbm90b25lQ2hhaW5JbmRleGVyLnByb3RvdHlwZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyA9IGZ1bmN0aW9uIGdldENoYWluU3RhcnRJbmRpY2VzIChwdHMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgc3RhcnRJbmRleExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHN0YXJ0SW5kZXhMaXN0LmFkZChuZXcgSW50ZWdlcihzdGFydCkpO1xuICBkbyB7XG4gICAgdmFyIGxhc3QgPSB0aGlzJDEuZmluZENoYWluRW5kKHB0cywgc3RhcnQpO1xuICAgIHN0YXJ0SW5kZXhMaXN0LmFkZChuZXcgSW50ZWdlcihsYXN0KSk7XG4gICAgc3RhcnQgPSBsYXN0O1xuICB9IHdoaWxlIChzdGFydCA8IHB0cy5sZW5ndGggLSAxKVxuICB2YXIgc3RhcnRJbmRleCA9IE1vbm90b25lQ2hhaW5JbmRleGVyLnRvSW50QXJyYXkoc3RhcnRJbmRleExpc3QpO1xuICByZXR1cm4gc3RhcnRJbmRleFxufTtcbk1vbm90b25lQ2hhaW5JbmRleGVyLnByb3RvdHlwZS5maW5kQ2hhaW5FbmQgPSBmdW5jdGlvbiBmaW5kQ2hhaW5FbmQgKHB0cywgc3RhcnQpIHtcbiAgdmFyIGNoYWluUXVhZCA9IFF1YWRyYW50LnF1YWRyYW50KHB0c1tzdGFydF0sIHB0c1tzdGFydCArIDFdKTtcbiAgdmFyIGxhc3QgPSBzdGFydCArIDE7XG4gIHdoaWxlIChsYXN0IDwgcHRzLmxlbmd0aCkge1xuICAgIHZhciBxdWFkID0gUXVhZHJhbnQucXVhZHJhbnQocHRzW2xhc3QgLSAxXSwgcHRzW2xhc3RdKTtcbiAgICBpZiAocXVhZCAhPT0gY2hhaW5RdWFkKSB7IGJyZWFrIH1cbiAgICBsYXN0Kys7XG4gIH1cbiAgcmV0dXJuIGxhc3QgLSAxXG59O1xuTW9ub3RvbmVDaGFpbkluZGV4ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Nb25vdG9uZUNoYWluSW5kZXhlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluSW5kZXhlclxufTtcbk1vbm90b25lQ2hhaW5JbmRleGVyLnRvSW50QXJyYXkgPSBmdW5jdGlvbiB0b0ludEFycmF5IChsaXN0KSB7XG4gIHZhciBhcnJheSA9IG5ldyBBcnJheShsaXN0LnNpemUoKSkuZmlsbChudWxsKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGFycmF5W2ldID0gbGlzdC5nZXQoaSkuaW50VmFsdWUoKTtcbiAgfVxuICByZXR1cm4gYXJyYXlcbn07XG5cbnZhciBNb25vdG9uZUNoYWluRWRnZSA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW5FZGdlICgpIHtcbiAgdGhpcy5lID0gbnVsbDtcbiAgdGhpcy5wdHMgPSBudWxsO1xuICB0aGlzLnN0YXJ0SW5kZXggPSBudWxsO1xuICB0aGlzLmVudjEgPSBuZXcgRW52ZWxvcGUoKTtcbiAgdGhpcy5lbnYyID0gbmV3IEVudmVsb3BlKCk7XG4gIHZhciBlID0gYXJndW1lbnRzWzBdO1xuICB0aGlzLmUgPSBlO1xuICB0aGlzLnB0cyA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgdmFyIG1jYiA9IG5ldyBNb25vdG9uZUNoYWluSW5kZXhlcigpO1xuICB0aGlzLnN0YXJ0SW5kZXggPSBtY2IuZ2V0Q2hhaW5TdGFydEluZGljZXModGhpcy5wdHMpO1xufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5nZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzICgpIHtcbiAgcmV0dXJuIHRoaXMucHRzXG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmdldE1heFggPSBmdW5jdGlvbiBnZXRNYXhYIChjaGFpbkluZGV4KSB7XG4gIHZhciB4MSA9IHRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFtjaGFpbkluZGV4XV0ueDtcbiAgdmFyIHgyID0gdGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W2NoYWluSW5kZXggKyAxXV0ueDtcbiAgcmV0dXJuIHgxID4geDIgPyB4MSA6IHgyXG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmdldE1pblggPSBmdW5jdGlvbiBnZXRNaW5YIChjaGFpbkluZGV4KSB7XG4gIHZhciB4MSA9IHRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFtjaGFpbkluZGV4XV0ueDtcbiAgdmFyIHgyID0gdGhpcy5wdHNbdGhpcy5zdGFydEluZGV4W2NoYWluSW5kZXggKyAxXV0ueDtcbiAgcmV0dXJuIHgxIDwgeDIgPyB4MSA6IHgyXG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4gPSBmdW5jdGlvbiBjb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDQpIHtcbiAgICB2YXIgY2hhaW5JbmRleDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgY2hhaW5JbmRleDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHNpID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbih0aGlzLnN0YXJ0SW5kZXhbY2hhaW5JbmRleDBdLCB0aGlzLnN0YXJ0SW5kZXhbY2hhaW5JbmRleDAgKyAxXSwgbWNlLCBtY2Uuc3RhcnRJbmRleFtjaGFpbkluZGV4MV0sIG1jZS5zdGFydEluZGV4W2NoYWluSW5kZXgxICsgMV0sIHNpKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSA2KSB7XG4gICAgdmFyIHN0YXJ0MCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZW5kMCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbWNlJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHN0YXJ0MSA9IGFyZ3VtZW50c1szXTtcbiAgICB2YXIgZW5kMSA9IGFyZ3VtZW50c1s0XTtcbiAgICB2YXIgZWkgPSBhcmd1bWVudHNbNV07XG4gICAgdmFyIHAwMCA9IHRoaXMucHRzW3N0YXJ0MF07XG4gICAgdmFyIHAwMSA9IHRoaXMucHRzW2VuZDBdO1xuICAgIHZhciBwMTAgPSBtY2UkMS5wdHNbc3RhcnQxXTtcbiAgICB2YXIgcDExID0gbWNlJDEucHRzW2VuZDFdO1xuICAgIGlmIChlbmQwIC0gc3RhcnQwID09PSAxICYmIGVuZDEgLSBzdGFydDEgPT09IDEpIHtcbiAgICAgIGVpLmFkZEludGVyc2VjdGlvbnModGhpcy5lLCBzdGFydDAsIG1jZSQxLmUsIHN0YXJ0MSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB0aGlzLmVudjEuaW5pdChwMDAsIHAwMSk7XG4gICAgdGhpcy5lbnYyLmluaXQocDEwLCBwMTEpO1xuICAgIGlmICghdGhpcy5lbnYxLmludGVyc2VjdHModGhpcy5lbnYyKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIG1pZDAgPSBNYXRoLnRydW5jKChzdGFydDAgKyBlbmQwKSAvIDIpO1xuICAgIHZhciBtaWQxID0gTWF0aC50cnVuYygoc3RhcnQxICsgZW5kMSkgLyAyKTtcbiAgICBpZiAoc3RhcnQwIDwgbWlkMCkge1xuICAgICAgaWYgKHN0YXJ0MSA8IG1pZDEpIHsgdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHN0YXJ0MCwgbWlkMCwgbWNlJDEsIHN0YXJ0MSwgbWlkMSwgZWkpOyB9XG4gICAgICBpZiAobWlkMSA8IGVuZDEpIHsgdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHN0YXJ0MCwgbWlkMCwgbWNlJDEsIG1pZDEsIGVuZDEsIGVpKTsgfVxuICAgIH1cbiAgICBpZiAobWlkMCA8IGVuZDApIHtcbiAgICAgIGlmIChzdGFydDEgPCBtaWQxKSB7IHRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihtaWQwLCBlbmQwLCBtY2UkMSwgc3RhcnQxLCBtaWQxLCBlaSk7IH1cbiAgICAgIGlmIChtaWQxIDwgZW5kMSkgeyB0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4obWlkMCwgZW5kMCwgbWNlJDEsIG1pZDEsIGVuZDEsIGVpKTsgfVxuICAgIH1cbiAgfVxufTtcbk1vbm90b25lQ2hhaW5FZGdlLnByb3RvdHlwZS5nZXRTdGFydEluZGV4ZXMgPSBmdW5jdGlvbiBnZXRTdGFydEluZGV4ZXMgKCkge1xuICByZXR1cm4gdGhpcy5zdGFydEluZGV4XG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3RzID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdHMgKG1jZSwgc2kpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhcnRJbmRleC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1jZS5zdGFydEluZGV4Lmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgdGhpcyQxLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oaSwgbWNlLCBqLCBzaSk7XG4gICAgfVxuICB9XG59O1xuTW9ub3RvbmVDaGFpbkVkZ2UucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Nb25vdG9uZUNoYWluRWRnZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluRWRnZVxufTtcblxudmFyIERlcHRoID0gZnVuY3Rpb24gRGVwdGggKCkge1xuICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB0aGlzLl9kZXB0aCA9IEFycmF5KDIpLmZpbGwoKS5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gQXJyYXkoMyk7IH0pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG4gICAgICB0aGlzJDEuX2RlcHRoW2ldW2pdID0gRGVwdGguTlVMTF9WQUxVRTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzEgPSB7IE5VTExfVkFMVUU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkRlcHRoLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uIGdldERlcHRoIChnZW9tSW5kZXgsIHBvc0luZGV4KSB7XG4gIHJldHVybiB0aGlzLl9kZXB0aFtnZW9tSW5kZXhdW3Bvc0luZGV4XVxufTtcbkRlcHRoLnByb3RvdHlwZS5zZXREZXB0aCA9IGZ1bmN0aW9uIHNldERlcHRoIChnZW9tSW5kZXgsIHBvc0luZGV4LCBkZXB0aFZhbHVlKSB7XG4gIHRoaXMuX2RlcHRoW2dlb21JbmRleF1bcG9zSW5kZXhdID0gZGVwdGhWYWx1ZTtcbn07XG5EZXB0aC5wcm90b3R5cGUuaXNOdWxsID0gZnVuY3Rpb24gaXNOdWxsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGorKykge1xuICAgICAgICBpZiAodGhpcyQxLl9kZXB0aFtpXVtqXSAhPT0gRGVwdGguTlVMTF9WQUxVRSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHJldHVybiB0aGlzLl9kZXB0aFtnZW9tSW5kZXhdWzFdID09PSBEZXB0aC5OVUxMX1ZBTFVFXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnZW9tSW5kZXgkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcG9zSW5kZXggPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoW2dlb21JbmRleCQxXVtwb3NJbmRleF0gPT09IERlcHRoLk5VTExfVkFMVUVcbiAgfVxufTtcbkRlcHRoLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbiBub3JtYWxpemUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgaWYgKCF0aGlzJDEuaXNOdWxsKGkpKSB7XG4gICAgICB2YXIgbWluRGVwdGggPSB0aGlzJDEuX2RlcHRoW2ldWzFdO1xuICAgICAgaWYgKHRoaXMkMS5fZGVwdGhbaV1bMl0gPCBtaW5EZXB0aCkgeyBtaW5EZXB0aCA9IHRoaXMkMS5fZGVwdGhbaV1bMl07IH1cbiAgICAgIGlmIChtaW5EZXB0aCA8IDApIHsgbWluRGVwdGggPSAwOyB9XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IDM7IGorKykge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSAwO1xuICAgICAgICBpZiAodGhpcyQxLl9kZXB0aFtpXVtqXSA+IG1pbkRlcHRoKSB7IG5ld1ZhbHVlID0gMTsgfVxuICAgICAgICB0aGlzJDEuX2RlcHRoW2ldW2pdID0gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuRGVwdGgucHJvdG90eXBlLmdldERlbHRhID0gZnVuY3Rpb24gZ2V0RGVsdGEgKGdlb21JbmRleCkge1xuICByZXR1cm4gdGhpcy5fZGVwdGhbZ2VvbUluZGV4XVtQb3NpdGlvbi5SSUdIVF0gLSB0aGlzLl9kZXB0aFtnZW9tSW5kZXhdW1Bvc2l0aW9uLkxFRlRdXG59O1xuRGVwdGgucHJvdG90eXBlLmdldExvY2F0aW9uID0gZnVuY3Rpb24gZ2V0TG9jYXRpb24gKGdlb21JbmRleCwgcG9zSW5kZXgpIHtcbiAgaWYgKHRoaXMuX2RlcHRoW2dlb21JbmRleF1bcG9zSW5kZXhdIDw9IDApIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SXG59O1xuRGVwdGgucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gJ0E6ICcgKyB0aGlzLl9kZXB0aFswXVsxXSArICcsJyArIHRoaXMuX2RlcHRoWzBdWzJdICsgJyBCOiAnICsgdGhpcy5fZGVwdGhbMV1bMV0gKyAnLCcgKyB0aGlzLl9kZXB0aFsxXVsyXVxufTtcbkRlcHRoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGxibCA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCAzOyBqKyspIHtcbiAgICAgICAgdmFyIGxvYyA9IGxibC5nZXRMb2NhdGlvbihpLCBqKTtcbiAgICAgICAgaWYgKGxvYyA9PT0gTG9jYXRpb24uRVhURVJJT1IgfHwgbG9jID09PSBMb2NhdGlvbi5JTlRFUklPUikge1xuICAgICAgICAgIGlmICh0aGlzJDEuaXNOdWxsKGksIGopKSB7XG4gICAgICAgICAgICB0aGlzJDEuX2RlcHRoW2ldW2pdID0gRGVwdGguZGVwdGhBdExvY2F0aW9uKGxvYyk7XG4gICAgICAgICAgfSBlbHNlIHsgdGhpcyQxLl9kZXB0aFtpXVtqXSArPSBEZXB0aC5kZXB0aEF0TG9jYXRpb24obG9jKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgZ2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwb3NJbmRleCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbG9jYXRpb24gPSBhcmd1bWVudHNbMl07XG4gICAgaWYgKGxvY2F0aW9uID09PSBMb2NhdGlvbi5JTlRFUklPUikgeyB0aGlzLl9kZXB0aFtnZW9tSW5kZXhdW3Bvc0luZGV4XSsrOyB9XG4gIH1cbn07XG5EZXB0aC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkRlcHRoLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERlcHRoXG59O1xuRGVwdGguZGVwdGhBdExvY2F0aW9uID0gZnVuY3Rpb24gZGVwdGhBdExvY2F0aW9uIChsb2NhdGlvbikge1xuICBpZiAobG9jYXRpb24gPT09IExvY2F0aW9uLkVYVEVSSU9SKSB7IHJldHVybiAwIH1cbiAgaWYgKGxvY2F0aW9uID09PSBMb2NhdGlvbi5JTlRFUklPUikgeyByZXR1cm4gMSB9XG4gIHJldHVybiBEZXB0aC5OVUxMX1ZBTFVFXG59O1xuc3RhdGljQWNjZXNzb3JzJDMxLk5VTExfVkFMVUUuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTEgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERlcHRoLCBzdGF0aWNBY2Nlc3NvcnMkMzEgKTtcblxudmFyIEVkZ2UgPSAoZnVuY3Rpb24gKEdyYXBoQ29tcG9uZW50JCQxKSB7XG4gIGZ1bmN0aW9uIEVkZ2UgKCkge1xuICAgIEdyYXBoQ29tcG9uZW50JCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5wdHMgPSBudWxsO1xuICAgIHRoaXMuX2VudiA9IG51bGw7XG4gICAgdGhpcy5laUxpc3QgPSBuZXcgRWRnZUludGVyc2VjdGlvbkxpc3QodGhpcyk7XG4gICAgdGhpcy5fbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fbWNlID0gbnVsbDtcbiAgICB0aGlzLl9pc0lzb2xhdGVkID0gdHJ1ZTtcbiAgICB0aGlzLl9kZXB0aCA9IG5ldyBEZXB0aCgpO1xuICAgIHRoaXMuX2RlcHRoRGVsdGEgPSAwO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICAgICAgRWRnZS5jYWxsKHRoaXMsIHB0cywgbnVsbCk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgcHRzJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGFiZWwgPSBhcmd1bWVudHNbMV07XG4gICAgICB0aGlzLnB0cyA9IHB0cyQxO1xuICAgICAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIEdyYXBoQ29tcG9uZW50JCQxICkgRWRnZS5fX3Byb3RvX18gPSBHcmFwaENvbXBvbmVudCQkMTtcbiAgRWRnZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBHcmFwaENvbXBvbmVudCQkMSAmJiBHcmFwaENvbXBvbmVudCQkMS5wcm90b3R5cGUgKTtcbiAgRWRnZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBFZGdlO1xuICBFZGdlLnByb3RvdHlwZS5nZXREZXB0aCA9IGZ1bmN0aW9uIGdldERlcHRoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGVwdGhcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0Q29sbGFwc2VkRWRnZSA9IGZ1bmN0aW9uIGdldENvbGxhcHNlZEVkZ2UgKCkge1xuICAgIHZhciBuZXdQdHMgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgICBuZXdQdHNbMF0gPSB0aGlzLnB0c1swXTtcbiAgICBuZXdQdHNbMV0gPSB0aGlzLnB0c1sxXTtcbiAgICB2YXIgbmV3ZSA9IG5ldyBFZGdlKG5ld1B0cywgTGFiZWwudG9MaW5lTGFiZWwodGhpcy5fbGFiZWwpKTtcbiAgICByZXR1cm4gbmV3ZVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5pc0lzb2xhdGVkID0gZnVuY3Rpb24gaXNJc29sYXRlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzSXNvbGF0ZWRcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMucHRzXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLnNldElzb2xhdGVkID0gZnVuY3Rpb24gc2V0SXNvbGF0ZWQgKGlzSXNvbGF0ZWQpIHtcbiAgICB0aGlzLl9pc0lzb2xhdGVkID0gaXNJc29sYXRlZDtcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuc2V0TmFtZSA9IGZ1bmN0aW9uIHNldE5hbWUgKG5hbWUpIHtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChvKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoIShvIGluc3RhbmNlb2YgRWRnZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgZSA9IG87XG4gICAgaWYgKHRoaXMucHRzLmxlbmd0aCAhPT0gZS5wdHMubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGlzRXF1YWxGb3J3YXJkID0gdHJ1ZTtcbiAgICB2YXIgaXNFcXVhbFJldmVyc2UgPSB0cnVlO1xuICAgIHZhciBpUmV2ID0gdGhpcy5wdHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcyQxLnB0c1tpXS5lcXVhbHMyRChlLnB0c1tpXSkpIHtcbiAgICAgICAgaXNFcXVhbEZvcndhcmQgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcyQxLnB0c1tpXS5lcXVhbHMyRChlLnB0c1stLWlSZXZdKSkge1xuICAgICAgICBpc0VxdWFsUmV2ZXJzZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0VxdWFsRm9yd2FyZCAmJiAhaXNFcXVhbFJldmVyc2UpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5wdHMubGVuZ3RoID4gMCkgeyByZXR1cm4gdGhpcy5wdHNbMF0gfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBpID0gYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIHRoaXMucHRzW2ldXG4gICAgfVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5wcmludCA9IGZ1bmN0aW9uIHByaW50IChvdXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIG91dC5wcmludCgnZWRnZSAnICsgdGhpcy5fbmFtZSArICc6ICcpO1xuICAgIG91dC5wcmludCgnTElORVNUUklORyAoJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPiAwKSB7IG91dC5wcmludCgnLCcpOyB9XG4gICAgICBvdXQucHJpbnQodGhpcyQxLnB0c1tpXS54ICsgJyAnICsgdGhpcyQxLnB0c1tpXS55KTtcbiAgICB9XG4gICAgb3V0LnByaW50KCcpICAnICsgdGhpcy5fbGFiZWwgKyAnICcgKyB0aGlzLl9kZXB0aERlbHRhKTtcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuY29tcHV0ZUlNID0gZnVuY3Rpb24gY29tcHV0ZUlNIChpbSkge1xuICAgIEVkZ2UudXBkYXRlSU0odGhpcy5fbGFiZWwsIGltKTtcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuaXNDb2xsYXBzZWQgPSBmdW5jdGlvbiBpc0NvbGxhcHNlZCAoKSB7XG4gICAgaWYgKCF0aGlzLl9sYWJlbC5pc0FyZWEoKSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGlmICh0aGlzLnB0cy5sZW5ndGggIT09IDMpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzWzJdKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKCkge1xuICAgIHJldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoIC0gMV0pXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldE1heGltdW1TZWdtZW50SW5kZXggPSBmdW5jdGlvbiBnZXRNYXhpbXVtU2VnbWVudEluZGV4ICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdHMubGVuZ3RoIC0gMVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXREZXB0aERlbHRhID0gZnVuY3Rpb24gZ2V0RGVwdGhEZWx0YSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlcHRoRGVsdGFcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0TnVtUG9pbnRzID0gZnVuY3Rpb24gZ2V0TnVtUG9pbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5wdHMubGVuZ3RoXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLnByaW50UmV2ZXJzZSA9IGZ1bmN0aW9uIHByaW50UmV2ZXJzZSAob3V0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBvdXQucHJpbnQoJ2VkZ2UgJyArIHRoaXMuX25hbWUgKyAnOiAnKTtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5wdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIG91dC5wcmludCh0aGlzJDEucHRzW2ldICsgJyAnKTtcbiAgICB9XG4gICAgb3V0LnByaW50bG4oJycpO1xuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRNb25vdG9uZUNoYWluRWRnZSA9IGZ1bmN0aW9uIGdldE1vbm90b25lQ2hhaW5FZGdlICgpIHtcbiAgICBpZiAodGhpcy5fbWNlID09PSBudWxsKSB7IHRoaXMuX21jZSA9IG5ldyBNb25vdG9uZUNoYWluRWRnZSh0aGlzKTsgfVxuICAgIHJldHVybiB0aGlzLl9tY2VcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuZ2V0RW52ZWxvcGUgPSBmdW5jdGlvbiBnZXRFbnZlbG9wZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fZW52ID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9lbnYgPSBuZXcgRW52ZWxvcGUoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLl9lbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMkMS5wdHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW52XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmFkZEludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGFkZEludGVyc2VjdGlvbiAobGksIHNlZ21lbnRJbmRleCwgZ2VvbUluZGV4LCBpbnRJbmRleCkge1xuICAgIHZhciBpbnRQdCA9IG5ldyBDb29yZGluYXRlKGxpLmdldEludGVyc2VjdGlvbihpbnRJbmRleCkpO1xuICAgIHZhciBub3JtYWxpemVkU2VnbWVudEluZGV4ID0gc2VnbWVudEluZGV4O1xuICAgIHZhciBkaXN0ID0gbGkuZ2V0RWRnZURpc3RhbmNlKGdlb21JbmRleCwgaW50SW5kZXgpO1xuICAgIHZhciBuZXh0U2VnSW5kZXggPSBub3JtYWxpemVkU2VnbWVudEluZGV4ICsgMTtcbiAgICBpZiAobmV4dFNlZ0luZGV4IDwgdGhpcy5wdHMubGVuZ3RoKSB7XG4gICAgICB2YXIgbmV4dFB0ID0gdGhpcy5wdHNbbmV4dFNlZ0luZGV4XTtcbiAgICAgIGlmIChpbnRQdC5lcXVhbHMyRChuZXh0UHQpKSB7XG4gICAgICAgIG5vcm1hbGl6ZWRTZWdtZW50SW5kZXggPSBuZXh0U2VnSW5kZXg7XG4gICAgICAgIGRpc3QgPSAwLjA7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZWlMaXN0LmFkZChpbnRQdCwgbm9ybWFsaXplZFNlZ21lbnRJbmRleCwgZGlzdCk7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGJ1ZiA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcbiAgICBidWYuYXBwZW5kKCdlZGdlICcgKyB0aGlzLl9uYW1lICsgJzogJyk7XG4gICAgYnVmLmFwcGVuZCgnTElORVNUUklORyAoJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGkgPiAwKSB7IGJ1Zi5hcHBlbmQoJywnKTsgfVxuICAgICAgYnVmLmFwcGVuZCh0aGlzJDEucHRzW2ldLnggKyAnICcgKyB0aGlzJDEucHRzW2ldLnkpO1xuICAgIH1cbiAgICBidWYuYXBwZW5kKCcpICAnICsgdGhpcy5fbGFiZWwgKyAnICcgKyB0aGlzLl9kZXB0aERlbHRhKTtcbiAgICByZXR1cm4gYnVmLnRvU3RyaW5nKClcbiAgfTtcbiAgRWRnZS5wcm90b3R5cGUuaXNQb2ludHdpc2VFcXVhbCA9IGZ1bmN0aW9uIGlzUG9pbnR3aXNlRXF1YWwgKGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLnB0cy5sZW5ndGggIT09IGUucHRzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghdGhpcyQxLnB0c1tpXS5lcXVhbHMyRChlLnB0c1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLnNldERlcHRoRGVsdGEgPSBmdW5jdGlvbiBzZXREZXB0aERlbHRhIChkZXB0aERlbHRhKSB7XG4gICAgdGhpcy5fZGVwdGhEZWx0YSA9IGRlcHRoRGVsdGE7XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0ID0gZnVuY3Rpb24gZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QgKCkge1xuICAgIHJldHVybiB0aGlzLmVpTGlzdFxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gYWRkSW50ZXJzZWN0aW9ucyAobGksIHNlZ21lbnRJbmRleCwgZ2VvbUluZGV4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpLmdldEludGVyc2VjdGlvbk51bSgpOyBpKyspIHtcbiAgICAgIHRoaXMkMS5hZGRJbnRlcnNlY3Rpb24obGksIHNlZ21lbnRJbmRleCwgZ2VvbUluZGV4LCBpKTtcbiAgICB9XG4gIH07XG4gIEVkZ2UucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBFZGdlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gRWRnZVxuICB9O1xuICBFZGdlLnVwZGF0ZUlNID0gZnVuY3Rpb24gdXBkYXRlSU0gKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YXIgbGFiZWwgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgaW0gPSBhcmd1bWVudHNbMV07XG4gICAgICBpbS5zZXRBdExlYXN0SWZWYWxpZChsYWJlbC5nZXRMb2NhdGlvbigwLCBQb3NpdGlvbi5PTiksIGxhYmVsLmdldExvY2F0aW9uKDEsIFBvc2l0aW9uLk9OKSwgMSk7XG4gICAgICBpZiAobGFiZWwuaXNBcmVhKCkpIHtcbiAgICAgICAgaW0uc2V0QXRMZWFzdElmVmFsaWQobGFiZWwuZ2V0TG9jYXRpb24oMCwgUG9zaXRpb24uTEVGVCksIGxhYmVsLmdldExvY2F0aW9uKDEsIFBvc2l0aW9uLkxFRlQpLCAyKTtcbiAgICAgICAgaW0uc2V0QXRMZWFzdElmVmFsaWQobGFiZWwuZ2V0TG9jYXRpb24oMCwgUG9zaXRpb24uUklHSFQpLCBsYWJlbC5nZXRMb2NhdGlvbigxLCBQb3NpdGlvbi5SSUdIVCksIDIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IHJldHVybiBHcmFwaENvbXBvbmVudCQkMS5wcm90b3R5cGUudXBkYXRlSU0uYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG5cbiAgcmV0dXJuIEVkZ2U7XG59KEdyYXBoQ29tcG9uZW50KSk7XG5cbnZhciBCdWZmZXJCdWlsZGVyID0gZnVuY3Rpb24gQnVmZmVyQnVpbGRlciAoYnVmUGFyYW1zKSB7XG4gIHRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX3dvcmtpbmdOb2RlciA9IG51bGw7XG4gIHRoaXMuX2dlb21GYWN0ID0gbnVsbDtcbiAgdGhpcy5fZ3JhcGggPSBudWxsO1xuICB0aGlzLl9lZGdlTGlzdCA9IG5ldyBFZGdlTGlzdCgpO1xuICB0aGlzLl9idWZQYXJhbXMgPSBidWZQYXJhbXMgfHwgbnVsbDtcbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwgPSBmdW5jdGlvbiBzZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwgKHBtKSB7XG4gIHRoaXMuX3dvcmtpbmdQcmVjaXNpb25Nb2RlbCA9IHBtO1xufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmluc2VydFVuaXF1ZUVkZ2UgPSBmdW5jdGlvbiBpbnNlcnRVbmlxdWVFZGdlIChlKSB7XG4gIHZhciBleGlzdGluZ0VkZ2UgPSB0aGlzLl9lZGdlTGlzdC5maW5kRXF1YWxFZGdlKGUpO1xuICBpZiAoZXhpc3RpbmdFZGdlICE9PSBudWxsKSB7XG4gICAgdmFyIGV4aXN0aW5nTGFiZWwgPSBleGlzdGluZ0VkZ2UuZ2V0TGFiZWwoKTtcbiAgICB2YXIgbGFiZWxUb01lcmdlID0gZS5nZXRMYWJlbCgpO1xuICAgIGlmICghZXhpc3RpbmdFZGdlLmlzUG9pbnR3aXNlRXF1YWwoZSkpIHtcbiAgICAgIGxhYmVsVG9NZXJnZSA9IG5ldyBMYWJlbChlLmdldExhYmVsKCkpO1xuICAgICAgbGFiZWxUb01lcmdlLmZsaXAoKTtcbiAgICB9XG4gICAgZXhpc3RpbmdMYWJlbC5tZXJnZShsYWJlbFRvTWVyZ2UpO1xuICAgIHZhciBtZXJnZURlbHRhID0gQnVmZmVyQnVpbGRlci5kZXB0aERlbHRhKGxhYmVsVG9NZXJnZSk7XG4gICAgdmFyIGV4aXN0aW5nRGVsdGEgPSBleGlzdGluZ0VkZ2UuZ2V0RGVwdGhEZWx0YSgpO1xuICAgIHZhciBuZXdEZWx0YSA9IGV4aXN0aW5nRGVsdGEgKyBtZXJnZURlbHRhO1xuICAgIGV4aXN0aW5nRWRnZS5zZXREZXB0aERlbHRhKG5ld0RlbHRhKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9lZGdlTGlzdC5hZGQoZSk7XG4gICAgZS5zZXREZXB0aERlbHRhKEJ1ZmZlckJ1aWxkZXIuZGVwdGhEZWx0YShlLmdldExhYmVsKCkpKTtcbiAgfVxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkU3ViZ3JhcGhzID0gZnVuY3Rpb24gYnVpbGRTdWJncmFwaHMgKHN1YmdyYXBoTGlzdCwgcG9seUJ1aWxkZXIpIHtcbiAgdmFyIHByb2Nlc3NlZEdyYXBocyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IHN1YmdyYXBoTGlzdC5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgc3ViZ3JhcGggPSBpLm5leHQoKTtcbiAgICB2YXIgcCA9IHN1YmdyYXBoLmdldFJpZ2h0bW9zdENvb3JkaW5hdGUoKTtcbiAgICB2YXIgbG9jYXRlciA9IG5ldyBTdWJncmFwaERlcHRoTG9jYXRlcihwcm9jZXNzZWRHcmFwaHMpO1xuICAgIHZhciBvdXRzaWRlRGVwdGggPSBsb2NhdGVyLmdldERlcHRoKHApO1xuICAgIHN1YmdyYXBoLmNvbXB1dGVEZXB0aChvdXRzaWRlRGVwdGgpO1xuICAgIHN1YmdyYXBoLmZpbmRSZXN1bHRFZGdlcygpO1xuICAgIHByb2Nlc3NlZEdyYXBocy5hZGQoc3ViZ3JhcGgpO1xuICAgIHBvbHlCdWlsZGVyLmFkZChzdWJncmFwaC5nZXREaXJlY3RlZEVkZ2VzKCksIHN1YmdyYXBoLmdldE5vZGVzKCkpO1xuICB9XG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuY3JlYXRlU3ViZ3JhcGhzID0gZnVuY3Rpb24gY3JlYXRlU3ViZ3JhcGhzIChncmFwaCkge1xuICB2YXIgc3ViZ3JhcGhMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgbm9kZSA9IGkubmV4dCgpO1xuICAgIGlmICghbm9kZS5pc1Zpc2l0ZWQoKSkge1xuICAgICAgdmFyIHN1YmdyYXBoID0gbmV3IEJ1ZmZlclN1YmdyYXBoKCk7XG4gICAgICBzdWJncmFwaC5jcmVhdGUobm9kZSk7XG4gICAgICBzdWJncmFwaExpc3QuYWRkKHN1YmdyYXBoKTtcbiAgICB9XG4gIH1cbiAgQ29sbGVjdGlvbnMuc29ydChzdWJncmFwaExpc3QsIENvbGxlY3Rpb25zLnJldmVyc2VPcmRlcigpKTtcbiAgcmV0dXJuIHN1YmdyYXBoTGlzdFxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkgPSBmdW5jdGlvbiBjcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5ICgpIHtcbiAgdmFyIGVtcHR5R2VvbSA9IHRoaXMuX2dlb21GYWN0LmNyZWF0ZVBvbHlnb24oKTtcbiAgcmV0dXJuIGVtcHR5R2VvbVxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmdldE5vZGVyID0gZnVuY3Rpb24gZ2V0Tm9kZXIgKHByZWNpc2lvbk1vZGVsKSB7XG4gIGlmICh0aGlzLl93b3JraW5nTm9kZXIgIT09IG51bGwpIHsgcmV0dXJuIHRoaXMuX3dvcmtpbmdOb2RlciB9XG4gIHZhciBub2RlciA9IG5ldyBNQ0luZGV4Tm9kZXIoKTtcbiAgdmFyIGxpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICBsaS5zZXRQcmVjaXNpb25Nb2RlbChwcmVjaXNpb25Nb2RlbCk7XG4gIG5vZGVyLnNldFNlZ21lbnRJbnRlcnNlY3RvcihuZXcgSW50ZXJzZWN0aW9uQWRkZXIobGkpKTtcbiAgcmV0dXJuIG5vZGVyXG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24gYnVmZmVyIChnLCBkaXN0YW5jZSkge1xuICB2YXIgcHJlY2lzaW9uTW9kZWwgPSB0aGlzLl93b3JraW5nUHJlY2lzaW9uTW9kZWw7XG4gIGlmIChwcmVjaXNpb25Nb2RlbCA9PT0gbnVsbCkgeyBwcmVjaXNpb25Nb2RlbCA9IGcuZ2V0UHJlY2lzaW9uTW9kZWwoKTsgfVxuICB0aGlzLl9nZW9tRmFjdCA9IGcuZ2V0RmFjdG9yeSgpO1xuICB2YXIgY3VydmVCdWlsZGVyID0gbmV3IE9mZnNldEN1cnZlQnVpbGRlcihwcmVjaXNpb25Nb2RlbCwgdGhpcy5fYnVmUGFyYW1zKTtcbiAgdmFyIGN1cnZlU2V0QnVpbGRlciA9IG5ldyBPZmZzZXRDdXJ2ZVNldEJ1aWxkZXIoZywgZGlzdGFuY2UsIGN1cnZlQnVpbGRlcik7XG4gIHZhciBidWZmZXJTZWdTdHJMaXN0ID0gY3VydmVTZXRCdWlsZGVyLmdldEN1cnZlcygpO1xuICBpZiAoYnVmZmVyU2VnU3RyTGlzdC5zaXplKCkgPD0gMCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKVxuICB9XG4gIHRoaXMuY29tcHV0ZU5vZGVkRWRnZXMoYnVmZmVyU2VnU3RyTGlzdCwgcHJlY2lzaW9uTW9kZWwpO1xuICB0aGlzLl9ncmFwaCA9IG5ldyBQbGFuYXJHcmFwaChuZXcgT3ZlcmxheU5vZGVGYWN0b3J5KCkpO1xuICB0aGlzLl9ncmFwaC5hZGRFZGdlcyh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKTtcbiAgdmFyIHN1YmdyYXBoTGlzdCA9IHRoaXMuY3JlYXRlU3ViZ3JhcGhzKHRoaXMuX2dyYXBoKTtcbiAgdmFyIHBvbHlCdWlsZGVyID0gbmV3IFBvbHlnb25CdWlsZGVyKHRoaXMuX2dlb21GYWN0KTtcbiAgdGhpcy5idWlsZFN1YmdyYXBocyhzdWJncmFwaExpc3QsIHBvbHlCdWlsZGVyKTtcbiAgdmFyIHJlc3VsdFBvbHlMaXN0ID0gcG9seUJ1aWxkZXIuZ2V0UG9seWdvbnMoKTtcbiAgaWYgKHJlc3VsdFBvbHlMaXN0LnNpemUoKSA8PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpXG4gIH1cbiAgdmFyIHJlc3VsdEdlb20gPSB0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHJlc3VsdFBvbHlMaXN0KTtcbiAgcmV0dXJuIHJlc3VsdEdlb21cbn07XG5CdWZmZXJCdWlsZGVyLnByb3RvdHlwZS5jb21wdXRlTm9kZWRFZGdlcyA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlZEVkZ2VzIChidWZmZXJTZWdTdHJMaXN0LCBwcmVjaXNpb25Nb2RlbCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBub2RlciA9IHRoaXMuZ2V0Tm9kZXIocHJlY2lzaW9uTW9kZWwpO1xuICBub2Rlci5jb21wdXRlTm9kZXMoYnVmZmVyU2VnU3RyTGlzdCk7XG4gIHZhciBub2RlZFNlZ1N0cmluZ3MgPSBub2Rlci5nZXROb2RlZFN1YnN0cmluZ3MoKTtcbiAgZm9yICh2YXIgaSA9IG5vZGVkU2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgc2VnU3RyID0gaS5uZXh0KCk7XG4gICAgdmFyIHB0cyA9IHNlZ1N0ci5nZXRDb29yZGluYXRlcygpO1xuICAgIGlmIChwdHMubGVuZ3RoID09PSAyICYmIHB0c1swXS5lcXVhbHMyRChwdHNbMV0pKSB7IGNvbnRpbnVlIH1cbiAgICB2YXIgb2xkTGFiZWwgPSBzZWdTdHIuZ2V0RGF0YSgpO1xuICAgIHZhciBlZGdlID0gbmV3IEVkZ2Uoc2VnU3RyLmdldENvb3JkaW5hdGVzKCksIG5ldyBMYWJlbChvbGRMYWJlbCkpO1xuICAgIHRoaXMkMS5pbnNlcnRVbmlxdWVFZGdlKGVkZ2UpO1xuICB9XG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuc2V0Tm9kZXIgPSBmdW5jdGlvbiBzZXROb2RlciAobm9kZXIpIHtcbiAgdGhpcy5fd29ya2luZ05vZGVyID0gbm9kZXI7XG59O1xuQnVmZmVyQnVpbGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJ1ZmZlckJ1aWxkZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQnVmZmVyQnVpbGRlclxufTtcbkJ1ZmZlckJ1aWxkZXIuZGVwdGhEZWx0YSA9IGZ1bmN0aW9uIGRlcHRoRGVsdGEgKGxhYmVsKSB7XG4gIHZhciBsTG9jID0gbGFiZWwuZ2V0TG9jYXRpb24oMCwgUG9zaXRpb24uTEVGVCk7XG4gIHZhciByTG9jID0gbGFiZWwuZ2V0TG9jYXRpb24oMCwgUG9zaXRpb24uUklHSFQpO1xuICBpZiAobExvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IgJiYgckxvYyA9PT0gTG9jYXRpb24uRVhURVJJT1IpIHsgcmV0dXJuIDE7IH0gZWxzZSBpZiAobExvYyA9PT0gTG9jYXRpb24uRVhURVJJT1IgJiYgckxvYyA9PT0gTG9jYXRpb24uSU5URVJJT1IpIHsgcmV0dXJuIC0xIH1cbiAgcmV0dXJuIDBcbn07XG5CdWZmZXJCdWlsZGVyLmNvbnZlcnRTZWdTdHJpbmdzID0gZnVuY3Rpb24gY29udmVydFNlZ1N0cmluZ3MgKGl0KSB7XG4gIHZhciBmYWN0ID0gbmV3IEdlb21ldHJ5RmFjdG9yeSgpO1xuICB2YXIgbGluZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHdoaWxlIChpdC5oYXNOZXh0KCkpIHtcbiAgICB2YXIgc3MgPSBpdC5uZXh0KCk7XG4gICAgdmFyIGxpbmUgPSBmYWN0LmNyZWF0ZUxpbmVTdHJpbmcoc3MuZ2V0Q29vcmRpbmF0ZXMoKSk7XG4gICAgbGluZXMuYWRkKGxpbmUpO1xuICB9XG4gIHJldHVybiBmYWN0LmJ1aWxkR2VvbWV0cnkobGluZXMpXG59O1xuXG52YXIgU2NhbGVkTm9kZXIgPSBmdW5jdGlvbiBTY2FsZWROb2RlciAoKSB7XG4gIHRoaXMuX25vZGVyID0gbnVsbDtcbiAgdGhpcy5fc2NhbGVGYWN0b3IgPSBudWxsO1xuICB0aGlzLl9vZmZzZXRYID0gbnVsbDtcbiAgdGhpcy5fb2Zmc2V0WSA9IG51bGw7XG4gIHRoaXMuX2lzU2NhbGVkID0gZmFsc2U7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIG5vZGVyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzY2FsZUZhY3RvciA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9ub2RlciA9IG5vZGVyO1xuICAgIHRoaXMuX3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gICAgdGhpcy5fb2Zmc2V0WCA9IDAuMDtcbiAgICB0aGlzLl9vZmZzZXRZID0gMC4wO1xuICAgIHRoaXMuX2lzU2NhbGVkID0gIXRoaXMuaXNJbnRlZ2VyUHJlY2lzaW9uKCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBub2RlciQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzY2FsZUZhY3RvciQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBvZmZzZXRYID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBvZmZzZXRZID0gYXJndW1lbnRzWzNdO1xuICAgIHRoaXMuX25vZGVyID0gbm9kZXIkMTtcbiAgICB0aGlzLl9zY2FsZUZhY3RvciA9IHNjYWxlRmFjdG9yJDE7XG4gICAgdGhpcy5fb2Zmc2V0WCA9IG9mZnNldFg7XG4gICAgdGhpcy5fb2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgdGhpcy5faXNTY2FsZWQgPSAhdGhpcy5pc0ludGVnZXJQcmVjaXNpb24oKTtcbiAgfVxufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5yZXNjYWxlID0gZnVuY3Rpb24gcmVzY2FsZSAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvbGxlY3Rpb24pKSB7XG4gICAgdmFyIHNlZ1N0cmluZ3MgPSBhcmd1bWVudHNbMF07XG4gICAgZm9yICh2YXIgaSA9IHNlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgc3MgPSBpLm5leHQoKTtcbiAgICAgIHRoaXMkMS5yZXNjYWxlKHNzLmdldENvb3JkaW5hdGVzKCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gICAgLy8gbGV0IHAwID0gbnVsbFxuICAgIC8vIGxldCBwMSA9IG51bGxcbiAgICAvLyBpZiAocHRzLmxlbmd0aCA9PT0gMikge1xuICAgIC8vIHAwID0gbmV3IENvb3JkaW5hdGUocHRzWzBdKVxuICAgIC8vIHAxID0gbmV3IENvb3JkaW5hdGUocHRzWzFdKVxuICAgIC8vIH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBwdHMubGVuZ3RoOyBpJDErKykge1xuICAgICAgcHRzW2kkMV0ueCA9IHB0c1tpJDFdLnggLyB0aGlzJDEuX3NjYWxlRmFjdG9yICsgdGhpcyQxLl9vZmZzZXRYO1xuICAgICAgcHRzW2kkMV0ueSA9IHB0c1tpJDFdLnkgLyB0aGlzJDEuX3NjYWxlRmFjdG9yICsgdGhpcyQxLl9vZmZzZXRZO1xuICAgIH1cbiAgICBpZiAocHRzLmxlbmd0aCA9PT0gMiAmJiBwdHNbMF0uZXF1YWxzMkQocHRzWzFdKSkge1xuICAgICAgU3lzdGVtLm91dC5wcmludGxuKHB0cyk7XG4gICAgfVxuICB9XG59O1xuU2NhbGVkTm9kZXIucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb2xsZWN0aW9uKSkge1xuICAgIHZhciBzZWdTdHJpbmdzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBub2RlZFNlZ21lbnRTdHJpbmdzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkgPSBzZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIHNzID0gaS5uZXh0KCk7XG4gICAgICBub2RlZFNlZ21lbnRTdHJpbmdzLmFkZChuZXcgTm9kZWRTZWdtZW50U3RyaW5nKHRoaXMkMS5zY2FsZShzcy5nZXRDb29yZGluYXRlcygpKSwgc3MuZ2V0RGF0YSgpKSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlZFNlZ21lbnRTdHJpbmdzXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICB2YXIgcHRzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciByb3VuZFB0cyA9IG5ldyBBcnJheShwdHMubGVuZ3RoKS5maWxsKG51bGwpO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHB0cy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICByb3VuZFB0c1tpJDFdID0gbmV3IENvb3JkaW5hdGUoTWF0aC5yb3VuZCgocHRzW2kkMV0ueCAtIHRoaXMkMS5fb2Zmc2V0WCkgKiB0aGlzJDEuX3NjYWxlRmFjdG9yKSwgTWF0aC5yb3VuZCgocHRzW2kkMV0ueSAtIHRoaXMkMS5fb2Zmc2V0WSkgKiB0aGlzJDEuX3NjYWxlRmFjdG9yKSwgcHRzW2kkMV0ueik7XG4gICAgfVxuICAgIHZhciByb3VuZFB0c05vRHVwID0gQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVSZXBlYXRlZFBvaW50cyhyb3VuZFB0cyk7XG4gICAgcmV0dXJuIHJvdW5kUHRzTm9EdXBcbiAgfVxufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5pc0ludGVnZXJQcmVjaXNpb24gPSBmdW5jdGlvbiBpc0ludGVnZXJQcmVjaXNpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc2NhbGVGYWN0b3IgPT09IDEuMFxufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5nZXROb2RlZFN1YnN0cmluZ3MgPSBmdW5jdGlvbiBnZXROb2RlZFN1YnN0cmluZ3MgKCkge1xuICB2YXIgc3BsaXRTUyA9IHRoaXMuX25vZGVyLmdldE5vZGVkU3Vic3RyaW5ncygpO1xuICBpZiAodGhpcy5faXNTY2FsZWQpIHsgdGhpcy5yZXNjYWxlKHNwbGl0U1MpOyB9XG4gIHJldHVybiBzcGxpdFNTXG59O1xuU2NhbGVkTm9kZXIucHJvdG90eXBlLmNvbXB1dGVOb2RlcyA9IGZ1bmN0aW9uIGNvbXB1dGVOb2RlcyAoaW5wdXRTZWdTdHJpbmdzKSB7XG4gIHZhciBpbnRTZWdTdHJpbmdzID0gaW5wdXRTZWdTdHJpbmdzO1xuICBpZiAodGhpcy5faXNTY2FsZWQpIHsgaW50U2VnU3RyaW5ncyA9IHRoaXMuc2NhbGUoaW5wdXRTZWdTdHJpbmdzKTsgfVxuICB0aGlzLl9ub2Rlci5jb21wdXRlTm9kZXMoaW50U2VnU3RyaW5ncyk7XG59O1xuU2NhbGVkTm9kZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW05vZGVyXVxufTtcblNjYWxlZE5vZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNjYWxlZE5vZGVyXG59O1xuXG52YXIgTm9kaW5nVmFsaWRhdG9yID0gZnVuY3Rpb24gTm9kaW5nVmFsaWRhdG9yICgpIHtcbiAgdGhpcy5fbGkgPSBuZXcgUm9idXN0TGluZUludGVyc2VjdG9yKCk7XG4gIHRoaXMuX3NlZ1N0cmluZ3MgPSBudWxsO1xuICB2YXIgc2VnU3RyaW5ncyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fc2VnU3RyaW5ncyA9IHNlZ1N0cmluZ3M7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDMzID0geyBmYWN0OiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgc3MgPSBpLm5leHQoKTtcbiAgICAgIHZhciBwdHMgPSBzcy5nZXRDb29yZGluYXRlcygpO1xuICAgICAgdGhpcyQxLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKHB0c1swXSwgdGhpcyQxLl9zZWdTdHJpbmdzKTtcbiAgICAgIHRoaXMkMS5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucyhwdHNbcHRzLmxlbmd0aCAtIDFdLCB0aGlzJDEuX3NlZ1N0cmluZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHRlc3RQdCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2VnU3RyaW5ncyA9IGFyZ3VtZW50c1sxXTtcbiAgICBmb3IgKHZhciBpJDEgPSBzZWdTdHJpbmdzLml0ZXJhdG9yKCk7IGkkMS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgc3MkMSA9IGkkMS5uZXh0KCk7XG4gICAgICB2YXIgcHRzJDEgPSBzcyQxLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICBmb3IgKHZhciBqID0gMTsgaiA8IHB0cyQxLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICBpZiAocHRzJDFbal0uZXF1YWxzKHRlc3RQdCkpIHsgdGhyb3cgbmV3IFJ1bnRpbWVFeGNlcHRpb24oJ2ZvdW5kIGVuZHB0L2ludGVyaW9yIHB0IGludGVyc2VjdGlvbiBhdCBpbmRleCAnICsgaiArICcgOnB0ICcgKyB0ZXN0UHQpIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX3NlZ1N0cmluZ3MuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgc3MwID0gaS5uZXh0KCk7XG4gICAgICBmb3IgKHZhciBqID0gdGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBqLmhhc05leHQoKTspIHtcbiAgICAgICAgdmFyIHNzMSA9IGoubmV4dCgpO1xuICAgICAgICB0aGlzJDEuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoc3MwLCBzczEpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHNzMCQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzczEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHRzMCA9IHNzMCQxLmdldENvb3JkaW5hdGVzKCk7XG4gICAgdmFyIHB0czEgPSBzczEkMS5nZXRDb29yZGluYXRlcygpO1xuICAgIGZvciAodmFyIGkwID0gMDsgaTAgPCBwdHMwLmxlbmd0aCAtIDE7IGkwKyspIHtcbiAgICAgIGZvciAodmFyIGkxID0gMDsgaTEgPCBwdHMxLmxlbmd0aCAtIDE7IGkxKyspIHtcbiAgICAgICAgdGhpcyQxLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHNzMCQxLCBpMCwgc3MxJDEsIGkxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBlMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc2VnSW5kZXgwID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBlMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgc2VnSW5kZXgxID0gYXJndW1lbnRzWzNdO1xuICAgIGlmIChlMCA9PT0gZTEgJiYgc2VnSW5kZXgwID09PSBzZWdJbmRleDEpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBwMDAgPSBlMC5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MF07XG4gICAgdmFyIHAwMSA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwICsgMV07XG4gICAgdmFyIHAxMCA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxXTtcbiAgICB2YXIgcDExID0gZTEuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDEgKyAxXTtcbiAgICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwMCwgcDAxLCBwMTAsIHAxMSk7XG4gICAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgICBpZiAodGhpcy5fbGkuaXNQcm9wZXIoKSB8fCB0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMuX2xpLCBwMDAsIHAwMSkgfHwgdGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLl9saSwgcDEwLCBwMTEpKSB7XG4gICAgICAgIHRocm93IG5ldyBSdW50aW1lRXhjZXB0aW9uKCdmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGF0ICcgKyBwMDAgKyAnLScgKyBwMDEgKyAnIGFuZCAnICsgcDEwICsgJy0nICsgcDExKVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKCkge1xuICB0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKCk7XG4gIHRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKTtcbiAgdGhpcy5jaGVja0NvbGxhcHNlcygpO1xufTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tDb2xsYXBzZXMgPSBmdW5jdGlvbiBjaGVja0NvbGxhcHNlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fc2VnU3RyaW5ncy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBzcyA9IGkubmV4dCgpO1xuICAgICAgdGhpcyQxLmNoZWNrQ29sbGFwc2VzKHNzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBzcyQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdHMgPSBzcyQxLmdldENvb3JkaW5hdGVzKCk7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHRzLmxlbmd0aCAtIDI7IGkkMSsrKSB7XG4gICAgICB0aGlzJDEuY2hlY2tDb2xsYXBzZShwdHNbaSQxXSwgcHRzW2kkMSArIDFdLCBwdHNbaSQxICsgMl0pO1xuICAgIH1cbiAgfVxufTtcbk5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNJbnRlcmlvckludGVyc2VjdGlvbiAobGksIHAwLCBwMSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpLmdldEludGVyc2VjdGlvbk51bSgpOyBpKyspIHtcbiAgICB2YXIgaW50UHQgPSBsaS5nZXRJbnRlcnNlY3Rpb24oaSk7XG4gICAgaWYgKCEoaW50UHQuZXF1YWxzKHAwKSB8fCBpbnRQdC5lcXVhbHMocDEpKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0NvbGxhcHNlID0gZnVuY3Rpb24gY2hlY2tDb2xsYXBzZSAocDAsIHAxLCBwMikge1xuICBpZiAocDAuZXF1YWxzKHAyKSkgeyB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbignZm91bmQgbm9uLW5vZGVkIGNvbGxhcHNlIGF0ICcgKyBOb2RpbmdWYWxpZGF0b3IuZmFjdC5jcmVhdGVMaW5lU3RyaW5nKFtwMCwgcDEsIHAyXSkpIH1cbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Ob2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTm9kaW5nVmFsaWRhdG9yXG59O1xuc3RhdGljQWNjZXNzb3JzJDMzLmZhY3QuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEdlb21ldHJ5RmFjdG9yeSgpIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBOb2RpbmdWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyQzMyApO1xuXG52YXIgSG90UGl4ZWwgPSBmdW5jdGlvbiBIb3RQaXhlbCAoKSB7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5fcHQgPSBudWxsO1xuICB0aGlzLl9vcmlnaW5hbFB0ID0gbnVsbDtcbiAgdGhpcy5fcHRTY2FsZWQgPSBudWxsO1xuICB0aGlzLl9wMFNjYWxlZCA9IG51bGw7XG4gIHRoaXMuX3AxU2NhbGVkID0gbnVsbDtcbiAgdGhpcy5fc2NhbGVGYWN0b3IgPSBudWxsO1xuICB0aGlzLl9taW54ID0gbnVsbDtcbiAgdGhpcy5fbWF4eCA9IG51bGw7XG4gIHRoaXMuX21pbnkgPSBudWxsO1xuICB0aGlzLl9tYXh5ID0gbnVsbDtcbiAgdGhpcy5fY29ybmVyID0gbmV3IEFycmF5KDQpLmZpbGwobnVsbCk7XG4gIHRoaXMuX3NhZmVFbnYgPSBudWxsO1xuICB2YXIgcHQgPSBhcmd1bWVudHNbMF07XG4gIHZhciBzY2FsZUZhY3RvciA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIGxpID0gYXJndW1lbnRzWzJdO1xuICB0aGlzLl9vcmlnaW5hbFB0ID0gcHQ7XG4gIHRoaXMuX3B0ID0gcHQ7XG4gIHRoaXMuX3NjYWxlRmFjdG9yID0gc2NhbGVGYWN0b3I7XG4gIHRoaXMuX2xpID0gbGk7XG4gIGlmIChzY2FsZUZhY3RvciA8PSAwKSB7IHRocm93IG5ldyBJbGxlZ2FsQXJndW1lbnRFeGNlcHRpb24oJ1NjYWxlIGZhY3RvciBtdXN0IGJlIG5vbi16ZXJvJykgfVxuICBpZiAoc2NhbGVGYWN0b3IgIT09IDEuMCkge1xuICAgIHRoaXMuX3B0ID0gbmV3IENvb3JkaW5hdGUodGhpcy5zY2FsZShwdC54KSwgdGhpcy5zY2FsZShwdC55KSk7XG4gICAgdGhpcy5fcDBTY2FsZWQgPSBuZXcgQ29vcmRpbmF0ZSgpO1xuICAgIHRoaXMuX3AxU2NhbGVkID0gbmV3IENvb3JkaW5hdGUoKTtcbiAgfVxuICB0aGlzLmluaXRDb3JuZXJzKHRoaXMuX3B0KTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzQgPSB7IFNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkhvdFBpeGVsLnByb3RvdHlwZS5pbnRlcnNlY3RzU2NhbGVkID0gZnVuY3Rpb24gaW50ZXJzZWN0c1NjYWxlZCAocDAsIHAxKSB7XG4gIHZhciBzZWdNaW54ID0gTWF0aC5taW4ocDAueCwgcDEueCk7XG4gIHZhciBzZWdNYXh4ID0gTWF0aC5tYXgocDAueCwgcDEueCk7XG4gIHZhciBzZWdNaW55ID0gTWF0aC5taW4ocDAueSwgcDEueSk7XG4gIHZhciBzZWdNYXh5ID0gTWF0aC5tYXgocDAueSwgcDEueSk7XG4gIHZhciBpc091dHNpZGVQaXhlbEVudiA9IHRoaXMuX21heHggPCBzZWdNaW54IHx8IHRoaXMuX21pbnggPiBzZWdNYXh4IHx8IHRoaXMuX21heHkgPCBzZWdNaW55IHx8IHRoaXMuX21pbnkgPiBzZWdNYXh5O1xuICBpZiAoaXNPdXRzaWRlUGl4ZWxFbnYpIHsgcmV0dXJuIGZhbHNlIH1cbiAgdmFyIGludGVyc2VjdHMgPSB0aGlzLmludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUocDAsIHAxKTtcbiAgQXNzZXJ0LmlzVHJ1ZSghKGlzT3V0c2lkZVBpeGVsRW52ICYmIGludGVyc2VjdHMpLCAnRm91bmQgYmFkIGVudmVsb3BlIHRlc3QnKTtcbiAgcmV0dXJuIGludGVyc2VjdHNcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuaW5pdENvcm5lcnMgPSBmdW5jdGlvbiBpbml0Q29ybmVycyAocHQpIHtcbiAgdmFyIHRvbGVyYW5jZSA9IDAuNTtcbiAgdGhpcy5fbWlueCA9IHB0LnggLSB0b2xlcmFuY2U7XG4gIHRoaXMuX21heHggPSBwdC54ICsgdG9sZXJhbmNlO1xuICB0aGlzLl9taW55ID0gcHQueSAtIHRvbGVyYW5jZTtcbiAgdGhpcy5fbWF4eSA9IHB0LnkgKyB0b2xlcmFuY2U7XG4gIHRoaXMuX2Nvcm5lclswXSA9IG5ldyBDb29yZGluYXRlKHRoaXMuX21heHgsIHRoaXMuX21heHkpO1xuICB0aGlzLl9jb3JuZXJbMV0gPSBuZXcgQ29vcmRpbmF0ZSh0aGlzLl9taW54LCB0aGlzLl9tYXh5KTtcbiAgdGhpcy5fY29ybmVyWzJdID0gbmV3IENvb3JkaW5hdGUodGhpcy5fbWlueCwgdGhpcy5fbWlueSk7XG4gIHRoaXMuX2Nvcm5lclszXSA9IG5ldyBDb29yZGluYXRlKHRoaXMuX21heHgsIHRoaXMuX21pbnkpO1xufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyAocDAsIHAxKSB7XG4gIGlmICh0aGlzLl9zY2FsZUZhY3RvciA9PT0gMS4wKSB7IHJldHVybiB0aGlzLmludGVyc2VjdHNTY2FsZWQocDAsIHAxKSB9XG4gIHRoaXMuY29weVNjYWxlZChwMCwgdGhpcy5fcDBTY2FsZWQpO1xuICB0aGlzLmNvcHlTY2FsZWQocDEsIHRoaXMuX3AxU2NhbGVkKTtcbiAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0c1NjYWxlZCh0aGlzLl9wMFNjYWxlZCwgdGhpcy5fcDFTY2FsZWQpXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUgKHZhbCkge1xuICByZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiB0aGlzLl9zY2FsZUZhY3Rvcilcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5fb3JpZ2luYWxQdFxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5jb3B5U2NhbGVkID0gZnVuY3Rpb24gY29weVNjYWxlZCAocCwgcFNjYWxlZCkge1xuICBwU2NhbGVkLnggPSB0aGlzLnNjYWxlKHAueCk7XG4gIHBTY2FsZWQueSA9IHRoaXMuc2NhbGUocC55KTtcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuZ2V0U2FmZUVudmVsb3BlID0gZnVuY3Rpb24gZ2V0U2FmZUVudmVsb3BlICgpIHtcbiAgaWYgKHRoaXMuX3NhZmVFbnYgPT09IG51bGwpIHtcbiAgICB2YXIgc2FmZVRvbGVyYW5jZSA9IEhvdFBpeGVsLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1IgLyB0aGlzLl9zY2FsZUZhY3RvcjtcbiAgICB0aGlzLl9zYWZlRW52ID0gbmV3IEVudmVsb3BlKHRoaXMuX29yaWdpbmFsUHQueCAtIHNhZmVUb2xlcmFuY2UsIHRoaXMuX29yaWdpbmFsUHQueCArIHNhZmVUb2xlcmFuY2UsIHRoaXMuX29yaWdpbmFsUHQueSAtIHNhZmVUb2xlcmFuY2UsIHRoaXMuX29yaWdpbmFsUHQueSArIHNhZmVUb2xlcmFuY2UpO1xuICB9XG4gIHJldHVybiB0aGlzLl9zYWZlRW52XG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmludGVyc2VjdHNQaXhlbENsb3N1cmUgPSBmdW5jdGlvbiBpbnRlcnNlY3RzUGl4ZWxDbG9zdXJlIChwMCwgcDEpIHtcbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMCwgcDEsIHRoaXMuX2Nvcm5lclswXSwgdGhpcy5fY29ybmVyWzFdKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7IHJldHVybiB0cnVlIH1cbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMCwgcDEsIHRoaXMuX2Nvcm5lclsxXSwgdGhpcy5fY29ybmVyWzJdKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7IHJldHVybiB0cnVlIH1cbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMCwgcDEsIHRoaXMuX2Nvcm5lclsyXSwgdGhpcy5fY29ybmVyWzNdKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7IHJldHVybiB0cnVlIH1cbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMCwgcDEsIHRoaXMuX2Nvcm5lclszXSwgdGhpcy5fY29ybmVyWzBdKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUgPSBmdW5jdGlvbiBpbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlIChwMCwgcDEpIHtcbiAgdmFyIGludGVyc2VjdHNMZWZ0ID0gZmFsc2U7XG4gIHZhciBpbnRlcnNlY3RzQm90dG9tID0gZmFsc2U7XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMF0sIHRoaXMuX2Nvcm5lclsxXSk7XG4gIGlmICh0aGlzLl9saS5pc1Byb3BlcigpKSB7IHJldHVybiB0cnVlIH1cbiAgdGhpcy5fbGkuY29tcHV0ZUludGVyc2VjdGlvbihwMCwgcDEsIHRoaXMuX2Nvcm5lclsxXSwgdGhpcy5fY29ybmVyWzJdKTtcbiAgaWYgKHRoaXMuX2xpLmlzUHJvcGVyKCkpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAodGhpcy5fbGkuaGFzSW50ZXJzZWN0aW9uKCkpIHsgaW50ZXJzZWN0c0xlZnQgPSB0cnVlOyB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbMl0sIHRoaXMuX2Nvcm5lclszXSk7XG4gIGlmICh0aGlzLl9saS5pc1Byb3BlcigpKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7IGludGVyc2VjdHNCb3R0b20gPSB0cnVlOyB9XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAsIHAxLCB0aGlzLl9jb3JuZXJbM10sIHRoaXMuX2Nvcm5lclswXSk7XG4gIGlmICh0aGlzLl9saS5pc1Byb3BlcigpKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKGludGVyc2VjdHNMZWZ0ICYmIGludGVyc2VjdHNCb3R0b20pIHsgcmV0dXJuIHRydWUgfVxuICBpZiAocDAuZXF1YWxzKHRoaXMuX3B0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChwMS5lcXVhbHModGhpcy5fcHQpKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuSG90UGl4ZWwucHJvdG90eXBlLmFkZFNuYXBwZWROb2RlID0gZnVuY3Rpb24gYWRkU25hcHBlZE5vZGUgKHNlZ1N0ciwgc2VnSW5kZXgpIHtcbiAgdmFyIHAwID0gc2VnU3RyLmdldENvb3JkaW5hdGUoc2VnSW5kZXgpO1xuICB2YXIgcDEgPSBzZWdTdHIuZ2V0Q29vcmRpbmF0ZShzZWdJbmRleCArIDEpO1xuICBpZiAodGhpcy5pbnRlcnNlY3RzKHAwLCBwMSkpIHtcbiAgICBzZWdTdHIuYWRkSW50ZXJzZWN0aW9uKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLCBzZWdJbmRleCk7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5Ib3RQaXhlbC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkhvdFBpeGVsLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEhvdFBpeGVsXG59O1xuc3RhdGljQWNjZXNzb3JzJDM0LlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1IuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMC43NSB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggSG90UGl4ZWwsIHN0YXRpY0FjY2Vzc29ycyQzNCApO1xuXG52YXIgTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24gKCkge1xuICB0aGlzLnRlbXBFbnYxID0gbmV3IEVudmVsb3BlKCk7XG4gIHRoaXMuc2VsZWN0ZWRTZWdtZW50ID0gbmV3IExpbmVTZWdtZW50KCk7XG59O1xuTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbi5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gc2VsZWN0ICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBjb25zdCBzZWcgPSBhcmd1bWVudHNbMF1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIG1jID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzdGFydEluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIG1jLmdldExpbmVTZWdtZW50KHN0YXJ0SW5kZXgsIHRoaXMuc2VsZWN0ZWRTZWdtZW50KTtcbiAgICB0aGlzLnNlbGVjdCh0aGlzLnNlbGVjdGVkU2VnbWVudCk7XG4gIH1cbn07XG5Nb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uXG59O1xuXG52YXIgTUNJbmRleFBvaW50U25hcHBlciA9IGZ1bmN0aW9uIE1DSW5kZXhQb2ludFNuYXBwZXIgKCkge1xuICB0aGlzLl9pbmRleCA9IG51bGw7XG4gIHZhciBpbmRleCA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5faW5kZXggPSBpbmRleDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkMzUgPSB7IEhvdFBpeGVsU25hcEFjdGlvbjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuTUNJbmRleFBvaW50U25hcHBlci5wcm90b3R5cGUuc25hcCA9IGZ1bmN0aW9uIHNuYXAgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBob3RQaXhlbCA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5zbmFwKGhvdFBpeGVsLCBudWxsLCAtMSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGhvdFBpeGVsJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBhcmVudEVkZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGhvdFBpeGVsVmVydGV4SW5kZXggPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHBpeGVsRW52ID0gaG90UGl4ZWwkMS5nZXRTYWZlRW52ZWxvcGUoKTtcbiAgICB2YXIgaG90UGl4ZWxTbmFwQWN0aW9uID0gbmV3IEhvdFBpeGVsU25hcEFjdGlvbihob3RQaXhlbCQxLCBwYXJlbnRFZGdlLCBob3RQaXhlbFZlcnRleEluZGV4KTtcbiAgICB0aGlzLl9pbmRleC5xdWVyeShwaXhlbEVudiwge1xuICAgICAgaW50ZXJmYWNlc186IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFtJdGVtVmlzaXRvcl1cbiAgICAgIH0sXG4gICAgICB2aXNpdEl0ZW06IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHZhciB0ZXN0Q2hhaW4gPSBpdGVtO1xuICAgICAgICB0ZXN0Q2hhaW4uc2VsZWN0KHBpeGVsRW52LCBob3RQaXhlbFNuYXBBY3Rpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBob3RQaXhlbFNuYXBBY3Rpb24uaXNOb2RlQWRkZWQoKVxuICB9XG59O1xuTUNJbmRleFBvaW50U25hcHBlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk1DSW5kZXhQb2ludFNuYXBwZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTUNJbmRleFBvaW50U25hcHBlclxufTtcbnN0YXRpY0FjY2Vzc29ycyQzNS5Ib3RQaXhlbFNuYXBBY3Rpb24uZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gSG90UGl4ZWxTbmFwQWN0aW9uIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBNQ0luZGV4UG9pbnRTbmFwcGVyLCBzdGF0aWNBY2Nlc3NvcnMkMzUgKTtcblxudmFyIEhvdFBpeGVsU25hcEFjdGlvbiA9IChmdW5jdGlvbiAoTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMSkge1xuICBmdW5jdGlvbiBIb3RQaXhlbFNuYXBBY3Rpb24gKCkge1xuICAgIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEuY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9ob3RQaXhlbCA9IG51bGw7XG4gICAgdGhpcy5fcGFyZW50RWRnZSA9IG51bGw7XG4gICAgdGhpcy5faG90UGl4ZWxWZXJ0ZXhJbmRleCA9IG51bGw7XG4gICAgdGhpcy5faXNOb2RlQWRkZWQgPSBmYWxzZTtcbiAgICB2YXIgaG90UGl4ZWwgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBhcmVudEVkZ2UgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGhvdFBpeGVsVmVydGV4SW5kZXggPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5faG90UGl4ZWwgPSBob3RQaXhlbDtcbiAgICB0aGlzLl9wYXJlbnRFZGdlID0gcGFyZW50RWRnZTtcbiAgICB0aGlzLl9ob3RQaXhlbFZlcnRleEluZGV4ID0gaG90UGl4ZWxWZXJ0ZXhJbmRleDtcbiAgfVxuXG4gIGlmICggTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMSApIEhvdFBpeGVsU25hcEFjdGlvbi5fX3Byb3RvX18gPSBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxO1xuICBIb3RQaXhlbFNuYXBBY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbiQkMSAmJiBNb25vdG9uZUNoYWluU2VsZWN0QWN0aW9uJCQxLnByb3RvdHlwZSApO1xuICBIb3RQaXhlbFNuYXBBY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSG90UGl4ZWxTbmFwQWN0aW9uO1xuICBIb3RQaXhlbFNuYXBBY3Rpb24ucHJvdG90eXBlLmlzTm9kZUFkZGVkID0gZnVuY3Rpb24gaXNOb2RlQWRkZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc05vZGVBZGRlZFxuICB9O1xuICBIb3RQaXhlbFNuYXBBY3Rpb24ucHJvdG90eXBlLnNlbGVjdCA9IGZ1bmN0aW9uIHNlbGVjdCAoKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBtYyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBzdGFydEluZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHNzID0gbWMuZ2V0Q29udGV4dCgpO1xuICAgICAgaWYgKHRoaXMuX3BhcmVudEVkZ2UgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNzID09PSB0aGlzLl9wYXJlbnRFZGdlICYmIHN0YXJ0SW5kZXggPT09IHRoaXMuX2hvdFBpeGVsVmVydGV4SW5kZXgpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfVxuICAgICAgdGhpcy5faXNOb2RlQWRkZWQgPSB0aGlzLl9ob3RQaXhlbC5hZGRTbmFwcGVkTm9kZShzcywgc3RhcnRJbmRleCk7XG4gICAgfSBlbHNlIHsgcmV0dXJuIE1vbm90b25lQ2hhaW5TZWxlY3RBY3Rpb24kJDEucHJvdG90eXBlLnNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgSG90UGl4ZWxTbmFwQWN0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gSG90UGl4ZWxTbmFwQWN0aW9uXG4gIH07XG5cbiAgcmV0dXJuIEhvdFBpeGVsU25hcEFjdGlvbjtcbn0oTW9ub3RvbmVDaGFpblNlbGVjdEFjdGlvbikpO1xuXG52YXIgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlciA9IGZ1bmN0aW9uIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIgKCkge1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9ucyA9IG51bGw7XG4gIHZhciBsaSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fbGkgPSBsaTtcbiAgdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb25zID0gbmV3IEFycmF5TGlzdCgpO1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIucHJvdG90eXBlLnByb2Nlc3NJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gcHJvY2Vzc0ludGVyc2VjdGlvbnMgKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoZTAgPT09IGUxICYmIHNlZ0luZGV4MCA9PT0gc2VnSW5kZXgxKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHAwMCA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwXTtcbiAgdmFyIHAwMSA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwICsgMV07XG4gIHZhciBwMTAgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MV07XG4gIHZhciBwMTEgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MSArIDFdO1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwMCwgcDAxLCBwMTAsIHAxMSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIGlmICh0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkpIHtcbiAgICAgIGZvciAodmFyIGludEluZGV4ID0gMDsgaW50SW5kZXggPCB0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTsgaW50SW5kZXgrKykge1xuICAgICAgICB0aGlzJDEuX2ludGVyaW9ySW50ZXJzZWN0aW9ucy5hZGQodGhpcyQxLl9saS5nZXRJbnRlcnNlY3Rpb24oaW50SW5kZXgpKTtcbiAgICAgIH1cbiAgICAgIGUwLmFkZEludGVyc2VjdGlvbnModGhpcy5fbGksIHNlZ0luZGV4MCwgMCk7XG4gICAgICBlMS5hZGRJbnRlcnNlY3Rpb25zKHRoaXMuX2xpLCBzZWdJbmRleDEsIDEpO1xuICAgIH1cbiAgfVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyQWRkZXIucHJvdG90eXBlLmdldEludGVyaW9ySW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGdldEludGVyaW9ySW50ZXJzZWN0aW9ucyAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbnNcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZWdtZW50SW50ZXJzZWN0b3JdXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlckFkZGVyXG59O1xuXG52YXIgTUNJbmRleFNuYXBSb3VuZGVyID0gZnVuY3Rpb24gTUNJbmRleFNuYXBSb3VuZGVyICgpIHtcbiAgdGhpcy5fcG0gPSBudWxsO1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX3NjYWxlRmFjdG9yID0gbnVsbDtcbiAgdGhpcy5fbm9kZXIgPSBudWxsO1xuICB0aGlzLl9wb2ludFNuYXBwZXIgPSBudWxsO1xuICB0aGlzLl9ub2RlZFNlZ1N0cmluZ3MgPSBudWxsO1xuICB2YXIgcG0gPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3BtID0gcG07XG4gIHRoaXMuX2xpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICB0aGlzLl9saS5zZXRQcmVjaXNpb25Nb2RlbChwbSk7XG4gIHRoaXMuX3NjYWxlRmFjdG9yID0gcG0uZ2V0U2NhbGUoKTtcbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmNoZWNrQ29ycmVjdG5lc3MgPSBmdW5jdGlvbiBjaGVja0NvcnJlY3RuZXNzIChpbnB1dFNlZ21lbnRTdHJpbmdzKSB7XG4gIHZhciByZXN1bHRTZWdTdHJpbmdzID0gTm9kZWRTZWdtZW50U3RyaW5nLmdldE5vZGVkU3Vic3RyaW5ncyhpbnB1dFNlZ21lbnRTdHJpbmdzKTtcbiAgdmFyIG52ID0gbmV3IE5vZGluZ1ZhbGlkYXRvcihyZXN1bHRTZWdTdHJpbmdzKTtcbiAgdHJ5IHtcbiAgICBudi5jaGVja1ZhbGlkKCk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGV4IGluc3RhbmNlb2YgRXhjZXB0aW9uKSB7XG4gICAgICBleC5wcmludFN0YWNrVHJhY2UoKTtcbiAgICB9IGVsc2UgeyB0aHJvdyBleCB9XG4gIH0gZmluYWxseSB7fVxufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuZ2V0Tm9kZWRTdWJzdHJpbmdzID0gZnVuY3Rpb24gZ2V0Tm9kZWRTdWJzdHJpbmdzICgpIHtcbiAgcmV0dXJuIE5vZGVkU2VnbWVudFN0cmluZy5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5fbm9kZWRTZWdTdHJpbmdzKVxufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuc25hcFJvdW5kID0gZnVuY3Rpb24gc25hcFJvdW5kIChzZWdTdHJpbmdzLCBsaSkge1xuICB2YXIgaW50ZXJzZWN0aW9ucyA9IHRoaXMuZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyhzZWdTdHJpbmdzLCBsaSk7XG4gIHRoaXMuY29tcHV0ZUludGVyc2VjdGlvblNuYXBzKGludGVyc2VjdGlvbnMpO1xuICB0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyhzZWdTdHJpbmdzKTtcbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmZpbmRJbnRlcmlvckludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBmaW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zIChzZWdTdHJpbmdzLCBsaSkge1xuICB2YXIgaW50RmluZGVyQWRkZXIgPSBuZXcgSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJBZGRlcihsaSk7XG4gIHRoaXMuX25vZGVyLnNldFNlZ21lbnRJbnRlcnNlY3RvcihpbnRGaW5kZXJBZGRlcik7XG4gIHRoaXMuX25vZGVyLmNvbXB1dGVOb2RlcyhzZWdTdHJpbmdzKTtcbiAgcmV0dXJuIGludEZpbmRlckFkZGVyLmdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpXG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5jb21wdXRlVmVydGV4U25hcHMgPSBmdW5jdGlvbiBjb21wdXRlVmVydGV4U25hcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb2xsZWN0aW9uKSkge1xuICAgIHZhciBlZGdlcyA9IGFyZ3VtZW50c1swXTtcbiAgICBmb3IgKHZhciBpMCA9IGVkZ2VzLml0ZXJhdG9yKCk7IGkwLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlZGdlMCA9IGkwLm5leHQoKTtcbiAgICAgIHRoaXMkMS5jb21wdXRlVmVydGV4U25hcHMoZWRnZTApO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBOb2RlZFNlZ21lbnRTdHJpbmcpIHtcbiAgICB2YXIgZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHRzMCA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHB0czAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBob3RQaXhlbCA9IG5ldyBIb3RQaXhlbChwdHMwW2ldLCB0aGlzJDEuX3NjYWxlRmFjdG9yLCB0aGlzJDEuX2xpKTtcbiAgICAgIHZhciBpc05vZGVBZGRlZCA9IHRoaXMkMS5fcG9pbnRTbmFwcGVyLnNuYXAoaG90UGl4ZWwsIGUsIGkpO1xuICAgICAgaWYgKGlzTm9kZUFkZGVkKSB7XG4gICAgICAgIGUuYWRkSW50ZXJzZWN0aW9uKHB0czBbaV0sIGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuY29tcHV0ZU5vZGVzID0gZnVuY3Rpb24gY29tcHV0ZU5vZGVzIChpbnB1dFNlZ21lbnRTdHJpbmdzKSB7XG4gIHRoaXMuX25vZGVkU2VnU3RyaW5ncyA9IGlucHV0U2VnbWVudFN0cmluZ3M7XG4gIHRoaXMuX25vZGVyID0gbmV3IE1DSW5kZXhOb2RlcigpO1xuICB0aGlzLl9wb2ludFNuYXBwZXIgPSBuZXcgTUNJbmRleFBvaW50U25hcHBlcih0aGlzLl9ub2Rlci5nZXRJbmRleCgpKTtcbiAgdGhpcy5zbmFwUm91bmQoaW5wdXRTZWdtZW50U3RyaW5ncywgdGhpcy5fbGkpO1xufTtcbk1DSW5kZXhTbmFwUm91bmRlci5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvblNuYXBzID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdGlvblNuYXBzIChzbmFwUHRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaXQgPSBzbmFwUHRzLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgc25hcFB0ID0gaXQubmV4dCgpO1xuICAgIHZhciBob3RQaXhlbCA9IG5ldyBIb3RQaXhlbChzbmFwUHQsIHRoaXMkMS5fc2NhbGVGYWN0b3IsIHRoaXMkMS5fbGkpO1xuICAgIHRoaXMkMS5fcG9pbnRTbmFwcGVyLnNuYXAoaG90UGl4ZWwpO1xuICB9XG59O1xuTUNJbmRleFNuYXBSb3VuZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtOb2Rlcl1cbn07XG5NQ0luZGV4U25hcFJvdW5kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTUNJbmRleFNuYXBSb3VuZGVyXG59O1xuXG52YXIgQnVmZmVyT3AgPSBmdW5jdGlvbiBCdWZmZXJPcCAoKSB7XG4gIHRoaXMuX2FyZ0dlb20gPSBudWxsO1xuICB0aGlzLl9kaXN0YW5jZSA9IG51bGw7XG4gIHRoaXMuX2J1ZlBhcmFtcyA9IG5ldyBCdWZmZXJQYXJhbWV0ZXJzKCk7XG4gIHRoaXMuX3Jlc3VsdEdlb21ldHJ5ID0gbnVsbDtcbiAgdGhpcy5fc2F2ZUV4Y2VwdGlvbiA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5fYXJnR2VvbSA9IGc7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGJ1ZlBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9hcmdHZW9tID0gZyQxO1xuICAgIHRoaXMuX2J1ZlBhcmFtcyA9IGJ1ZlBhcmFtcztcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzMiA9IHsgQ0FQX1JPVU5EOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENBUF9CVVRUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENBUF9GTEFUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LENBUF9TUVVBUkU6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTUFYX1BSRUNJU0lPTl9ESUdJVFM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5idWZmZXJGaXhlZFByZWNpc2lvbiA9IGZ1bmN0aW9uIGJ1ZmZlckZpeGVkUHJlY2lzaW9uIChmaXhlZFBNKSB7XG4gIHZhciBub2RlciA9IG5ldyBTY2FsZWROb2RlcihuZXcgTUNJbmRleFNuYXBSb3VuZGVyKG5ldyBQcmVjaXNpb25Nb2RlbCgxLjApKSwgZml4ZWRQTS5nZXRTY2FsZSgpKTtcbiAgdmFyIGJ1ZkJ1aWxkZXIgPSBuZXcgQnVmZmVyQnVpbGRlcih0aGlzLl9idWZQYXJhbXMpO1xuICBidWZCdWlsZGVyLnNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbChmaXhlZFBNKTtcbiAgYnVmQnVpbGRlci5zZXROb2Rlcihub2Rlcik7XG4gIHRoaXMuX3Jlc3VsdEdlb21ldHJ5ID0gYnVmQnVpbGRlci5idWZmZXIodGhpcy5fYXJnR2VvbSwgdGhpcy5fZGlzdGFuY2UpO1xufTtcbkJ1ZmZlck9wLnByb3RvdHlwZS5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uID0gZnVuY3Rpb24gYnVmZmVyUmVkdWNlZFByZWNpc2lvbiAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKHZhciBwcmVjRGlnaXRzID0gQnVmZmVyT3AuTUFYX1BSRUNJU0lPTl9ESUdJVFM7IHByZWNEaWdpdHMgPj0gMDsgcHJlY0RpZ2l0cy0tKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzJDEuYnVmZmVyUmVkdWNlZFByZWNpc2lvbihwcmVjRGlnaXRzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGlmIChleCBpbnN0YW5jZW9mIFRvcG9sb2d5RXhjZXB0aW9uKSB7XG4gICAgICAgICAgdGhpcyQxLl9zYXZlRXhjZXB0aW9uID0gZXg7XG4gICAgICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgICAgIH0gZmluYWxseSB7fVxuICAgICAgaWYgKHRoaXMkMS5fcmVzdWx0R2VvbWV0cnkgIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIH1cbiAgICB0aHJvdyB0aGlzLl9zYXZlRXhjZXB0aW9uXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwcmVjaXNpb25EaWdpdHMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNpemVCYXNlZFNjYWxlRmFjdG9yID0gQnVmZmVyT3AucHJlY2lzaW9uU2NhbGVGYWN0b3IodGhpcy5fYXJnR2VvbSwgdGhpcy5fZGlzdGFuY2UsIHByZWNpc2lvbkRpZ2l0cyk7XG4gICAgdmFyIGZpeGVkUE0gPSBuZXcgUHJlY2lzaW9uTW9kZWwoc2l6ZUJhc2VkU2NhbGVGYWN0b3IpO1xuICAgIHRoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24oZml4ZWRQTSk7XG4gIH1cbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuY29tcHV0ZUdlb21ldHJ5ID0gZnVuY3Rpb24gY29tcHV0ZUdlb21ldHJ5ICgpIHtcbiAgdGhpcy5idWZmZXJPcmlnaW5hbFByZWNpc2lvbigpO1xuICBpZiAodGhpcy5fcmVzdWx0R2VvbWV0cnkgIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICB2YXIgYXJnUE0gPSB0aGlzLl9hcmdHZW9tLmdldEZhY3RvcnkoKS5nZXRQcmVjaXNpb25Nb2RlbCgpO1xuICBpZiAoYXJnUE0uZ2V0VHlwZSgpID09PSBQcmVjaXNpb25Nb2RlbC5GSVhFRCkgeyB0aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKGFyZ1BNKTsgfSBlbHNlIHsgdGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCk7IH1cbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuc2V0UXVhZHJhbnRTZWdtZW50cyA9IGZ1bmN0aW9uIHNldFF1YWRyYW50U2VnbWVudHMgKHF1YWRyYW50U2VnbWVudHMpIHtcbiAgdGhpcy5fYnVmUGFyYW1zLnNldFF1YWRyYW50U2VnbWVudHMocXVhZHJhbnRTZWdtZW50cyk7XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uID0gZnVuY3Rpb24gYnVmZmVyT3JpZ2luYWxQcmVjaXNpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWZCdWlsZGVyID0gbmV3IEJ1ZmZlckJ1aWxkZXIodGhpcy5fYnVmUGFyYW1zKTtcbiAgICB0aGlzLl9yZXN1bHRHZW9tZXRyeSA9IGJ1ZkJ1aWxkZXIuYnVmZmVyKHRoaXMuX2FyZ0dlb20sIHRoaXMuX2Rpc3RhbmNlKTtcbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZXggaW5zdGFuY2VvZiBSdW50aW1lRXhjZXB0aW9uKSB7XG4gICAgICB0aGlzLl9zYXZlRXhjZXB0aW9uID0gZXg7XG4gICAgfSBlbHNlIHsgdGhyb3cgZXggfVxuICB9IGZpbmFsbHkge31cbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuZ2V0UmVzdWx0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRSZXN1bHRHZW9tZXRyeSAoZGlzdGFuY2UpIHtcbiAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgdGhpcy5jb21wdXRlR2VvbWV0cnkoKTtcbiAgcmV0dXJuIHRoaXMuX3Jlc3VsdEdlb21ldHJ5XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLnNldEVuZENhcFN0eWxlID0gZnVuY3Rpb24gc2V0RW5kQ2FwU3R5bGUgKGVuZENhcFN0eWxlKSB7XG4gIHRoaXMuX2J1ZlBhcmFtcy5zZXRFbmRDYXBTdHlsZShlbmRDYXBTdHlsZSk7XG59O1xuQnVmZmVyT3AucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5CdWZmZXJPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJPcFxufTtcbkJ1ZmZlck9wLmJ1ZmZlck9wID0gZnVuY3Rpb24gYnVmZmVyT3AgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBkaXN0YW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZ0J1ZiA9IG5ldyBCdWZmZXJPcChnKTtcbiAgICB2YXIgZ2VvbUJ1ZiA9IGdCdWYuZ2V0UmVzdWx0R2VvbWV0cnkoZGlzdGFuY2UpO1xuICAgIHJldHVybiBnZW9tQnVmXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSkge1xuICAgICAgdmFyIGckMSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBkaXN0YW5jZSQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIHF1YWRyYW50U2VnbWVudHMgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgYnVmT3AgPSBuZXcgQnVmZmVyT3AoZyQxKTtcbiAgICAgIGJ1Zk9wLnNldFF1YWRyYW50U2VnbWVudHMocXVhZHJhbnRTZWdtZW50cyk7XG4gICAgICB2YXIgZ2VvbUJ1ZiQxID0gYnVmT3AuZ2V0UmVzdWx0R2VvbWV0cnkoZGlzdGFuY2UkMSk7XG4gICAgICByZXR1cm4gZ2VvbUJ1ZiQxXG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBCdWZmZXJQYXJhbWV0ZXJzICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykpIHtcbiAgICAgIHZhciBnJDIgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgZGlzdGFuY2UkMiA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YXIgYnVmT3AkMSA9IG5ldyBCdWZmZXJPcChnJDIsIHBhcmFtcyk7XG4gICAgICB2YXIgZ2VvbUJ1ZiQyID0gYnVmT3AkMS5nZXRSZXN1bHRHZW9tZXRyeShkaXN0YW5jZSQyKTtcbiAgICAgIHJldHVybiBnZW9tQnVmJDJcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gNCkge1xuICAgIHZhciBnJDMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGRpc3RhbmNlJDMgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHF1YWRyYW50U2VnbWVudHMkMSA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgZW5kQ2FwU3R5bGUgPSBhcmd1bWVudHNbM107XG4gICAgdmFyIGJ1Zk9wJDIgPSBuZXcgQnVmZmVyT3AoZyQzKTtcbiAgICBidWZPcCQyLnNldFF1YWRyYW50U2VnbWVudHMocXVhZHJhbnRTZWdtZW50cyQxKTtcbiAgICBidWZPcCQyLnNldEVuZENhcFN0eWxlKGVuZENhcFN0eWxlKTtcbiAgICB2YXIgZ2VvbUJ1ZiQzID0gYnVmT3AkMi5nZXRSZXN1bHRHZW9tZXRyeShkaXN0YW5jZSQzKTtcbiAgICByZXR1cm4gZ2VvbUJ1ZiQzXG4gIH1cbn07XG5CdWZmZXJPcC5wcmVjaXNpb25TY2FsZUZhY3RvciA9IGZ1bmN0aW9uIHByZWNpc2lvblNjYWxlRmFjdG9yIChnLCBkaXN0YW5jZSwgbWF4UHJlY2lzaW9uRGlnaXRzKSB7XG4gIHZhciBlbnYgPSBnLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgdmFyIGVudk1heCA9IE1hdGhVdGlsLm1heChNYXRoLmFicyhlbnYuZ2V0TWF4WCgpKSwgTWF0aC5hYnMoZW52LmdldE1heFkoKSksIE1hdGguYWJzKGVudi5nZXRNaW5YKCkpLCBNYXRoLmFicyhlbnYuZ2V0TWluWSgpKSk7XG4gIHZhciBleHBhbmRCeURpc3RhbmNlID0gZGlzdGFuY2UgPiAwLjAgPyBkaXN0YW5jZSA6IDAuMDtcbiAgdmFyIGJ1ZkVudk1heCA9IGVudk1heCArIDIgKiBleHBhbmRCeURpc3RhbmNlO1xuICB2YXIgYnVmRW52UHJlY2lzaW9uRGlnaXRzID0gTWF0aC50cnVuYyhNYXRoLmxvZyhidWZFbnZNYXgpIC8gTWF0aC5sb2coMTApICsgMS4wKTtcbiAgdmFyIG1pblVuaXRMb2cxMCA9IG1heFByZWNpc2lvbkRpZ2l0cyAtIGJ1ZkVudlByZWNpc2lvbkRpZ2l0cztcbiAgdmFyIHNjYWxlRmFjdG9yID0gTWF0aC5wb3coMTAuMCwgbWluVW5pdExvZzEwKTtcbiAgcmV0dXJuIHNjYWxlRmFjdG9yXG59O1xuc3RhdGljQWNjZXNzb3JzJDMyLkNBUF9ST1VORC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9ST1VORCB9O1xuc3RhdGljQWNjZXNzb3JzJDMyLkNBUF9CVVRULmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEJ1ZmZlclBhcmFtZXRlcnMuQ0FQX0ZMQVQgfTtcbnN0YXRpY0FjY2Vzc29ycyQzMi5DQVBfRkxBVC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9GTEFUIH07XG5zdGF0aWNBY2Nlc3NvcnMkMzIuQ0FQX1NRVUFSRS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBCdWZmZXJQYXJhbWV0ZXJzLkNBUF9TUVVBUkUgfTtcbnN0YXRpY0FjY2Vzc29ycyQzMi5NQVhfUFJFQ0lTSU9OX0RJR0lUUy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAxMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyT3AsIHN0YXRpY0FjY2Vzc29ycyQzMiApO1xuXG52YXIgUG9pbnRQYWlyRGlzdGFuY2UgPSBmdW5jdGlvbiBQb2ludFBhaXJEaXN0YW5jZSAoKSB7XG4gIHRoaXMuX3B0ID0gW25ldyBDb29yZGluYXRlKCksIG5ldyBDb29yZGluYXRlKCldO1xuICB0aGlzLl9kaXN0YW5jZSA9IERvdWJsZS5OYU47XG4gIHRoaXMuX2lzTnVsbCA9IHRydWU7XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5fcHRcbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKGkpIHtcbiAgcmV0dXJuIHRoaXMuX3B0W2ldXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLnNldE1pbmltdW0gPSBmdW5jdGlvbiBzZXRNaW5pbXVtICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHREaXN0ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0TWluaW11bShwdERpc3QuX3B0WzBdLCBwdERpc3QuX3B0WzFdKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5faXNOdWxsKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUocDAsIHAxKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHZhciBkaXN0ID0gcDAuZGlzdGFuY2UocDEpO1xuICAgIGlmIChkaXN0IDwgdGhpcy5fZGlzdGFuY2UpIHsgdGhpcy5pbml0aWFsaXplKHAwLCBwMSwgZGlzdCk7IH1cbiAgfVxufTtcblBvaW50UGFpckRpc3RhbmNlLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gaW5pdGlhbGl6ZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgdGhpcy5faXNOdWxsID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9wdFswXS5zZXRDb29yZGluYXRlKHAwKTtcbiAgICB0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKHAxKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICB0aGlzLl9pc051bGwgPSBmYWxzZTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIHAwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRpc3RhbmNlID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUocDAkMSk7XG4gICAgdGhpcy5fcHRbMV0uc2V0Q29vcmRpbmF0ZShwMSQxKTtcbiAgICB0aGlzLl9kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgIHRoaXMuX2lzTnVsbCA9IGZhbHNlO1xuICB9XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLmdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fZGlzdGFuY2Vcbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuc2V0TWF4aW11bSA9IGZ1bmN0aW9uIHNldE1heGltdW0gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBwdERpc3QgPSBhcmd1bWVudHNbMF07XG4gICAgdGhpcy5zZXRNYXhpbXVtKHB0RGlzdC5fcHRbMF0sIHB0RGlzdC5fcHRbMV0pO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIGlmICh0aGlzLl9pc051bGwpIHtcbiAgICAgIHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEpO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdmFyIGRpc3QgPSBwMC5kaXN0YW5jZShwMSk7XG4gICAgaWYgKGRpc3QgPiB0aGlzLl9kaXN0YW5jZSkgeyB0aGlzLmluaXRpYWxpemUocDAsIHAxLCBkaXN0KTsgfVxuICB9XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Qb2ludFBhaXJEaXN0YW5jZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludFBhaXJEaXN0YW5jZVxufTtcblxudmFyIERpc3RhbmNlVG9Qb2ludEZpbmRlciA9IGZ1bmN0aW9uIERpc3RhbmNlVG9Qb2ludEZpbmRlciAoKSB7fTtcblxuRGlzdGFuY2VUb1BvaW50RmluZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRGlzdGFuY2VUb1BvaW50RmluZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERpc3RhbmNlVG9Qb2ludEZpbmRlclxufTtcbkRpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlRGlzdGFuY2UgKCkge1xuICBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgUG9pbnRQYWlyRGlzdGFuY2UgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgbGluZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCA9IGFyZ3VtZW50c1syXTtcbiAgICB2YXIgY29vcmRzID0gbGluZS5nZXRDb29yZGluYXRlcygpO1xuICAgIHZhciB0ZW1wU2VnbWVudCA9IG5ldyBMaW5lU2VnbWVudCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdGVtcFNlZ21lbnQuc2V0Q29vcmRpbmF0ZXMoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKTtcbiAgICAgIHZhciBjbG9zZXN0UHQgPSB0ZW1wU2VnbWVudC5jbG9zZXN0UG9pbnQocHQpO1xuICAgICAgcHREaXN0LnNldE1pbmltdW0oY2xvc2VzdFB0LCBwdCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBQb2x5Z29uICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIHBvbHkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCQxID0gYXJndW1lbnRzWzJdO1xuICAgIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UocG9seS5nZXRFeHRlcmlvclJpbmcoKSwgcHQkMSwgcHREaXN0JDEpO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkkMSsrKSB7XG4gICAgICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKHBvbHkuZ2V0SW50ZXJpb3JSaW5nTihpJDEpLCBwdCQxLCBwdERpc3QkMSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSkge1xuICAgIHZhciBnZW9tID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQyID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QkMiA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICAgIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UoZ2VvbSwgcHQkMiwgcHREaXN0JDIpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHtcbiAgICAgIERpc3RhbmNlVG9Qb2ludEZpbmRlci5jb21wdXRlRGlzdGFuY2UoZ2VvbSwgcHQkMiwgcHREaXN0JDIpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikge1xuICAgICAgdmFyIGdjID0gZ2VvbTtcbiAgICAgIGZvciAodmFyIGkkMiA9IDA7IGkkMiA8IGdjLmdldE51bUdlb21ldHJpZXMoKTsgaSQyKyspIHtcbiAgICAgICAgdmFyIGcgPSBnYy5nZXRHZW9tZXRyeU4oaSQyKTtcbiAgICAgICAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZShnLCBwdCQyLCBwdERpc3QkMik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHB0RGlzdCQyLnNldE1pbmltdW0oZ2VvbS5nZXRDb29yZGluYXRlKCksIHB0JDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVNlZ21lbnQgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSkpIHtcbiAgICB2YXIgc2VnbWVudCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMyA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcHREaXN0JDMgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIGNsb3Nlc3RQdCQxID0gc2VnbWVudC5jbG9zZXN0UG9pbnQocHQkMyk7XG4gICAgcHREaXN0JDMuc2V0TWluaW11bShjbG9zZXN0UHQkMSwgcHQkMyk7XG4gIH1cbn07XG5cbnZhciBCdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlciA9IGZ1bmN0aW9uIEJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyIChpbnB1dEdlb20pIHtcbiAgdGhpcy5fbWF4UHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlKCk7XG4gIHRoaXMuX2lucHV0R2VvbSA9IGlucHV0R2VvbSB8fCBudWxsO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzNiA9IHsgTWF4UG9pbnREaXN0YW5jZUZpbHRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxNYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5CdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlci5wcm90b3R5cGUuY29tcHV0ZU1heE1pZHBvaW50RGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlTWF4TWlkcG9pbnREaXN0YW5jZSAoY3VydmUpIHtcbiAgdmFyIGRpc3RGaWx0ZXIgPSBuZXcgTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlcih0aGlzLl9pbnB1dEdlb20pO1xuICBjdXJ2ZS5hcHBseShkaXN0RmlsdGVyKTtcbiAgdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0oZGlzdEZpbHRlci5nZXRNYXhQb2ludERpc3RhbmNlKCkpO1xufTtcbkJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyLnByb3RvdHlwZS5jb21wdXRlTWF4VmVydGV4RGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlTWF4VmVydGV4RGlzdGFuY2UgKGN1cnZlKSB7XG4gIHZhciBkaXN0RmlsdGVyID0gbmV3IE1heFBvaW50RGlzdGFuY2VGaWx0ZXIodGhpcy5faW5wdXRHZW9tKTtcbiAgY3VydmUuYXBwbHkoZGlzdEZpbHRlcik7XG4gIHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKGRpc3RGaWx0ZXIuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKTtcbn07XG5CdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlci5wcm90b3R5cGUuZmluZERpc3RhbmNlID0gZnVuY3Rpb24gZmluZERpc3RhbmNlIChidWZmZXJDdXJ2ZSkge1xuICB0aGlzLmNvbXB1dGVNYXhWZXJ0ZXhEaXN0YW5jZShidWZmZXJDdXJ2ZSk7XG4gIHRoaXMuY29tcHV0ZU1heE1pZHBvaW50RGlzdGFuY2UoYnVmZmVyQ3VydmUpO1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0LmdldERpc3RhbmNlKClcbn07XG5CdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlci5wcm90b3R5cGUuZ2V0RGlzdGFuY2VQb2ludHMgPSBmdW5jdGlvbiBnZXREaXN0YW5jZVBvaW50cyAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXhQdERpc3Rcbn07XG5CdWZmZXJDdXJ2ZU1heGltdW1EaXN0YW5jZUZpbmRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlckN1cnZlTWF4aW11bURpc3RhbmNlRmluZGVyXG59O1xuc3RhdGljQWNjZXNzb3JzJDM2Lk1heFBvaW50RGlzdGFuY2VGaWx0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF4UG9pbnREaXN0YW5jZUZpbHRlciB9O1xuc3RhdGljQWNjZXNzb3JzJDM2Lk1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlciB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyQ3VydmVNYXhpbXVtRGlzdGFuY2VGaW5kZXIsIHN0YXRpY0FjY2Vzc29ycyQzNiApO1xuXG52YXIgTWF4UG9pbnREaXN0YW5jZUZpbHRlciA9IGZ1bmN0aW9uIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIgKGdlb20pIHtcbiAgdGhpcy5fbWF4UHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlKCk7XG4gIHRoaXMuX21pblB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSgpO1xuICB0aGlzLl9nZW9tID0gZ2VvbSB8fCBudWxsO1xufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAocHQpIHtcbiAgdGhpcy5fbWluUHREaXN0LmluaXRpYWxpemUoKTtcbiAgRGlzdGFuY2VUb1BvaW50RmluZGVyLmNvbXB1dGVEaXN0YW5jZSh0aGlzLl9nZW9tLCBwdCwgdGhpcy5fbWluUHREaXN0KTtcbiAgdGhpcy5fbWF4UHREaXN0LnNldE1heGltdW0odGhpcy5fbWluUHREaXN0KTtcbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5nZXRNYXhQb2ludERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0TWF4UG9pbnREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXhQdERpc3Rcbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlRmlsdGVyXVxufTtcbk1heFBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTWF4UG9pbnREaXN0YW5jZUZpbHRlclxufTtcblxudmFyIE1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIgPSBmdW5jdGlvbiBNYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyIChnZW9tKSB7XG4gIHRoaXMuX21heFB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSgpO1xuICB0aGlzLl9taW5QdERpc3QgPSBuZXcgUG9pbnRQYWlyRGlzdGFuY2UoKTtcbiAgdGhpcy5fZ2VvbSA9IGdlb20gfHwgbnVsbDtcbn07XG5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHNlcSwgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSAwKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHAwID0gc2VxLmdldENvb3JkaW5hdGUoaW5kZXggLSAxKTtcbiAgdmFyIHAxID0gc2VxLmdldENvb3JkaW5hdGUoaW5kZXgpO1xuICB2YXIgbWlkUHQgPSBuZXcgQ29vcmRpbmF0ZSgocDAueCArIHAxLngpIC8gMiwgKHAwLnkgKyBwMS55KSAvIDIpO1xuICB0aGlzLl9taW5QdERpc3QuaW5pdGlhbGl6ZSgpO1xuICBEaXN0YW5jZVRvUG9pbnRGaW5kZXIuY29tcHV0ZURpc3RhbmNlKHRoaXMuX2dlb20sIG1pZFB0LCB0aGlzLl9taW5QdERpc3QpO1xuICB0aGlzLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzLl9taW5QdERpc3QpO1xufTtcbk1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcbk1heE1pZHBvaW50RGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmlzR2VvbWV0cnlDaGFuZ2VkID0gZnVuY3Rpb24gaXNHZW9tZXRyeUNoYW5nZWQgKCkge1xuICByZXR1cm4gZmFsc2Vcbn07XG5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5nZXRNYXhQb2ludERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0TWF4UG9pbnREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXhQdERpc3Rcbn07XG5NYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXJdXG59O1xuTWF4TWlkcG9pbnREaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBNYXhNaWRwb2ludERpc3RhbmNlRmlsdGVyXG59O1xuXG52YXIgUG9seWdvbkV4dHJhY3RlciA9IGZ1bmN0aW9uIFBvbHlnb25FeHRyYWN0ZXIgKGNvbXBzKSB7XG4gIHRoaXMuX2NvbXBzID0gY29tcHMgfHwgbnVsbDtcbn07XG5Qb2x5Z29uRXh0cmFjdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHtcbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7IHRoaXMuX2NvbXBzLmFkZChnZW9tKTsgfVxufTtcblBvbHlnb25FeHRyYWN0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5RmlsdGVyXVxufTtcblBvbHlnb25FeHRyYWN0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9seWdvbkV4dHJhY3RlclxufTtcblBvbHlnb25FeHRyYWN0ZXIuZ2V0UG9seWdvbnMgPSBmdW5jdGlvbiBnZXRQb2x5Z29ucyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIFBvbHlnb25FeHRyYWN0ZXIuZ2V0UG9seWdvbnMoZ2VvbSwgbmV3IEFycmF5TGlzdCgpKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsaXN0ID0gYXJndW1lbnRzWzFdO1xuICAgIGlmIChnZW9tJDEgaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgICBsaXN0LmFkZChnZW9tJDEpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbSQxIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgICBnZW9tJDEuYXBwbHkobmV3IFBvbHlnb25FeHRyYWN0ZXIobGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdFxuICB9XG59O1xuXG52YXIgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyID0gZnVuY3Rpb24gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyICgpIHtcbiAgdGhpcy5fbGluZXMgPSBudWxsO1xuICB0aGlzLl9pc0ZvcmNlZFRvTGluZVN0cmluZyA9IGZhbHNlO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBsaW5lcyA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLl9saW5lcyA9IGxpbmVzO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgbGluZXMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgaXNGb3JjZWRUb0xpbmVTdHJpbmcgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fbGluZXMgPSBsaW5lcyQxO1xuICAgIHRoaXMuX2lzRm9yY2VkVG9MaW5lU3RyaW5nID0gaXNGb3JjZWRUb0xpbmVTdHJpbmc7XG4gIH1cbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoZ2VvbSkge1xuICBpZiAodGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcgJiYgZ2VvbSBpbnN0YW5jZW9mIExpbmVhclJpbmcpIHtcbiAgICB2YXIgbGluZSA9IGdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoZ2VvbS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7XG4gICAgdGhpcy5fbGluZXMuYWRkKGxpbmUpO1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7IHRoaXMuX2xpbmVzLmFkZChnZW9tKTsgfVxufTtcbkxpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5wcm90b3R5cGUuc2V0Rm9yY2VUb0xpbmVTdHJpbmcgPSBmdW5jdGlvbiBzZXRGb3JjZVRvTGluZVN0cmluZyAoaXNGb3JjZWRUb0xpbmVTdHJpbmcpIHtcbiAgdGhpcy5faXNGb3JjZWRUb0xpbmVTdHJpbmcgPSBpc0ZvcmNlZFRvTGluZVN0cmluZztcbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5Q29tcG9uZW50RmlsdGVyXVxufTtcbkxpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXJcbn07XG5MaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRHZW9tZXRyeSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgcmV0dXJuIGdlb20uZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkoTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKGdlb20pKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZ2VvbSQxID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBmb3JjZVRvTGluZVN0cmluZyA9IGFyZ3VtZW50c1sxXTtcbiAgICByZXR1cm4gZ2VvbSQxLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyhnZW9tJDEsIGZvcmNlVG9MaW5lU3RyaW5nKSlcbiAgfVxufTtcbkxpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyA9IGZ1bmN0aW9uIGdldExpbmVzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKGdlb20sIGZhbHNlKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICBpZiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgQ29sbGVjdGlvbikgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgQ29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBnZW9tcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBsaW5lcyQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgZm9yICh2YXIgaSA9IGdlb21zLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZyA9IGkubmV4dCgpO1xuICAgICAgICBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMoZywgbGluZXMkMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXMkMVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICB2YXIgZ2VvbSQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGZvcmNlVG9MaW5lU3RyaW5nID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGxpbmVzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgICAgZ2VvbSQxLmFwcGx5KG5ldyBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIobGluZXMsIGZvcmNlVG9MaW5lU3RyaW5nKSk7XG4gICAgICByZXR1cm4gbGluZXNcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIENvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgZ2VvbSQyID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxpbmVzJDIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZ2VvbSQyIGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgICAgICBsaW5lcyQyLmFkZChnZW9tJDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VvbSQyLmFwcGx5KG5ldyBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIobGluZXMkMikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmVzJDJcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnYm9vbGVhbicgJiYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIENvbGxlY3Rpb24pICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIENvbGxlY3Rpb24pKSkge1xuICAgICAgdmFyIGdlb21zJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGluZXMkMyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBmb3JjZVRvTGluZVN0cmluZyQxID0gYXJndW1lbnRzWzJdO1xuICAgICAgZm9yICh2YXIgaSQxID0gZ2VvbXMkMS5pdGVyYXRvcigpOyBpJDEuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZyQxID0gaSQxLm5leHQoKTtcbiAgICAgICAgTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKGckMSwgbGluZXMkMywgZm9yY2VUb0xpbmVTdHJpbmckMSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGluZXMkM1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGFyZ3VtZW50c1syXSA9PT0gJ2Jvb2xlYW4nICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBHZW9tZXRyeSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBDb2xsZWN0aW9uKSkpIHtcbiAgICAgIHZhciBnZW9tJDMgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgbGluZXMkNCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBmb3JjZVRvTGluZVN0cmluZyQyID0gYXJndW1lbnRzWzJdO1xuICAgICAgZ2VvbSQzLmFwcGx5KG5ldyBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIobGluZXMkNCwgZm9yY2VUb0xpbmVTdHJpbmckMikpO1xuICAgICAgcmV0dXJuIGxpbmVzJDRcbiAgICB9XG4gIH1cbn07XG5cbnZhciBQb2ludExvY2F0b3IgPSBmdW5jdGlvbiBQb2ludExvY2F0b3IgKCkge1xuICB0aGlzLl9ib3VuZGFyeVJ1bGUgPSBCb3VuZGFyeU5vZGVSdWxlLk9HQ19TRlNfQk9VTkRBUllfUlVMRTtcbiAgdGhpcy5faXNJbiA9IG51bGw7XG4gIHRoaXMuX251bUJvdW5kYXJpZXMgPSBudWxsO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge30gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBib3VuZGFyeVJ1bGUgPSBhcmd1bWVudHNbMF07XG4gICAgaWYgKGJvdW5kYXJ5UnVsZSA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgSWxsZWdhbEFyZ3VtZW50RXhjZXB0aW9uKCdSdWxlIG11c3QgYmUgbm9uLW51bGwnKSB9XG4gICAgdGhpcy5fYm91bmRhcnlSdWxlID0gYm91bmRhcnlSdWxlO1xuICB9XG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS5sb2NhdGVJbnRlcm5hbCA9IGZ1bmN0aW9uIGxvY2F0ZUludGVybmFsICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQ29vcmRpbmF0ZSAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHBvbHkgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHBvbHkuaXNFbXB0eSgpKSB7IHJldHVybiBMb2NhdGlvbi5FWFRFUklPUiB9XG4gICAgdmFyIHNoZWxsID0gcG9seS5nZXRFeHRlcmlvclJpbmcoKTtcbiAgICB2YXIgc2hlbGxMb2MgPSB0aGlzLmxvY2F0ZUluUG9seWdvblJpbmcocCwgc2hlbGwpO1xuICAgIGlmIChzaGVsbExvYyA9PT0gTG9jYXRpb24uRVhURVJJT1IpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgICBpZiAoc2hlbGxMb2MgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IHJldHVybiBMb2NhdGlvbi5CT1VOREFSWSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5LmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICAgIHZhciBob2xlID0gcG9seS5nZXRJbnRlcmlvclJpbmdOKGkpO1xuICAgICAgdmFyIGhvbGVMb2MgPSB0aGlzJDEubG9jYXRlSW5Qb2x5Z29uUmluZyhwLCBob2xlKTtcbiAgICAgIGlmIChob2xlTG9jID09PSBMb2NhdGlvbi5JTlRFUklPUikgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICAgICAgaWYgKGhvbGVMb2MgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IHJldHVybiBMb2NhdGlvbi5CT1VOREFSWSB9XG4gICAgfVxuICAgIHJldHVybiBMb2NhdGlvbi5JTlRFUklPUlxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgIHZhciBwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGwgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKCFsLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHAkMSkpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgICB2YXIgcHQgPSBsLmdldENvb3JkaW5hdGVzKCk7XG4gICAgaWYgKCFsLmlzQ2xvc2VkKCkpIHtcbiAgICAgIGlmIChwJDEuZXF1YWxzKHB0WzBdKSB8fCBwJDEuZXF1YWxzKHB0W3B0Lmxlbmd0aCAtIDFdKSkge1xuICAgICAgICByZXR1cm4gTG9jYXRpb24uQk9VTkRBUllcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKENHQWxnb3JpdGhtcy5pc09uTGluZShwJDEsIHB0KSkgeyByZXR1cm4gTG9jYXRpb24uSU5URVJJT1IgfVxuICAgIHJldHVybiBMb2NhdGlvbi5FWFRFUklPUlxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUgJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICB2YXIgcCQyID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwdCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdENvb3JkID0gcHQkMS5nZXRDb29yZGluYXRlKCk7XG4gICAgaWYgKHB0Q29vcmQuZXF1YWxzMkQocCQyKSkgeyByZXR1cm4gTG9jYXRpb24uSU5URVJJT1IgfVxuICAgIHJldHVybiBMb2NhdGlvbi5FWFRFUklPUlxuICB9XG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS5sb2NhdGVJblBvbHlnb25SaW5nID0gZnVuY3Rpb24gbG9jYXRlSW5Qb2x5Z29uUmluZyAocCwgcmluZykge1xuICBpZiAoIXJpbmcuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMocCkpIHsgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SIH1cbiAgcmV0dXJuIENHQWxnb3JpdGhtcy5sb2NhdGVQb2ludEluUmluZyhwLCByaW5nLmdldENvb3JkaW5hdGVzKCkpXG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS5pbnRlcnNlY3RzID0gZnVuY3Rpb24gaW50ZXJzZWN0cyAocCwgZ2VvbSkge1xuICByZXR1cm4gdGhpcy5sb2NhdGUocCwgZ2VvbSkgIT09IExvY2F0aW9uLkVYVEVSSU9SXG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS51cGRhdGVMb2NhdGlvbkluZm8gPSBmdW5jdGlvbiB1cGRhdGVMb2NhdGlvbkluZm8gKGxvYykge1xuICBpZiAobG9jID09PSBMb2NhdGlvbi5JTlRFUklPUikgeyB0aGlzLl9pc0luID0gdHJ1ZTsgfVxuICBpZiAobG9jID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyB0aGlzLl9udW1Cb3VuZGFyaWVzKys7IH1cbn07XG5Qb2ludExvY2F0b3IucHJvdG90eXBlLmNvbXB1dGVMb2NhdGlvbiA9IGZ1bmN0aW9uIGNvbXB1dGVMb2NhdGlvbiAocCwgZ2VvbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChnZW9tIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICB0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHAsIGdlb20pKTtcbiAgfVxuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICB0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHAsIGdlb20pKTtcbiAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgIHRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwocCwgZ2VvbSkpO1xuICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBNdWx0aUxpbmVTdHJpbmcpIHtcbiAgICB2YXIgbWwgPSBnZW9tO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWwuZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICAgIHZhciBsID0gbWwuZ2V0R2VvbWV0cnlOKGkpO1xuICAgICAgdGhpcyQxLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzJDEubG9jYXRlSW50ZXJuYWwocCwgbCkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgTXVsdGlQb2x5Z29uKSB7XG4gICAgdmFyIG1wb2x5ID0gZ2VvbTtcbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBtcG9seS5nZXROdW1HZW9tZXRyaWVzKCk7IGkkMSsrKSB7XG4gICAgICB2YXIgcG9seSA9IG1wb2x5LmdldEdlb21ldHJ5TihpJDEpO1xuICAgICAgdGhpcyQxLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzJDEubG9jYXRlSW50ZXJuYWwocCwgcG9seSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgdmFyIGdlb21pID0gbmV3IEdlb21ldHJ5Q29sbGVjdGlvbkl0ZXJhdG9yKGdlb20pO1xuICAgIHdoaWxlIChnZW9taS5oYXNOZXh0KCkpIHtcbiAgICAgIHZhciBnMiA9IGdlb21pLm5leHQoKTtcbiAgICAgIGlmIChnMiAhPT0gZ2VvbSkgeyB0aGlzJDEuY29tcHV0ZUxvY2F0aW9uKHAsIGcyKTsgfVxuICAgIH1cbiAgfVxufTtcblBvaW50TG9jYXRvci5wcm90b3R5cGUubG9jYXRlID0gZnVuY3Rpb24gbG9jYXRlIChwLCBnZW9tKSB7XG4gIGlmIChnZW9tLmlzRW1wdHkoKSkgeyByZXR1cm4gTG9jYXRpb24uRVhURVJJT1IgfVxuICBpZiAoZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhdGVJbnRlcm5hbChwLCBnZW9tKVxuICB9IGVsc2UgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYXRlSW50ZXJuYWwocCwgZ2VvbSlcbiAgfVxuICB0aGlzLl9pc0luID0gZmFsc2U7XG4gIHRoaXMuX251bUJvdW5kYXJpZXMgPSAwO1xuICB0aGlzLmNvbXB1dGVMb2NhdGlvbihwLCBnZW9tKTtcbiAgaWYgKHRoaXMuX2JvdW5kYXJ5UnVsZS5pc0luQm91bmRhcnkodGhpcy5fbnVtQm91bmRhcmllcykpIHsgcmV0dXJuIExvY2F0aW9uLkJPVU5EQVJZIH1cbiAgaWYgKHRoaXMuX251bUJvdW5kYXJpZXMgPiAwIHx8IHRoaXMuX2lzSW4pIHsgcmV0dXJuIExvY2F0aW9uLklOVEVSSU9SIH1cbiAgcmV0dXJuIExvY2F0aW9uLkVYVEVSSU9SXG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9pbnRMb2NhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvaW50TG9jYXRvclxufTtcblxudmFyIEdlb21ldHJ5TG9jYXRpb24gPSBmdW5jdGlvbiBHZW9tZXRyeUxvY2F0aW9uICgpIHtcbiAgdGhpcy5fY29tcG9uZW50ID0gbnVsbDtcbiAgdGhpcy5fc2VnSW5kZXggPSBudWxsO1xuICB0aGlzLl9wdCA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQgPSBhcmd1bWVudHNbMV07XG4gICAgR2VvbWV0cnlMb2NhdGlvbi5jYWxsKHRoaXMsIGNvbXBvbmVudCwgR2VvbWV0cnlMb2NhdGlvbi5JTlNJREVfQVJFQSwgcHQpO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgY29tcG9uZW50JDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNlZ0luZGV4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdCQxID0gYXJndW1lbnRzWzJdO1xuICAgIHRoaXMuX2NvbXBvbmVudCA9IGNvbXBvbmVudCQxO1xuICAgIHRoaXMuX3NlZ0luZGV4ID0gc2VnSW5kZXg7XG4gICAgdGhpcy5fcHQgPSBwdCQxO1xuICB9XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDM4ID0geyBJTlNJREVfQVJFQTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuR2VvbWV0cnlMb2NhdGlvbi5wcm90b3R5cGUuaXNJbnNpZGVBcmVhID0gZnVuY3Rpb24gaXNJbnNpZGVBcmVhICgpIHtcbiAgcmV0dXJuIHRoaXMuX3NlZ0luZGV4ID09PSBHZW9tZXRyeUxvY2F0aW9uLklOU0lERV9BUkVBXG59O1xuR2VvbWV0cnlMb2NhdGlvbi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5fcHRcbn07XG5HZW9tZXRyeUxvY2F0aW9uLnByb3RvdHlwZS5nZXRHZW9tZXRyeUNvbXBvbmVudCA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5Q29tcG9uZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFxufTtcbkdlb21ldHJ5TG9jYXRpb24ucHJvdG90eXBlLmdldFNlZ21lbnRJbmRleCA9IGZ1bmN0aW9uIGdldFNlZ21lbnRJbmRleCAoKSB7XG4gIHJldHVybiB0aGlzLl9zZWdJbmRleFxufTtcbkdlb21ldHJ5TG9jYXRpb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeUxvY2F0aW9uLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5TG9jYXRpb25cbn07XG5zdGF0aWNBY2Nlc3NvcnMkMzguSU5TSURFX0FSRUEuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gLTEgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdlb21ldHJ5TG9jYXRpb24sIHN0YXRpY0FjY2Vzc29ycyQzOCApO1xuXG52YXIgUG9pbnRFeHRyYWN0ZXIgPSBmdW5jdGlvbiBQb2ludEV4dHJhY3RlciAocHRzKSB7XG4gIHRoaXMuX3B0cyA9IHB0cyB8fCBudWxsO1xufTtcblBvaW50RXh0cmFjdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGdlb20pIHtcbiAgaWYgKGdlb20gaW5zdGFuY2VvZiBQb2ludCkgeyB0aGlzLl9wdHMuYWRkKGdlb20pOyB9XG59O1xuUG9pbnRFeHRyYWN0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0dlb21ldHJ5RmlsdGVyXVxufTtcblBvaW50RXh0cmFjdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvaW50RXh0cmFjdGVyXG59O1xuUG9pbnRFeHRyYWN0ZXIuZ2V0UG9pbnRzID0gZnVuY3Rpb24gZ2V0UG9pbnRzICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgICBpZiAoZ2VvbSBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICByZXR1cm4gQ29sbGVjdGlvbnMuc2luZ2xldG9uTGlzdChnZW9tKVxuICAgIH1cbiAgICByZXR1cm4gUG9pbnRFeHRyYWN0ZXIuZ2V0UG9pbnRzKGdlb20sIG5ldyBBcnJheUxpc3QoKSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGdlb20kMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbGlzdCA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZ2VvbSQxIGluc3RhbmNlb2YgUG9pbnQpIHtcbiAgICAgIGxpc3QuYWRkKGdlb20kMSk7XG4gICAgfSBlbHNlIGlmIChnZW9tJDEgaW5zdGFuY2VvZiBHZW9tZXRyeUNvbGxlY3Rpb24pIHtcbiAgICAgIGdlb20kMS5hcHBseShuZXcgUG9pbnRFeHRyYWN0ZXIobGlzdCkpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdFxuICB9XG59O1xuXG52YXIgQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyID0gZnVuY3Rpb24gQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyICgpIHtcbiAgdGhpcy5fbG9jYXRpb25zID0gbnVsbDtcbiAgdmFyIGxvY2F0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fbG9jYXRpb25zID0gbG9jYXRpb25zO1xufTtcbkNvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnZW9tKSB7XG4gIGlmIChnZW9tIGluc3RhbmNlb2YgUG9pbnQgfHwgZ2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcgfHwgZ2VvbSBpbnN0YW5jZW9mIFBvbHlnb24pIHsgdGhpcy5fbG9jYXRpb25zLmFkZChuZXcgR2VvbWV0cnlMb2NhdGlvbihnZW9tLCAwLCBnZW9tLmdldENvb3JkaW5hdGUoKSkpOyB9XG59O1xuQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtHZW9tZXRyeUZpbHRlcl1cbn07XG5Db25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyXG59O1xuQ29ubmVjdGVkRWxlbWVudExvY2F0aW9uRmlsdGVyLmdldExvY2F0aW9ucyA9IGZ1bmN0aW9uIGdldExvY2F0aW9ucyAoZ2VvbSkge1xuICB2YXIgbG9jYXRpb25zID0gbmV3IEFycmF5TGlzdCgpO1xuICBnZW9tLmFwcGx5KG5ldyBDb25uZWN0ZWRFbGVtZW50TG9jYXRpb25GaWx0ZXIobG9jYXRpb25zKSk7XG4gIHJldHVybiBsb2NhdGlvbnNcbn07XG5cbnZhciBEaXN0YW5jZU9wID0gZnVuY3Rpb24gRGlzdGFuY2VPcCAoKSB7XG4gIHRoaXMuX2dlb20gPSBudWxsO1xuICB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSA9IDAuMDtcbiAgdGhpcy5fcHRMb2NhdG9yID0gbmV3IFBvaW50TG9jYXRvcigpO1xuICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uID0gbnVsbDtcbiAgdGhpcy5fbWluRGlzdGFuY2UgPSBEb3VibGUuTUFYX1ZBTFVFO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fZ2VvbSA9IFtnMCwgZzFdO1xuICAgIHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlID0gMC4wO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgZzAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgdGVybWluYXRlRGlzdGFuY2UgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5fZ2VvbSA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICAgIHRoaXMuX2dlb21bMF0gPSBnMCQxO1xuICAgIHRoaXMuX2dlb21bMV0gPSBnMSQxO1xuICAgIHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlID0gdGVybWluYXRlRGlzdGFuY2U7XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVDb250YWlubWVudERpc3RhbmNlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIHZhciBsb2NQdFBvbHkgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgICB0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDAsIGxvY1B0UG9seSk7XG4gICAgaWYgKHRoaXMuX21pbkRpc3RhbmNlIDw9IHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICB0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDEsIGxvY1B0UG9seSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwb2x5R2VvbUluZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBsb2NQdFBvbHkkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgbG9jYXRpb25zSW5kZXggPSAxIC0gcG9seUdlb21JbmRleDtcbiAgICB2YXIgcG9seXMgPSBQb2x5Z29uRXh0cmFjdGVyLmdldFBvbHlnb25zKHRoaXMuX2dlb21bcG9seUdlb21JbmRleF0pO1xuICAgIGlmIChwb2x5cy5zaXplKCkgPiAwKSB7XG4gICAgICB2YXIgaW5zaWRlTG9jcyA9IENvbm5lY3RlZEVsZW1lbnRMb2NhdGlvbkZpbHRlci5nZXRMb2NhdGlvbnModGhpcy5fZ2VvbVtsb2NhdGlvbnNJbmRleF0pO1xuICAgICAgdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZShpbnNpZGVMb2NzLCBwb2x5cywgbG9jUHRQb2x5JDEpO1xuICAgICAgaWYgKHRoaXMuX21pbkRpc3RhbmNlIDw9IHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bbG9jYXRpb25zSW5kZXhdID0gbG9jUHRQb2x5JDFbMF07XG4gICAgICAgIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bcG9seUdlb21JbmRleF0gPSBsb2NQdFBvbHkkMVsxXTtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBBcnJheSAmJiAoaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1swXSwgTGlzdCkgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgTGlzdCkpKSB7XG4gICAgICB2YXIgbG9jcyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwb2x5cyQxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGxvY1B0UG9seSQyID0gYXJndW1lbnRzWzJdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLnNpemUoKTsgaSsrKSB7XG4gICAgICAgIHZhciBsb2MgPSBsb2NzLmdldChpKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwb2x5cyQxLnNpemUoKTsgaisrKSB7XG4gICAgICAgICAgdGhpcyQxLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKGxvYywgcG9seXMkMS5nZXQoaiksIGxvY1B0UG9seSQyKTtcbiAgICAgICAgICBpZiAodGhpcyQxLl9taW5EaXN0YW5jZSA8PSB0aGlzJDEuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgQXJyYXkgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5TG9jYXRpb24gJiYgYXJndW1lbnRzWzFdIGluc3RhbmNlb2YgUG9seWdvbikpIHtcbiAgICAgIHZhciBwdExvYyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHZhciBwb2x5ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGxvY1B0UG9seSQzID0gYXJndW1lbnRzWzJdO1xuICAgICAgdmFyIHB0ID0gcHRMb2MuZ2V0Q29vcmRpbmF0ZSgpO1xuICAgICAgaWYgKExvY2F0aW9uLkVYVEVSSU9SICE9PSB0aGlzLl9wdExvY2F0b3IubG9jYXRlKHB0LCBwb2x5KSkge1xuICAgICAgICB0aGlzLl9taW5EaXN0YW5jZSA9IDAuMDtcbiAgICAgICAgbG9jUHRQb2x5JDNbMF0gPSBwdExvYztcbiAgICAgICAgbG9jUHRQb2x5JDNbMV0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihwb2x5LCBwdCk7XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyA9IGZ1bmN0aW9uIGNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzIChsaW5lcywgcG9pbnRzLCBsb2NHZW9tKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5zaXplKCk7IGkrKykge1xuICAgIHZhciBsaW5lID0gbGluZXMuZ2V0KGkpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLnNpemUoKTsgaisrKSB7XG4gICAgICB2YXIgcHQgPSBwb2ludHMuZ2V0KGopO1xuICAgICAgdGhpcyQxLmNvbXB1dGVNaW5EaXN0YW5jZShsaW5lLCBwdCwgbG9jR2VvbSk7XG4gICAgICBpZiAodGhpcyQxLl9taW5EaXN0YW5jZSA8PSB0aGlzJDEuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICB9XG4gIH1cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5jb21wdXRlRmFjZXREaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVGYWNldERpc3RhbmNlICgpIHtcbiAgdmFyIGxvY0dlb20gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgdmFyIGxpbmVzMCA9IExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyh0aGlzLl9nZW9tWzBdKTtcbiAgdmFyIGxpbmVzMSA9IExpbmVhckNvbXBvbmVudEV4dHJhY3Rlci5nZXRMaW5lcyh0aGlzLl9nZW9tWzFdKTtcbiAgdmFyIHB0czAgPSBQb2ludEV4dHJhY3Rlci5nZXRQb2ludHModGhpcy5fZ2VvbVswXSk7XG4gIHZhciBwdHMxID0gUG9pbnRFeHRyYWN0ZXIuZ2V0UG9pbnRzKHRoaXMuX2dlb21bMV0pO1xuICB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzKGxpbmVzMCwgbGluZXMxLCBsb2NHZW9tKTtcbiAgdGhpcy51cGRhdGVNaW5EaXN0YW5jZShsb2NHZW9tLCBmYWxzZSk7XG4gIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gIGxvY0dlb21bMF0gPSBudWxsO1xuICBsb2NHZW9tWzFdID0gbnVsbDtcbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50cyhsaW5lczAsIHB0czEsIGxvY0dlb20pO1xuICB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKGxvY0dlb20sIGZhbHNlKTtcbiAgaWYgKHRoaXMuX21pbkRpc3RhbmNlIDw9IHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgbG9jR2VvbVswXSA9IG51bGw7XG4gIGxvY0dlb21bMV0gPSBudWxsO1xuICB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKGxpbmVzMSwgcHRzMCwgbG9jR2VvbSk7XG4gIHRoaXMudXBkYXRlTWluRGlzdGFuY2UobG9jR2VvbSwgdHJ1ZSk7XG4gIGlmICh0aGlzLl9taW5EaXN0YW5jZSA8PSB0aGlzLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gIGxvY0dlb21bMF0gPSBudWxsO1xuICBsb2NHZW9tWzFdID0gbnVsbDtcbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2VQb2ludHMocHRzMCwgcHRzMSwgbG9jR2VvbSk7XG4gIHRoaXMudXBkYXRlTWluRGlzdGFuY2UobG9jR2VvbSwgZmFsc2UpO1xufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLm5lYXJlc3RMb2NhdGlvbnMgPSBmdW5jdGlvbiBuZWFyZXN0TG9jYXRpb25zICgpIHtcbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKTtcbiAgcmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25cbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS51cGRhdGVNaW5EaXN0YW5jZSA9IGZ1bmN0aW9uIHVwZGF0ZU1pbkRpc3RhbmNlIChsb2NHZW9tLCBmbGlwKSB7XG4gIGlmIChsb2NHZW9tWzBdID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGZsaXApIHtcbiAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdID0gbG9jR2VvbVsxXTtcbiAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdID0gbG9jR2VvbVswXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzBdID0gbG9jR2VvbVswXTtcbiAgICB0aGlzLl9taW5EaXN0YW5jZUxvY2F0aW9uWzFdID0gbG9jR2VvbVsxXTtcbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLm5lYXJlc3RQb2ludHMgPSBmdW5jdGlvbiBuZWFyZXN0UG9pbnRzICgpIHtcbiAgdGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKTtcbiAgdmFyIG5lYXJlc3RQdHMgPSBbdGhpcy5fbWluRGlzdGFuY2VMb2NhdGlvblswXS5nZXRDb29yZGluYXRlKCksIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb25bMV0uZ2V0Q29vcmRpbmF0ZSgpXTtcbiAgcmV0dXJuIG5lYXJlc3RQdHNcbn07XG5EaXN0YW5jZU9wLnByb3RvdHlwZS5jb21wdXRlTWluRGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlTWluRGlzdGFuY2UgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb24gIT09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIHRoaXMuX21pbkRpc3RhbmNlTG9jYXRpb24gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgICB0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKCk7XG4gICAgaWYgKHRoaXMuX21pbkRpc3RhbmNlIDw9IHRoaXMuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICB0aGlzLmNvbXB1dGVGYWNldERpc3RhbmNlKCk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBBcnJheSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVN0cmluZyAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBQb2ludCkpIHtcbiAgICAgIHZhciBsaW5lID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHB0ID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGxvY0dlb20gPSBhcmd1bWVudHNbMl07XG4gICAgICBpZiAobGluZS5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UocHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSA+IHRoaXMuX21pbkRpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICAgIHZhciBjb29yZDAgPSBsaW5lLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgY29vcmQgPSBwdC5nZXRDb29yZGluYXRlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3JkMC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGRpc3QgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VQb2ludExpbmUoY29vcmQsIGNvb3JkMFtpXSwgY29vcmQwW2kgKyAxXSk7XG4gICAgICAgIGlmIChkaXN0IDwgdGhpcyQxLl9taW5EaXN0YW5jZSkge1xuICAgICAgICAgIHRoaXMkMS5fbWluRGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgIHZhciBzZWcgPSBuZXcgTGluZVNlZ21lbnQoY29vcmQwW2ldLCBjb29yZDBbaSArIDFdKTtcbiAgICAgICAgICB2YXIgc2VnQ2xvc2VzdFBvaW50ID0gc2VnLmNsb3Nlc3RQb2ludChjb29yZCk7XG4gICAgICAgICAgbG9jR2VvbVswXSA9IG5ldyBHZW9tZXRyeUxvY2F0aW9uKGxpbmUsIGksIHNlZ0Nsb3Nlc3RQb2ludCk7XG4gICAgICAgICAgbG9jR2VvbVsxXSA9IG5ldyBHZW9tZXRyeUxvY2F0aW9uKHB0LCAwLCBjb29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBBcnJheSAmJiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgTGluZVN0cmluZyAmJiBhcmd1bWVudHNbMV0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSkge1xuICAgICAgdmFyIGxpbmUwID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGxpbmUxID0gYXJndW1lbnRzWzFdO1xuICAgICAgdmFyIGxvY0dlb20kMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIGlmIChsaW5lMC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UobGluZTEuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSA+IHRoaXMuX21pbkRpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICAgIHZhciBjb29yZDAkMSA9IGxpbmUwLmdldENvb3JkaW5hdGVzKCk7XG4gICAgICB2YXIgY29vcmQxID0gbGluZTEuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGNvb3JkMCQxLmxlbmd0aCAtIDE7IGkkMSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY29vcmQxLmxlbmd0aCAtIDE7IGorKykge1xuICAgICAgICAgIHZhciBkaXN0JDEgPSBDR0FsZ29yaXRobXMuZGlzdGFuY2VMaW5lTGluZShjb29yZDAkMVtpJDFdLCBjb29yZDAkMVtpJDEgKyAxXSwgY29vcmQxW2pdLCBjb29yZDFbaiArIDFdKTtcbiAgICAgICAgICBpZiAoZGlzdCQxIDwgdGhpcyQxLl9taW5EaXN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcyQxLl9taW5EaXN0YW5jZSA9IGRpc3QkMTtcbiAgICAgICAgICAgIHZhciBzZWcwID0gbmV3IExpbmVTZWdtZW50KGNvb3JkMCQxW2kkMV0sIGNvb3JkMCQxW2kkMSArIDFdKTtcbiAgICAgICAgICAgIHZhciBzZWcxID0gbmV3IExpbmVTZWdtZW50KGNvb3JkMVtqXSwgY29vcmQxW2ogKyAxXSk7XG4gICAgICAgICAgICB2YXIgY2xvc2VzdFB0ID0gc2VnMC5jbG9zZXN0UG9pbnRzKHNlZzEpO1xuICAgICAgICAgICAgbG9jR2VvbSQxWzBdID0gbmV3IEdlb21ldHJ5TG9jYXRpb24obGluZTAsIGkkMSwgY2xvc2VzdFB0WzBdKTtcbiAgICAgICAgICAgIGxvY0dlb20kMVsxXSA9IG5ldyBHZW9tZXRyeUxvY2F0aW9uKGxpbmUxLCBqLCBjbG9zZXN0UHRbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcyQxLl9taW5EaXN0YW5jZSA8PSB0aGlzJDEuX3Rlcm1pbmF0ZURpc3RhbmNlKSB7IHJldHVybiBudWxsIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyA9IGZ1bmN0aW9uIGNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyAocG9pbnRzMCwgcG9pbnRzMSwgbG9jR2VvbSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzMC5zaXplKCk7IGkrKykge1xuICAgIHZhciBwdDAgPSBwb2ludHMwLmdldChpKTtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50czEuc2l6ZSgpOyBqKyspIHtcbiAgICAgIHZhciBwdDEgPSBwb2ludHMxLmdldChqKTtcbiAgICAgIHZhciBkaXN0ID0gcHQwLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZShwdDEuZ2V0Q29vcmRpbmF0ZSgpKTtcbiAgICAgIGlmIChkaXN0IDwgdGhpcyQxLl9taW5EaXN0YW5jZSkge1xuICAgICAgICB0aGlzJDEuX21pbkRpc3RhbmNlID0gZGlzdDtcbiAgICAgICAgbG9jR2VvbVswXSA9IG5ldyBHZW9tZXRyeUxvY2F0aW9uKHB0MCwgMCwgcHQwLmdldENvb3JkaW5hdGUoKSk7XG4gICAgICAgIGxvY0dlb21bMV0gPSBuZXcgR2VvbWV0cnlMb2NhdGlvbihwdDEsIDAsIHB0MS5nZXRDb29yZGluYXRlKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgfVxuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoKSB7XG4gIGlmICh0aGlzLl9nZW9tWzBdID09PSBudWxsIHx8IHRoaXMuX2dlb21bMV0gPT09IG51bGwpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignbnVsbCBnZW9tZXRyaWVzIGFyZSBub3Qgc3VwcG9ydGVkJykgfVxuICBpZiAodGhpcy5fZ2VvbVswXS5pc0VtcHR5KCkgfHwgdGhpcy5fZ2VvbVsxXS5pc0VtcHR5KCkpIHsgcmV0dXJuIDAuMCB9XG4gIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCk7XG4gIHJldHVybiB0aGlzLl9taW5EaXN0YW5jZVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzID0gZnVuY3Rpb24gY29tcHV0ZU1pbkRpc3RhbmNlTGluZXMgKGxpbmVzMCwgbGluZXMxLCBsb2NHZW9tKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lczAuc2l6ZSgpOyBpKyspIHtcbiAgICB2YXIgbGluZTAgPSBsaW5lczAuZ2V0KGkpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgbGluZXMxLnNpemUoKTsgaisrKSB7XG4gICAgICB2YXIgbGluZTEgPSBsaW5lczEuZ2V0KGopO1xuICAgICAgdGhpcyQxLmNvbXB1dGVNaW5EaXN0YW5jZShsaW5lMCwgbGluZTEsIGxvY0dlb20pO1xuICAgICAgaWYgKHRoaXMkMS5fbWluRGlzdGFuY2UgPD0gdGhpcyQxLl90ZXJtaW5hdGVEaXN0YW5jZSkgeyByZXR1cm4gbnVsbCB9XG4gICAgfVxuICB9XG59O1xuRGlzdGFuY2VPcC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkRpc3RhbmNlT3AucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGlzdGFuY2VPcFxufTtcbkRpc3RhbmNlT3AuZGlzdGFuY2UgPSBmdW5jdGlvbiBkaXN0YW5jZSAoZzAsIGcxKSB7XG4gIHZhciBkaXN0T3AgPSBuZXcgRGlzdGFuY2VPcChnMCwgZzEpO1xuICByZXR1cm4gZGlzdE9wLmRpc3RhbmNlKClcbn07XG5EaXN0YW5jZU9wLmlzV2l0aGluRGlzdGFuY2UgPSBmdW5jdGlvbiBpc1dpdGhpbkRpc3RhbmNlIChnMCwgZzEsIGRpc3RhbmNlKSB7XG4gIHZhciBkaXN0T3AgPSBuZXcgRGlzdGFuY2VPcChnMCwgZzEsIGRpc3RhbmNlKTtcbiAgcmV0dXJuIGRpc3RPcC5kaXN0YW5jZSgpIDw9IGRpc3RhbmNlXG59O1xuRGlzdGFuY2VPcC5uZWFyZXN0UG9pbnRzID0gZnVuY3Rpb24gbmVhcmVzdFBvaW50cyAoZzAsIGcxKSB7XG4gIHZhciBkaXN0T3AgPSBuZXcgRGlzdGFuY2VPcChnMCwgZzEpO1xuICByZXR1cm4gZGlzdE9wLm5lYXJlc3RQb2ludHMoKVxufTtcblxudmFyIFBvaW50UGFpckRpc3RhbmNlJDIgPSBmdW5jdGlvbiBQb2ludFBhaXJEaXN0YW5jZSAoKSB7XG4gIHRoaXMuX3B0ID0gW25ldyBDb29yZGluYXRlKCksIG5ldyBDb29yZGluYXRlKCldO1xuICB0aGlzLl9kaXN0YW5jZSA9IERvdWJsZS5OYU47XG4gIHRoaXMuX2lzTnVsbCA9IHRydWU7XG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9wdFxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7XG4gIHJldHVybiB0aGlzLl9wdFtpXVxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLnNldE1pbmltdW0gPSBmdW5jdGlvbiBzZXRNaW5pbXVtICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgcHREaXN0ID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0TWluaW11bShwdERpc3QuX3B0WzBdLCBwdERpc3QuX3B0WzFdKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHAwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBwMSA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAodGhpcy5faXNOdWxsKSB7XG4gICAgICB0aGlzLmluaXRpYWxpemUocDAsIHAxKTtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHZhciBkaXN0ID0gcDAuZGlzdGFuY2UocDEpO1xuICAgIGlmIChkaXN0IDwgdGhpcy5fZGlzdGFuY2UpIHsgdGhpcy5pbml0aWFsaXplKHAwLCBwMSwgZGlzdCk7IH1cbiAgfVxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiBpbml0aWFsaXplICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICB0aGlzLl9pc051bGwgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgcDAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHAxID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX3B0WzBdLnNldENvb3JkaW5hdGUocDApO1xuICAgIHRoaXMuX3B0WzFdLnNldENvb3JkaW5hdGUocDEpO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gcDAuZGlzdGFuY2UocDEpO1xuICAgIHRoaXMuX2lzTnVsbCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgcDAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgZGlzdGFuY2UgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5fcHRbMF0uc2V0Q29vcmRpbmF0ZShwMCQxKTtcbiAgICB0aGlzLl9wdFsxXS5zZXRDb29yZGluYXRlKHAxJDEpO1xuICAgIHRoaXMuX2Rpc3RhbmNlID0gZGlzdGFuY2U7XG4gICAgdGhpcy5faXNOdWxsID0gZmFsc2U7XG4gIH1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgcmV0dXJuIFdLVFdyaXRlci50b0xpbmVTdHJpbmcodGhpcy5fcHRbMF0sIHRoaXMuX3B0WzFdKVxufTtcblBvaW50UGFpckRpc3RhbmNlJDIucHJvdG90eXBlLmdldERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fZGlzdGFuY2Vcbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5zZXRNYXhpbXVtID0gZnVuY3Rpb24gc2V0TWF4aW11bSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIHB0RGlzdCA9IGFyZ3VtZW50c1swXTtcbiAgICB0aGlzLnNldE1heGltdW0ocHREaXN0Ll9wdFswXSwgcHREaXN0Ll9wdFsxXSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBwMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcDEgPSBhcmd1bWVudHNbMV07XG4gICAgaWYgKHRoaXMuX2lzTnVsbCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKHAwLCBwMSk7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YXIgZGlzdCA9IHAwLmRpc3RhbmNlKHAxKTtcbiAgICBpZiAoZGlzdCA+IHRoaXMuX2Rpc3RhbmNlKSB7IHRoaXMuaW5pdGlhbGl6ZShwMCwgcDEsIGRpc3QpOyB9XG4gIH1cbn07XG5Qb2ludFBhaXJEaXN0YW5jZSQyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9pbnRQYWlyRGlzdGFuY2UkMi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBQb2ludFBhaXJEaXN0YW5jZSQyXG59O1xuXG52YXIgRGlzdGFuY2VUb1BvaW50ID0gZnVuY3Rpb24gRGlzdGFuY2VUb1BvaW50ICgpIHt9O1xuXG5EaXN0YW5jZVRvUG9pbnQucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EaXN0YW5jZVRvUG9pbnQucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gRGlzdGFuY2VUb1BvaW50XG59O1xuRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVEaXN0YW5jZSAoKSB7XG4gIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSQyICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBMaW5lU3RyaW5nICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIGxpbmUgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBwdERpc3QgPSBhcmd1bWVudHNbMl07XG4gICAgdmFyIHRlbXBTZWdtZW50ID0gbmV3IExpbmVTZWdtZW50KCk7XG4gICAgdmFyIGNvb3JkcyA9IGxpbmUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHRlbXBTZWdtZW50LnNldENvb3JkaW5hdGVzKGNvb3Jkc1tpXSwgY29vcmRzW2kgKyAxXSk7XG4gICAgICB2YXIgY2xvc2VzdFB0ID0gdGVtcFNlZ21lbnQuY2xvc2VzdFBvaW50KHB0KTtcbiAgICAgIHB0RGlzdC5zZXRNaW5pbXVtKGNsb3Nlc3RQdCwgcHQpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChhcmd1bWVudHNbMl0gaW5zdGFuY2VvZiBQb2ludFBhaXJEaXN0YW5jZSQyICYmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBQb2x5Z29uICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIHBvbHkgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCQxID0gYXJndW1lbnRzWzJdO1xuICAgIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UocG9seS5nZXRFeHRlcmlvclJpbmcoKSwgcHQkMSwgcHREaXN0JDEpO1xuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkkMSsrKSB7XG4gICAgICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKHBvbHkuZ2V0SW50ZXJpb3JSaW5nTihpJDEpLCBwdCQxLCBwdERpc3QkMSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlJDIgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIEdlb21ldHJ5ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDIgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCQyID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChnZW9tIGluc3RhbmNlb2YgTGluZVN0cmluZykge1xuICAgICAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZShnZW9tLCBwdCQyLCBwdERpc3QkMik7XG4gICAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgUG9seWdvbikge1xuICAgICAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZShnZW9tLCBwdCQyLCBwdERpc3QkMik7XG4gICAgfSBlbHNlIGlmIChnZW9tIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZ2MgPSBnZW9tO1xuICAgICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgZ2MuZ2V0TnVtR2VvbWV0cmllcygpOyBpJDIrKykge1xuICAgICAgICB2YXIgZyA9IGdjLmdldEdlb21ldHJ5TihpJDIpO1xuICAgICAgICBEaXN0YW5jZVRvUG9pbnQuY29tcHV0ZURpc3RhbmNlKGcsIHB0JDIsIHB0RGlzdCQyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHREaXN0JDIuc2V0TWluaW11bShnZW9tLmdldENvb3JkaW5hdGUoKSwgcHQkMik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50c1syXSBpbnN0YW5jZW9mIFBvaW50UGFpckRpc3RhbmNlJDIgJiYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTZWdtZW50ICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIENvb3JkaW5hdGUpKSB7XG4gICAgdmFyIHNlZ21lbnQgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHB0JDMgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIHB0RGlzdCQzID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBjbG9zZXN0UHQkMSA9IHNlZ21lbnQuY2xvc2VzdFBvaW50KHB0JDMpO1xuICAgIHB0RGlzdCQzLnNldE1pbmltdW0oY2xvc2VzdFB0JDEsIHB0JDMpO1xuICB9XG59O1xuXG52YXIgRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZSA9IGZ1bmN0aW9uIERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UgKCkge1xuICB0aGlzLl9nMCA9IG51bGw7XG4gIHRoaXMuX2cxID0gbnVsbDtcbiAgdGhpcy5fcHREaXN0ID0gbmV3IFBvaW50UGFpckRpc3RhbmNlJDIoKTtcbiAgdGhpcy5fZGVuc2lmeUZyYWMgPSAwLjA7XG4gIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGcxID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl9nMCA9IGcwO1xuICB0aGlzLl9nMSA9IGcxO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzOSA9IHsgTWF4UG9pbnREaXN0YW5jZUZpbHRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSxNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLmdldENvb3JkaW5hdGVzID0gZnVuY3Rpb24gZ2V0Q29vcmRpbmF0ZXMgKCkge1xuICByZXR1cm4gdGhpcy5fcHREaXN0LmdldENvb3JkaW5hdGVzKClcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5zZXREZW5zaWZ5RnJhY3Rpb24gPSBmdW5jdGlvbiBzZXREZW5zaWZ5RnJhY3Rpb24gKGRlbnNpZnlGcmFjKSB7XG4gIGlmIChkZW5zaWZ5RnJhYyA+IDEuMCB8fCBkZW5zaWZ5RnJhYyA8PSAwLjApIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignRnJhY3Rpb24gaXMgbm90IGluIHJhbmdlICgwLjAgLSAxLjBdJykgfVxuICB0aGlzLl9kZW5zaWZ5RnJhYyA9IGRlbnNpZnlGcmFjO1xufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLmNvbXB1dGUgPSBmdW5jdGlvbiBjb21wdXRlIChnMCwgZzEpIHtcbiAgdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZShnMCwgZzEsIHRoaXMuX3B0RGlzdCk7XG4gIHRoaXMuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UoZzEsIGcwLCB0aGlzLl9wdERpc3QpO1xufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKCkge1xuICB0aGlzLmNvbXB1dGUodGhpcy5fZzAsIHRoaXMuX2cxKTtcbiAgcmV0dXJuIHRoaXMuX3B0RGlzdC5nZXREaXN0YW5jZSgpXG59O1xuRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZS5wcm90b3R5cGUuY29tcHV0ZU9yaWVudGVkRGlzdGFuY2UgPSBmdW5jdGlvbiBjb21wdXRlT3JpZW50ZWREaXN0YW5jZSAoZGlzY3JldGVHZW9tLCBnZW9tLCBwdERpc3QpIHtcbiAgdmFyIGRpc3RGaWx0ZXIgPSBuZXcgTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxKGdlb20pO1xuICBkaXNjcmV0ZUdlb20uYXBwbHkoZGlzdEZpbHRlcik7XG4gIHB0RGlzdC5zZXRNYXhpbXVtKGRpc3RGaWx0ZXIuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKTtcbiAgaWYgKHRoaXMuX2RlbnNpZnlGcmFjID4gMCkge1xuICAgIHZhciBmcmFjRmlsdGVyID0gbmV3IE1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlcihnZW9tLCB0aGlzLl9kZW5zaWZ5RnJhYyk7XG4gICAgZGlzY3JldGVHZW9tLmFwcGx5KGZyYWNGaWx0ZXIpO1xuICAgIHB0RGlzdC5zZXRNYXhpbXVtKGZyYWNGaWx0ZXIuZ2V0TWF4UG9pbnREaXN0YW5jZSgpKTtcbiAgfVxufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLm9yaWVudGVkRGlzdGFuY2UgPSBmdW5jdGlvbiBvcmllbnRlZERpc3RhbmNlICgpIHtcbiAgdGhpcy5jb21wdXRlT3JpZW50ZWREaXN0YW5jZSh0aGlzLl9nMCwgdGhpcy5fZzEsIHRoaXMuX3B0RGlzdCk7XG4gIHJldHVybiB0aGlzLl9wdERpc3QuZ2V0RGlzdGFuY2UoKVxufTtcbkRpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2Vcbn07XG5EaXNjcmV0ZUhhdXNkb3JmZkRpc3RhbmNlLmRpc3RhbmNlID0gZnVuY3Rpb24gZGlzdGFuY2UgKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRpc3QgPSBuZXcgRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZShnMCwgZzEpO1xuICAgIHJldHVybiBkaXN0LmRpc3RhbmNlKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGcwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRlbnNpZnlGcmFjID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBkaXN0JDEgPSBuZXcgRGlzY3JldGVIYXVzZG9yZmZEaXN0YW5jZShnMCQxLCBnMSQxKTtcbiAgICBkaXN0JDEuc2V0RGVuc2lmeUZyYWN0aW9uKGRlbnNpZnlGcmFjKTtcbiAgICByZXR1cm4gZGlzdCQxLmRpc3RhbmNlKClcbiAgfVxufTtcbnN0YXRpY0FjY2Vzc29ycyQzOS5NYXhQb2ludERpc3RhbmNlRmlsdGVyLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMSB9O1xuc3RhdGljQWNjZXNzb3JzJDM5Lk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBNYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UsIHN0YXRpY0FjY2Vzc29ycyQzOSApO1xuXG52YXIgTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxID0gZnVuY3Rpb24gTWF4UG9pbnREaXN0YW5jZUZpbHRlciAoKSB7XG4gIHRoaXMuX21heFB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSQyKCk7XG4gIHRoaXMuX21pblB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSQyKCk7XG4gIHRoaXMuX2V1Y2xpZGVhbkRpc3QgPSBuZXcgRGlzdGFuY2VUb1BvaW50KCk7XG4gIHRoaXMuX2dlb20gPSBudWxsO1xuICB2YXIgZ2VvbSA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fZ2VvbSA9IGdlb207XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKHB0KSB7XG4gIHRoaXMuX21pblB0RGlzdC5pbml0aWFsaXplKCk7XG4gIERpc3RhbmNlVG9Qb2ludC5jb21wdXRlRGlzdGFuY2UodGhpcy5fZ2VvbSwgcHQsIHRoaXMuX21pblB0RGlzdCk7XG4gIHRoaXMuX21heFB0RGlzdC5zZXRNYXhpbXVtKHRoaXMuX21pblB0RGlzdCk7XG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxLnByb3RvdHlwZS5nZXRNYXhQb2ludERpc3RhbmNlID0gZnVuY3Rpb24gZ2V0TWF4UG9pbnREaXN0YW5jZSAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXhQdERpc3Rcbn07XG5NYXhQb2ludERpc3RhbmNlRmlsdGVyJDEucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nvb3JkaW5hdGVGaWx0ZXJdXG59O1xuTWF4UG9pbnREaXN0YW5jZUZpbHRlciQxLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1heFBvaW50RGlzdGFuY2VGaWx0ZXIkMVxufTtcblxudmFyIE1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlciA9IGZ1bmN0aW9uIE1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlciAoKSB7XG4gIHRoaXMuX21heFB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSQyKCk7XG4gIHRoaXMuX21pblB0RGlzdCA9IG5ldyBQb2ludFBhaXJEaXN0YW5jZSQyKCk7XG4gIHRoaXMuX2dlb20gPSBudWxsO1xuICB0aGlzLl9udW1TdWJTZWdzID0gMDtcbiAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gIHZhciBmcmFjdGlvbiA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fZ2VvbSA9IGdlb207XG4gIHRoaXMuX251bVN1YlNlZ3MgPSBNYXRoLnRydW5jKE1hdGgucm91bmQoMS4wIC8gZnJhY3Rpb24pKTtcbn07XG5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoc2VxLCBpbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChpbmRleCA9PT0gMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBwMCA9IHNlcS5nZXRDb29yZGluYXRlKGluZGV4IC0gMSk7XG4gIHZhciBwMSA9IHNlcS5nZXRDb29yZGluYXRlKGluZGV4KTtcbiAgdmFyIGRlbHggPSAocDEueCAtIHAwLngpIC8gdGhpcy5fbnVtU3ViU2VncztcbiAgdmFyIGRlbHkgPSAocDEueSAtIHAwLnkpIC8gdGhpcy5fbnVtU3ViU2VncztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9udW1TdWJTZWdzOyBpKyspIHtcbiAgICB2YXIgeCA9IHAwLnggKyBpICogZGVseDtcbiAgICB2YXIgeSA9IHAwLnkgKyBpICogZGVseTtcbiAgICB2YXIgcHQgPSBuZXcgQ29vcmRpbmF0ZSh4LCB5KTtcbiAgICB0aGlzJDEuX21pblB0RGlzdC5pbml0aWFsaXplKCk7XG4gICAgRGlzdGFuY2VUb1BvaW50LmNvbXB1dGVEaXN0YW5jZSh0aGlzJDEuX2dlb20sIHB0LCB0aGlzJDEuX21pblB0RGlzdCk7XG4gICAgdGhpcyQxLl9tYXhQdERpc3Quc2V0TWF4aW11bSh0aGlzJDEuX21pblB0RGlzdCk7XG4gIH1cbn07XG5NYXhEZW5zaWZpZWRCeUZyYWN0aW9uRGlzdGFuY2VGaWx0ZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcbk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuaXNHZW9tZXRyeUNoYW5nZWQgPSBmdW5jdGlvbiBpc0dlb21ldHJ5Q2hhbmdlZCAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcbk1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlci5wcm90b3R5cGUuZ2V0TWF4UG9pbnREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldE1heFBvaW50RGlzdGFuY2UgKCkge1xuICByZXR1cm4gdGhpcy5fbWF4UHREaXN0XG59O1xuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlU2VxdWVuY2VGaWx0ZXJdXG59O1xuTWF4RGVuc2lmaWVkQnlGcmFjdGlvbkRpc3RhbmNlRmlsdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1heERlbnNpZmllZEJ5RnJhY3Rpb25EaXN0YW5jZUZpbHRlclxufTtcblxudmFyIEJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yID0gZnVuY3Rpb24gQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IgKGlucHV0LCBidWZEaXN0YW5jZSwgcmVzdWx0KSB7XG4gIHRoaXMuX21pblZhbGlkRGlzdGFuY2UgPSBudWxsO1xuICB0aGlzLl9tYXhWYWxpZERpc3RhbmNlID0gbnVsbDtcbiAgdGhpcy5fbWluRGlzdGFuY2VGb3VuZCA9IG51bGw7XG4gIHRoaXMuX21heERpc3RhbmNlRm91bmQgPSBudWxsO1xuICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbiAgdGhpcy5fZXJyTXNnID0gbnVsbDtcbiAgdGhpcy5fZXJyb3JMb2NhdGlvbiA9IG51bGw7XG4gIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gbnVsbDtcbiAgdGhpcy5faW5wdXQgPSBpbnB1dCB8fCBudWxsO1xuICB0aGlzLl9idWZEaXN0YW5jZSA9IGJ1ZkRpc3RhbmNlIHx8IG51bGw7XG4gIHRoaXMuX3Jlc3VsdCA9IHJlc3VsdCB8fCBudWxsO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQzNyA9IHsgVkVSQk9TRTogeyBjb25maWd1cmFibGU6IHRydWUgfSxNQVhfRElTVEFOQ0VfRElGRl9GUkFDOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tNYXhpbXVtRGlzdGFuY2UgPSBmdW5jdGlvbiBjaGVja01heGltdW1EaXN0YW5jZSAoaW5wdXQsIGJ1ZkN1cnZlLCBtYXhEaXN0KSB7XG4gIHZhciBoYXVzID0gbmV3IERpc2NyZXRlSGF1c2RvcmZmRGlzdGFuY2UoYnVmQ3VydmUsIGlucHV0KTtcbiAgaGF1cy5zZXREZW5zaWZ5RnJhY3Rpb24oMC4yNSk7XG4gIHRoaXMuX21heERpc3RhbmNlRm91bmQgPSBoYXVzLm9yaWVudGVkRGlzdGFuY2UoKTtcbiAgaWYgKHRoaXMuX21heERpc3RhbmNlRm91bmQgPiBtYXhEaXN0KSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHZhciBwdHMgPSBoYXVzLmdldENvb3JkaW5hdGVzKCk7XG4gICAgdGhpcy5fZXJyb3JMb2NhdGlvbiA9IHB0c1sxXTtcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IGlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHB0cyk7XG4gICAgdGhpcy5fZXJyTXNnID0gJ0Rpc3RhbmNlIGJldHdlZW4gYnVmZmVyIGN1cnZlIGFuZCBpbnB1dCBpcyB0b28gbGFyZ2UgKCcgKyB0aGlzLl9tYXhEaXN0YW5jZUZvdW5kICsgJyBhdCAnICsgV0tUV3JpdGVyLnRvTGluZVN0cmluZyhwdHNbMF0sIHB0c1sxXSkgKyAnKSc7XG4gIH1cbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKCkge1xuICB2YXIgcG9zRGlzdGFuY2UgPSBNYXRoLmFicyh0aGlzLl9idWZEaXN0YW5jZSk7XG4gIHZhciBkaXN0RGVsdGEgPSBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5NQVhfRElTVEFOQ0VfRElGRl9GUkFDICogcG9zRGlzdGFuY2U7XG4gIHRoaXMuX21pblZhbGlkRGlzdGFuY2UgPSBwb3NEaXN0YW5jZSAtIGRpc3REZWx0YTtcbiAgdGhpcy5fbWF4VmFsaWREaXN0YW5jZSA9IHBvc0Rpc3RhbmNlICsgZGlzdERlbHRhO1xuICBpZiAodGhpcy5faW5wdXQuaXNFbXB0eSgpIHx8IHRoaXMuX3Jlc3VsdC5pc0VtcHR5KCkpIHsgcmV0dXJuIHRydWUgfVxuICBpZiAodGhpcy5fYnVmRGlzdGFuY2UgPiAwLjApIHtcbiAgICB0aGlzLmNoZWNrUG9zaXRpdmVWYWxpZCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuY2hlY2tOZWdhdGl2ZVZhbGlkKCk7XG4gIH1cbiAgaWYgKEJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLlZFUkJPU0UpIHtcbiAgICBTeXN0ZW0ub3V0LnByaW50bG4oJ01pbiBEaXN0PSAnICsgdGhpcy5fbWluRGlzdGFuY2VGb3VuZCArICcgIGVycj0gJyArICgxLjAgLSB0aGlzLl9taW5EaXN0YW5jZUZvdW5kIC8gdGhpcy5fYnVmRGlzdGFuY2UpICsgJyAgTWF4IERpc3Q9ICcgKyB0aGlzLl9tYXhEaXN0YW5jZUZvdW5kICsgJyAgZXJyPSAnICsgKHRoaXMuX21heERpc3RhbmNlRm91bmQgLyB0aGlzLl9idWZEaXN0YW5jZSAtIDEuMCkpO1xuICB9XG4gIHJldHVybiB0aGlzLl9pc1ZhbGlkXG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrTmVnYXRpdmVWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrTmVnYXRpdmVWYWxpZCAoKSB7XG4gIGlmICghKHRoaXMuX2lucHV0IGluc3RhbmNlb2YgUG9seWdvbiB8fCB0aGlzLl9pbnB1dCBpbnN0YW5jZW9mIE11bHRpUG9seWdvbiB8fCB0aGlzLl9pbnB1dCBpbnN0YW5jZW9mIEdlb21ldHJ5Q29sbGVjdGlvbikpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHZhciBpbnB1dEN1cnZlID0gdGhpcy5nZXRQb2x5Z29uTGluZXModGhpcy5faW5wdXQpO1xuICB0aGlzLmNoZWNrTWluaW11bURpc3RhbmNlKGlucHV0Q3VydmUsIHRoaXMuX3Jlc3VsdCwgdGhpcy5fbWluVmFsaWREaXN0YW5jZSk7XG4gIGlmICghdGhpcy5faXNWYWxpZCkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuY2hlY2tNYXhpbXVtRGlzdGFuY2UoaW5wdXRDdXJ2ZSwgdGhpcy5fcmVzdWx0LCB0aGlzLl9tYXhWYWxpZERpc3RhbmNlKTtcbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JJbmRpY2F0b3IgPSBmdW5jdGlvbiBnZXRFcnJvckluZGljYXRvciAoKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvckluZGljYXRvclxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja01pbmltdW1EaXN0YW5jZSA9IGZ1bmN0aW9uIGNoZWNrTWluaW11bURpc3RhbmNlIChnMSwgZzIsIG1pbkRpc3QpIHtcbiAgdmFyIGRpc3RPcCA9IG5ldyBEaXN0YW5jZU9wKGcxLCBnMiwgbWluRGlzdCk7XG4gIHRoaXMuX21pbkRpc3RhbmNlRm91bmQgPSBkaXN0T3AuZGlzdGFuY2UoKTtcbiAgaWYgKHRoaXMuX21pbkRpc3RhbmNlRm91bmQgPCBtaW5EaXN0KSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHZhciBwdHMgPSBkaXN0T3AubmVhcmVzdFBvaW50cygpO1xuICAgIHRoaXMuX2Vycm9yTG9jYXRpb24gPSBkaXN0T3AubmVhcmVzdFBvaW50cygpWzFdO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gZzEuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcocHRzKTtcbiAgICB0aGlzLl9lcnJNc2cgPSAnRGlzdGFuY2UgYmV0d2VlbiBidWZmZXIgY3VydmUgYW5kIGlucHV0IGlzIHRvbyBzbWFsbCAoJyArIHRoaXMuX21pbkRpc3RhbmNlRm91bmQgKyAnIGF0ICcgKyBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKHB0c1swXSwgcHRzWzFdKSArICcgKSc7XG4gIH1cbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tQb3NpdGl2ZVZhbGlkID0gZnVuY3Rpb24gY2hlY2tQb3NpdGl2ZVZhbGlkICgpIHtcbiAgdmFyIGJ1ZkN1cnZlID0gdGhpcy5fcmVzdWx0LmdldEJvdW5kYXJ5KCk7XG4gIHRoaXMuY2hlY2tNaW5pbXVtRGlzdGFuY2UodGhpcy5faW5wdXQsIGJ1ZkN1cnZlLCB0aGlzLl9taW5WYWxpZERpc3RhbmNlKTtcbiAgaWYgKCF0aGlzLl9pc1ZhbGlkKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5jaGVja01heGltdW1EaXN0YW5jZSh0aGlzLl9pbnB1dCwgYnVmQ3VydmUsIHRoaXMuX21heFZhbGlkRGlzdGFuY2UpO1xufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvckxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RXJyb3JMb2NhdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvckxvY2F0aW9uXG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmdldFBvbHlnb25MaW5lcyA9IGZ1bmN0aW9uIGdldFBvbHlnb25MaW5lcyAoZykge1xuICB2YXIgbGluZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBsaW5lRXh0cmFjdGVyID0gbmV3IExpbmVhckNvbXBvbmVudEV4dHJhY3RlcihsaW5lcyk7XG4gIHZhciBwb2x5cyA9IFBvbHlnb25FeHRyYWN0ZXIuZ2V0UG9seWdvbnMoZyk7XG4gIGZvciAodmFyIGkgPSBwb2x5cy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgcG9seSA9IGkubmV4dCgpO1xuICAgIHBvbHkuYXBwbHkobGluZUV4dHJhY3Rlcik7XG4gIH1cbiAgcmV0dXJuIGcuZ2V0RmFjdG9yeSgpLmJ1aWxkR2VvbWV0cnkobGluZXMpXG59O1xuQnVmZmVyRGlzdGFuY2VWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lcnJNc2dcbn07XG5CdWZmZXJEaXN0YW5jZVZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yXG59O1xuc3RhdGljQWNjZXNzb3JzJDM3LlZFUkJPU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfTtcbnN0YXRpY0FjY2Vzc29ycyQzNy5NQVhfRElTVEFOQ0VfRElGRl9GUkFDLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDAuMDEyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBCdWZmZXJEaXN0YW5jZVZhbGlkYXRvciwgc3RhdGljQWNjZXNzb3JzJDM3ICk7XG5cbnZhciBCdWZmZXJSZXN1bHRWYWxpZGF0b3IgPSBmdW5jdGlvbiBCdWZmZXJSZXN1bHRWYWxpZGF0b3IgKGlucHV0LCBkaXN0YW5jZSwgcmVzdWx0KSB7XG4gIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICB0aGlzLl9lcnJvck1zZyA9IG51bGw7XG4gIHRoaXMuX2Vycm9yTG9jYXRpb24gPSBudWxsO1xuICB0aGlzLl9lcnJvckluZGljYXRvciA9IG51bGw7XG4gIHRoaXMuX2lucHV0ID0gaW5wdXQgfHwgbnVsbDtcbiAgdGhpcy5fZGlzdGFuY2UgPSBkaXN0YW5jZSB8fCBudWxsO1xuICB0aGlzLl9yZXN1bHQgPSByZXN1bHQgfHwgbnVsbDtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDAgPSB7IFZFUkJPU0U6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sTUFYX0VOVl9ESUZGX0ZSQUM6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKCkge1xuICB0aGlzLmNoZWNrUG9seWdvbmFsKCk7XG4gIGlmICghdGhpcy5faXNWYWxpZCkgeyByZXR1cm4gdGhpcy5faXNWYWxpZCB9XG4gIHRoaXMuY2hlY2tFeHBlY3RlZEVtcHR5KCk7XG4gIGlmICghdGhpcy5faXNWYWxpZCkgeyByZXR1cm4gdGhpcy5faXNWYWxpZCB9XG4gIHRoaXMuY2hlY2tFbnZlbG9wZSgpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIHRoaXMuX2lzVmFsaWQgfVxuICB0aGlzLmNoZWNrQXJlYSgpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuIHRoaXMuX2lzVmFsaWQgfVxuICB0aGlzLmNoZWNrRGlzdGFuY2UoKTtcbiAgcmV0dXJuIHRoaXMuX2lzVmFsaWRcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrRW52ZWxvcGUgPSBmdW5jdGlvbiBjaGVja0VudmVsb3BlICgpIHtcbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDwgMC4wKSB7IHJldHVybiBudWxsIH1cbiAgdmFyIHBhZGRpbmcgPSB0aGlzLl9kaXN0YW5jZSAqIEJ1ZmZlclJlc3VsdFZhbGlkYXRvci5NQVhfRU5WX0RJRkZfRlJBQztcbiAgaWYgKHBhZGRpbmcgPT09IDAuMCkgeyBwYWRkaW5nID0gMC4wMDE7IH1cbiAgdmFyIGV4cGVjdGVkRW52ID0gbmV3IEVudmVsb3BlKHRoaXMuX2lucHV0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk7XG4gIGV4cGVjdGVkRW52LmV4cGFuZEJ5KHRoaXMuX2Rpc3RhbmNlKTtcbiAgdmFyIGJ1ZkVudiA9IG5ldyBFbnZlbG9wZSh0aGlzLl9yZXN1bHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtcbiAgYnVmRW52LmV4cGFuZEJ5KHBhZGRpbmcpO1xuICBpZiAoIWJ1ZkVudi5jb250YWlucyhleHBlY3RlZEVudikpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5fZXJyb3JNc2cgPSAnQnVmZmVyIGVudmVsb3BlIGlzIGluY29ycmVjdCc7XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSB0aGlzLl9pbnB1dC5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeShidWZFbnYpO1xuICB9XG4gIHRoaXMucmVwb3J0KCdFbnZlbG9wZScpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuY2hlY2tEaXN0YW5jZSA9IGZ1bmN0aW9uIGNoZWNrRGlzdGFuY2UgKCkge1xuICB2YXIgZGlzdFZhbGlkID0gbmV3IEJ1ZmZlckRpc3RhbmNlVmFsaWRhdG9yKHRoaXMuX2lucHV0LCB0aGlzLl9kaXN0YW5jZSwgdGhpcy5fcmVzdWx0KTtcbiAgaWYgKCFkaXN0VmFsaWQuaXNWYWxpZCgpKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yTXNnID0gZGlzdFZhbGlkLmdldEVycm9yTWVzc2FnZSgpO1xuICAgIHRoaXMuX2Vycm9yTG9jYXRpb24gPSBkaXN0VmFsaWQuZ2V0RXJyb3JMb2NhdGlvbigpO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gZGlzdFZhbGlkLmdldEVycm9ySW5kaWNhdG9yKCk7XG4gIH1cbiAgdGhpcy5yZXBvcnQoJ0Rpc3RhbmNlJyk7XG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0FyZWEgPSBmdW5jdGlvbiBjaGVja0FyZWEgKCkge1xuICB2YXIgaW5wdXRBcmVhID0gdGhpcy5faW5wdXQuZ2V0QXJlYSgpO1xuICB2YXIgcmVzdWx0QXJlYSA9IHRoaXMuX3Jlc3VsdC5nZXRBcmVhKCk7XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA+IDAuMCAmJiBpbnB1dEFyZWEgPiByZXN1bHRBcmVhKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Vycm9yTXNnID0gJ0FyZWEgb2YgcG9zaXRpdmUgYnVmZmVyIGlzIHNtYWxsZXIgdGhhbiBpbnB1dCc7XG4gICAgdGhpcy5fZXJyb3JJbmRpY2F0b3IgPSB0aGlzLl9yZXN1bHQ7XG4gIH1cbiAgaWYgKHRoaXMuX2Rpc3RhbmNlIDwgMC4wICYmIGlucHV0QXJlYSA8IHJlc3VsdEFyZWEpIHtcbiAgICB0aGlzLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgdGhpcy5fZXJyb3JNc2cgPSAnQXJlYSBvZiBuZWdhdGl2ZSBidWZmZXIgaXMgbGFyZ2VyIHRoYW4gaW5wdXQnO1xuICAgIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gdGhpcy5fcmVzdWx0O1xuICB9XG4gIHRoaXMucmVwb3J0KCdBcmVhJyk7XG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja1BvbHlnb25hbCA9IGZ1bmN0aW9uIGNoZWNrUG9seWdvbmFsICgpIHtcbiAgaWYgKCEodGhpcy5fcmVzdWx0IGluc3RhbmNlb2YgUG9seWdvbiB8fCB0aGlzLl9yZXN1bHQgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pKSB7IHRoaXMuX2lzVmFsaWQgPSBmYWxzZTsgfVxuICB0aGlzLl9lcnJvck1zZyA9ICdSZXN1bHQgaXMgbm90IHBvbHlnb25hbCc7XG4gIHRoaXMuX2Vycm9ySW5kaWNhdG9yID0gdGhpcy5fcmVzdWx0O1xuICB0aGlzLnJlcG9ydCgnUG9seWdvbmFsJyk7XG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvckluZGljYXRvciA9IGZ1bmN0aW9uIGdldEVycm9ySW5kaWNhdG9yICgpIHtcbiAgcmV0dXJuIHRoaXMuX2Vycm9ySW5kaWNhdG9yXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5nZXRFcnJvckxvY2F0aW9uID0gZnVuY3Rpb24gZ2V0RXJyb3JMb2NhdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvckxvY2F0aW9uXG59O1xuQnVmZmVyUmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja0V4cGVjdGVkRW1wdHkgPSBmdW5jdGlvbiBjaGVja0V4cGVjdGVkRW1wdHkgKCkge1xuICBpZiAodGhpcy5faW5wdXQuZ2V0RGltZW5zaW9uKCkgPj0gMikgeyByZXR1cm4gbnVsbCB9XG4gIGlmICh0aGlzLl9kaXN0YW5jZSA+IDAuMCkgeyByZXR1cm4gbnVsbCB9XG4gIGlmICghdGhpcy5fcmVzdWx0LmlzRW1wdHkoKSkge1xuICAgIHRoaXMuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvck1zZyA9ICdSZXN1bHQgaXMgbm9uLWVtcHR5JztcbiAgICB0aGlzLl9lcnJvckluZGljYXRvciA9IHRoaXMuX3Jlc3VsdDtcbiAgfVxuICB0aGlzLnJlcG9ydCgnRXhwZWN0ZWRFbXB0eScpO1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUucmVwb3J0ID0gZnVuY3Rpb24gcmVwb3J0IChjaGVja05hbWUpIHtcbiAgaWYgKCFCdWZmZXJSZXN1bHRWYWxpZGF0b3IuVkVSQk9TRSkgeyByZXR1cm4gbnVsbCB9XG4gIFN5c3RlbS5vdXQucHJpbnRsbignQ2hlY2sgJyArIGNoZWNrTmFtZSArICc6ICcgKyAodGhpcy5faXNWYWxpZCA/ICdwYXNzZWQnIDogJ0ZBSUxFRCcpKTtcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmdldEVycm9yTWVzc2FnZSA9IGZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZSAoKSB7XG4gIHJldHVybiB0aGlzLl9lcnJvck1zZ1xufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkJ1ZmZlclJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBCdWZmZXJSZXN1bHRWYWxpZGF0b3Jcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IuaXNWYWxpZE1zZyA9IGZ1bmN0aW9uIGlzVmFsaWRNc2cgKGcsIGRpc3RhbmNlLCByZXN1bHQpIHtcbiAgdmFyIHZhbGlkYXRvciA9IG5ldyBCdWZmZXJSZXN1bHRWYWxpZGF0b3IoZywgZGlzdGFuY2UsIHJlc3VsdCk7XG4gIGlmICghdmFsaWRhdG9yLmlzVmFsaWQoKSkgeyByZXR1cm4gdmFsaWRhdG9yLmdldEVycm9yTWVzc2FnZSgpIH1cbiAgcmV0dXJuIG51bGxcbn07XG5CdWZmZXJSZXN1bHRWYWxpZGF0b3IuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKGcsIGRpc3RhbmNlLCByZXN1bHQpIHtcbiAgdmFyIHZhbGlkYXRvciA9IG5ldyBCdWZmZXJSZXN1bHRWYWxpZGF0b3IoZywgZGlzdGFuY2UsIHJlc3VsdCk7XG4gIGlmICh2YWxpZGF0b3IuaXNWYWxpZCgpKSB7IHJldHVybiB0cnVlIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuc3RhdGljQWNjZXNzb3JzJDQwLlZFUkJPU0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfTtcbnN0YXRpY0FjY2Vzc29ycyQ0MC5NQVhfRU5WX0RJRkZfRlJBQy5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwLjAxMiB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQnVmZmVyUmVzdWx0VmFsaWRhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkNDAgKTtcblxuLy8gb3BlcmF0aW9uLmJ1ZmZlclxuXG52YXIgQmFzaWNTZWdtZW50U3RyaW5nID0gZnVuY3Rpb24gQmFzaWNTZWdtZW50U3RyaW5nICgpIHtcbiAgdGhpcy5fcHRzID0gbnVsbDtcbiAgdGhpcy5fZGF0YSA9IG51bGw7XG4gIHZhciBwdHMgPSBhcmd1bWVudHNbMF07XG4gIHZhciBkYXRhID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLl9wdHMgPSBwdHM7XG4gIHRoaXMuX2RhdGEgPSBkYXRhO1xufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlcyAoKSB7XG4gIHJldHVybiB0aGlzLl9wdHNcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiBzaXplICgpIHtcbiAgcmV0dXJuIHRoaXMuX3B0cy5sZW5ndGhcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldENvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb29yZGluYXRlIChpKSB7XG4gIHJldHVybiB0aGlzLl9wdHNbaV1cbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmlzQ2xvc2VkID0gZnVuY3Rpb24gaXNDbG9zZWQgKCkge1xuICByZXR1cm4gdGhpcy5fcHRzWzBdLmVxdWFscyh0aGlzLl9wdHNbdGhpcy5fcHRzLmxlbmd0aCAtIDFdKVxufTtcbkJhc2ljU2VnbWVudFN0cmluZy5wcm90b3R5cGUuZ2V0U2VnbWVudE9jdGFudCA9IGZ1bmN0aW9uIGdldFNlZ21lbnRPY3RhbnQgKGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gdGhpcy5fcHRzLmxlbmd0aCAtIDEpIHsgcmV0dXJuIC0xIH1cbiAgcmV0dXJuIE9jdGFudC5vY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKGluZGV4KSwgdGhpcy5nZXRDb29yZGluYXRlKGluZGV4ICsgMSkpXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5zZXREYXRhID0gZnVuY3Rpb24gc2V0RGF0YSAoZGF0YSkge1xuICB0aGlzLl9kYXRhID0gZGF0YTtcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmdldERhdGEgPSBmdW5jdGlvbiBnZXREYXRhICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RhdGFcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICByZXR1cm4gV0tUV3JpdGVyLnRvTGluZVN0cmluZyhuZXcgQ29vcmRpbmF0ZUFycmF5U2VxdWVuY2UodGhpcy5fcHRzKSlcbn07XG5CYXNpY1NlZ21lbnRTdHJpbmcucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW1NlZ21lbnRTdHJpbmddXG59O1xuQmFzaWNTZWdtZW50U3RyaW5nLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEJhc2ljU2VnbWVudFN0cmluZ1xufTtcblxudmFyIEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyID0gZnVuY3Rpb24gSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIgKCkge1xuICB0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyA9IGZhbHNlO1xuICB0aGlzLl9pc0NoZWNrRW5kU2VnbWVudHNPbmx5ID0gZmFsc2U7XG4gIHRoaXMuX2xpID0gbnVsbDtcbiAgdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBudWxsO1xuICB0aGlzLl9pbnRTZWdtZW50cyA9IG51bGw7XG4gIHRoaXMuX2ludGVyc2VjdGlvbnMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX2ludGVyc2VjdGlvbkNvdW50ID0gMDtcbiAgdGhpcy5fa2VlcEludGVyc2VjdGlvbnMgPSB0cnVlO1xuICB2YXIgbGkgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2xpID0gbGk7XG4gIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uID0gbnVsbDtcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBnZXRJbnRlcmlvckludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvblxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5zZXRDaGVja0VuZFNlZ21lbnRzT25seSA9IGZ1bmN0aW9uIHNldENoZWNrRW5kU2VnbWVudHNPbmx5IChpc0NoZWNrRW5kU2VnbWVudHNPbmx5KSB7XG4gIHRoaXMuX2lzQ2hlY2tFbmRTZWdtZW50c09ubHkgPSBpc0NoZWNrRW5kU2VnbWVudHNPbmx5O1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5nZXRJbnRlcnNlY3Rpb25TZWdtZW50cyA9IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvblNlZ21lbnRzICgpIHtcbiAgcmV0dXJuIHRoaXMuX2ludFNlZ21lbnRzXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmNvdW50ID0gZnVuY3Rpb24gY291bnQgKCkge1xuICByZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uQ291bnRcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuZ2V0SW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGdldEludGVyc2VjdGlvbnMgKCkge1xuICByZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uc1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIHNldEZpbmRBbGxJbnRlcnNlY3Rpb25zIChmaW5kQWxsSW50ZXJzZWN0aW9ucykge1xuICB0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyA9IGZpbmRBbGxJbnRlcnNlY3Rpb25zO1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIHNldEtlZXBJbnRlcnNlY3Rpb25zIChrZWVwSW50ZXJzZWN0aW9ucykge1xuICB0aGlzLl9rZWVwSW50ZXJzZWN0aW9ucyA9IGtlZXBJbnRlcnNlY3Rpb25zO1xufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5wcm9jZXNzSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIHByb2Nlc3NJbnRlcnNlY3Rpb25zIChlMCwgc2VnSW5kZXgwLCBlMSwgc2VnSW5kZXgxKSB7XG4gIGlmICghdGhpcy5fZmluZEFsbEludGVyc2VjdGlvbnMgJiYgdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChlMCA9PT0gZTEgJiYgc2VnSW5kZXgwID09PSBzZWdJbmRleDEpIHsgcmV0dXJuIG51bGwgfVxuICBpZiAodGhpcy5faXNDaGVja0VuZFNlZ21lbnRzT25seSkge1xuICAgIHZhciBpc0VuZFNlZ1ByZXNlbnQgPSB0aGlzLmlzRW5kU2VnbWVudChlMCwgc2VnSW5kZXgwKSB8fCB0aGlzLmlzRW5kU2VnbWVudChlMSwgc2VnSW5kZXgxKTtcbiAgICBpZiAoIWlzRW5kU2VnUHJlc2VudCkgeyByZXR1cm4gbnVsbCB9XG4gIH1cbiAgdmFyIHAwMCA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwXTtcbiAgdmFyIHAwMSA9IGUwLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgwICsgMV07XG4gIHZhciBwMTAgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MV07XG4gIHZhciBwMTEgPSBlMS5nZXRDb29yZGluYXRlcygpW3NlZ0luZGV4MSArIDFdO1xuICB0aGlzLl9saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAwMCwgcDAxLCBwMTAsIHAxMSk7XG4gIGlmICh0aGlzLl9saS5oYXNJbnRlcnNlY3Rpb24oKSkge1xuICAgIGlmICh0aGlzLl9saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkpIHtcbiAgICAgIHRoaXMuX2ludFNlZ21lbnRzID0gbmV3IEFycmF5KDQpLmZpbGwobnVsbCk7XG4gICAgICB0aGlzLl9pbnRTZWdtZW50c1swXSA9IHAwMDtcbiAgICAgIHRoaXMuX2ludFNlZ21lbnRzWzFdID0gcDAxO1xuICAgICAgdGhpcy5faW50U2VnbWVudHNbMl0gPSBwMTA7XG4gICAgICB0aGlzLl9pbnRTZWdtZW50c1szXSA9IHAxMTtcbiAgICAgIHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uID0gdGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApO1xuICAgICAgaWYgKHRoaXMuX2tlZXBJbnRlcnNlY3Rpb25zKSB7IHRoaXMuX2ludGVyc2VjdGlvbnMuYWRkKHRoaXMuX2ludGVyaW9ySW50ZXJzZWN0aW9uKTsgfVxuICAgICAgdGhpcy5faW50ZXJzZWN0aW9uQ291bnQrKztcbiAgICB9XG4gIH1cbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuaXNFbmRTZWdtZW50ID0gZnVuY3Rpb24gaXNFbmRTZWdtZW50IChzZWdTdHIsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gMCkgeyByZXR1cm4gdHJ1ZSB9XG4gIGlmIChpbmRleCA+PSBzZWdTdHIuc2l6ZSgpIC0gMikgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5oYXNJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNJbnRlcnNlY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faW50ZXJpb3JJbnRlcnNlY3Rpb24gIT09IG51bGxcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5wcm90b3R5cGUuaXNEb25lID0gZnVuY3Rpb24gaXNEb25lICgpIHtcbiAgaWYgKHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0aGlzLl9pbnRlcmlvckludGVyc2VjdGlvbiAhPT0gbnVsbFxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtTZWdtZW50SW50ZXJzZWN0b3JdXG59O1xuSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW50ZXJpb3JJbnRlcnNlY3Rpb25GaW5kZXJcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5jcmVhdGVBbGxJbnRlcnNlY3Rpb25zRmluZGVyID0gZnVuY3Rpb24gY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlciAobGkpIHtcbiAgdmFyIGZpbmRlciA9IG5ldyBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlcihsaSk7XG4gIGZpbmRlci5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0cnVlKTtcbiAgcmV0dXJuIGZpbmRlclxufTtcbkludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyLmNyZWF0ZUFueUludGVyc2VjdGlvbkZpbmRlciA9IGZ1bmN0aW9uIGNyZWF0ZUFueUludGVyc2VjdGlvbkZpbmRlciAobGkpIHtcbiAgcmV0dXJuIG5ldyBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlcihsaSlcbn07XG5JbnRlcmlvckludGVyc2VjdGlvbkZpbmRlci5jcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyID0gZnVuY3Rpb24gY3JlYXRlSW50ZXJzZWN0aW9uQ291bnRlciAobGkpIHtcbiAgdmFyIGZpbmRlciA9IG5ldyBJbnRlcmlvckludGVyc2VjdGlvbkZpbmRlcihsaSk7XG4gIGZpbmRlci5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0cnVlKTtcbiAgZmluZGVyLnNldEtlZXBJbnRlcnNlY3Rpb25zKGZhbHNlKTtcbiAgcmV0dXJuIGZpbmRlclxufTtcblxudmFyIEZhc3ROb2RpbmdWYWxpZGF0b3IgPSBmdW5jdGlvbiBGYXN0Tm9kaW5nVmFsaWRhdG9yICgpIHtcbiAgdGhpcy5fbGkgPSBuZXcgUm9idXN0TGluZUludGVyc2VjdG9yKCk7XG4gIHRoaXMuX3NlZ1N0cmluZ3MgPSBudWxsO1xuICB0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyA9IGZhbHNlO1xuICB0aGlzLl9zZWdJbnQgPSBudWxsO1xuICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbiAgdmFyIHNlZ1N0cmluZ3MgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX3NlZ1N0cmluZ3MgPSBzZWdTdHJpbmdzO1xufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiBleGVjdXRlICgpIHtcbiAgaWYgKHRoaXMuX3NlZ0ludCAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKTtcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5nZXRJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9ucyAoKSB7XG4gIHJldHVybiB0aGlzLl9zZWdJbnQuZ2V0SW50ZXJzZWN0aW9ucygpXG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKCkge1xuICB0aGlzLmV4ZWN1dGUoKTtcbiAgcmV0dXJuIHRoaXMuX2lzVmFsaWRcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIHNldEZpbmRBbGxJbnRlcnNlY3Rpb25zIChmaW5kQWxsSW50ZXJzZWN0aW9ucykge1xuICB0aGlzLl9maW5kQWxsSW50ZXJzZWN0aW9ucyA9IGZpbmRBbGxJbnRlcnNlY3Rpb25zO1xufTtcbkZhc3ROb2RpbmdWYWxpZGF0b3IucHJvdG90eXBlLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMgKCkge1xuICB0aGlzLl9pc1ZhbGlkID0gdHJ1ZTtcbiAgdGhpcy5fc2VnSW50ID0gbmV3IEludGVyaW9ySW50ZXJzZWN0aW9uRmluZGVyKHRoaXMuX2xpKTtcbiAgdGhpcy5fc2VnSW50LnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHRoaXMuX2ZpbmRBbGxJbnRlcnNlY3Rpb25zKTtcbiAgdmFyIG5vZGVyID0gbmV3IE1DSW5kZXhOb2RlcigpO1xuICBub2Rlci5zZXRTZWdtZW50SW50ZXJzZWN0b3IodGhpcy5fc2VnSW50KTtcbiAgbm9kZXIuY29tcHV0ZU5vZGVzKHRoaXMuX3NlZ1N0cmluZ3MpO1xuICBpZiAodGhpcy5fc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgdGhpcy5faXNWYWxpZCA9IGZhbHNlO1xuICAgIHJldHVybiBudWxsXG4gIH1cbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja1ZhbGlkID0gZnVuY3Rpb24gY2hlY2tWYWxpZCAoKSB7XG4gIHRoaXMuZXhlY3V0ZSgpO1xuICBpZiAoIXRoaXMuX2lzVmFsaWQpIHsgdGhyb3cgbmV3IFRvcG9sb2d5RXhjZXB0aW9uKHRoaXMuZ2V0RXJyb3JNZXNzYWdlKCksIHRoaXMuX3NlZ0ludC5nZXRJbnRlcmlvckludGVyc2VjdGlvbigpKSB9XG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuZ2V0RXJyb3JNZXNzYWdlID0gZnVuY3Rpb24gZ2V0RXJyb3JNZXNzYWdlICgpIHtcbiAgaWYgKHRoaXMuX2lzVmFsaWQpIHsgcmV0dXJuICdubyBpbnRlcnNlY3Rpb25zIGZvdW5kJyB9XG4gIHZhciBpbnRTZWdzID0gdGhpcy5fc2VnSW50LmdldEludGVyc2VjdGlvblNlZ21lbnRzKCk7XG4gIHJldHVybiAnZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBiZXR3ZWVuICcgKyBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKGludFNlZ3NbMF0sIGludFNlZ3NbMV0pICsgJyBhbmQgJyArIFdLVFdyaXRlci50b0xpbmVTdHJpbmcoaW50U2Vnc1syXSwgaW50U2Vnc1szXSlcbn07XG5GYXN0Tm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBGYXN0Tm9kaW5nVmFsaWRhdG9yXG59O1xuRmFzdE5vZGluZ1ZhbGlkYXRvci5jb21wdXRlSW50ZXJzZWN0aW9ucyA9IGZ1bmN0aW9uIGNvbXB1dGVJbnRlcnNlY3Rpb25zIChzZWdTdHJpbmdzKSB7XG4gIHZhciBudiA9IG5ldyBGYXN0Tm9kaW5nVmFsaWRhdG9yKHNlZ1N0cmluZ3MpO1xuICBudi5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0cnVlKTtcbiAgbnYuaXNWYWxpZCgpO1xuICByZXR1cm4gbnYuZ2V0SW50ZXJzZWN0aW9ucygpXG59O1xuXG52YXIgRWRnZU5vZGluZ1ZhbGlkYXRvciA9IGZ1bmN0aW9uIEVkZ2VOb2RpbmdWYWxpZGF0b3IgKCkge1xuICB0aGlzLl9udiA9IG51bGw7XG4gIHZhciBlZGdlcyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fbnYgPSBuZXcgRmFzdE5vZGluZ1ZhbGlkYXRvcihFZGdlTm9kaW5nVmFsaWRhdG9yLnRvU2VnbWVudFN0cmluZ3MoZWRnZXMpKTtcbn07XG5FZGdlTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja1ZhbGlkID0gZnVuY3Rpb24gY2hlY2tWYWxpZCAoKSB7XG4gIHRoaXMuX252LmNoZWNrVmFsaWQoKTtcbn07XG5FZGdlTm9kaW5nVmFsaWRhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuRWRnZU5vZGluZ1ZhbGlkYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlTm9kaW5nVmFsaWRhdG9yXG59O1xuRWRnZU5vZGluZ1ZhbGlkYXRvci50b1NlZ21lbnRTdHJpbmdzID0gZnVuY3Rpb24gdG9TZWdtZW50U3RyaW5ncyAoZWRnZXMpIHtcbiAgdmFyIHNlZ1N0cmluZ3MgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSBlZGdlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgZSA9IGkubmV4dCgpO1xuICAgIHNlZ1N0cmluZ3MuYWRkKG5ldyBCYXNpY1NlZ21lbnRTdHJpbmcoZS5nZXRDb29yZGluYXRlcygpLCBlKSk7XG4gIH1cbiAgcmV0dXJuIHNlZ1N0cmluZ3Ncbn07XG5FZGdlTm9kaW5nVmFsaWRhdG9yLmNoZWNrVmFsaWQgPSBmdW5jdGlvbiBjaGVja1ZhbGlkIChlZGdlcykge1xuICB2YXIgdmFsaWRhdG9yID0gbmV3IEVkZ2VOb2RpbmdWYWxpZGF0b3IoZWRnZXMpO1xuICB2YWxpZGF0b3IuY2hlY2tWYWxpZCgpO1xufTtcblxudmFyIEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlciA9IGZ1bmN0aW9uIEdlb21ldHJ5Q29sbGVjdGlvbk1hcHBlciAobWFwT3ApIHtcbiAgdGhpcy5fbWFwT3AgPSBtYXBPcDtcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAoZ2MpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbWFwcGVkID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdjLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIGcgPSB0aGlzJDEuX21hcE9wLm1hcChnYy5nZXRHZW9tZXRyeU4oaSkpO1xuICAgIGlmICghZy5pc0VtcHR5KCkpIHsgbWFwcGVkLmFkZChnKTsgfVxuICB9XG4gIHJldHVybiBnYy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEdlb21ldHJ5RmFjdG9yeS50b0dlb21ldHJ5QXJyYXkobWFwcGVkKSlcbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeUNvbGxlY3Rpb25NYXBwZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyXG59O1xuR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyLm1hcCA9IGZ1bmN0aW9uIG1hcCAoZ2MsIG9wKSB7XG4gIHZhciBtYXBwZXIgPSBuZXcgR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyKG9wKTtcbiAgcmV0dXJuIG1hcHBlci5tYXAoZ2MpXG59O1xuXG52YXIgTGluZUJ1aWxkZXIgPSBmdW5jdGlvbiBMaW5lQnVpbGRlciAoKSB7XG4gIHRoaXMuX29wID0gbnVsbDtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gbnVsbDtcbiAgdGhpcy5fcHRMb2NhdG9yID0gbnVsbDtcbiAgdGhpcy5fbGluZUVkZ2VzTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdGhpcy5fcmVzdWx0TGluZUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBvcCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdlb21ldHJ5RmFjdG9yeSA9IGFyZ3VtZW50c1sxXTtcbiAgdmFyIHB0TG9jYXRvciA9IGFyZ3VtZW50c1syXTtcbiAgdGhpcy5fb3AgPSBvcDtcbiAgdGhpcy5fZ2VvbWV0cnlGYWN0b3J5ID0gZ2VvbWV0cnlGYWN0b3J5O1xuICB0aGlzLl9wdExvY2F0b3IgPSBwdExvY2F0b3I7XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmNvbGxlY3RMaW5lcyA9IGZ1bmN0aW9uIGNvbGxlY3RMaW5lcyAob3BDb2RlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaXQgPSB0aGlzLl9vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICB0aGlzJDEuY29sbGVjdExpbmVFZGdlKGRlLCBvcENvZGUsIHRoaXMkMS5fbGluZUVkZ2VzTGlzdCk7XG4gICAgdGhpcyQxLmNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZShkZSwgb3BDb2RlLCB0aGlzJDEuX2xpbmVFZGdlc0xpc3QpO1xuICB9XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmxhYmVsSXNvbGF0ZWRMaW5lID0gZnVuY3Rpb24gbGFiZWxJc29sYXRlZExpbmUgKGUsIHRhcmdldEluZGV4KSB7XG4gIHZhciBsb2MgPSB0aGlzLl9wdExvY2F0b3IubG9jYXRlKGUuZ2V0Q29vcmRpbmF0ZSgpLCB0aGlzLl9vcC5nZXRBcmdHZW9tZXRyeSh0YXJnZXRJbmRleCkpO1xuICBlLmdldExhYmVsKCkuc2V0TG9jYXRpb24odGFyZ2V0SW5kZXgsIGxvYyk7XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmJ1aWxkID0gZnVuY3Rpb24gYnVpbGQgKG9wQ29kZSkge1xuICB0aGlzLmZpbmRDb3ZlcmVkTGluZUVkZ2VzKCk7XG4gIHRoaXMuY29sbGVjdExpbmVzKG9wQ29kZSk7XG4gIHRoaXMuYnVpbGRMaW5lcyhvcENvZGUpO1xuICByZXR1cm4gdGhpcy5fcmVzdWx0TGluZUxpc3Rcbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuY29sbGVjdExpbmVFZGdlID0gZnVuY3Rpb24gY29sbGVjdExpbmVFZGdlIChkZSwgb3BDb2RlLCBlZGdlcykge1xuICB2YXIgbGFiZWwgPSBkZS5nZXRMYWJlbCgpO1xuICB2YXIgZSA9IGRlLmdldEVkZ2UoKTtcbiAgaWYgKGRlLmlzTGluZUVkZ2UoKSkge1xuICAgIGlmICghZGUuaXNWaXNpdGVkKCkgJiYgT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcChsYWJlbCwgb3BDb2RlKSAmJiAhZS5pc0NvdmVyZWQoKSkge1xuICAgICAgZWRnZXMuYWRkKGUpO1xuICAgICAgZGUuc2V0VmlzaXRlZEVkZ2UodHJ1ZSk7XG4gICAgfVxuICB9XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmZpbmRDb3ZlcmVkTGluZUVkZ2VzID0gZnVuY3Rpb24gZmluZENvdmVyZWRMaW5lRWRnZXMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIG5vZGVpdCA9IHRoaXMuX29wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICBub2RlLmdldEVkZ2VzKCkuZmluZENvdmVyZWRMaW5lRWRnZXMoKTtcbiAgfVxuICBmb3IgKHZhciBpdCA9IHRoaXMuX29wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGRlID0gaXQubmV4dCgpO1xuICAgIHZhciBlID0gZGUuZ2V0RWRnZSgpO1xuICAgIGlmIChkZS5pc0xpbmVFZGdlKCkgJiYgIWUuaXNDb3ZlcmVkU2V0KCkpIHtcbiAgICAgIHZhciBpc0NvdmVyZWQgPSB0aGlzJDEuX29wLmlzQ292ZXJlZEJ5QShkZS5nZXRDb29yZGluYXRlKCkpO1xuICAgICAgZS5zZXRDb3ZlcmVkKGlzQ292ZXJlZCk7XG4gICAgfVxuICB9XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmxhYmVsSXNvbGF0ZWRMaW5lcyA9IGZ1bmN0aW9uIGxhYmVsSXNvbGF0ZWRMaW5lcyAoZWRnZXNMaXN0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaXQgPSBlZGdlc0xpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgIHZhciBsYWJlbCA9IGUuZ2V0TGFiZWwoKTtcbiAgICBpZiAoZS5pc0lzb2xhdGVkKCkpIHtcbiAgICAgIGlmIChsYWJlbC5pc051bGwoMCkpIHsgdGhpcyQxLmxhYmVsSXNvbGF0ZWRMaW5lKGUsIDApOyB9IGVsc2UgeyB0aGlzJDEubGFiZWxJc29sYXRlZExpbmUoZSwgMSk7IH1cbiAgICB9XG4gIH1cbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuYnVpbGRMaW5lcyA9IGZ1bmN0aW9uIGJ1aWxkTGluZXMgKG9wQ29kZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGZvciAodmFyIGl0ID0gdGhpcy5fbGluZUVkZ2VzTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgLy8gY29uc3QgbGFiZWwgPSBlLmdldExhYmVsKClcbiAgICB2YXIgbGluZSA9IHRoaXMkMS5fZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoZS5nZXRDb29yZGluYXRlcygpKTtcbiAgICB0aGlzJDEuX3Jlc3VsdExpbmVMaXN0LmFkZChsaW5lKTtcbiAgICBlLnNldEluUmVzdWx0KHRydWUpO1xuICB9XG59O1xuTGluZUJ1aWxkZXIucHJvdG90eXBlLmNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZSA9IGZ1bmN0aW9uIGNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZSAoZGUsIG9wQ29kZSwgZWRnZXMpIHtcbiAgdmFyIGxhYmVsID0gZGUuZ2V0TGFiZWwoKTtcbiAgaWYgKGRlLmlzTGluZUVkZ2UoKSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChkZS5pc1Zpc2l0ZWQoKSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChkZS5pc0ludGVyaW9yQXJlYUVkZ2UoKSkgeyByZXR1cm4gbnVsbCB9XG4gIGlmIChkZS5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKSB7IHJldHVybiBudWxsIH1cbiAgQXNzZXJ0LmlzVHJ1ZSghKGRlLmlzSW5SZXN1bHQoKSB8fCBkZS5nZXRTeW0oKS5pc0luUmVzdWx0KCkpIHx8ICFkZS5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKTtcbiAgaWYgKE92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AobGFiZWwsIG9wQ29kZSkgJiYgb3BDb2RlID09PSBPdmVybGF5T3AuSU5URVJTRUNUSU9OKSB7XG4gICAgZWRnZXMuYWRkKGRlLmdldEVkZ2UoKSk7XG4gICAgZGUuc2V0VmlzaXRlZEVkZ2UodHJ1ZSk7XG4gIH1cbn07XG5MaW5lQnVpbGRlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkxpbmVCdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIExpbmVCdWlsZGVyXG59O1xuXG52YXIgUG9pbnRCdWlsZGVyID0gZnVuY3Rpb24gUG9pbnRCdWlsZGVyICgpIHtcbiAgdGhpcy5fb3AgPSBudWxsO1xuICB0aGlzLl9nZW9tZXRyeUZhY3RvcnkgPSBudWxsO1xuICB0aGlzLl9yZXN1bHRQb2ludExpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHZhciBvcCA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGdlb21ldHJ5RmFjdG9yeSA9IGFyZ3VtZW50c1sxXTtcbiAgLy8gY29uc3QgcHRMb2NhdG9yID0gYXJndW1lbnRzWzJdXG4gIHRoaXMuX29wID0gb3A7XG4gIHRoaXMuX2dlb21ldHJ5RmFjdG9yeSA9IGdlb21ldHJ5RmFjdG9yeTtcbn07XG5Qb2ludEJ1aWxkZXIucHJvdG90eXBlLmZpbHRlckNvdmVyZWROb2RlVG9Qb2ludCA9IGZ1bmN0aW9uIGZpbHRlckNvdmVyZWROb2RlVG9Qb2ludCAobikge1xuICB2YXIgY29vcmQgPSBuLmdldENvb3JkaW5hdGUoKTtcbiAgaWYgKCF0aGlzLl9vcC5pc0NvdmVyZWRCeUxBKGNvb3JkKSkge1xuICAgIHZhciBwdCA9IHRoaXMuX2dlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChjb29yZCk7XG4gICAgdGhpcy5fcmVzdWx0UG9pbnRMaXN0LmFkZChwdCk7XG4gIH1cbn07XG5Qb2ludEJ1aWxkZXIucHJvdG90eXBlLmV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXMgPSBmdW5jdGlvbiBleHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzIChvcENvZGUpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICB2YXIgbiA9IG5vZGVpdC5uZXh0KCk7XG4gICAgaWYgKG4uaXNJblJlc3VsdCgpKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAobi5pc0luY2lkZW50RWRnZUluUmVzdWx0KCkpIHsgY29udGludWUgfVxuICAgIGlmIChuLmdldEVkZ2VzKCkuZ2V0RGVncmVlKCkgPT09IDAgfHwgb3BDb2RlID09PSBPdmVybGF5T3AuSU5URVJTRUNUSU9OKSB7XG4gICAgICB2YXIgbGFiZWwgPSBuLmdldExhYmVsKCk7XG4gICAgICBpZiAoT3ZlcmxheU9wLmlzUmVzdWx0T2ZPcChsYWJlbCwgb3BDb2RlKSkge1xuICAgICAgICB0aGlzJDEuZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50KG4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblBvaW50QnVpbGRlci5wcm90b3R5cGUuYnVpbGQgPSBmdW5jdGlvbiBidWlsZCAob3BDb2RlKSB7XG4gIHRoaXMuZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2RlcyhvcENvZGUpO1xuICByZXR1cm4gdGhpcy5fcmVzdWx0UG9pbnRMaXN0XG59O1xuUG9pbnRCdWlsZGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuUG9pbnRCdWlsZGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFBvaW50QnVpbGRlclxufTtcblxudmFyIEdlb21ldHJ5VHJhbnNmb3JtZXIgPSBmdW5jdGlvbiBHZW9tZXRyeVRyYW5zZm9ybWVyICgpIHtcbiAgdGhpcy5faW5wdXRHZW9tID0gbnVsbDtcbiAgdGhpcy5fZmFjdG9yeSA9IG51bGw7XG4gIHRoaXMuX3BydW5lRW1wdHlHZW9tZXRyeSA9IHRydWU7XG4gIHRoaXMuX3ByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZSA9IHRydWU7XG4gIHRoaXMuX3ByZXNlcnZlQ29sbGVjdGlvbnMgPSBmYWxzZTtcbiAgdGhpcy5fcHJlc2VydmVUeXBlID0gZmFsc2U7XG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtUG9pbnQgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludCAoZ2VvbSwgcGFyZW50KSB7XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXMoZ2VvbS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSwgZ2VvbSkpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtUG9seWdvbiA9IGZ1bmN0aW9uIHRyYW5zZm9ybVBvbHlnb24gKGdlb20sIHBhcmVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpc0FsbFZhbGlkTGluZWFyUmluZ3MgPSB0cnVlO1xuICB2YXIgc2hlbGwgPSB0aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcoZ2VvbS5nZXRFeHRlcmlvclJpbmcoKSwgZ2VvbSk7XG4gIGlmIChzaGVsbCA9PT0gbnVsbCB8fCAhKHNoZWxsIGluc3RhbmNlb2YgTGluZWFyUmluZykgfHwgc2hlbGwuaXNFbXB0eSgpKSB7IGlzQWxsVmFsaWRMaW5lYXJSaW5ncyA9IGZhbHNlOyB9XG4gIHZhciBob2xlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUludGVyaW9yUmluZygpOyBpKyspIHtcbiAgICB2YXIgaG9sZSA9IHRoaXMkMS50cmFuc2Zvcm1MaW5lYXJSaW5nKGdlb20uZ2V0SW50ZXJpb3JSaW5nTihpKSwgZ2VvbSk7XG4gICAgaWYgKGhvbGUgPT09IG51bGwgfHwgaG9sZS5pc0VtcHR5KCkpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICghKGhvbGUgaW5zdGFuY2VvZiBMaW5lYXJSaW5nKSkgeyBpc0FsbFZhbGlkTGluZWFyUmluZ3MgPSBmYWxzZTsgfVxuICAgIGhvbGVzLmFkZChob2xlKTtcbiAgfVxuICBpZiAoaXNBbGxWYWxpZExpbmVhclJpbmdzKSB7IHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZVBvbHlnb24oc2hlbGwsIGhvbGVzLnRvQXJyYXkoW10pKTsgfSBlbHNlIHtcbiAgICB2YXIgY29tcG9uZW50cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBpZiAoc2hlbGwgIT09IG51bGwpIHsgY29tcG9uZW50cy5hZGQoc2hlbGwpOyB9XG4gICAgY29tcG9uZW50cy5hZGRBbGwoaG9sZXMpO1xuICAgIHJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkoY29tcG9uZW50cylcbiAgfVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLmNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZSA9IGZ1bmN0aW9uIGNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZSAoY29vcmRzKSB7XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoY29vcmRzKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLmdldElucHV0R2VvbWV0cnkgPSBmdW5jdGlvbiBnZXRJbnB1dEdlb21ldHJ5ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2lucHV0R2VvbVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybU11bHRpTGluZVN0cmluZyA9IGZ1bmN0aW9uIHRyYW5zZm9ybU11bHRpTGluZVN0cmluZyAoZ2VvbSwgcGFyZW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHRyYW5zR2VvbUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciB0cmFuc2Zvcm1HZW9tID0gdGhpcyQxLnRyYW5zZm9ybUxpbmVTdHJpbmcoZ2VvbS5nZXRHZW9tZXRyeU4oaSksIGdlb20pO1xuICAgIGlmICh0cmFuc2Zvcm1HZW9tID09PSBudWxsKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAodHJhbnNmb3JtR2VvbS5pc0VtcHR5KCkpIHsgY29udGludWUgfVxuICAgIHRyYW5zR2VvbUxpc3QuYWRkKHRyYW5zZm9ybUdlb20pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmJ1aWxkR2VvbWV0cnkodHJhbnNHZW9tTGlzdClcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1Db29yZGluYXRlcyA9IGZ1bmN0aW9uIHRyYW5zZm9ybUNvb3JkaW5hdGVzIChjb29yZHMsIHBhcmVudCkge1xuICByZXR1cm4gdGhpcy5jb3B5KGNvb3Jkcylcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1MaW5lU3RyaW5nID0gZnVuY3Rpb24gdHJhbnNmb3JtTGluZVN0cmluZyAoZ2VvbSwgcGFyZW50KSB7XG4gIHJldHVybiB0aGlzLl9mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyhnZW9tLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLCBnZW9tKSlcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1NdWx0aVBvaW50ID0gZnVuY3Rpb24gdHJhbnNmb3JtTXVsdGlQb2ludCAoZ2VvbSwgcGFyZW50KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHRyYW5zR2VvbUxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciB0cmFuc2Zvcm1HZW9tID0gdGhpcyQxLnRyYW5zZm9ybVBvaW50KGdlb20uZ2V0R2VvbWV0cnlOKGkpLCBnZW9tKTtcbiAgICBpZiAodHJhbnNmb3JtR2VvbSA9PT0gbnVsbCkgeyBjb250aW51ZSB9XG4gICAgaWYgKHRyYW5zZm9ybUdlb20uaXNFbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICB0cmFuc0dlb21MaXN0LmFkZCh0cmFuc2Zvcm1HZW9tKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRyYW5zR2VvbUxpc3QpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtTXVsdGlQb2x5Z29uID0gZnVuY3Rpb24gdHJhbnNmb3JtTXVsdGlQb2x5Z29uIChnZW9tLCBwYXJlbnQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgdHJhbnNHZW9tTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIHRyYW5zZm9ybUdlb20gPSB0aGlzJDEudHJhbnNmb3JtUG9seWdvbihnZW9tLmdldEdlb21ldHJ5TihpKSwgZ2VvbSk7XG4gICAgaWYgKHRyYW5zZm9ybUdlb20gPT09IG51bGwpIHsgY29udGludWUgfVxuICAgIGlmICh0cmFuc2Zvcm1HZW9tLmlzRW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgdHJhbnNHZW9tTGlzdC5hZGQodHJhbnNmb3JtR2VvbSk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0cmFuc0dlb21MaXN0KVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChzZXEpIHtcbiAgcmV0dXJuIHNlcS5jb3B5KClcbn07XG5HZW9tZXRyeVRyYW5zZm9ybWVyLnByb3RvdHlwZS50cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiB0cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24gKGdlb20sIHBhcmVudCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciB0cmFuc0dlb21MaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgdHJhbnNmb3JtR2VvbSA9IHRoaXMkMS50cmFuc2Zvcm0oZ2VvbS5nZXRHZW9tZXRyeU4oaSkpO1xuICAgIGlmICh0cmFuc2Zvcm1HZW9tID09PSBudWxsKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAodGhpcyQxLl9wcnVuZUVtcHR5R2VvbWV0cnkgJiYgdHJhbnNmb3JtR2VvbS5pc0VtcHR5KCkpIHsgY29udGludWUgfVxuICAgIHRyYW5zR2VvbUxpc3QuYWRkKHRyYW5zZm9ybUdlb20pO1xuICB9XG4gIGlmICh0aGlzLl9wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGUpIHsgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKEdlb21ldHJ5RmFjdG9yeS50b0dlb21ldHJ5QXJyYXkodHJhbnNHZW9tTGlzdCkpIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0cmFuc0dlb21MaXN0KVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAoaW5wdXRHZW9tKSB7XG4gIHRoaXMuX2lucHV0R2VvbSA9IGlucHV0R2VvbTtcbiAgdGhpcy5fZmFjdG9yeSA9IGlucHV0R2VvbS5nZXRGYWN0b3J5KCk7XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBQb2ludCkgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2ludChpbnB1dEdlb20sIG51bGwpIH1cbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIE11bHRpUG9pbnQpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2ludChpbnB1dEdlb20sIG51bGwpIH1cbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIExpbmVhclJpbmcpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZWFyUmluZyhpbnB1dEdlb20sIG51bGwpIH1cbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIExpbmVTdHJpbmcpIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZVN0cmluZyhpbnB1dEdlb20sIG51bGwpIH1cbiAgaWYgKGlucHV0R2VvbSBpbnN0YW5jZW9mIE11bHRpTGluZVN0cmluZykgeyByZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcoaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBQb2x5Z29uKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybVBvbHlnb24oaW5wdXRHZW9tLCBudWxsKSB9XG4gIGlmIChpbnB1dEdlb20gaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pIHsgcmV0dXJuIHRoaXMudHJhbnNmb3JtTXVsdGlQb2x5Z29uKGlucHV0R2VvbSwgbnVsbCkgfVxuICBpZiAoaW5wdXRHZW9tIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7IHJldHVybiB0aGlzLnRyYW5zZm9ybUdlb21ldHJ5Q29sbGVjdGlvbihpbnB1dEdlb20sIG51bGwpIH1cbiAgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignVW5rbm93biBHZW9tZXRyeSBzdWJ0eXBlOiAnICsgaW5wdXRHZW9tLmdldENsYXNzKCkuZ2V0TmFtZSgpKVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLnRyYW5zZm9ybUxpbmVhclJpbmcgPSBmdW5jdGlvbiB0cmFuc2Zvcm1MaW5lYXJSaW5nIChnZW9tLCBwYXJlbnQpIHtcbiAgdmFyIHNlcSA9IHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXMoZ2VvbS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSwgZ2VvbSk7XG4gIGlmIChzZXEgPT09IG51bGwpIHsgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhudWxsKSB9XG4gIHZhciBzZXFTaXplID0gc2VxLnNpemUoKTtcbiAgaWYgKHNlcVNpemUgPiAwICYmIHNlcVNpemUgPCA0ICYmICF0aGlzLl9wcmVzZXJ2ZVR5cGUpIHsgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhzZXEpIH1cbiAgcmV0dXJuIHRoaXMuX2ZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhzZXEpXG59O1xuR2VvbWV0cnlUcmFuc2Zvcm1lci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5VHJhbnNmb3JtZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlUcmFuc2Zvcm1lclxufTtcblxudmFyIExpbmVTdHJpbmdTbmFwcGVyID0gZnVuY3Rpb24gTGluZVN0cmluZ1NuYXBwZXIgKCkge1xuICB0aGlzLl9zbmFwVG9sZXJhbmNlID0gMC4wO1xuICB0aGlzLl9zcmNQdHMgPSBudWxsO1xuICB0aGlzLl9zZWcgPSBuZXcgTGluZVNlZ21lbnQoKTtcbiAgdGhpcy5fYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMgPSBmYWxzZTtcbiAgdGhpcy5faXNDbG9zZWQgPSBmYWxzZTtcbiAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIExpbmVTdHJpbmcgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgc3JjTGluZSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc25hcFRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgICBMaW5lU3RyaW5nU25hcHBlci5jYWxsKHRoaXMsIHNyY0xpbmUuZ2V0Q29vcmRpbmF0ZXMoKSwgc25hcFRvbGVyYW5jZSk7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcbiAgICB2YXIgc3JjUHRzID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBzbmFwVG9sZXJhbmNlJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdGhpcy5fc3JjUHRzID0gc3JjUHRzO1xuICAgIHRoaXMuX2lzQ2xvc2VkID0gTGluZVN0cmluZ1NuYXBwZXIuaXNDbG9zZWQoc3JjUHRzKTtcbiAgICB0aGlzLl9zbmFwVG9sZXJhbmNlID0gc25hcFRvbGVyYW5jZSQxO1xuICB9XG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLnNuYXBWZXJ0aWNlcyA9IGZ1bmN0aW9uIHNuYXBWZXJ0aWNlcyAoc3JjQ29vcmRzLCBzbmFwUHRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIGVuZCA9IHRoaXMuX2lzQ2xvc2VkID8gc3JjQ29vcmRzLnNpemUoKSAtIDEgOiBzcmNDb29yZHMuc2l6ZSgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgdmFyIHNyY1B0ID0gc3JjQ29vcmRzLmdldChpKTtcbiAgICB2YXIgc25hcFZlcnQgPSB0aGlzJDEuZmluZFNuYXBGb3JWZXJ0ZXgoc3JjUHQsIHNuYXBQdHMpO1xuICAgIGlmIChzbmFwVmVydCAhPT0gbnVsbCkge1xuICAgICAgc3JjQ29vcmRzLnNldChpLCBuZXcgQ29vcmRpbmF0ZShzbmFwVmVydCkpO1xuICAgICAgaWYgKGkgPT09IDAgJiYgdGhpcyQxLl9pc0Nsb3NlZCkgeyBzcmNDb29yZHMuc2V0KHNyY0Nvb3Jkcy5zaXplKCkgLSAxLCBuZXcgQ29vcmRpbmF0ZShzbmFwVmVydCkpOyB9XG4gICAgfVxuICB9XG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLmZpbmRTbmFwRm9yVmVydGV4ID0gZnVuY3Rpb24gZmluZFNuYXBGb3JWZXJ0ZXggKHB0LCBzbmFwUHRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbmFwUHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHB0LmVxdWFsczJEKHNuYXBQdHNbaV0pKSB7IHJldHVybiBudWxsIH1cbiAgICBpZiAocHQuZGlzdGFuY2Uoc25hcFB0c1tpXSkgPCB0aGlzJDEuX3NuYXBUb2xlcmFuY2UpIHsgcmV0dXJuIHNuYXBQdHNbaV0gfVxuICB9XG4gIHJldHVybiBudWxsXG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLnNuYXBUbyA9IGZ1bmN0aW9uIHNuYXBUbyAoc25hcFB0cykge1xuICB2YXIgY29vcmRMaXN0ID0gbmV3IENvb3JkaW5hdGVMaXN0KHRoaXMuX3NyY1B0cyk7XG4gIHRoaXMuc25hcFZlcnRpY2VzKGNvb3JkTGlzdCwgc25hcFB0cyk7XG4gIHRoaXMuc25hcFNlZ21lbnRzKGNvb3JkTGlzdCwgc25hcFB0cyk7XG4gIHZhciBuZXdQdHMgPSBjb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKTtcbiAgcmV0dXJuIG5ld1B0c1xufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5zbmFwU2VnbWVudHMgPSBmdW5jdGlvbiBzbmFwU2VnbWVudHMgKHNyY0Nvb3Jkcywgc25hcFB0cykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChzbmFwUHRzLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbnVsbCB9XG4gIHZhciBkaXN0aW5jdFB0Q291bnQgPSBzbmFwUHRzLmxlbmd0aDtcbiAgaWYgKHNuYXBQdHNbMF0uZXF1YWxzMkQoc25hcFB0c1tzbmFwUHRzLmxlbmd0aCAtIDFdKSkgeyBkaXN0aW5jdFB0Q291bnQgPSBzbmFwUHRzLmxlbmd0aCAtIDE7IH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0aW5jdFB0Q291bnQ7IGkrKykge1xuICAgIHZhciBzbmFwUHQgPSBzbmFwUHRzW2ldO1xuICAgIHZhciBpbmRleCA9IHRoaXMkMS5maW5kU2VnbWVudEluZGV4VG9TbmFwKHNuYXBQdCwgc3JjQ29vcmRzKTtcbiAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgc3JjQ29vcmRzLmFkZChpbmRleCArIDEsIG5ldyBDb29yZGluYXRlKHNuYXBQdCksIGZhbHNlKTtcbiAgICB9XG4gIH1cbn07XG5MaW5lU3RyaW5nU25hcHBlci5wcm90b3R5cGUuZmluZFNlZ21lbnRJbmRleFRvU25hcCA9IGZ1bmN0aW9uIGZpbmRTZWdtZW50SW5kZXhUb1NuYXAgKHNuYXBQdCwgc3JjQ29vcmRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG1pbkRpc3QgPSBEb3VibGUuTUFYX1ZBTFVFO1xuICB2YXIgc25hcEluZGV4ID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3JjQ29vcmRzLnNpemUoKSAtIDE7IGkrKykge1xuICAgIHRoaXMkMS5fc2VnLnAwID0gc3JjQ29vcmRzLmdldChpKTtcbiAgICB0aGlzJDEuX3NlZy5wMSA9IHNyY0Nvb3Jkcy5nZXQoaSArIDEpO1xuICAgIGlmICh0aGlzJDEuX3NlZy5wMC5lcXVhbHMyRChzbmFwUHQpIHx8IHRoaXMkMS5fc2VnLnAxLmVxdWFsczJEKHNuYXBQdCkpIHtcbiAgICAgIGlmICh0aGlzJDEuX2FsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKSB7IGNvbnRpbnVlOyB9IGVsc2UgeyByZXR1cm4gLTEgfVxuICAgIH1cbiAgICB2YXIgZGlzdCA9IHRoaXMkMS5fc2VnLmRpc3RhbmNlKHNuYXBQdCk7XG4gICAgaWYgKGRpc3QgPCB0aGlzJDEuX3NuYXBUb2xlcmFuY2UgJiYgZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgIG1pbkRpc3QgPSBkaXN0O1xuICAgICAgc25hcEluZGV4ID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNuYXBJbmRleFxufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5zZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyA9IGZ1bmN0aW9uIHNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzIChhbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcykge1xuICB0aGlzLl9hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcyA9IGFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzO1xufTtcbkxpbmVTdHJpbmdTbmFwcGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTGluZVN0cmluZ1NuYXBwZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gTGluZVN0cmluZ1NuYXBwZXJcbn07XG5MaW5lU3RyaW5nU25hcHBlci5pc0Nsb3NlZCA9IGZ1bmN0aW9uIGlzQ2xvc2VkIChwdHMpIHtcbiAgaWYgKHB0cy5sZW5ndGggPD0gMSkgeyByZXR1cm4gZmFsc2UgfVxuICByZXR1cm4gcHRzWzBdLmVxdWFsczJEKHB0c1twdHMubGVuZ3RoIC0gMV0pXG59O1xuXG52YXIgR2VvbWV0cnlTbmFwcGVyID0gZnVuY3Rpb24gR2VvbWV0cnlTbmFwcGVyIChzcmNHZW9tKSB7XG4gIHRoaXMuX3NyY0dlb20gPSBzcmNHZW9tIHx8IG51bGw7XG59O1xuXG52YXIgc3RhdGljQWNjZXNzb3JzJDQxID0geyBTTkFQX1BSRUNJU0lPTl9GQUNUT1I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuc25hcFRvID0gZnVuY3Rpb24gc25hcFRvIChzbmFwR2VvbSwgc25hcFRvbGVyYW5jZSkge1xuICB2YXIgc25hcFB0cyA9IHRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHNuYXBHZW9tKTtcbiAgdmFyIHNuYXBUcmFucyA9IG5ldyBTbmFwVHJhbnNmb3JtZXIoc25hcFRvbGVyYW5jZSwgc25hcFB0cyk7XG4gIHJldHVybiBzbmFwVHJhbnMudHJhbnNmb3JtKHRoaXMuX3NyY0dlb20pXG59O1xuR2VvbWV0cnlTbmFwcGVyLnByb3RvdHlwZS5zbmFwVG9TZWxmID0gZnVuY3Rpb24gc25hcFRvU2VsZiAoc25hcFRvbGVyYW5jZSwgY2xlYW5SZXN1bHQpIHtcbiAgdmFyIHNuYXBQdHMgPSB0aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0aGlzLl9zcmNHZW9tKTtcbiAgdmFyIHNuYXBUcmFucyA9IG5ldyBTbmFwVHJhbnNmb3JtZXIoc25hcFRvbGVyYW5jZSwgc25hcFB0cywgdHJ1ZSk7XG4gIHZhciBzbmFwcGVkR2VvbSA9IHNuYXBUcmFucy50cmFuc2Zvcm0odGhpcy5fc3JjR2VvbSk7XG4gIHZhciByZXN1bHQgPSBzbmFwcGVkR2VvbTtcbiAgaWYgKGNsZWFuUmVzdWx0ICYmIGhhc0ludGVyZmFjZShyZXN1bHQsIFBvbHlnb25hbCkpIHtcbiAgICByZXN1bHQgPSBzbmFwcGVkR2VvbS5idWZmZXIoMCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuY29tcHV0ZVNuYXBUb2xlcmFuY2UgPSBmdW5jdGlvbiBjb21wdXRlU25hcFRvbGVyYW5jZSAocmluZ1B0cykge1xuICB2YXIgbWluU2VnTGVuID0gdGhpcy5jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGgocmluZ1B0cyk7XG4gIHZhciBzbmFwVG9sID0gbWluU2VnTGVuIC8gMTA7XG4gIHJldHVybiBzbmFwVG9sXG59O1xuR2VvbWV0cnlTbmFwcGVyLnByb3RvdHlwZS5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXMgPSBmdW5jdGlvbiBleHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXMgKGcpIHtcbiAgdmFyIHB0U2V0ID0gbmV3IFRyZWVTZXQoKTtcbiAgdmFyIHB0cyA9IGcuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICBwdFNldC5hZGQocHRzW2ldKTtcbiAgfVxuICByZXR1cm4gcHRTZXQudG9BcnJheShuZXcgQXJyYXkoMCkuZmlsbChudWxsKSlcbn07XG5HZW9tZXRyeVNuYXBwZXIucHJvdG90eXBlLmNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCA9IGZ1bmN0aW9uIGNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aCAocHRzKSB7XG4gIHZhciBtaW5TZWdMZW4gPSBEb3VibGUuTUFYX1ZBTFVFO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHB0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICB2YXIgc2VnTGVuID0gcHRzW2ldLmRpc3RhbmNlKHB0c1tpICsgMV0pO1xuICAgIGlmIChzZWdMZW4gPCBtaW5TZWdMZW4pIHsgbWluU2VnTGVuID0gc2VnTGVuOyB9XG4gIH1cbiAgcmV0dXJuIG1pblNlZ0xlblxufTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkdlb21ldHJ5U25hcHBlci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBHZW9tZXRyeVNuYXBwZXJcbn07XG5HZW9tZXRyeVNuYXBwZXIuc25hcCA9IGZ1bmN0aW9uIHNuYXAgKGcwLCBnMSwgc25hcFRvbGVyYW5jZSkge1xuICB2YXIgc25hcEdlb20gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgdmFyIHNuYXBwZXIwID0gbmV3IEdlb21ldHJ5U25hcHBlcihnMCk7XG4gIHNuYXBHZW9tWzBdID0gc25hcHBlcjAuc25hcFRvKGcxLCBzbmFwVG9sZXJhbmNlKTtcbiAgdmFyIHNuYXBwZXIxID0gbmV3IEdlb21ldHJ5U25hcHBlcihnMSk7XG4gIHNuYXBHZW9tWzFdID0gc25hcHBlcjEuc25hcFRvKHNuYXBHZW9tWzBdLCBzbmFwVG9sZXJhbmNlKTtcbiAgcmV0dXJuIHNuYXBHZW9tXG59O1xuR2VvbWV0cnlTbmFwcGVyLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHNuYXBUb2xlcmFuY2UgPSBHZW9tZXRyeVNuYXBwZXIuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UoZyk7XG4gICAgdmFyIHBtID0gZy5nZXRQcmVjaXNpb25Nb2RlbCgpO1xuICAgIGlmIChwbS5nZXRUeXBlKCkgPT09IFByZWNpc2lvbk1vZGVsLkZJWEVEKSB7XG4gICAgICB2YXIgZml4ZWRTbmFwVG9sID0gMSAvIHBtLmdldFNjYWxlKCkgKiAyIC8gMS40MTU7XG4gICAgICBpZiAoZml4ZWRTbmFwVG9sID4gc25hcFRvbGVyYW5jZSkgeyBzbmFwVG9sZXJhbmNlID0gZml4ZWRTbmFwVG9sOyB9XG4gICAgfVxuICAgIHJldHVybiBzbmFwVG9sZXJhbmNlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gICAgcmV0dXJuIE1hdGgubWluKEdlb21ldHJ5U25hcHBlci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UoZzApLCBHZW9tZXRyeVNuYXBwZXIuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKGcxKSlcbiAgfVxufTtcbkdlb21ldHJ5U25hcHBlci5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlIChnKSB7XG4gIHZhciBlbnYgPSBnLmdldEVudmVsb3BlSW50ZXJuYWwoKTtcbiAgdmFyIG1pbkRpbWVuc2lvbiA9IE1hdGgubWluKGVudi5nZXRIZWlnaHQoKSwgZW52LmdldFdpZHRoKCkpO1xuICB2YXIgc25hcFRvbCA9IG1pbkRpbWVuc2lvbiAqIEdlb21ldHJ5U25hcHBlci5TTkFQX1BSRUNJU0lPTl9GQUNUT1I7XG4gIHJldHVybiBzbmFwVG9sXG59O1xuR2VvbWV0cnlTbmFwcGVyLnNuYXBUb1NlbGYgPSBmdW5jdGlvbiBzbmFwVG9TZWxmIChnZW9tLCBzbmFwVG9sZXJhbmNlLCBjbGVhblJlc3VsdCkge1xuICB2YXIgc25hcHBlcjAgPSBuZXcgR2VvbWV0cnlTbmFwcGVyKGdlb20pO1xuICByZXR1cm4gc25hcHBlcjAuc25hcFRvU2VsZihzbmFwVG9sZXJhbmNlLCBjbGVhblJlc3VsdClcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDEuU05BUF9QUkVDSVNJT05fRkFDVE9SLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDFlLTkgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIEdlb21ldHJ5U25hcHBlciwgc3RhdGljQWNjZXNzb3JzJDQxICk7XG5cbnZhciBTbmFwVHJhbnNmb3JtZXIgPSAoZnVuY3Rpb24gKEdlb21ldHJ5VHJhbnNmb3JtZXIkJDEpIHtcbiAgZnVuY3Rpb24gU25hcFRyYW5zZm9ybWVyIChzbmFwVG9sZXJhbmNlLCBzbmFwUHRzLCBpc1NlbGZTbmFwKSB7XG4gICAgR2VvbWV0cnlUcmFuc2Zvcm1lciQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX3NuYXBUb2xlcmFuY2UgPSBzbmFwVG9sZXJhbmNlIHx8IG51bGw7XG4gICAgdGhpcy5fc25hcFB0cyA9IHNuYXBQdHMgfHwgbnVsbDtcbiAgICB0aGlzLl9pc1NlbGZTbmFwID0gKGlzU2VsZlNuYXAgIT09IHVuZGVmaW5lZCkgPyBpc1NlbGZTbmFwIDogZmFsc2U7XG4gIH1cblxuICBpZiAoIEdlb21ldHJ5VHJhbnNmb3JtZXIkJDEgKSBTbmFwVHJhbnNmb3JtZXIuX19wcm90b19fID0gR2VvbWV0cnlUcmFuc2Zvcm1lciQkMTtcbiAgU25hcFRyYW5zZm9ybWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEdlb21ldHJ5VHJhbnNmb3JtZXIkJDEgJiYgR2VvbWV0cnlUcmFuc2Zvcm1lciQkMS5wcm90b3R5cGUgKTtcbiAgU25hcFRyYW5zZm9ybWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFNuYXBUcmFuc2Zvcm1lcjtcbiAgU25hcFRyYW5zZm9ybWVyLnByb3RvdHlwZS5zbmFwTGluZSA9IGZ1bmN0aW9uIHNuYXBMaW5lIChzcmNQdHMsIHNuYXBQdHMpIHtcbiAgICB2YXIgc25hcHBlciA9IG5ldyBMaW5lU3RyaW5nU25hcHBlcihzcmNQdHMsIHRoaXMuX3NuYXBUb2xlcmFuY2UpO1xuICAgIHNuYXBwZXIuc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModGhpcy5faXNTZWxmU25hcCk7XG4gICAgcmV0dXJuIHNuYXBwZXIuc25hcFRvKHNuYXBQdHMpXG4gIH07XG4gIFNuYXBUcmFuc2Zvcm1lci5wcm90b3R5cGUudHJhbnNmb3JtQ29vcmRpbmF0ZXMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1Db29yZGluYXRlcyAoY29vcmRzLCBwYXJlbnQpIHtcbiAgICB2YXIgc3JjUHRzID0gY29vcmRzLnRvQ29vcmRpbmF0ZUFycmF5KCk7XG4gICAgdmFyIG5ld1B0cyA9IHRoaXMuc25hcExpbmUoc3JjUHRzLCB0aGlzLl9zbmFwUHRzKTtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKG5ld1B0cylcbiAgfTtcbiAgU25hcFRyYW5zZm9ybWVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgU25hcFRyYW5zZm9ybWVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gU25hcFRyYW5zZm9ybWVyXG4gIH07XG5cbiAgcmV0dXJuIFNuYXBUcmFuc2Zvcm1lcjtcbn0oR2VvbWV0cnlUcmFuc2Zvcm1lcikpO1xuXG52YXIgQ29tbW9uQml0cyA9IGZ1bmN0aW9uIENvbW1vbkJpdHMgKCkge1xuICB0aGlzLl9pc0ZpcnN0ID0gdHJ1ZTtcbiAgdGhpcy5fY29tbW9uTWFudGlzc2FCaXRzQ291bnQgPSA1MztcbiAgdGhpcy5fY29tbW9uQml0cyA9IDA7XG4gIHRoaXMuX2NvbW1vblNpZ25FeHAgPSBudWxsO1xufTtcbkNvbW1vbkJpdHMucHJvdG90eXBlLmdldENvbW1vbiA9IGZ1bmN0aW9uIGdldENvbW1vbiAoKSB7XG4gIHJldHVybiBEb3VibGUubG9uZ0JpdHNUb0RvdWJsZSh0aGlzLl9jb21tb25CaXRzKVxufTtcbkNvbW1vbkJpdHMucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gIHZhciBudW1CaXRzID0gRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHMobnVtKTtcbiAgaWYgKHRoaXMuX2lzRmlyc3QpIHtcbiAgICB0aGlzLl9jb21tb25CaXRzID0gbnVtQml0cztcbiAgICB0aGlzLl9jb21tb25TaWduRXhwID0gQ29tbW9uQml0cy5zaWduRXhwQml0cyh0aGlzLl9jb21tb25CaXRzKTtcbiAgICB0aGlzLl9pc0ZpcnN0ID0gZmFsc2U7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB2YXIgbnVtU2lnbkV4cCA9IENvbW1vbkJpdHMuc2lnbkV4cEJpdHMobnVtQml0cyk7XG4gIGlmIChudW1TaWduRXhwICE9PSB0aGlzLl9jb21tb25TaWduRXhwKSB7XG4gICAgdGhpcy5fY29tbW9uQml0cyA9IDA7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICB0aGlzLl9jb21tb25NYW50aXNzYUJpdHNDb3VudCA9IENvbW1vbkJpdHMubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0aGlzLl9jb21tb25CaXRzLCBudW1CaXRzKTtcbiAgdGhpcy5fY29tbW9uQml0cyA9IENvbW1vbkJpdHMuemVyb0xvd2VyQml0cyh0aGlzLl9jb21tb25CaXRzLCA2NCAtICgxMiArIHRoaXMuX2NvbW1vbk1hbnRpc3NhQml0c0NvdW50KSk7XG59O1xuQ29tbW9uQml0cy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGJpdHMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIHggPSBEb3VibGUubG9uZ0JpdHNUb0RvdWJsZShiaXRzKTtcbiAgICB2YXIgbnVtU3RyID0gRG91YmxlLnRvQmluYXJ5U3RyaW5nKGJpdHMpO1xuICAgIHZhciBwYWRTdHIgPSAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcgKyBudW1TdHI7XG4gICAgdmFyIGJpdFN0ciA9IHBhZFN0ci5zdWJzdHJpbmcocGFkU3RyLmxlbmd0aCAtIDY0KTtcbiAgICB2YXIgc3RyID0gYml0U3RyLnN1YnN0cmluZygwLCAxKSArICcgICcgKyBiaXRTdHIuc3Vic3RyaW5nKDEsIDEyKSArICcoZXhwKSAnICsgYml0U3RyLnN1YnN0cmluZygxMikgKyAnIFsgJyArIHggKyAnIF0nO1xuICAgIHJldHVybiBzdHJcbiAgfVxufTtcbkNvbW1vbkJpdHMucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5Db21tb25CaXRzLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvbW1vbkJpdHNcbn07XG5Db21tb25CaXRzLmdldEJpdCA9IGZ1bmN0aW9uIGdldEJpdCAoYml0cywgaSkge1xuICB2YXIgbWFzayA9IDEgPDwgaTtcbiAgcmV0dXJuIChiaXRzICYgbWFzaykgIT09IDAgPyAxIDogMFxufTtcbkNvbW1vbkJpdHMuc2lnbkV4cEJpdHMgPSBmdW5jdGlvbiBzaWduRXhwQml0cyAobnVtKSB7XG4gIHJldHVybiBudW0gPj4gNTJcbn07XG5Db21tb25CaXRzLnplcm9Mb3dlckJpdHMgPSBmdW5jdGlvbiB6ZXJvTG93ZXJCaXRzIChiaXRzLCBuQml0cykge1xuICB2YXIgaW52TWFzayA9ICgxIDw8IG5CaXRzKSAtIDE7XG4gIHZhciBtYXNrID0gfmludk1hc2s7XG4gIHZhciB6ZXJvZWQgPSBiaXRzICYgbWFzaztcbiAgcmV0dXJuIHplcm9lZFxufTtcbkNvbW1vbkJpdHMubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyA9IGZ1bmN0aW9uIG51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHMgKG51bTEsIG51bTIpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgZm9yICh2YXIgaSA9IDUyOyBpID49IDA7IGktLSkge1xuICAgIGlmIChDb21tb25CaXRzLmdldEJpdChudW0xLCBpKSAhPT0gQ29tbW9uQml0cy5nZXRCaXQobnVtMiwgaSkpIHsgcmV0dXJuIGNvdW50IH1cbiAgICBjb3VudCsrO1xuICB9XG4gIHJldHVybiA1MlxufTtcblxudmFyIENvbW1vbkJpdHNSZW1vdmVyID0gZnVuY3Rpb24gQ29tbW9uQml0c1JlbW92ZXIgKCkge1xuICB0aGlzLl9jb21tb25Db29yZCA9IG51bGw7XG4gIHRoaXMuX2NjRmlsdGVyID0gbmV3IENvbW1vbkNvb3JkaW5hdGVGaWx0ZXIoKTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDIgPSB7IENvbW1vbkNvb3JkaW5hdGVGaWx0ZXI6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sVHJhbnNsYXRlcjogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLmFkZENvbW1vbkJpdHMgPSBmdW5jdGlvbiBhZGRDb21tb25CaXRzIChnZW9tKSB7XG4gIHZhciB0cmFucyA9IG5ldyBUcmFuc2xhdGVyKHRoaXMuX2NvbW1vbkNvb3JkKTtcbiAgZ2VvbS5hcHBseSh0cmFucyk7XG4gIGdlb20uZ2VvbWV0cnlDaGFuZ2VkKCk7XG59O1xuQ29tbW9uQml0c1JlbW92ZXIucHJvdG90eXBlLnJlbW92ZUNvbW1vbkJpdHMgPSBmdW5jdGlvbiByZW1vdmVDb21tb25CaXRzIChnZW9tKSB7XG4gIGlmICh0aGlzLl9jb21tb25Db29yZC54ID09PSAwLjAgJiYgdGhpcy5fY29tbW9uQ29vcmQueSA9PT0gMC4wKSB7IHJldHVybiBnZW9tIH1cbiAgdmFyIGludkNvb3JkID0gbmV3IENvb3JkaW5hdGUodGhpcy5fY29tbW9uQ29vcmQpO1xuICBpbnZDb29yZC54ID0gLWludkNvb3JkLng7XG4gIGludkNvb3JkLnkgPSAtaW52Q29vcmQueTtcbiAgdmFyIHRyYW5zID0gbmV3IFRyYW5zbGF0ZXIoaW52Q29vcmQpO1xuICBnZW9tLmFwcGx5KHRyYW5zKTtcbiAgZ2VvbS5nZW9tZXRyeUNoYW5nZWQoKTtcbiAgcmV0dXJuIGdlb21cbn07XG5Db21tb25CaXRzUmVtb3Zlci5wcm90b3R5cGUuZ2V0Q29tbW9uQ29vcmRpbmF0ZSA9IGZ1bmN0aW9uIGdldENvbW1vbkNvb3JkaW5hdGUgKCkge1xuICByZXR1cm4gdGhpcy5fY29tbW9uQ29vcmRcbn07XG5Db21tb25CaXRzUmVtb3Zlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChnZW9tKSB7XG4gIGdlb20uYXBwbHkodGhpcy5fY2NGaWx0ZXIpO1xuICB0aGlzLl9jb21tb25Db29yZCA9IHRoaXMuX2NjRmlsdGVyLmdldENvbW1vbkNvb3JkaW5hdGUoKTtcbn07XG5Db21tb25CaXRzUmVtb3Zlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkNvbW1vbkJpdHNSZW1vdmVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIENvbW1vbkJpdHNSZW1vdmVyXG59O1xuc3RhdGljQWNjZXNzb3JzJDQyLkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gQ29tbW9uQ29vcmRpbmF0ZUZpbHRlciB9O1xuc3RhdGljQWNjZXNzb3JzJDQyLlRyYW5zbGF0ZXIuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gVHJhbnNsYXRlciB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggQ29tbW9uQml0c1JlbW92ZXIsIHN0YXRpY0FjY2Vzc29ycyQ0MiApO1xuXG52YXIgQ29tbW9uQ29vcmRpbmF0ZUZpbHRlciA9IGZ1bmN0aW9uIENvbW1vbkNvb3JkaW5hdGVGaWx0ZXIgKCkge1xuICB0aGlzLl9jb21tb25CaXRzWCA9IG5ldyBDb21tb25CaXRzKCk7XG4gIHRoaXMuX2NvbW1vbkJpdHNZID0gbmV3IENvbW1vbkJpdHMoKTtcbn07XG5Db21tb25Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5maWx0ZXIgPSBmdW5jdGlvbiBmaWx0ZXIgKGNvb3JkKSB7XG4gIHRoaXMuX2NvbW1vbkJpdHNYLmFkZChjb29yZC54KTtcbiAgdGhpcy5fY29tbW9uQml0c1kuYWRkKGNvb3JkLnkpO1xufTtcbkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXIucHJvdG90eXBlLmdldENvbW1vbkNvb3JkaW5hdGUgPSBmdW5jdGlvbiBnZXRDb21tb25Db29yZGluYXRlICgpIHtcbiAgcmV0dXJuIG5ldyBDb29yZGluYXRlKHRoaXMuX2NvbW1vbkJpdHNYLmdldENvbW1vbigpLCB0aGlzLl9jb21tb25CaXRzWS5nZXRDb21tb24oKSlcbn07XG5Db21tb25Db29yZGluYXRlRmlsdGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtDb29yZGluYXRlRmlsdGVyXVxufTtcbkNvbW1vbkNvb3JkaW5hdGVGaWx0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gQ29tbW9uQ29vcmRpbmF0ZUZpbHRlclxufTtcblxudmFyIFRyYW5zbGF0ZXIgPSBmdW5jdGlvbiBUcmFuc2xhdGVyICgpIHtcbiAgdGhpcy50cmFucyA9IG51bGw7XG4gIHZhciB0cmFucyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy50cmFucyA9IHRyYW5zO1xufTtcblRyYW5zbGF0ZXIucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIGZpbHRlciAoc2VxLCBpKSB7XG4gIHZhciB4cCA9IHNlcS5nZXRPcmRpbmF0ZShpLCAwKSArIHRoaXMudHJhbnMueDtcbiAgdmFyIHlwID0gc2VxLmdldE9yZGluYXRlKGksIDEpICsgdGhpcy50cmFucy55O1xuICBzZXEuc2V0T3JkaW5hdGUoaSwgMCwgeHApO1xuICBzZXEuc2V0T3JkaW5hdGUoaSwgMSwgeXApO1xufTtcblRyYW5zbGF0ZXIucHJvdG90eXBlLmlzRG9uZSA9IGZ1bmN0aW9uIGlzRG9uZSAoKSB7XG4gIHJldHVybiBmYWxzZVxufTtcblRyYW5zbGF0ZXIucHJvdG90eXBlLmlzR2VvbWV0cnlDaGFuZ2VkID0gZnVuY3Rpb24gaXNHZW9tZXRyeUNoYW5nZWQgKCkge1xuICByZXR1cm4gdHJ1ZVxufTtcblRyYW5zbGF0ZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0Nvb3JkaW5hdGVTZXF1ZW5jZUZpbHRlcl1cbn07XG5UcmFuc2xhdGVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFRyYW5zbGF0ZXJcbn07XG5cbnZhciBTbmFwT3ZlcmxheU9wID0gZnVuY3Rpb24gU25hcE92ZXJsYXlPcCAoZzEsIGcyKSB7XG4gIHRoaXMuX2dlb20gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgdGhpcy5fc25hcFRvbGVyYW5jZSA9IG51bGw7XG4gIHRoaXMuX2NiciA9IG51bGw7XG4gIHRoaXMuX2dlb21bMF0gPSBnMTtcbiAgdGhpcy5fZ2VvbVsxXSA9IGcyO1xuICB0aGlzLmNvbXB1dGVTbmFwVG9sZXJhbmNlKCk7XG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuc2VsZlNuYXAgPSBmdW5jdGlvbiBzZWxmU25hcCAoZ2VvbSkge1xuICB2YXIgc25hcHBlcjAgPSBuZXcgR2VvbWV0cnlTbmFwcGVyKGdlb20pO1xuICB2YXIgc25hcEdlb20gPSBzbmFwcGVyMC5zbmFwVG8oZ2VvbSwgdGhpcy5fc25hcFRvbGVyYW5jZSk7XG4gIHJldHVybiBzbmFwR2VvbVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLnJlbW92ZUNvbW1vbkJpdHMgPSBmdW5jdGlvbiByZW1vdmVDb21tb25CaXRzIChnZW9tKSB7XG4gIHRoaXMuX2NiciA9IG5ldyBDb21tb25CaXRzUmVtb3ZlcigpO1xuICB0aGlzLl9jYnIuYWRkKGdlb21bMF0pO1xuICB0aGlzLl9jYnIuYWRkKGdlb21bMV0pO1xuICB2YXIgcmVtR2VvbSA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICByZW1HZW9tWzBdID0gdGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHMoZ2VvbVswXS5jb3B5KCkpO1xuICByZW1HZW9tWzFdID0gdGhpcy5fY2JyLnJlbW92ZUNvbW1vbkJpdHMoZ2VvbVsxXS5jb3B5KCkpO1xuICByZXR1cm4gcmVtR2VvbVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLnByZXBhcmVSZXN1bHQgPSBmdW5jdGlvbiBwcmVwYXJlUmVzdWx0IChnZW9tKSB7XG4gIHRoaXMuX2Nici5hZGRDb21tb25CaXRzKGdlb20pO1xuICByZXR1cm4gZ2VvbVxufTtcblNuYXBPdmVybGF5T3AucHJvdG90eXBlLmdldFJlc3VsdEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0UmVzdWx0R2VvbWV0cnkgKG9wQ29kZSkge1xuICB2YXIgcHJlcEdlb20gPSB0aGlzLnNuYXAodGhpcy5fZ2VvbSk7XG4gIHZhciByZXN1bHQgPSBPdmVybGF5T3Aub3ZlcmxheU9wKHByZXBHZW9tWzBdLCBwcmVwR2VvbVsxXSwgb3BDb2RlKTtcbiAgcmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChyZXN1bHQpXG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuY2hlY2tWYWxpZCA9IGZ1bmN0aW9uIGNoZWNrVmFsaWQgKGcpIHtcbiAgaWYgKCFnLmlzVmFsaWQoKSkge1xuICAgIFN5c3RlbS5vdXQucHJpbnRsbignU25hcHBlZCBnZW9tZXRyeSBpcyBpbnZhbGlkJyk7XG4gIH1cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5jb21wdXRlU25hcFRvbGVyYW5jZSA9IGZ1bmN0aW9uIGNvbXB1dGVTbmFwVG9sZXJhbmNlICgpIHtcbiAgdGhpcy5fc25hcFRvbGVyYW5jZSA9IEdlb21ldHJ5U25hcHBlci5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodGhpcy5fZ2VvbVswXSwgdGhpcy5fZ2VvbVsxXSk7XG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuc25hcCA9IGZ1bmN0aW9uIHNuYXAgKGdlb20pIHtcbiAgdmFyIHJlbUdlb20gPSB0aGlzLnJlbW92ZUNvbW1vbkJpdHMoZ2VvbSk7XG4gIHZhciBzbmFwR2VvbSA9IEdlb21ldHJ5U25hcHBlci5zbmFwKHJlbUdlb21bMF0sIHJlbUdlb21bMV0sIHRoaXMuX3NuYXBUb2xlcmFuY2UpO1xuICByZXR1cm4gc25hcEdlb21cbn07XG5TbmFwT3ZlcmxheU9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU25hcE92ZXJsYXlPcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTbmFwT3ZlcmxheU9wXG59O1xuU25hcE92ZXJsYXlPcC5vdmVybGF5T3AgPSBmdW5jdGlvbiBvdmVybGF5T3AgKGcwLCBnMSwgb3BDb2RlKSB7XG4gIHZhciBvcCA9IG5ldyBTbmFwT3ZlcmxheU9wKGcwLCBnMSk7XG4gIHJldHVybiBvcC5nZXRSZXN1bHRHZW9tZXRyeShvcENvZGUpXG59O1xuU25hcE92ZXJsYXlPcC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLlVOSU9OKVxufTtcblNuYXBPdmVybGF5T3AuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaW50ZXJzZWN0aW9uIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLklOVEVSU0VDVElPTilcbn07XG5TbmFwT3ZlcmxheU9wLnN5bURpZmZlcmVuY2UgPSBmdW5jdGlvbiBzeW1EaWZmZXJlbmNlIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0UpXG59O1xuU25hcE92ZXJsYXlPcC5kaWZmZXJlbmNlID0gZnVuY3Rpb24gZGlmZmVyZW5jZSAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5ESUZGRVJFTkNFKVxufTtcblxudmFyIFNuYXBJZk5lZWRlZE92ZXJsYXlPcCA9IGZ1bmN0aW9uIFNuYXBJZk5lZWRlZE92ZXJsYXlPcCAoZzEsIGcyKSB7XG4gIHRoaXMuX2dlb20gPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgdGhpcy5fZ2VvbVswXSA9IGcxO1xuICB0aGlzLl9nZW9tWzFdID0gZzI7XG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRSZXN1bHRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldFJlc3VsdEdlb21ldHJ5IChvcENvZGUpIHtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIHZhciBpc1N1Y2Nlc3MgPSBmYWxzZTtcbiAgdmFyIHNhdmVkRXhjZXB0aW9uID0gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBPdmVybGF5T3Aub3ZlcmxheU9wKHRoaXMuX2dlb21bMF0sIHRoaXMuX2dlb21bMV0sIG9wQ29kZSk7XG4gICAgdmFyIGlzVmFsaWQgPSB0cnVlO1xuICAgIGlmIChpc1ZhbGlkKSB7IGlzU3VjY2VzcyA9IHRydWU7IH1cbiAgfSBjYXRjaCAoZXgpIHtcbiAgICBpZiAoZXggaW5zdGFuY2VvZiBSdW50aW1lRXhjZXB0aW9uKSB7XG4gICAgICBzYXZlZEV4Y2VwdGlvbiA9IGV4O1xuICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgfSBmaW5hbGx5IHt9XG4gIGlmICghaXNTdWNjZXNzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlc3VsdCA9IFNuYXBPdmVybGF5T3Aub3ZlcmxheU9wKHRoaXMuX2dlb21bMF0sIHRoaXMuX2dlb21bMV0sIG9wQ29kZSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChleCBpbnN0YW5jZW9mIFJ1bnRpbWVFeGNlcHRpb24pIHtcbiAgICAgICAgdGhyb3cgc2F2ZWRFeGNlcHRpb25cbiAgICAgIH0gZWxzZSB7IHRocm93IGV4IH1cbiAgICB9IGZpbmFsbHkge31cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcFxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AgPSBmdW5jdGlvbiBvdmVybGF5T3AgKGcwLCBnMSwgb3BDb2RlKSB7XG4gIHZhciBvcCA9IG5ldyBTbmFwSWZOZWVkZWRPdmVybGF5T3AoZzAsIGcxKTtcbiAgcmV0dXJuIG9wLmdldFJlc3VsdEdlb21ldHJ5KG9wQ29kZSlcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3AudW5pb24gPSBmdW5jdGlvbiB1bmlvbiAoZzAsIGcxKSB7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcwLCBnMSwgT3ZlcmxheU9wLlVOSU9OKVxufTtcblNuYXBJZk5lZWRlZE92ZXJsYXlPcC5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24gKGcwLCBnMSkge1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5JTlRFUlNFQ1RJT04pXG59O1xuU25hcElmTmVlZGVkT3ZlcmxheU9wLnN5bURpZmZlcmVuY2UgPSBmdW5jdGlvbiBzeW1EaWZmZXJlbmNlIChnMCwgZzEpIHtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZzAsIGcxLCBPdmVybGF5T3AuU1lNRElGRkVSRU5DRSlcbn07XG5TbmFwSWZOZWVkZWRPdmVybGF5T3AuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIGRpZmZlcmVuY2UgKGcwLCBnMSkge1xuICByZXR1cm4gU25hcElmTmVlZGVkT3ZlcmxheU9wLm92ZXJsYXlPcChnMCwgZzEsIE92ZXJsYXlPcC5ESUZGRVJFTkNFKVxufTtcblxudmFyIE1vbm90b25lQ2hhaW4kMiA9IGZ1bmN0aW9uIE1vbm90b25lQ2hhaW4gKCkge1xuICB0aGlzLm1jZSA9IG51bGw7XG4gIHRoaXMuY2hhaW5JbmRleCA9IG51bGw7XG4gIHZhciBtY2UgPSBhcmd1bWVudHNbMF07XG4gIHZhciBjaGFpbkluZGV4ID0gYXJndW1lbnRzWzFdO1xuICB0aGlzLm1jZSA9IG1jZTtcbiAgdGhpcy5jaGFpbkluZGV4ID0gY2hhaW5JbmRleDtcbn07XG5Nb25vdG9uZUNoYWluJDIucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdGlvbnMgKG1jLCBzaSkge1xuICB0aGlzLm1jZS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuY2hhaW5JbmRleCwgbWMubWNlLCBtYy5jaGFpbkluZGV4LCBzaSk7XG59O1xuTW9ub3RvbmVDaGFpbiQyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuTW9ub3RvbmVDaGFpbiQyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE1vbm90b25lQ2hhaW4kMlxufTtcblxudmFyIFN3ZWVwTGluZUV2ZW50ID0gZnVuY3Rpb24gU3dlZXBMaW5lRXZlbnQgKCkge1xuICB0aGlzLl9sYWJlbCA9IG51bGw7XG4gIHRoaXMuX3hWYWx1ZSA9IG51bGw7XG4gIHRoaXMuX2V2ZW50VHlwZSA9IG51bGw7XG4gIHRoaXMuX2luc2VydEV2ZW50ID0gbnVsbDtcbiAgdGhpcy5fZGVsZXRlRXZlbnRJbmRleCA9IG51bGw7XG4gIHRoaXMuX29iaiA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIHggPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGluc2VydEV2ZW50ID0gYXJndW1lbnRzWzFdO1xuICAgIHRoaXMuX2V2ZW50VHlwZSA9IFN3ZWVwTGluZUV2ZW50LkRFTEVURTtcbiAgICB0aGlzLl94VmFsdWUgPSB4O1xuICAgIHRoaXMuX2luc2VydEV2ZW50ID0gaW5zZXJ0RXZlbnQ7XG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgIHZhciBsYWJlbCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgeCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBvYmogPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5fZXZlbnRUeXBlID0gU3dlZXBMaW5lRXZlbnQuSU5TRVJUO1xuICAgIHRoaXMuX2xhYmVsID0gbGFiZWw7XG4gICAgdGhpcy5feFZhbHVlID0geCQxO1xuICAgIHRoaXMuX29iaiA9IG9iajtcbiAgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0MyA9IHsgSU5TRVJUOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9LERFTEVURTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmlzRGVsZXRlID0gZnVuY3Rpb24gaXNEZWxldGUgKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRUeXBlID09PSBTd2VlcExpbmVFdmVudC5ERUxFVEVcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuc2V0RGVsZXRlRXZlbnRJbmRleCA9IGZ1bmN0aW9uIHNldERlbGV0ZUV2ZW50SW5kZXggKGRlbGV0ZUV2ZW50SW5kZXgpIHtcbiAgdGhpcy5fZGVsZXRlRXZlbnRJbmRleCA9IGRlbGV0ZUV2ZW50SW5kZXg7XG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmdldE9iamVjdCA9IGZ1bmN0aW9uIGdldE9iamVjdCAoKSB7XG4gIHJldHVybiB0aGlzLl9vYmpcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuY29tcGFyZVRvID0gZnVuY3Rpb24gY29tcGFyZVRvIChvKSB7XG4gIHZhciBwZSA9IG87XG4gIGlmICh0aGlzLl94VmFsdWUgPCBwZS5feFZhbHVlKSB7IHJldHVybiAtMSB9XG4gIGlmICh0aGlzLl94VmFsdWUgPiBwZS5feFZhbHVlKSB7IHJldHVybiAxIH1cbiAgaWYgKHRoaXMuX2V2ZW50VHlwZSA8IHBlLl9ldmVudFR5cGUpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKHRoaXMuX2V2ZW50VHlwZSA+IHBlLl9ldmVudFR5cGUpIHsgcmV0dXJuIDEgfVxuICByZXR1cm4gMFxufTtcblN3ZWVwTGluZUV2ZW50LnByb3RvdHlwZS5nZXRJbnNlcnRFdmVudCA9IGZ1bmN0aW9uIGdldEluc2VydEV2ZW50ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2luc2VydEV2ZW50XG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmlzSW5zZXJ0ID0gZnVuY3Rpb24gaXNJbnNlcnQgKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRUeXBlID09PSBTd2VlcExpbmVFdmVudC5JTlNFUlRcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuaXNTYW1lTGFiZWwgPSBmdW5jdGlvbiBpc1NhbWVMYWJlbCAoZXYpIHtcbiAgaWYgKHRoaXMuX2xhYmVsID09PSBudWxsKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0aGlzLl9sYWJlbCA9PT0gZXYuX2xhYmVsXG59O1xuU3dlZXBMaW5lRXZlbnQucHJvdG90eXBlLmdldERlbGV0ZUV2ZW50SW5kZXggPSBmdW5jdGlvbiBnZXREZWxldGVFdmVudEluZGV4ICgpIHtcbiAgcmV0dXJuIHRoaXMuX2RlbGV0ZUV2ZW50SW5kZXhcbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYWJsZV1cbn07XG5Td2VlcExpbmVFdmVudC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTd2VlcExpbmVFdmVudFxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0My5JTlNFUlQuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMSB9O1xuc3RhdGljQWNjZXNzb3JzJDQzLkRFTEVURS5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAyIH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBTd2VlcExpbmVFdmVudCwgc3RhdGljQWNjZXNzb3JzJDQzICk7XG5cbnZhciBFZGdlU2V0SW50ZXJzZWN0b3IgPSBmdW5jdGlvbiBFZGdlU2V0SW50ZXJzZWN0b3IgKCkge307XG5cbkVkZ2VTZXRJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkVkZ2VTZXRJbnRlcnNlY3Rvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBFZGdlU2V0SW50ZXJzZWN0b3Jcbn07XG5cbnZhciBTZWdtZW50SW50ZXJzZWN0b3IkMiA9IGZ1bmN0aW9uIFNlZ21lbnRJbnRlcnNlY3RvciAoKSB7XG4gIHRoaXMuX2hhc0ludGVyc2VjdGlvbiA9IGZhbHNlO1xuICB0aGlzLl9oYXNQcm9wZXIgPSBmYWxzZTtcbiAgdGhpcy5faGFzUHJvcGVySW50ZXJpb3IgPSBmYWxzZTtcbiAgdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnQgPSBudWxsO1xuICB0aGlzLl9saSA9IG51bGw7XG4gIHRoaXMuX2luY2x1ZGVQcm9wZXIgPSBudWxsO1xuICB0aGlzLl9yZWNvcmRJc29sYXRlZCA9IG51bGw7XG4gIHRoaXMuX2lzU2VsZkludGVyc2VjdGlvbiA9IG51bGw7XG4gIHRoaXMuX251bUludGVyc2VjdGlvbnMgPSAwO1xuICB0aGlzLm51bVRlc3RzID0gMDtcbiAgdGhpcy5fYmR5Tm9kZXMgPSBudWxsO1xuICB0aGlzLl9pc0RvbmUgPSBmYWxzZTtcbiAgdGhpcy5faXNEb25lV2hlblByb3BlckludCA9IGZhbHNlO1xuICB2YXIgbGkgPSBhcmd1bWVudHNbMF07XG4gIHZhciBpbmNsdWRlUHJvcGVyID0gYXJndW1lbnRzWzFdO1xuICB2YXIgcmVjb3JkSXNvbGF0ZWQgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuX2xpID0gbGk7XG4gIHRoaXMuX2luY2x1ZGVQcm9wZXIgPSBpbmNsdWRlUHJvcGVyO1xuICB0aGlzLl9yZWNvcmRJc29sYXRlZCA9IHJlY29yZElzb2xhdGVkO1xufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5pc1RyaXZpYWxJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBpc1RyaXZpYWxJbnRlcnNlY3Rpb24gKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpIHtcbiAgaWYgKGUwID09PSBlMSkge1xuICAgIGlmICh0aGlzLl9saS5nZXRJbnRlcnNlY3Rpb25OdW0oKSA9PT0gMSkge1xuICAgICAgaWYgKFNlZ21lbnRJbnRlcnNlY3RvciQyLmlzQWRqYWNlbnRTZWdtZW50cyhzZWdJbmRleDAsIHNlZ0luZGV4MSkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgaWYgKGUwLmlzQ2xvc2VkKCkpIHtcbiAgICAgICAgdmFyIG1heFNlZ0luZGV4ID0gZTAuZ2V0TnVtUG9pbnRzKCkgLSAxO1xuICAgICAgICBpZiAoKHNlZ0luZGV4MCA9PT0gMCAmJiBzZWdJbmRleDEgPT09IG1heFNlZ0luZGV4KSB8fFxuICAgICAgICAgICAgKHNlZ0luZGV4MSA9PT0gMCAmJiBzZWdJbmRleDAgPT09IG1heFNlZ0luZGV4KSkge1xuICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmdldFByb3BlckludGVyc2VjdGlvblBvaW50ID0gZnVuY3Rpb24gZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQgKCkge1xuICByZXR1cm4gdGhpcy5fcHJvcGVySW50ZXJzZWN0aW9uUG9pbnRcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuc2V0SXNEb25lSWZQcm9wZXJJbnQgPSBmdW5jdGlvbiBzZXRJc0RvbmVJZlByb3BlckludCAoaXNEb25lV2hlblByb3BlckludCkge1xuICB0aGlzLl9pc0RvbmVXaGVuUHJvcGVySW50ID0gaXNEb25lV2hlblByb3BlckludDtcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaGFzUHJvcGVySW50ZXJpb3JJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiBoYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvclxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCA9IGZ1bmN0aW9uIGlzQm91bmRhcnlQb2ludEludGVybmFsIChsaSwgYmR5Tm9kZXMpIHtcbiAgZm9yICh2YXIgaSA9IGJkeU5vZGVzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBub2RlID0gaS5uZXh0KCk7XG4gICAgdmFyIHB0ID0gbm9kZS5nZXRDb29yZGluYXRlKCk7XG4gICAgaWYgKGxpLmlzSW50ZXJzZWN0aW9uKHB0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmhhc1Byb3BlckludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIGhhc1Byb3BlckludGVyc2VjdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9oYXNQcm9wZXJcbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaGFzSW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gaGFzSW50ZXJzZWN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvblxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5pc0RvbmUgPSBmdW5jdGlvbiBpc0RvbmUgKCkge1xuICByZXR1cm4gdGhpcy5faXNEb25lXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIucHJvdG90eXBlLmlzQm91bmRhcnlQb2ludCA9IGZ1bmN0aW9uIGlzQm91bmRhcnlQb2ludCAobGksIGJkeU5vZGVzKSB7XG4gIGlmIChiZHlOb2RlcyA9PT0gbnVsbCkgeyByZXR1cm4gZmFsc2UgfVxuICBpZiAodGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbChsaSwgYmR5Tm9kZXNbMF0pKSB7IHJldHVybiB0cnVlIH1cbiAgaWYgKHRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwobGksIGJkeU5vZGVzWzFdKSkgeyByZXR1cm4gdHJ1ZSB9XG4gIHJldHVybiBmYWxzZVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5zZXRCb3VuZGFyeU5vZGVzID0gZnVuY3Rpb24gc2V0Qm91bmRhcnlOb2RlcyAoYmR5Tm9kZXMwLCBiZHlOb2RlczEpIHtcbiAgdGhpcy5fYmR5Tm9kZXMgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgdGhpcy5fYmR5Tm9kZXNbMF0gPSBiZHlOb2RlczA7XG4gIHRoaXMuX2JkeU5vZGVzWzFdID0gYmR5Tm9kZXMxO1xufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5hZGRJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gYWRkSW50ZXJzZWN0aW9ucyAoZTAsIHNlZ0luZGV4MCwgZTEsIHNlZ0luZGV4MSkge1xuICBpZiAoZTAgPT09IGUxICYmIHNlZ0luZGV4MCA9PT0gc2VnSW5kZXgxKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5udW1UZXN0cysrO1xuICB2YXIgcDAwID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDBdO1xuICB2YXIgcDAxID0gZTAuZ2V0Q29vcmRpbmF0ZXMoKVtzZWdJbmRleDAgKyAxXTtcbiAgdmFyIHAxMCA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxXTtcbiAgdmFyIHAxMSA9IGUxLmdldENvb3JkaW5hdGVzKClbc2VnSW5kZXgxICsgMV07XG4gIHRoaXMuX2xpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocDAwLCBwMDEsIHAxMCwgcDExKTtcbiAgaWYgKHRoaXMuX2xpLmhhc0ludGVyc2VjdGlvbigpKSB7XG4gICAgaWYgKHRoaXMuX3JlY29yZElzb2xhdGVkKSB7XG4gICAgICBlMC5zZXRJc29sYXRlZChmYWxzZSk7XG4gICAgICBlMS5zZXRJc29sYXRlZChmYWxzZSk7XG4gICAgfVxuICAgIHRoaXMuX251bUludGVyc2VjdGlvbnMrKztcbiAgICBpZiAoIXRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKGUwLCBzZWdJbmRleDAsIGUxLCBzZWdJbmRleDEpKSB7XG4gICAgICB0aGlzLl9oYXNJbnRlcnNlY3Rpb24gPSB0cnVlO1xuICAgICAgaWYgKHRoaXMuX2luY2x1ZGVQcm9wZXIgfHwgIXRoaXMuX2xpLmlzUHJvcGVyKCkpIHtcbiAgICAgICAgZTAuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSwgc2VnSW5kZXgwLCAwKTtcbiAgICAgICAgZTEuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLl9saSwgc2VnSW5kZXgxLCAxKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9saS5pc1Byb3BlcigpKSB7XG4gICAgICAgIHRoaXMuX3Byb3BlckludGVyc2VjdGlvblBvaW50ID0gdGhpcy5fbGkuZ2V0SW50ZXJzZWN0aW9uKDApLmNvcHkoKTtcbiAgICAgICAgdGhpcy5faGFzUHJvcGVyID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2lzRG9uZVdoZW5Qcm9wZXJJbnQpIHtcbiAgICAgICAgICB0aGlzLl9pc0RvbmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc0JvdW5kYXJ5UG9pbnQodGhpcy5fbGksIHRoaXMuX2JkeU5vZGVzKSkgeyB0aGlzLl9oYXNQcm9wZXJJbnRlcmlvciA9IHRydWU7IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5TZWdtZW50SW50ZXJzZWN0b3IkMi5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcblNlZ21lbnRJbnRlcnNlY3RvciQyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNlZ21lbnRJbnRlcnNlY3RvciQyXG59O1xuU2VnbWVudEludGVyc2VjdG9yJDIuaXNBZGphY2VudFNlZ21lbnRzID0gZnVuY3Rpb24gaXNBZGphY2VudFNlZ21lbnRzIChpMSwgaTIpIHtcbiAgcmV0dXJuIE1hdGguYWJzKGkxIC0gaTIpID09PSAxXG59O1xuXG52YXIgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3RvciA9IChmdW5jdGlvbiAoRWRnZVNldEludGVyc2VjdG9yJCQxKSB7XG4gIGZ1bmN0aW9uIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IgKCkge1xuICAgIEVkZ2VTZXRJbnRlcnNlY3RvciQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuZXZlbnRzID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHRoaXMubk92ZXJsYXBzID0gbnVsbDtcbiAgfVxuXG4gIGlmICggRWRnZVNldEludGVyc2VjdG9yJCQxICkgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5fX3Byb3RvX18gPSBFZGdlU2V0SW50ZXJzZWN0b3IkJDE7XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggRWRnZVNldEludGVyc2VjdG9yJCQxICYmIEVkZ2VTZXRJbnRlcnNlY3RvciQkMS5wcm90b3R5cGUgKTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yO1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5wcmVwYXJlRXZlbnRzID0gZnVuY3Rpb24gcHJlcGFyZUV2ZW50cyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBDb2xsZWN0aW9ucy5zb3J0KHRoaXMuZXZlbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZXZlbnRzLnNpemUoKTsgaSsrKSB7XG4gICAgICB2YXIgZXYgPSB0aGlzJDEuZXZlbnRzLmdldChpKTtcbiAgICAgIGlmIChldi5pc0RlbGV0ZSgpKSB7XG4gICAgICAgIGV2LmdldEluc2VydEV2ZW50KCkuc2V0RGVsZXRlRXZlbnRJbmRleChpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmNvbXB1dGVJbnRlcnNlY3Rpb25zID0gZnVuY3Rpb24gY29tcHV0ZUludGVyc2VjdGlvbnMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBzaSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHRoaXMubk92ZXJsYXBzID0gMDtcbiAgICAgIHRoaXMucHJlcGFyZUV2ZW50cygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmV2ZW50cy5zaXplKCk7IGkrKykge1xuICAgICAgICB2YXIgZXYgPSB0aGlzJDEuZXZlbnRzLmdldChpKTtcbiAgICAgICAgaWYgKGV2LmlzSW5zZXJ0KCkpIHtcbiAgICAgICAgICB0aGlzJDEucHJvY2Vzc092ZXJsYXBzKGksIGV2LmdldERlbGV0ZUV2ZW50SW5kZXgoKSwgZXYsIHNpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2kuaXNEb25lKCkpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBpZiAoYXJndW1lbnRzWzJdIGluc3RhbmNlb2YgU2VnbWVudEludGVyc2VjdG9yJDIgJiYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIExpc3QpICYmIGhhc0ludGVyZmFjZShhcmd1bWVudHNbMV0sIExpc3QpKSkge1xuICAgICAgICB2YXIgZWRnZXMwID0gYXJndW1lbnRzWzBdO1xuICAgICAgICB2YXIgZWRnZXMxID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgc2kkMSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgdGhpcy5hZGRFZGdlcyhlZGdlczAsIGVkZ2VzMCk7XG4gICAgICAgIHRoaXMuYWRkRWRnZXMoZWRnZXMxLCBlZGdlczEpO1xuICAgICAgICB0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHNpJDEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXJndW1lbnRzWzJdID09PSAnYm9vbGVhbicgJiYgKGhhc0ludGVyZmFjZShhcmd1bWVudHNbMF0sIExpc3QpICYmIGFyZ3VtZW50c1sxXSBpbnN0YW5jZW9mIFNlZ21lbnRJbnRlcnNlY3RvciQyKSkge1xuICAgICAgICB2YXIgZWRnZXMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIHZhciBzaSQyID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB2YXIgdGVzdEFsbFNlZ21lbnRzID0gYXJndW1lbnRzWzJdO1xuICAgICAgICBpZiAodGVzdEFsbFNlZ21lbnRzKSB7IHRoaXMuYWRkRWRnZXMoZWRnZXMsIG51bGwpOyB9IGVsc2UgeyB0aGlzLmFkZEVkZ2VzKGVkZ2VzKTsgfVxuICAgICAgICB0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHNpJDIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuYWRkRWRnZSA9IGZ1bmN0aW9uIGFkZEVkZ2UgKGVkZ2UsIGVkZ2VTZXQpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBtY2UgPSBlZGdlLmdldE1vbm90b25lQ2hhaW5FZGdlKCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBtY2UuZ2V0U3RhcnRJbmRleGVzKCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGFydEluZGV4Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIG1jID0gbmV3IE1vbm90b25lQ2hhaW4kMihtY2UsIGkpO1xuICAgICAgdmFyIGluc2VydEV2ZW50ID0gbmV3IFN3ZWVwTGluZUV2ZW50KGVkZ2VTZXQsIG1jZS5nZXRNaW5YKGkpLCBtYyk7XG4gICAgICB0aGlzJDEuZXZlbnRzLmFkZChpbnNlcnRFdmVudCk7XG4gICAgICB0aGlzJDEuZXZlbnRzLmFkZChuZXcgU3dlZXBMaW5lRXZlbnQobWNlLmdldE1heFgoaSksIGluc2VydEV2ZW50KSk7XG4gICAgfVxuICB9O1xuICBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yLnByb3RvdHlwZS5wcm9jZXNzT3ZlcmxhcHMgPSBmdW5jdGlvbiBwcm9jZXNzT3ZlcmxhcHMgKHN0YXJ0LCBlbmQsIGV2MCwgc2kpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBtYzAgPSBldjAuZ2V0T2JqZWN0KCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHZhciBldjEgPSB0aGlzJDEuZXZlbnRzLmdldChpKTtcbiAgICAgIGlmIChldjEuaXNJbnNlcnQoKSkge1xuICAgICAgICB2YXIgbWMxID0gZXYxLmdldE9iamVjdCgpO1xuICAgICAgICBpZiAoIWV2MC5pc1NhbWVMYWJlbChldjEpKSB7XG4gICAgICAgICAgbWMwLmNvbXB1dGVJbnRlcnNlY3Rpb25zKG1jMSwgc2kpO1xuICAgICAgICAgIHRoaXMkMS5uT3ZlcmxhcHMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuYWRkRWRnZXMgPSBmdW5jdGlvbiBhZGRFZGdlcyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGVkZ2VzID0gYXJndW1lbnRzWzBdO1xuICAgICAgZm9yICh2YXIgaSA9IGVkZ2VzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZWRnZSA9IGkubmV4dCgpO1xuICAgICAgICB0aGlzJDEuYWRkRWRnZShlZGdlLCBlZGdlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHZhciBlZGdlcyQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGVkZ2VTZXQgPSBhcmd1bWVudHNbMV07XG4gICAgICBmb3IgKHZhciBpJDEgPSBlZGdlcyQxLml0ZXJhdG9yKCk7IGkkMS5oYXNOZXh0KCk7KSB7XG4gICAgICAgIHZhciBlZGdlJDEgPSBpJDEubmV4dCgpO1xuICAgICAgICB0aGlzJDEuYWRkRWRnZShlZGdlJDEsIGVkZ2VTZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU2ltcGxlTUNTd2VlcExpbmVJbnRlcnNlY3Rvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBTaW1wbGVNQ1N3ZWVwTGluZUludGVyc2VjdG9yXG4gIH07XG5cbiAgcmV0dXJuIFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3I7XG59KEVkZ2VTZXRJbnRlcnNlY3RvcikpO1xuXG52YXIgSW50ZXJ2YWxSVHJlZU5vZGUgPSBmdW5jdGlvbiBJbnRlcnZhbFJUcmVlTm9kZSAoKSB7XG4gIHRoaXMuX21pbiA9IERvdWJsZS5QT1NJVElWRV9JTkZJTklUWTtcbiAgdGhpcy5fbWF4ID0gRG91YmxlLk5FR0FUSVZFX0lORklOSVRZO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0NSA9IHsgTm9kZUNvbXBhcmF0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkludGVydmFsUlRyZWVOb2RlLnByb3RvdHlwZS5nZXRNaW4gPSBmdW5jdGlvbiBnZXRNaW4gKCkge1xuICByZXR1cm4gdGhpcy5fbWluXG59O1xuSW50ZXJ2YWxSVHJlZU5vZGUucHJvdG90eXBlLmludGVyc2VjdHMgPSBmdW5jdGlvbiBpbnRlcnNlY3RzIChxdWVyeU1pbiwgcXVlcnlNYXgpIHtcbiAgaWYgKHRoaXMuX21pbiA+IHF1ZXJ5TWF4IHx8IHRoaXMuX21heCA8IHF1ZXJ5TWluKSB7IHJldHVybiBmYWxzZSB9XG4gIHJldHVybiB0cnVlXG59O1xuSW50ZXJ2YWxSVHJlZU5vZGUucHJvdG90eXBlLmdldE1heCA9IGZ1bmN0aW9uIGdldE1heCAoKSB7XG4gIHJldHVybiB0aGlzLl9tYXhcbn07XG5JbnRlcnZhbFJUcmVlTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHJldHVybiBXS1RXcml0ZXIudG9MaW5lU3RyaW5nKG5ldyBDb29yZGluYXRlKHRoaXMuX21pbiwgMCksIG5ldyBDb29yZGluYXRlKHRoaXMuX21heCwgMCkpXG59O1xuSW50ZXJ2YWxSVHJlZU5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5JbnRlcnZhbFJUcmVlTm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJbnRlcnZhbFJUcmVlTm9kZVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0NS5Ob2RlQ29tcGFyYXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBOb2RlQ29tcGFyYXRvciB9O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyggSW50ZXJ2YWxSVHJlZU5vZGUsIHN0YXRpY0FjY2Vzc29ycyQ0NSApO1xuXG52YXIgTm9kZUNvbXBhcmF0b3IgPSBmdW5jdGlvbiBOb2RlQ29tcGFyYXRvciAoKSB7fTtcblxuTm9kZUNvbXBhcmF0b3IucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChvMSwgbzIpIHtcbiAgdmFyIG4xID0gbzE7XG4gIHZhciBuMiA9IG8yO1xuICB2YXIgbWlkMSA9IChuMS5fbWluICsgbjEuX21heCkgLyAyO1xuICB2YXIgbWlkMiA9IChuMi5fbWluICsgbjIuX21heCkgLyAyO1xuICBpZiAobWlkMSA8IG1pZDIpIHsgcmV0dXJuIC0xIH1cbiAgaWYgKG1pZDEgPiBtaWQyKSB7IHJldHVybiAxIH1cbiAgcmV0dXJuIDBcbn07XG5Ob2RlQ29tcGFyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbQ29tcGFyYXRvcl1cbn07XG5Ob2RlQ29tcGFyYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBOb2RlQ29tcGFyYXRvclxufTtcblxudmFyIEludGVydmFsUlRyZWVMZWFmTm9kZSA9IChmdW5jdGlvbiAoSW50ZXJ2YWxSVHJlZU5vZGUkJDEpIHtcbiAgZnVuY3Rpb24gSW50ZXJ2YWxSVHJlZUxlYWZOb2RlICgpIHtcbiAgICBJbnRlcnZhbFJUcmVlTm9kZSQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX2l0ZW0gPSBudWxsO1xuICAgIHZhciBtaW4gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1heCA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgaXRlbSA9IGFyZ3VtZW50c1syXTtcbiAgICB0aGlzLl9taW4gPSBtaW47XG4gICAgdGhpcy5fbWF4ID0gbWF4O1xuICAgIHRoaXMuX2l0ZW0gPSBpdGVtO1xuICB9XG5cbiAgaWYgKCBJbnRlcnZhbFJUcmVlTm9kZSQkMSApIEludGVydmFsUlRyZWVMZWFmTm9kZS5fX3Byb3RvX18gPSBJbnRlcnZhbFJUcmVlTm9kZSQkMTtcbiAgSW50ZXJ2YWxSVHJlZUxlYWZOb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIEludGVydmFsUlRyZWVOb2RlJCQxICYmIEludGVydmFsUlRyZWVOb2RlJCQxLnByb3RvdHlwZSApO1xuICBJbnRlcnZhbFJUcmVlTGVhZk5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50ZXJ2YWxSVHJlZUxlYWZOb2RlO1xuICBJbnRlcnZhbFJUcmVlTGVhZk5vZGUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKHF1ZXJ5TWluLCBxdWVyeU1heCwgdmlzaXRvcikge1xuICAgIGlmICghdGhpcy5pbnRlcnNlY3RzKHF1ZXJ5TWluLCBxdWVyeU1heCkpIHsgcmV0dXJuIG51bGwgfVxuICAgIHZpc2l0b3IudmlzaXRJdGVtKHRoaXMuX2l0ZW0pO1xuICB9O1xuICBJbnRlcnZhbFJUcmVlTGVhZk5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBJbnRlcnZhbFJUcmVlTGVhZk5vZGUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBJbnRlcnZhbFJUcmVlTGVhZk5vZGVcbiAgfTtcblxuICByZXR1cm4gSW50ZXJ2YWxSVHJlZUxlYWZOb2RlO1xufShJbnRlcnZhbFJUcmVlTm9kZSkpO1xuXG52YXIgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUgPSAoZnVuY3Rpb24gKEludGVydmFsUlRyZWVOb2RlJCQxKSB7XG4gIGZ1bmN0aW9uIEludGVydmFsUlRyZWVCcmFuY2hOb2RlICgpIHtcbiAgICBJbnRlcnZhbFJUcmVlTm9kZSQkMS5jYWxsKHRoaXMpO1xuICAgIHRoaXMuX25vZGUxID0gbnVsbDtcbiAgICB0aGlzLl9ub2RlMiA9IG51bGw7XG4gICAgdmFyIG4xID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBuMiA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9ub2RlMSA9IG4xO1xuICAgIHRoaXMuX25vZGUyID0gbjI7XG4gICAgdGhpcy5idWlsZEV4dGVudCh0aGlzLl9ub2RlMSwgdGhpcy5fbm9kZTIpO1xuICB9XG5cbiAgaWYgKCBJbnRlcnZhbFJUcmVlTm9kZSQkMSApIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLl9fcHJvdG9fXyA9IEludGVydmFsUlRyZWVOb2RlJCQxO1xuICBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBJbnRlcnZhbFJUcmVlTm9kZSQkMSAmJiBJbnRlcnZhbFJUcmVlTm9kZSQkMS5wcm90b3R5cGUgKTtcbiAgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGU7XG4gIEludGVydmFsUlRyZWVCcmFuY2hOb2RlLnByb3RvdHlwZS5idWlsZEV4dGVudCA9IGZ1bmN0aW9uIGJ1aWxkRXh0ZW50IChuMSwgbjIpIHtcbiAgICB0aGlzLl9taW4gPSBNYXRoLm1pbihuMS5fbWluLCBuMi5fbWluKTtcbiAgICB0aGlzLl9tYXggPSBNYXRoLm1heChuMS5fbWF4LCBuMi5fbWF4KTtcbiAgfTtcbiAgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKHF1ZXJ5TWluLCBxdWVyeU1heCwgdmlzaXRvcikge1xuICAgIGlmICghdGhpcy5pbnRlcnNlY3RzKHF1ZXJ5TWluLCBxdWVyeU1heCkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGlmICh0aGlzLl9ub2RlMSAhPT0gbnVsbCkgeyB0aGlzLl9ub2RlMS5xdWVyeShxdWVyeU1pbiwgcXVlcnlNYXgsIHZpc2l0b3IpOyB9XG4gICAgaWYgKHRoaXMuX25vZGUyICE9PSBudWxsKSB7IHRoaXMuX25vZGUyLnF1ZXJ5KHF1ZXJ5TWluLCBxdWVyeU1heCwgdmlzaXRvcik7IH1cbiAgfTtcbiAgSW50ZXJ2YWxSVHJlZUJyYW5jaE5vZGUucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICAgIHJldHVybiBbXVxuICB9O1xuICBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gICAgcmV0dXJuIEludGVydmFsUlRyZWVCcmFuY2hOb2RlXG4gIH07XG5cbiAgcmV0dXJuIEludGVydmFsUlRyZWVCcmFuY2hOb2RlO1xufShJbnRlcnZhbFJUcmVlTm9kZSkpO1xuXG52YXIgU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZSA9IGZ1bmN0aW9uIFNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUgKCkge1xuICB0aGlzLl9sZWF2ZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIHRoaXMuX3Jvb3QgPSBudWxsO1xuICB0aGlzLl9sZXZlbCA9IDA7XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuYnVpbGRUcmVlID0gZnVuY3Rpb24gYnVpbGRUcmVlICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBDb2xsZWN0aW9ucy5zb3J0KHRoaXMuX2xlYXZlcywgbmV3IEludGVydmFsUlRyZWVOb2RlLk5vZGVDb21wYXJhdG9yKCkpO1xuICB2YXIgc3JjID0gdGhpcy5fbGVhdmVzO1xuICB2YXIgdGVtcCA9IG51bGw7XG4gIHZhciBkZXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHRoaXMkMS5idWlsZExldmVsKHNyYywgZGVzdCk7XG4gICAgaWYgKGRlc3Quc2l6ZSgpID09PSAxKSB7IHJldHVybiBkZXN0LmdldCgwKSB9XG4gICAgdGVtcCA9IHNyYztcbiAgICBzcmMgPSBkZXN0O1xuICAgIGRlc3QgPSB0ZW1wO1xuICB9XG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuaW5zZXJ0ID0gZnVuY3Rpb24gaW5zZXJ0IChtaW4sIG1heCwgaXRlbSkge1xuICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgRXJyb3IoJ0luZGV4IGNhbm5vdCBiZSBhZGRlZCB0byBvbmNlIGl0IGhhcyBiZWVuIHF1ZXJpZWQnKSB9XG4gIHRoaXMuX2xlYXZlcy5hZGQobmV3IEludGVydmFsUlRyZWVMZWFmTm9kZShtaW4sIG1heCwgaXRlbSkpO1xufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLnF1ZXJ5ID0gZnVuY3Rpb24gcXVlcnkgKG1pbiwgbWF4LCB2aXNpdG9yKSB7XG4gIHRoaXMuaW5pdCgpO1xuICB0aGlzLl9yb290LnF1ZXJ5KG1pbiwgbWF4LCB2aXNpdG9yKTtcbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5idWlsZFJvb3QgPSBmdW5jdGlvbiBidWlsZFJvb3QgKCkge1xuICBpZiAodGhpcy5fcm9vdCAhPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuX3Jvb3QgPSB0aGlzLmJ1aWxkVHJlZSgpO1xufTtcblNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUucHJvdG90eXBlLnByaW50Tm9kZSA9IGZ1bmN0aW9uIHByaW50Tm9kZSAobm9kZSkge1xuICBTeXN0ZW0ub3V0LnByaW50bG4oV0tUV3JpdGVyLnRvTGluZVN0cmluZyhuZXcgQ29vcmRpbmF0ZShub2RlLl9taW4sIHRoaXMuX2xldmVsKSwgbmV3IENvb3JkaW5hdGUobm9kZS5fbWF4LCB0aGlzLl9sZXZlbCkpKTtcbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdCAoKSB7XG4gIGlmICh0aGlzLl9yb290ICE9PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgdGhpcy5idWlsZFJvb3QoKTtcbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5idWlsZExldmVsID0gZnVuY3Rpb24gYnVpbGRMZXZlbCAoc3JjLCBkZXN0KSB7XG4gIHRoaXMuX2xldmVsKys7XG4gIGRlc3QuY2xlYXIoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmMuc2l6ZSgpOyBpICs9IDIpIHtcbiAgICB2YXIgbjEgPSBzcmMuZ2V0KGkpO1xuICAgIHZhciBuMiA9IGkgKyAxIDwgc3JjLnNpemUoKSA/IHNyYy5nZXQoaSkgOiBudWxsO1xuICAgIGlmIChuMiA9PT0gbnVsbCkge1xuICAgICAgZGVzdC5hZGQobjEpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9kZSA9IG5ldyBJbnRlcnZhbFJUcmVlQnJhbmNoTm9kZShzcmMuZ2V0KGkpLCBzcmMuZ2V0KGkgKyAxKSk7XG4gICAgICBkZXN0LmFkZChub2RlKTtcbiAgICB9XG4gIH1cbn07XG5Tb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuU29ydGVkUGFja2VkSW50ZXJ2YWxSVHJlZS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBTb3J0ZWRQYWNrZWRJbnRlcnZhbFJUcmVlXG59O1xuXG52YXIgQXJyYXlMaXN0VmlzaXRvciA9IGZ1bmN0aW9uIEFycmF5TGlzdFZpc2l0b3IgKCkge1xuICB0aGlzLl9pdGVtcyA9IG5ldyBBcnJheUxpc3QoKTtcbn07XG5BcnJheUxpc3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdEl0ZW0gPSBmdW5jdGlvbiB2aXNpdEl0ZW0gKGl0ZW0pIHtcbiAgdGhpcy5faXRlbXMuYWRkKGl0ZW0pO1xufTtcbkFycmF5TGlzdFZpc2l0b3IucHJvdG90eXBlLmdldEl0ZW1zID0gZnVuY3Rpb24gZ2V0SXRlbXMgKCkge1xuICByZXR1cm4gdGhpcy5faXRlbXNcbn07XG5BcnJheUxpc3RWaXNpdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtJdGVtVmlzaXRvcl1cbn07XG5BcnJheUxpc3RWaXNpdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEFycmF5TGlzdFZpc2l0b3Jcbn07XG5cbnZhciBJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yID0gZnVuY3Rpb24gSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvciAoKSB7XG4gIHRoaXMuX2luZGV4ID0gbnVsbDtcbiAgdmFyIGcgPSBhcmd1bWVudHNbMF07XG4gIGlmICghaGFzSW50ZXJmYWNlKGcsIFBvbHlnb25hbCkpIHsgdGhyb3cgbmV3IElsbGVnYWxBcmd1bWVudEV4Y2VwdGlvbignQXJndW1lbnQgbXVzdCBiZSBQb2x5Z29uYWwnKSB9XG4gIHRoaXMuX2luZGV4ID0gbmV3IEludGVydmFsSW5kZXhlZEdlb21ldHJ5KGcpO1xufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0NCA9IHsgU2VnbWVudFZpc2l0b3I6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0sSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnk6IHsgY29uZmlndXJhYmxlOiB0cnVlIH0gfTtcbkluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3IucHJvdG90eXBlLmxvY2F0ZSA9IGZ1bmN0aW9uIGxvY2F0ZSAocCkge1xuICB2YXIgcmNjID0gbmV3IFJheUNyb3NzaW5nQ291bnRlcihwKTtcbiAgdmFyIHZpc2l0b3IgPSBuZXcgU2VnbWVudFZpc2l0b3IocmNjKTtcbiAgdGhpcy5faW5kZXgucXVlcnkocC55LCBwLnksIHZpc2l0b3IpO1xuICByZXR1cm4gcmNjLmdldExvY2F0aW9uKClcbn07XG5JbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtQb2ludE9uR2VvbWV0cnlMb2NhdG9yXVxufTtcbkluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3IucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gSW5kZXhlZFBvaW50SW5BcmVhTG9jYXRvclxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0NC5TZWdtZW50VmlzaXRvci5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBTZWdtZW50VmlzaXRvciB9O1xuc3RhdGljQWNjZXNzb3JzJDQ0LkludGVydmFsSW5kZXhlZEdlb21ldHJ5LmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEludGVydmFsSW5kZXhlZEdlb21ldHJ5IH07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBJbmRleGVkUG9pbnRJbkFyZWFMb2NhdG9yLCBzdGF0aWNBY2Nlc3NvcnMkNDQgKTtcblxudmFyIFNlZ21lbnRWaXNpdG9yID0gZnVuY3Rpb24gU2VnbWVudFZpc2l0b3IgKCkge1xuICB0aGlzLl9jb3VudGVyID0gbnVsbDtcbiAgdmFyIGNvdW50ZXIgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2NvdW50ZXIgPSBjb3VudGVyO1xufTtcblNlZ21lbnRWaXNpdG9yLnByb3RvdHlwZS52aXNpdEl0ZW0gPSBmdW5jdGlvbiB2aXNpdEl0ZW0gKGl0ZW0pIHtcbiAgdmFyIHNlZyA9IGl0ZW07XG4gIHRoaXMuX2NvdW50ZXIuY291bnRTZWdtZW50KHNlZy5nZXRDb29yZGluYXRlKDApLCBzZWcuZ2V0Q29vcmRpbmF0ZSgxKSk7XG59O1xuU2VnbWVudFZpc2l0b3IucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW0l0ZW1WaXNpdG9yXVxufTtcblNlZ21lbnRWaXNpdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIFNlZ21lbnRWaXNpdG9yXG59O1xuXG52YXIgSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkgPSBmdW5jdGlvbiBJbnRlcnZhbEluZGV4ZWRHZW9tZXRyeSAoKSB7XG4gIHRoaXMuX2luZGV4ID0gbmV3IFNvcnRlZFBhY2tlZEludGVydmFsUlRyZWUoKTtcbiAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuaW5pdChnZW9tKTtcbn07XG5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIGluaXQgKGdlb20pIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgbGluZXMgPSBMaW5lYXJDb21wb25lbnRFeHRyYWN0ZXIuZ2V0TGluZXMoZ2VvbSk7XG4gIGZvciAodmFyIGkgPSBsaW5lcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICB2YXIgbGluZSA9IGkubmV4dCgpO1xuICAgIHZhciBwdHMgPSBsaW5lLmdldENvb3JkaW5hdGVzKCk7XG4gICAgdGhpcyQxLmFkZExpbmUocHRzKTtcbiAgfVxufTtcbkludGVydmFsSW5kZXhlZEdlb21ldHJ5LnByb3RvdHlwZS5hZGRMaW5lID0gZnVuY3Rpb24gYWRkTGluZSAocHRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnID0gbmV3IExpbmVTZWdtZW50KHB0c1tpIC0gMV0sIHB0c1tpXSk7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluKHNlZy5wMC55LCBzZWcucDEueSk7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHNlZy5wMC55LCBzZWcucDEueSk7XG4gICAgdGhpcyQxLl9pbmRleC5pbnNlcnQobWluLCBtYXgsIHNlZyk7XG4gIH1cbn07XG5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeS5wcm90b3R5cGUucXVlcnkgPSBmdW5jdGlvbiBxdWVyeSAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIG1pbiA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbWF4ID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB2aXNpdG9yID0gbmV3IEFycmF5TGlzdFZpc2l0b3IoKTtcbiAgICB0aGlzLl9pbmRleC5xdWVyeShtaW4sIG1heCwgdmlzaXRvcik7XG4gICAgcmV0dXJuIHZpc2l0b3IuZ2V0SXRlbXMoKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgbWluJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG1heCQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciB2aXNpdG9yJDEgPSBhcmd1bWVudHNbMl07XG4gICAgdGhpcy5faW5kZXgucXVlcnkobWluJDEsIG1heCQxLCB2aXNpdG9yJDEpO1xuICB9XG59O1xuSW50ZXJ2YWxJbmRleGVkR2VvbWV0cnkucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeS5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBJbnRlcnZhbEluZGV4ZWRHZW9tZXRyeVxufTtcblxudmFyIEdlb21ldHJ5R3JhcGggPSAoZnVuY3Rpb24gKFBsYW5hckdyYXBoJCQxKSB7XG4gIGZ1bmN0aW9uIEdlb21ldHJ5R3JhcGggKCkge1xuICAgIFBsYW5hckdyYXBoJCQxLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fcGFyZW50R2VvbSA9IG51bGw7XG4gICAgdGhpcy5fbGluZUVkZ2VNYXAgPSBuZXcgSGFzaE1hcCgpO1xuICAgIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGUgPSBudWxsO1xuICAgIHRoaXMuX3VzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGUgPSB0cnVlO1xuICAgIHRoaXMuX2FyZ0luZGV4ID0gbnVsbDtcbiAgICB0aGlzLl9ib3VuZGFyeU5vZGVzID0gbnVsbDtcbiAgICB0aGlzLl9oYXNUb29GZXdQb2ludHMgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnZhbGlkUG9pbnQgPSBudWxsO1xuICAgIHRoaXMuX2FyZWFQdExvY2F0b3IgPSBudWxsO1xuICAgIHRoaXMuX3B0TG9jYXRvciA9IG5ldyBQb2ludExvY2F0b3IoKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHBhcmVudEdlb20gPSBhcmd1bWVudHNbMV07XG4gICAgICB2YXIgYm91bmRhcnlOb2RlUnVsZSA9IEJvdW5kYXJ5Tm9kZVJ1bGUuT0dDX1NGU19CT1VOREFSWV9SVUxFO1xuICAgICAgdGhpcy5fYXJnSW5kZXggPSBhcmdJbmRleDtcbiAgICAgIHRoaXMuX3BhcmVudEdlb20gPSBwYXJlbnRHZW9tO1xuICAgICAgdGhpcy5fYm91bmRhcnlOb2RlUnVsZSA9IGJvdW5kYXJ5Tm9kZVJ1bGU7XG4gICAgICBpZiAocGFyZW50R2VvbSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmFkZChwYXJlbnRHZW9tKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHZhciBhcmdJbmRleCQxID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIHBhcmVudEdlb20kMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBib3VuZGFyeU5vZGVSdWxlJDEgPSBhcmd1bWVudHNbMl07XG4gICAgICB0aGlzLl9hcmdJbmRleCA9IGFyZ0luZGV4JDE7XG4gICAgICB0aGlzLl9wYXJlbnRHZW9tID0gcGFyZW50R2VvbSQxO1xuICAgICAgdGhpcy5fYm91bmRhcnlOb2RlUnVsZSA9IGJvdW5kYXJ5Tm9kZVJ1bGUkMTtcbiAgICAgIGlmIChwYXJlbnRHZW9tJDEgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5hZGQocGFyZW50R2VvbSQxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoIFBsYW5hckdyYXBoJCQxICkgR2VvbWV0cnlHcmFwaC5fX3Byb3RvX18gPSBQbGFuYXJHcmFwaCQkMTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKCBQbGFuYXJHcmFwaCQkMSAmJiBQbGFuYXJHcmFwaCQkMS5wcm90b3R5cGUgKTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW9tZXRyeUdyYXBoO1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5pbnNlcnRCb3VuZGFyeVBvaW50ID0gZnVuY3Rpb24gaW5zZXJ0Qm91bmRhcnlQb2ludCAoYXJnSW5kZXgsIGNvb3JkKSB7XG4gICAgdmFyIG4gPSB0aGlzLl9ub2Rlcy5hZGROb2RlKGNvb3JkKTtcbiAgICB2YXIgbGJsID0gbi5nZXRMYWJlbCgpO1xuICAgIHZhciBib3VuZGFyeUNvdW50ID0gMTtcbiAgICB2YXIgbG9jID0gTG9jYXRpb24uTk9ORTtcbiAgICBsb2MgPSBsYmwuZ2V0TG9jYXRpb24oYXJnSW5kZXgsIFBvc2l0aW9uLk9OKTtcbiAgICBpZiAobG9jID09PSBMb2NhdGlvbi5CT1VOREFSWSkgeyBib3VuZGFyeUNvdW50Kys7IH1cbiAgICB2YXIgbmV3TG9jID0gR2VvbWV0cnlHcmFwaC5kZXRlcm1pbmVCb3VuZGFyeSh0aGlzLl9ib3VuZGFyeU5vZGVSdWxlLCBib3VuZGFyeUNvdW50KTtcbiAgICBsYmwuc2V0TG9jYXRpb24oYXJnSW5kZXgsIG5ld0xvYyk7XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmNvbXB1dGVTZWxmTm9kZXMgPSBmdW5jdGlvbiBjb21wdXRlU2VsZk5vZGVzICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgdmFyIGxpID0gYXJndW1lbnRzWzBdO1xuICAgICAgdmFyIGNvbXB1dGVSaW5nU2VsZk5vZGVzID0gYXJndW1lbnRzWzFdO1xuICAgICAgcmV0dXJuIHRoaXMuY29tcHV0ZVNlbGZOb2RlcyhsaSwgY29tcHV0ZVJpbmdTZWxmTm9kZXMsIGZhbHNlKVxuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMykge1xuICAgICAgdmFyIGxpJDEgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY29tcHV0ZVJpbmdTZWxmTm9kZXMkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhciBpc0RvbmVJZlByb3BlckludCA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhciBzaSA9IG5ldyBTZWdtZW50SW50ZXJzZWN0b3IkMihsaSQxLCB0cnVlLCBmYWxzZSk7XG4gICAgICBzaS5zZXRJc0RvbmVJZlByb3BlckludChpc0RvbmVJZlByb3BlckludCk7XG4gICAgICB2YXIgZXNpID0gdGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKTtcbiAgICAgIHZhciBpc1JpbmdzID0gdGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIExpbmVhclJpbmcgfHwgdGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIFBvbHlnb24gfHwgdGhpcy5fcGFyZW50R2VvbSBpbnN0YW5jZW9mIE11bHRpUG9seWdvbjtcbiAgICAgIHZhciBjb21wdXRlQWxsU2VnbWVudHMgPSBjb21wdXRlUmluZ1NlbGZOb2RlcyQxIHx8ICFpc1JpbmdzO1xuICAgICAgZXNpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuX2VkZ2VzLCBzaSwgY29tcHV0ZUFsbFNlZ21lbnRzKTtcbiAgICAgIHRoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzKHRoaXMuX2FyZ0luZGV4KTtcbiAgICAgIHJldHVybiBzaVxuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuY29tcHV0ZVNwbGl0RWRnZXMgPSBmdW5jdGlvbiBjb21wdXRlU3BsaXRFZGdlcyAoZWRnZWxpc3QpIHtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZSA9IGkubmV4dCgpO1xuICAgICAgZS5laUxpc3QuYWRkU3BsaXRFZGdlcyhlZGdlbGlzdCk7XG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiBjb21wdXRlRWRnZUludGVyc2VjdGlvbnMgKGcsIGxpLCBpbmNsdWRlUHJvcGVyKSB7XG4gICAgdmFyIHNpID0gbmV3IFNlZ21lbnRJbnRlcnNlY3RvciQyKGxpLCBpbmNsdWRlUHJvcGVyLCB0cnVlKTtcbiAgICBzaS5zZXRCb3VuZGFyeU5vZGVzKHRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLCBnLmdldEJvdW5kYXJ5Tm9kZXMoKSk7XG4gICAgdmFyIGVzaSA9IHRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCk7XG4gICAgZXNpLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuX2VkZ2VzLCBnLl9lZGdlcywgc2kpO1xuICAgIHJldHVybiBzaVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5nZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50R2VvbVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5nZXRCb3VuZGFyeU5vZGVSdWxlID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlOb2RlUnVsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kYXJ5Tm9kZVJ1bGVcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuaGFzVG9vRmV3UG9pbnRzID0gZnVuY3Rpb24gaGFzVG9vRmV3UG9pbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZFBvaW50ID0gZnVuY3Rpb24gYWRkUG9pbnQgKCkge1xuICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBQb2ludCkge1xuICAgICAgdmFyIHAgPSBhcmd1bWVudHNbMF07XG4gICAgICB2YXIgY29vcmQgPSBwLmdldENvb3JkaW5hdGUoKTtcbiAgICAgIHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsIGNvb3JkLCBMb2NhdGlvbi5JTlRFUklPUik7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBDb29yZGluYXRlKSB7XG4gICAgICB2YXIgcHQgPSBhcmd1bWVudHNbMF07XG4gICAgICB0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LCBwdCwgTG9jYXRpb24uSU5URVJJT1IpO1xuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkUG9seWdvbiA9IGZ1bmN0aW9uIGFkZFBvbHlnb24gKHApIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHRoaXMuYWRkUG9seWdvblJpbmcocC5nZXRFeHRlcmlvclJpbmcoKSwgTG9jYXRpb24uRVhURVJJT1IsIExvY2F0aW9uLklOVEVSSU9SKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkrKykge1xuICAgICAgdmFyIGhvbGUgPSBwLmdldEludGVyaW9yUmluZ04oaSk7XG4gICAgICB0aGlzJDEuYWRkUG9seWdvblJpbmcoaG9sZSwgTG9jYXRpb24uSU5URVJJT1IsIExvY2F0aW9uLkVYVEVSSU9SKTtcbiAgICB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZEVkZ2UgPSBmdW5jdGlvbiBhZGRFZGdlIChlKSB7XG4gICAgdGhpcy5pbnNlcnRFZGdlKGUpO1xuICAgIHZhciBjb29yZCA9IGUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgICB0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LCBjb29yZFswXSwgTG9jYXRpb24uQk9VTkRBUlkpO1xuICAgIHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5fYXJnSW5kZXgsIGNvb3JkW2Nvb3JkLmxlbmd0aCAtIDFdLCBMb2NhdGlvbi5CT1VOREFSWSk7XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZExpbmVTdHJpbmcgPSBmdW5jdGlvbiBhZGRMaW5lU3RyaW5nIChsaW5lKSB7XG4gICAgdmFyIGNvb3JkID0gQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVSZXBlYXRlZFBvaW50cyhsaW5lLmdldENvb3JkaW5hdGVzKCkpO1xuICAgIGlmIChjb29yZC5sZW5ndGggPCAyKSB7XG4gICAgICB0aGlzLl9oYXNUb29GZXdQb2ludHMgPSB0cnVlO1xuICAgICAgdGhpcy5faW52YWxpZFBvaW50ID0gY29vcmRbMF07XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB2YXIgZSA9IG5ldyBFZGdlKGNvb3JkLCBuZXcgTGFiZWwodGhpcy5fYXJnSW5kZXgsIExvY2F0aW9uLklOVEVSSU9SKSk7XG4gICAgdGhpcy5fbGluZUVkZ2VNYXAucHV0KGxpbmUsIGUpO1xuICAgIHRoaXMuaW5zZXJ0RWRnZShlKTtcbiAgICBBc3NlcnQuaXNUcnVlKGNvb3JkLmxlbmd0aCA+PSAyLCAnZm91bmQgTGluZVN0cmluZyB3aXRoIHNpbmdsZSBwb2ludCcpO1xuICAgIHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLl9hcmdJbmRleCwgY29vcmRbMF0pO1xuICAgIHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLl9hcmdJbmRleCwgY29vcmRbY29vcmQubGVuZ3RoIC0gMV0pO1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5nZXRJbnZhbGlkUG9pbnQgPSBmdW5jdGlvbiBnZXRJbnZhbGlkUG9pbnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnZhbGlkUG9pbnRcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuZ2V0Qm91bmRhcnlQb2ludHMgPSBmdW5jdGlvbiBnZXRCb3VuZGFyeVBvaW50cyAoKSB7XG4gICAgdmFyIGNvbGwgPSB0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKTtcbiAgICB2YXIgcHRzID0gbmV3IEFycmF5KGNvbGwuc2l6ZSgpKS5maWxsKG51bGwpO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKHZhciBpdCA9IGNvbGwuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG5vZGUgPSBpdC5uZXh0KCk7XG4gICAgICBwdHNbaSsrXSA9IG5vZGUuZ2V0Q29vcmRpbmF0ZSgpLmNvcHkoKTtcbiAgICB9XG4gICAgcmV0dXJuIHB0c1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5nZXRCb3VuZGFyeU5vZGVzID0gZnVuY3Rpb24gZ2V0Qm91bmRhcnlOb2RlcyAoKSB7XG4gICAgaWYgKHRoaXMuX2JvdW5kYXJ5Tm9kZXMgPT09IG51bGwpIHsgdGhpcy5fYm91bmRhcnlOb2RlcyA9IHRoaXMuX25vZGVzLmdldEJvdW5kYXJ5Tm9kZXModGhpcy5fYXJnSW5kZXgpOyB9XG4gICAgcmV0dXJuIHRoaXMuX2JvdW5kYXJ5Tm9kZXNcbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuYWRkU2VsZkludGVyc2VjdGlvbk5vZGUgPSBmdW5jdGlvbiBhZGRTZWxmSW50ZXJzZWN0aW9uTm9kZSAoYXJnSW5kZXgsIGNvb3JkLCBsb2MpIHtcbiAgICBpZiAodGhpcy5pc0JvdW5kYXJ5Tm9kZShhcmdJbmRleCwgY29vcmQpKSB7IHJldHVybiBudWxsIH1cbiAgICBpZiAobG9jID09PSBMb2NhdGlvbi5CT1VOREFSWSAmJiB0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlKSB7IHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludChhcmdJbmRleCwgY29vcmQpOyB9IGVsc2UgeyB0aGlzLmluc2VydFBvaW50KGFyZ0luZGV4LCBjb29yZCwgbG9jKTsgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRQb2x5Z29uUmluZyA9IGZ1bmN0aW9uIGFkZFBvbHlnb25SaW5nIChsciwgY3dMZWZ0LCBjd1JpZ2h0KSB7XG4gICAgaWYgKGxyLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGNvb3JkID0gQ29vcmRpbmF0ZUFycmF5cy5yZW1vdmVSZXBlYXRlZFBvaW50cyhsci5nZXRDb29yZGluYXRlcygpKTtcbiAgICBpZiAoY29vcmQubGVuZ3RoIDwgNCkge1xuICAgICAgdGhpcy5faGFzVG9vRmV3UG9pbnRzID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ludmFsaWRQb2ludCA9IGNvb3JkWzBdO1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gICAgdmFyIGxlZnQgPSBjd0xlZnQ7XG4gICAgdmFyIHJpZ2h0ID0gY3dSaWdodDtcbiAgICBpZiAoQ0dBbGdvcml0aG1zLmlzQ0NXKGNvb3JkKSkge1xuICAgICAgbGVmdCA9IGN3UmlnaHQ7XG4gICAgICByaWdodCA9IGN3TGVmdDtcbiAgICB9XG4gICAgdmFyIGUgPSBuZXcgRWRnZShjb29yZCwgbmV3IExhYmVsKHRoaXMuX2FyZ0luZGV4LCBMb2NhdGlvbi5CT1VOREFSWSwgbGVmdCwgcmlnaHQpKTtcbiAgICB0aGlzLl9saW5lRWRnZU1hcC5wdXQobHIsIGUpO1xuICAgIHRoaXMuaW5zZXJ0RWRnZShlKTtcbiAgICB0aGlzLmluc2VydFBvaW50KHRoaXMuX2FyZ0luZGV4LCBjb29yZFswXSwgTG9jYXRpb24uQk9VTkRBUlkpO1xuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5pbnNlcnRQb2ludCA9IGZ1bmN0aW9uIGluc2VydFBvaW50IChhcmdJbmRleCwgY29vcmQsIG9uTG9jYXRpb24pIHtcbiAgICB2YXIgbiA9IHRoaXMuX25vZGVzLmFkZE5vZGUoY29vcmQpO1xuICAgIHZhciBsYmwgPSBuLmdldExhYmVsKCk7XG4gICAgaWYgKGxibCA9PT0gbnVsbCkge1xuICAgICAgbi5fbGFiZWwgPSBuZXcgTGFiZWwoYXJnSW5kZXgsIG9uTG9jYXRpb24pO1xuICAgIH0gZWxzZSB7IGxibC5zZXRMb2NhdGlvbihhcmdJbmRleCwgb25Mb2NhdGlvbik7IH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yID0gZnVuY3Rpb24gY3JlYXRlRWRnZVNldEludGVyc2VjdG9yICgpIHtcbiAgICByZXR1cm4gbmV3IFNpbXBsZU1DU3dlZXBMaW5lSW50ZXJzZWN0b3IoKVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXMgPSBmdW5jdGlvbiBhZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXMgKGFyZ0luZGV4KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy5fZWRnZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZSA9IGkubmV4dCgpO1xuICAgICAgdmFyIGVMb2MgPSBlLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oYXJnSW5kZXgpO1xuICAgICAgZm9yICh2YXIgZWlJdCA9IGUuZWlMaXN0Lml0ZXJhdG9yKCk7IGVpSXQuaGFzTmV4dCgpOykge1xuICAgICAgICB2YXIgZWkgPSBlaUl0Lm5leHQoKTtcbiAgICAgICAgdGhpcyQxLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKGFyZ0luZGV4LCBlaS5jb29yZCwgZUxvYyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIGlmIChnLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBpZiAoZyBpbnN0YW5jZW9mIE11bHRpUG9seWdvbikgeyB0aGlzLl91c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlID0gZmFsc2U7IH1cbiAgICAgIGlmIChnIGluc3RhbmNlb2YgUG9seWdvbikgeyB0aGlzLmFkZFBvbHlnb24oZyk7IH1cbiAgICAgIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBMaW5lU3RyaW5nKSB7IHRoaXMuYWRkTGluZVN0cmluZyhnKTsgfVxuICAgICAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIFBvaW50KSB7IHRoaXMuYWRkUG9pbnQoZyk7IH1cbiAgICAgIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aVBvaW50KSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICAgICAgZWxzZSBpZiAoZyBpbnN0YW5jZW9mIE11bHRpTGluZVN0cmluZykgeyB0aGlzLmFkZENvbGxlY3Rpb24oZyk7IH1cbiAgICAgIGVsc2UgaWYgKGcgaW5zdGFuY2VvZiBNdWx0aVBvbHlnb24pIHsgdGhpcy5hZGRDb2xsZWN0aW9uKGcpOyB9XG4gICAgICBlbHNlIGlmIChnIGluc3RhbmNlb2YgR2VvbWV0cnlDb2xsZWN0aW9uKSB7IHRoaXMuYWRkQ29sbGVjdGlvbihnKTsgfVxuICAgICAgZWxzZSB7IHRocm93IG5ldyBFcnJvcihnLmdldENsYXNzKCkuZ2V0TmFtZSgpKSB9XG4gICAgfSBlbHNlIHsgcmV0dXJuIFBsYW5hckdyYXBoJCQxLnByb3RvdHlwZS5hZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmFkZENvbGxlY3Rpb24gPSBmdW5jdGlvbiBhZGRDb2xsZWN0aW9uIChnYykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnYy5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgICAgdmFyIGcgPSBnYy5nZXRHZW9tZXRyeU4oaSk7XG4gICAgICB0aGlzJDEuYWRkKGcpO1xuICAgIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUubG9jYXRlID0gZnVuY3Rpb24gbG9jYXRlIChwdCkge1xuICAgIGlmIChoYXNJbnRlcmZhY2UodGhpcy5fcGFyZW50R2VvbSwgUG9seWdvbmFsKSAmJiB0aGlzLl9wYXJlbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKSA+IDUwKSB7XG4gICAgICBpZiAodGhpcy5fYXJlYVB0TG9jYXRvciA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLl9hcmVhUHRMb2NhdG9yID0gbmV3IEluZGV4ZWRQb2ludEluQXJlYUxvY2F0b3IodGhpcy5fcGFyZW50R2VvbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYXJlYVB0TG9jYXRvci5sb2NhdGUocHQpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wdExvY2F0b3IubG9jYXRlKHB0LCB0aGlzLl9wYXJlbnRHZW9tKVxuICB9O1xuICBHZW9tZXRyeUdyYXBoLnByb3RvdHlwZS5maW5kRWRnZSA9IGZ1bmN0aW9uIGZpbmRFZGdlICgpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGxpbmUgPSBhcmd1bWVudHNbMF07XG4gICAgICByZXR1cm4gdGhpcy5fbGluZUVkZ2VNYXAuZ2V0KGxpbmUpXG4gICAgfSBlbHNlIHsgcmV0dXJuIFBsYW5hckdyYXBoJCQxLnByb3RvdHlwZS5maW5kRWRnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgfTtcbiAgR2VvbWV0cnlHcmFwaC5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH07XG4gIEdlb21ldHJ5R3JhcGgucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICAgIHJldHVybiBHZW9tZXRyeUdyYXBoXG4gIH07XG4gIEdlb21ldHJ5R3JhcGguZGV0ZXJtaW5lQm91bmRhcnkgPSBmdW5jdGlvbiBkZXRlcm1pbmVCb3VuZGFyeSAoYm91bmRhcnlOb2RlUnVsZSwgYm91bmRhcnlDb3VudCkge1xuICAgIHJldHVybiBib3VuZGFyeU5vZGVSdWxlLmlzSW5Cb3VuZGFyeShib3VuZGFyeUNvdW50KSA/IExvY2F0aW9uLkJPVU5EQVJZIDogTG9jYXRpb24uSU5URVJJT1JcbiAgfTtcblxuICByZXR1cm4gR2VvbWV0cnlHcmFwaDtcbn0oUGxhbmFyR3JhcGgpKTtcblxudmFyIEdlb21ldHJ5R3JhcGhPcCA9IGZ1bmN0aW9uIEdlb21ldHJ5R3JhcGhPcCAoKSB7XG4gIHRoaXMuX2xpID0gbmV3IFJvYnVzdExpbmVJbnRlcnNlY3RvcigpO1xuICB0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbCA9IG51bGw7XG4gIHRoaXMuX2FyZyA9IG51bGw7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgdmFyIGcwID0gYXJndW1lbnRzWzBdO1xuICAgIHRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZzAuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7XG4gICAgdGhpcy5fYXJnID0gbmV3IEFycmF5KDEpLmZpbGwobnVsbCk7XG4gICAgdGhpcy5fYXJnWzBdID0gbmV3IEdlb21ldHJ5R3JhcGgoMCwgZzApO1xuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICB2YXIgZzAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGJvdW5kYXJ5Tm9kZVJ1bGUgPSBCb3VuZGFyeU5vZGVSdWxlLk9HQ19TRlNfQk9VTkRBUllfUlVMRTtcbiAgICBpZiAoZzAkMS5nZXRQcmVjaXNpb25Nb2RlbCgpLmNvbXBhcmVUbyhnMS5nZXRQcmVjaXNpb25Nb2RlbCgpKSA+PSAwKSB7IHRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oZzAkMS5nZXRQcmVjaXNpb25Nb2RlbCgpKTsgfSBlbHNlIHsgdGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihnMS5nZXRQcmVjaXNpb25Nb2RlbCgpKTsgfVxuICAgIHRoaXMuX2FyZyA9IG5ldyBBcnJheSgyKS5maWxsKG51bGwpO1xuICAgIHRoaXMuX2FyZ1swXSA9IG5ldyBHZW9tZXRyeUdyYXBoKDAsIGcwJDEsIGJvdW5kYXJ5Tm9kZVJ1bGUpO1xuICAgIHRoaXMuX2FyZ1sxXSA9IG5ldyBHZW9tZXRyeUdyYXBoKDEsIGcxLCBib3VuZGFyeU5vZGVSdWxlKTtcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGcwJDIgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGJvdW5kYXJ5Tm9kZVJ1bGUkMSA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoZzAkMi5nZXRQcmVjaXNpb25Nb2RlbCgpLmNvbXBhcmVUbyhnMSQxLmdldFByZWNpc2lvbk1vZGVsKCkpID49IDApIHsgdGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihnMCQyLmdldFByZWNpc2lvbk1vZGVsKCkpOyB9IGVsc2UgeyB0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKGcxJDEuZ2V0UHJlY2lzaW9uTW9kZWwoKSk7IH1cbiAgICB0aGlzLl9hcmcgPSBuZXcgQXJyYXkoMikuZmlsbChudWxsKTtcbiAgICB0aGlzLl9hcmdbMF0gPSBuZXcgR2VvbWV0cnlHcmFwaCgwLCBnMCQyLCBib3VuZGFyeU5vZGVSdWxlJDEpO1xuICAgIHRoaXMuX2FyZ1sxXSA9IG5ldyBHZW9tZXRyeUdyYXBoKDEsIGcxJDEsIGJvdW5kYXJ5Tm9kZVJ1bGUkMSk7XG4gIH1cbn07XG5HZW9tZXRyeUdyYXBoT3AucHJvdG90eXBlLmdldEFyZ0dlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0QXJnR2VvbWV0cnkgKGkpIHtcbiAgcmV0dXJuIHRoaXMuX2FyZ1tpXS5nZXRHZW9tZXRyeSgpXG59O1xuR2VvbWV0cnlHcmFwaE9wLnByb3RvdHlwZS5zZXRDb21wdXRhdGlvblByZWNpc2lvbiA9IGZ1bmN0aW9uIHNldENvbXB1dGF0aW9uUHJlY2lzaW9uIChwbSkge1xuICB0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbCA9IHBtO1xuICB0aGlzLl9saS5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLl9yZXN1bHRQcmVjaXNpb25Nb2RlbCk7XG59O1xuR2VvbWV0cnlHcmFwaE9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlHcmFwaE9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5R3JhcGhPcFxufTtcblxuLy8gb3BlcmF0aW9uLmdlb21ldHJ5Z3JhcGhcblxudmFyIEdlb21ldHJ5TWFwcGVyID0gZnVuY3Rpb24gR2VvbWV0cnlNYXBwZXIgKCkge307XG5cbkdlb21ldHJ5TWFwcGVyLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuR2VvbWV0cnlNYXBwZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gR2VvbWV0cnlNYXBwZXJcbn07XG5HZW9tZXRyeU1hcHBlci5tYXAgPSBmdW5jdGlvbiBtYXAgKCkge1xuICBpZiAoYXJndW1lbnRzWzBdIGluc3RhbmNlb2YgR2VvbWV0cnkgJiYgaGFzSW50ZXJmYWNlKGFyZ3VtZW50c1sxXSwgR2VvbWV0cnlNYXBwZXIuTWFwT3ApKSB7XG4gICAgdmFyIGdlb20gPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9wID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBtYXBwZWQgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgICB2YXIgZyA9IG9wLm1hcChnZW9tLmdldEdlb21ldHJ5TihpKSk7XG4gICAgICBpZiAoZyAhPT0gbnVsbCkgeyBtYXBwZWQuYWRkKGcpOyB9XG4gICAgfVxuICAgIHJldHVybiBnZW9tLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KG1hcHBlZClcbiAgfSBlbHNlIGlmIChoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzBdLCBDb2xsZWN0aW9uKSAmJiBoYXNJbnRlcmZhY2UoYXJndW1lbnRzWzFdLCBHZW9tZXRyeU1hcHBlci5NYXBPcCkpIHtcbiAgICB2YXIgZ2VvbXMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9wJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIG1hcHBlZCQxID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIGZvciAodmFyIGkkMSA9IGdlb21zLml0ZXJhdG9yKCk7IGkkMS5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZyQxID0gaSQxLm5leHQoKTtcbiAgICAgIHZhciBnciA9IG9wJDEubWFwKGckMSk7XG4gICAgICBpZiAoZ3IgIT09IG51bGwpIHsgbWFwcGVkJDEuYWRkKGdyKTsgfVxuICAgIH1cbiAgICByZXR1cm4gbWFwcGVkJDFcbiAgfVxufTtcbkdlb21ldHJ5TWFwcGVyLk1hcE9wID0gZnVuY3Rpb24gTWFwT3AgKCkge307XG5cbnZhciBPdmVybGF5T3AgPSAoZnVuY3Rpb24gKEdlb21ldHJ5R3JhcGhPcCkge1xuICBmdW5jdGlvbiBPdmVybGF5T3AgKCkge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gICAgR2VvbWV0cnlHcmFwaE9wLmNhbGwodGhpcywgZzAsIGcxKTtcbiAgICB0aGlzLl9wdExvY2F0b3IgPSBuZXcgUG9pbnRMb2NhdG9yKCk7XG4gICAgdGhpcy5fZ2VvbUZhY3QgPSBudWxsO1xuICAgIHRoaXMuX3Jlc3VsdEdlb20gPSBudWxsO1xuICAgIHRoaXMuX2dyYXBoID0gbnVsbDtcbiAgICB0aGlzLl9lZGdlTGlzdCA9IG5ldyBFZGdlTGlzdCgpO1xuICAgIHRoaXMuX3Jlc3VsdFBvbHlMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHRoaXMuX3Jlc3VsdExpbmVMaXN0ID0gbmV3IEFycmF5TGlzdCgpO1xuICAgIHRoaXMuX3Jlc3VsdFBvaW50TGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICB0aGlzLl9ncmFwaCA9IG5ldyBQbGFuYXJHcmFwaChuZXcgT3ZlcmxheU5vZGVGYWN0b3J5KCkpO1xuICAgIHRoaXMuX2dlb21GYWN0ID0gZzAuZ2V0RmFjdG9yeSgpO1xuICB9XG5cbiAgaWYgKCBHZW9tZXRyeUdyYXBoT3AgKSBPdmVybGF5T3AuX19wcm90b19fID0gR2VvbWV0cnlHcmFwaE9wO1xuICBPdmVybGF5T3AucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggR2VvbWV0cnlHcmFwaE9wICYmIEdlb21ldHJ5R3JhcGhPcC5wcm90b3R5cGUgKTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE92ZXJsYXlPcDtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5pbnNlcnRVbmlxdWVFZGdlID0gZnVuY3Rpb24gaW5zZXJ0VW5pcXVlRWRnZSAoZSkge1xuICAgIHZhciBleGlzdGluZ0VkZ2UgPSB0aGlzLl9lZGdlTGlzdC5maW5kRXF1YWxFZGdlKGUpO1xuICAgIGlmIChleGlzdGluZ0VkZ2UgIT09IG51bGwpIHtcbiAgICAgIHZhciBleGlzdGluZ0xhYmVsID0gZXhpc3RpbmdFZGdlLmdldExhYmVsKCk7XG4gICAgICB2YXIgbGFiZWxUb01lcmdlID0gZS5nZXRMYWJlbCgpO1xuICAgICAgaWYgKCFleGlzdGluZ0VkZ2UuaXNQb2ludHdpc2VFcXVhbChlKSkge1xuICAgICAgICBsYWJlbFRvTWVyZ2UgPSBuZXcgTGFiZWwoZS5nZXRMYWJlbCgpKTtcbiAgICAgICAgbGFiZWxUb01lcmdlLmZsaXAoKTtcbiAgICAgIH1cbiAgICAgIHZhciBkZXB0aCA9IGV4aXN0aW5nRWRnZS5nZXREZXB0aCgpO1xuICAgICAgaWYgKGRlcHRoLmlzTnVsbCgpKSB7XG4gICAgICAgIGRlcHRoLmFkZChleGlzdGluZ0xhYmVsKTtcbiAgICAgIH1cbiAgICAgIGRlcHRoLmFkZChsYWJlbFRvTWVyZ2UpO1xuICAgICAgZXhpc3RpbmdMYWJlbC5tZXJnZShsYWJlbFRvTWVyZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lZGdlTGlzdC5hZGQoZSk7XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmdldEdyYXBoID0gZnVuY3Rpb24gZ2V0R3JhcGggKCkge1xuICAgIHJldHVybiB0aGlzLl9ncmFwaFxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmNhbmNlbER1cGxpY2F0ZVJlc3VsdEVkZ2VzID0gZnVuY3Rpb24gY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMgKCkge1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5fZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZGUgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgc3ltID0gZGUuZ2V0U3ltKCk7XG4gICAgICBpZiAoZGUuaXNJblJlc3VsdCgpICYmIHN5bS5pc0luUmVzdWx0KCkpIHtcbiAgICAgICAgZGUuc2V0SW5SZXN1bHQoZmFsc2UpO1xuICAgICAgICBzeW0uc2V0SW5SZXN1bHQoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5pc0NvdmVyZWRCeUxBID0gZnVuY3Rpb24gaXNDb3ZlcmVkQnlMQSAoY29vcmQpIHtcbiAgICBpZiAodGhpcy5pc0NvdmVyZWQoY29vcmQsIHRoaXMuX3Jlc3VsdExpbmVMaXN0KSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgaWYgKHRoaXMuaXNDb3ZlcmVkKGNvb3JkLCB0aGlzLl9yZXN1bHRQb2x5TGlzdCkpIHsgcmV0dXJuIHRydWUgfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmNvbXB1dGVHZW9tZXRyeSA9IGZ1bmN0aW9uIGNvbXB1dGVHZW9tZXRyeSAocmVzdWx0UG9pbnRMaXN0LCByZXN1bHRMaW5lTGlzdCwgcmVzdWx0UG9seUxpc3QsIG9wY29kZSkge1xuICAgIHZhciBnZW9tTGlzdCA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBnZW9tTGlzdC5hZGRBbGwocmVzdWx0UG9pbnRMaXN0KTtcbiAgICBnZW9tTGlzdC5hZGRBbGwocmVzdWx0TGluZUxpc3QpO1xuICAgIGdlb21MaXN0LmFkZEFsbChyZXN1bHRQb2x5TGlzdCk7XG4gICAgaWYgKGdlb21MaXN0LmlzRW1wdHkoKSkgeyByZXR1cm4gT3ZlcmxheU9wLmNyZWF0ZUVtcHR5UmVzdWx0KG9wY29kZSwgdGhpcy5fYXJnWzBdLmdldEdlb21ldHJ5KCksIHRoaXMuX2FyZ1sxXS5nZXRHZW9tZXRyeSgpLCB0aGlzLl9nZW9tRmFjdCkgfVxuICAgIHJldHVybiB0aGlzLl9nZW9tRmFjdC5idWlsZEdlb21ldHJ5KGdlb21MaXN0KVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLm1lcmdlU3ltTGFiZWxzID0gZnVuY3Rpb24gbWVyZ2VTeW1MYWJlbHMgKCkge1xuICAgIGZvciAodmFyIG5vZGVpdCA9IHRoaXMuX2dyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTsgbm9kZWl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBub2RlID0gbm9kZWl0Lm5leHQoKTtcbiAgICAgIG5vZGUuZ2V0RWRnZXMoKS5tZXJnZVN5bUxhYmVscygpO1xuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5pc0NvdmVyZWQgPSBmdW5jdGlvbiBpc0NvdmVyZWQgKGNvb3JkLCBnZW9tTGlzdCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaXQgPSBnZW9tTGlzdC5pdGVyYXRvcigpOyBpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgZ2VvbSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBsb2MgPSB0aGlzJDEuX3B0TG9jYXRvci5sb2NhdGUoY29vcmQsIGdlb20pO1xuICAgICAgaWYgKGxvYyAhPT0gTG9jYXRpb24uRVhURVJJT1IpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5yZXBsYWNlQ29sbGFwc2VkRWRnZXMgPSBmdW5jdGlvbiByZXBsYWNlQ29sbGFwc2VkRWRnZXMgKCkge1xuICAgIHZhciBuZXdFZGdlcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgICBmb3IgKHZhciBpdCA9IHRoaXMuX2VkZ2VMaXN0Lml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlID0gaXQubmV4dCgpO1xuICAgICAgaWYgKGUuaXNDb2xsYXBzZWQoKSkge1xuICAgICAgICBpdC5yZW1vdmUoKTtcbiAgICAgICAgbmV3RWRnZXMuYWRkKGUuZ2V0Q29sbGFwc2VkRWRnZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZWRnZUxpc3QuYWRkQWxsKG5ld0VkZ2VzKTtcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS51cGRhdGVOb2RlTGFiZWxsaW5nID0gZnVuY3Rpb24gdXBkYXRlTm9kZUxhYmVsbGluZyAoKSB7XG4gICAgZm9yICh2YXIgbm9kZWl0ID0gdGhpcy5fZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpOyBub2RlaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIG5vZGUgPSBub2RlaXQubmV4dCgpO1xuICAgICAgdmFyIGxibCA9IG5vZGUuZ2V0RWRnZXMoKS5nZXRMYWJlbCgpO1xuICAgICAgbm9kZS5nZXRMYWJlbCgpLm1lcmdlKGxibCk7XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmdldFJlc3VsdEdlb21ldHJ5ID0gZnVuY3Rpb24gZ2V0UmVzdWx0R2VvbWV0cnkgKG92ZXJsYXlPcENvZGUpIHtcbiAgICB0aGlzLmNvbXB1dGVPdmVybGF5KG92ZXJsYXlPcENvZGUpO1xuICAgIHJldHVybiB0aGlzLl9yZXN1bHRHZW9tXG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaW5zZXJ0VW5pcXVlRWRnZXMgPSBmdW5jdGlvbiBpbnNlcnRVbmlxdWVFZGdlcyAoZWRnZXMpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGZvciAodmFyIGkgPSBlZGdlcy5pdGVyYXRvcigpOyBpLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBlID0gaS5uZXh0KCk7XG4gICAgICB0aGlzJDEuaW5zZXJ0VW5pcXVlRWRnZShlKTtcbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuY29tcHV0ZU92ZXJsYXkgPSBmdW5jdGlvbiBjb21wdXRlT3ZlcmxheSAob3BDb2RlKSB7XG4gICAgdGhpcy5jb3B5UG9pbnRzKDApO1xuICAgIHRoaXMuY29weVBvaW50cygxKTtcbiAgICB0aGlzLl9hcmdbMF0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLl9saSwgZmFsc2UpO1xuICAgIHRoaXMuX2FyZ1sxXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMuX2xpLCBmYWxzZSk7XG4gICAgdGhpcy5fYXJnWzBdLmNvbXB1dGVFZGdlSW50ZXJzZWN0aW9ucyh0aGlzLl9hcmdbMV0sIHRoaXMuX2xpLCB0cnVlKTtcbiAgICB2YXIgYmFzZVNwbGl0RWRnZXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgdGhpcy5fYXJnWzBdLmNvbXB1dGVTcGxpdEVkZ2VzKGJhc2VTcGxpdEVkZ2VzKTtcbiAgICB0aGlzLl9hcmdbMV0uY29tcHV0ZVNwbGl0RWRnZXMoYmFzZVNwbGl0RWRnZXMpO1xuICAgIC8vIGNvbnN0IHNwbGl0RWRnZXMgPSBiYXNlU3BsaXRFZGdlc1xuICAgIHRoaXMuaW5zZXJ0VW5pcXVlRWRnZXMoYmFzZVNwbGl0RWRnZXMpO1xuICAgIHRoaXMuY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMoKTtcbiAgICB0aGlzLnJlcGxhY2VDb2xsYXBzZWRFZGdlcygpO1xuICAgIEVkZ2VOb2RpbmdWYWxpZGF0b3IuY2hlY2tWYWxpZCh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKTtcbiAgICB0aGlzLl9ncmFwaC5hZGRFZGdlcyh0aGlzLl9lZGdlTGlzdC5nZXRFZGdlcygpKTtcbiAgICB0aGlzLmNvbXB1dGVMYWJlbGxpbmcoKTtcbiAgICB0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGVzKCk7XG4gICAgdGhpcy5maW5kUmVzdWx0QXJlYUVkZ2VzKG9wQ29kZSk7XG4gICAgdGhpcy5jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcygpO1xuICAgIHZhciBwb2x5QnVpbGRlciA9IG5ldyBQb2x5Z29uQnVpbGRlcih0aGlzLl9nZW9tRmFjdCk7XG4gICAgcG9seUJ1aWxkZXIuYWRkKHRoaXMuX2dyYXBoKTtcbiAgICB0aGlzLl9yZXN1bHRQb2x5TGlzdCA9IHBvbHlCdWlsZGVyLmdldFBvbHlnb25zKCk7XG4gICAgdmFyIGxpbmVCdWlsZGVyID0gbmV3IExpbmVCdWlsZGVyKHRoaXMsIHRoaXMuX2dlb21GYWN0LCB0aGlzLl9wdExvY2F0b3IpO1xuICAgIHRoaXMuX3Jlc3VsdExpbmVMaXN0ID0gbGluZUJ1aWxkZXIuYnVpbGQob3BDb2RlKTtcbiAgICB2YXIgcG9pbnRCdWlsZGVyID0gbmV3IFBvaW50QnVpbGRlcih0aGlzLCB0aGlzLl9nZW9tRmFjdCwgdGhpcy5fcHRMb2NhdG9yKTtcbiAgICB0aGlzLl9yZXN1bHRQb2ludExpc3QgPSBwb2ludEJ1aWxkZXIuYnVpbGQob3BDb2RlKTtcbiAgICB0aGlzLl9yZXN1bHRHZW9tID0gdGhpcy5jb21wdXRlR2VvbWV0cnkodGhpcy5fcmVzdWx0UG9pbnRMaXN0LCB0aGlzLl9yZXN1bHRMaW5lTGlzdCwgdGhpcy5fcmVzdWx0UG9seUxpc3QsIG9wQ29kZSk7XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUubGFiZWxJbmNvbXBsZXRlTm9kZSA9IGZ1bmN0aW9uIGxhYmVsSW5jb21wbGV0ZU5vZGUgKG4sIHRhcmdldEluZGV4KSB7XG4gICAgdmFyIGxvYyA9IHRoaXMuX3B0TG9jYXRvci5sb2NhdGUobi5nZXRDb29yZGluYXRlKCksIHRoaXMuX2FyZ1t0YXJnZXRJbmRleF0uZ2V0R2VvbWV0cnkoKSk7XG4gICAgbi5nZXRMYWJlbCgpLnNldExvY2F0aW9uKHRhcmdldEluZGV4LCBsb2MpO1xuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmNvcHlQb2ludHMgPSBmdW5jdGlvbiBjb3B5UG9pbnRzIChhcmdJbmRleCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgZm9yICh2YXIgaSA9IHRoaXMuX2FyZ1thcmdJbmRleF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGdyYXBoTm9kZSA9IGkubmV4dCgpO1xuICAgICAgdmFyIG5ld05vZGUgPSB0aGlzJDEuX2dyYXBoLmFkZE5vZGUoZ3JhcGhOb2RlLmdldENvb3JkaW5hdGUoKSk7XG4gICAgICBuZXdOb2RlLnNldExhYmVsKGFyZ0luZGV4LCBncmFwaE5vZGUuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihhcmdJbmRleCkpO1xuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5maW5kUmVzdWx0QXJlYUVkZ2VzID0gZnVuY3Rpb24gZmluZFJlc3VsdEFyZWFFZGdlcyAob3BDb2RlKSB7XG4gICAgZm9yICh2YXIgaXQgPSB0aGlzLl9ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7IGl0Lmhhc05leHQoKTspIHtcbiAgICAgIHZhciBkZSA9IGl0Lm5leHQoKTtcbiAgICAgIHZhciBsYWJlbCA9IGRlLmdldExhYmVsKCk7XG4gICAgICBpZiAobGFiZWwuaXNBcmVhKCkgJiYgIWRlLmlzSW50ZXJpb3JBcmVhRWRnZSgpICYmIE92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AobGFiZWwuZ2V0TG9jYXRpb24oMCwgUG9zaXRpb24uUklHSFQpLCBsYWJlbC5nZXRMb2NhdGlvbigxLCBQb3NpdGlvbi5SSUdIVCksIG9wQ29kZSkpIHtcbiAgICAgICAgZGUuc2V0SW5SZXN1bHQodHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBPdmVybGF5T3AucHJvdG90eXBlLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzID0gZnVuY3Rpb24gY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHMgKCkge1xuICAgIGZvciAodmFyIGl0ID0gdGhpcy5fZWRnZUxpc3QuaXRlcmF0b3IoKTsgaXQuaGFzTmV4dCgpOykge1xuICAgICAgdmFyIGUgPSBpdC5uZXh0KCk7XG4gICAgICB2YXIgbGJsID0gZS5nZXRMYWJlbCgpO1xuICAgICAgdmFyIGRlcHRoID0gZS5nZXREZXB0aCgpO1xuICAgICAgaWYgKCFkZXB0aC5pc051bGwoKSkge1xuICAgICAgICBkZXB0aC5ub3JtYWxpemUoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspIHtcbiAgICAgICAgICBpZiAoIWxibC5pc051bGwoaSkgJiYgbGJsLmlzQXJlYSgpICYmICFkZXB0aC5pc051bGwoaSkpIHtcbiAgICAgICAgICAgIGlmIChkZXB0aC5nZXREZWx0YShpKSA9PT0gMCkge1xuICAgICAgICAgICAgICBsYmwudG9MaW5lKGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgQXNzZXJ0LmlzVHJ1ZSghZGVwdGguaXNOdWxsKGksIFBvc2l0aW9uLkxFRlQpLCAnZGVwdGggb2YgTEVGVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCcpO1xuICAgICAgICAgICAgICBsYmwuc2V0TG9jYXRpb24oaSwgUG9zaXRpb24uTEVGVCwgZGVwdGguZ2V0TG9jYXRpb24oaSwgUG9zaXRpb24uTEVGVCkpO1xuICAgICAgICAgICAgICBBc3NlcnQuaXNUcnVlKCFkZXB0aC5pc051bGwoaSwgUG9zaXRpb24uUklHSFQpLCAnZGVwdGggb2YgUklHSFQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQnKTtcbiAgICAgICAgICAgICAgbGJsLnNldExvY2F0aW9uKGksIFBvc2l0aW9uLlJJR0hULCBkZXB0aC5nZXRMb2NhdGlvbihpLCBQb3NpdGlvbi5SSUdIVCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nID0gZnVuY3Rpb24gY29tcHV0ZUxhYmVsbGluZyAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBub2RlaXQgPSB0aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7IG5vZGVpdC5oYXNOZXh0KCk7KSB7XG4gICAgICB2YXIgbm9kZSA9IG5vZGVpdC5uZXh0KCk7XG4gICAgICBub2RlLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzJDEuX2FyZyk7XG4gICAgfVxuICAgIHRoaXMubWVyZ2VTeW1MYWJlbHMoKTtcbiAgICB0aGlzLnVwZGF0ZU5vZGVMYWJlbGxpbmcoKTtcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5sYWJlbEluY29tcGxldGVOb2RlcyA9IGZ1bmN0aW9uIGxhYmVsSW5jb21wbGV0ZU5vZGVzICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIC8vIGxldCBub2RlQ291bnQgPSAwXG4gICAgZm9yICh2YXIgbmkgPSB0aGlzLl9ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7IG5pLmhhc05leHQoKTspIHtcbiAgICAgIHZhciBuID0gbmkubmV4dCgpO1xuICAgICAgdmFyIGxhYmVsID0gbi5nZXRMYWJlbCgpO1xuICAgICAgaWYgKG4uaXNJc29sYXRlZCgpKSB7XG4gICAgICAgIC8vIG5vZGVDb3VudCsrXG4gICAgICAgIGlmIChsYWJlbC5pc051bGwoMCkpIHsgdGhpcyQxLmxhYmVsSW5jb21wbGV0ZU5vZGUobiwgMCk7IH0gZWxzZSB7IHRoaXMkMS5sYWJlbEluY29tcGxldGVOb2RlKG4sIDEpOyB9XG4gICAgICB9XG4gICAgICBuLmdldEVkZ2VzKCkudXBkYXRlTGFiZWxsaW5nKGxhYmVsKTtcbiAgICB9XG4gIH07XG4gIE92ZXJsYXlPcC5wcm90b3R5cGUuaXNDb3ZlcmVkQnlBID0gZnVuY3Rpb24gaXNDb3ZlcmVkQnlBIChjb29yZCkge1xuICAgIGlmICh0aGlzLmlzQ292ZXJlZChjb29yZCwgdGhpcy5fcmVzdWx0UG9seUxpc3QpKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgICByZXR1cm4gW11cbiAgfTtcbiAgT3ZlcmxheU9wLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgICByZXR1cm4gT3ZlcmxheU9wXG4gIH07XG5cbiAgcmV0dXJuIE92ZXJsYXlPcDtcbn0oR2VvbWV0cnlHcmFwaE9wKSk7XG5cbk92ZXJsYXlPcC5vdmVybGF5T3AgPSBmdW5jdGlvbiAoZ2VvbTAsIGdlb20xLCBvcENvZGUpIHtcbiAgdmFyIGdvdiA9IG5ldyBPdmVybGF5T3AoZ2VvbTAsIGdlb20xKTtcbiAgdmFyIGdlb21PdiA9IGdvdi5nZXRSZXN1bHRHZW9tZXRyeShvcENvZGUpO1xuICByZXR1cm4gZ2VvbU92XG59O1xuT3ZlcmxheU9wLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uIChnLCBvdGhlcikge1xuICBpZiAoZy5pc0VtcHR5KCkgfHwgb3RoZXIuaXNFbXB0eSgpKSB7IHJldHVybiBPdmVybGF5T3AuY3JlYXRlRW1wdHlSZXN1bHQoT3ZlcmxheU9wLklOVEVSU0VDVElPTiwgZywgb3RoZXIsIGcuZ2V0RmFjdG9yeSgpKSB9XG4gIGlmIChnLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpIHtcbiAgICB2YXIgZzIgPSBvdGhlcjtcbiAgICByZXR1cm4gR2VvbWV0cnlDb2xsZWN0aW9uTWFwcGVyLm1hcChnLCB7XG4gICAgICBpbnRlcmZhY2VzXzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW0dlb21ldHJ5TWFwcGVyLk1hcE9wXVxuICAgICAgfSxcbiAgICAgIG1hcDogZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgcmV0dXJuIGcuaW50ZXJzZWN0aW9uKGcyKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihnKTtcbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihvdGhlcik7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcsIG90aGVyLCBPdmVybGF5T3AuSU5URVJTRUNUSU9OKVxufTtcbk92ZXJsYXlPcC5zeW1EaWZmZXJlbmNlID0gZnVuY3Rpb24gKGcsIG90aGVyKSB7XG4gIGlmIChnLmlzRW1wdHkoKSB8fCBvdGhlci5pc0VtcHR5KCkpIHtcbiAgICBpZiAoZy5pc0VtcHR5KCkgJiYgb3RoZXIuaXNFbXB0eSgpKSB7IHJldHVybiBPdmVybGF5T3AuY3JlYXRlRW1wdHlSZXN1bHQoT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0UsIGcsIG90aGVyLCBnLmdldEZhY3RvcnkoKSkgfVxuICAgIGlmIChnLmlzRW1wdHkoKSkgeyByZXR1cm4gb3RoZXIuY29weSgpIH1cbiAgICBpZiAob3RoZXIuaXNFbXB0eSgpKSB7IHJldHVybiBnLmNvcHkoKSB9XG4gIH1cbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihnKTtcbiAgZy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihvdGhlcik7XG4gIHJldHVybiBTbmFwSWZOZWVkZWRPdmVybGF5T3Aub3ZlcmxheU9wKGcsIG90aGVyLCBPdmVybGF5T3AuU1lNRElGRkVSRU5DRSlcbn07XG5PdmVybGF5T3AucmVzdWx0RGltZW5zaW9uID0gZnVuY3Rpb24gKG9wQ29kZSwgZzAsIGcxKSB7XG4gIHZhciBkaW0wID0gZzAuZ2V0RGltZW5zaW9uKCk7XG4gIHZhciBkaW0xID0gZzEuZ2V0RGltZW5zaW9uKCk7XG4gIHZhciByZXN1bHREaW1lbnNpb24gPSAtMTtcbiAgc3dpdGNoIChvcENvZGUpIHtcbiAgICBjYXNlIE92ZXJsYXlPcC5JTlRFUlNFQ1RJT046XG4gICAgICByZXN1bHREaW1lbnNpb24gPSBNYXRoLm1pbihkaW0wLCBkaW0xKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBPdmVybGF5T3AuVU5JT046XG4gICAgICByZXN1bHREaW1lbnNpb24gPSBNYXRoLm1heChkaW0wLCBkaW0xKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBPdmVybGF5T3AuRElGRkVSRU5DRTpcbiAgICAgIHJlc3VsdERpbWVuc2lvbiA9IGRpbTA7XG4gICAgICBicmVha1xuICAgIGNhc2UgT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0U6XG4gICAgICByZXN1bHREaW1lbnNpb24gPSBNYXRoLm1heChkaW0wLCBkaW0xKTtcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgfVxuICByZXR1cm4gcmVzdWx0RGltZW5zaW9uXG59O1xuT3ZlcmxheU9wLmNyZWF0ZUVtcHR5UmVzdWx0ID0gZnVuY3Rpb24gKG92ZXJsYXlPcENvZGUsIGEsIGIsIGdlb21GYWN0KSB7XG4gIHZhciByZXN1bHQgPSBudWxsO1xuICBzd2l0Y2ggKE92ZXJsYXlPcC5yZXN1bHREaW1lbnNpb24ob3ZlcmxheU9wQ29kZSwgYSwgYikpIHtcbiAgICBjYXNlIC0xOlxuICAgICAgcmVzdWx0ID0gZ2VvbUZhY3QuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG5ldyBBcnJheSgwKS5maWxsKG51bGwpKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAwOlxuICAgICAgcmVzdWx0ID0gZ2VvbUZhY3QuY3JlYXRlUG9pbnQoKTtcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxOlxuICAgICAgcmVzdWx0ID0gZ2VvbUZhY3QuY3JlYXRlTGluZVN0cmluZygpO1xuICAgICAgYnJlYWtcbiAgICBjYXNlIDI6XG4gICAgICByZXN1bHQgPSBnZW9tRmFjdC5jcmVhdGVQb2x5Z29uKCk7XG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufTtcbk92ZXJsYXlPcC5kaWZmZXJlbmNlID0gZnVuY3Rpb24gKGcsIG90aGVyKSB7XG4gIGlmIChnLmlzRW1wdHkoKSkgeyByZXR1cm4gT3ZlcmxheU9wLmNyZWF0ZUVtcHR5UmVzdWx0KE92ZXJsYXlPcC5ESUZGRVJFTkNFLCBnLCBvdGhlciwgZy5nZXRGYWN0b3J5KCkpIH1cbiAgaWYgKG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gZy5jb3B5KCkgfVxuICBnLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGcpO1xuICBnLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKG90aGVyKTtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZywgb3RoZXIsIE92ZXJsYXlPcC5ESUZGRVJFTkNFKVxufTtcbk92ZXJsYXlPcC5pc1Jlc3VsdE9mT3AgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGxhYmVsID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBvcENvZGUgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxvYzAgPSBsYWJlbC5nZXRMb2NhdGlvbigwKTtcbiAgICB2YXIgbG9jMSA9IGxhYmVsLmdldExvY2F0aW9uKDEpO1xuICAgIHJldHVybiBPdmVybGF5T3AuaXNSZXN1bHRPZk9wKGxvYzAsIGxvYzEsIG9wQ29kZSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGxvYzAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgbG9jMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBvdmVybGF5T3BDb2RlID0gYXJndW1lbnRzWzJdO1xuICAgIGlmIChsb2MwJDEgPT09IExvY2F0aW9uLkJPVU5EQVJZKSB7IGxvYzAkMSA9IExvY2F0aW9uLklOVEVSSU9SOyB9XG4gICAgaWYgKGxvYzEkMSA9PT0gTG9jYXRpb24uQk9VTkRBUlkpIHsgbG9jMSQxID0gTG9jYXRpb24uSU5URVJJT1I7IH1cbiAgICBzd2l0Y2ggKG92ZXJsYXlPcENvZGUpIHtcbiAgICAgIGNhc2UgT3ZlcmxheU9wLklOVEVSU0VDVElPTjpcbiAgICAgICAgcmV0dXJuIGxvYzAkMSA9PT0gTG9jYXRpb24uSU5URVJJT1IgJiYgbG9jMSQxID09PSBMb2NhdGlvbi5JTlRFUklPUlxuICAgICAgY2FzZSBPdmVybGF5T3AuVU5JT046XG4gICAgICAgIHJldHVybiBsb2MwJDEgPT09IExvY2F0aW9uLklOVEVSSU9SIHx8IGxvYzEkMSA9PT0gTG9jYXRpb24uSU5URVJJT1JcbiAgICAgIGNhc2UgT3ZlcmxheU9wLkRJRkZFUkVOQ0U6XG4gICAgICAgIHJldHVybiBsb2MwJDEgPT09IExvY2F0aW9uLklOVEVSSU9SICYmIGxvYzEkMSAhPT0gTG9jYXRpb24uSU5URVJJT1JcbiAgICAgIGNhc2UgT3ZlcmxheU9wLlNZTURJRkZFUkVOQ0U6XG4gICAgICAgIHJldHVybiAobG9jMCQxID09PSBMb2NhdGlvbi5JTlRFUklPUiAmJiBsb2MxJDEgIT09IExvY2F0aW9uLklOVEVSSU9SKSB8fCAobG9jMCQxICE9PSBMb2NhdGlvbi5JTlRFUklPUiAmJiBsb2MxJDEgPT09IExvY2F0aW9uLklOVEVSSU9SKVxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn07XG5PdmVybGF5T3AuSU5URVJTRUNUSU9OID0gMTtcbk92ZXJsYXlPcC5VTklPTiA9IDI7XG5PdmVybGF5T3AuRElGRkVSRU5DRSA9IDM7XG5PdmVybGF5T3AuU1lNRElGRkVSRU5DRSA9IDQ7XG5cbnZhciBGdXp6eVBvaW50TG9jYXRvciA9IGZ1bmN0aW9uIEZ1enp5UG9pbnRMb2NhdG9yICgpIHtcbiAgdGhpcy5fZyA9IG51bGw7XG4gIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgPSBudWxsO1xuICB0aGlzLl9saW5ld29yayA9IG51bGw7XG4gIHRoaXMuX3B0TG9jYXRvciA9IG5ldyBQb2ludExvY2F0b3IoKTtcbiAgdGhpcy5fc2VnID0gbmV3IExpbmVTZWdtZW50KCk7XG4gIHZhciBnID0gYXJndW1lbnRzWzBdO1xuICB2YXIgYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSA9IGFyZ3VtZW50c1sxXTtcbiAgdGhpcy5fZyA9IGc7XG4gIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgPSBib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlO1xuICB0aGlzLl9saW5ld29yayA9IHRoaXMuZXh0cmFjdExpbmV3b3JrKGcpO1xufTtcbkZ1enp5UG9pbnRMb2NhdG9yLnByb3RvdHlwZS5pc1dpdGhpblRvbGVyYW5jZU9mQm91bmRhcnkgPSBmdW5jdGlvbiBpc1dpdGhpblRvbGVyYW5jZU9mQm91bmRhcnkgKHB0KSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9saW5ld29yay5nZXROdW1HZW9tZXRyaWVzKCk7IGkrKykge1xuICAgIHZhciBsaW5lID0gdGhpcyQxLl9saW5ld29yay5nZXRHZW9tZXRyeU4oaSk7XG4gICAgdmFyIHNlcSA9IGxpbmUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzZXEuc2l6ZSgpIC0gMTsgaisrKSB7XG4gICAgICBzZXEuZ2V0Q29vcmRpbmF0ZShqLCB0aGlzJDEuX3NlZy5wMCk7XG4gICAgICBzZXEuZ2V0Q29vcmRpbmF0ZShqICsgMSwgdGhpcyQxLl9zZWcucDEpO1xuICAgICAgdmFyIGRpc3QgPSB0aGlzJDEuX3NlZy5kaXN0YW5jZShwdCk7XG4gICAgICBpZiAoZGlzdCA8PSB0aGlzJDEuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UpIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn07XG5GdXp6eVBvaW50TG9jYXRvci5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAocHQpIHtcbiAgaWYgKHRoaXMuaXNXaXRoaW5Ub2xlcmFuY2VPZkJvdW5kYXJ5KHB0KSkgeyByZXR1cm4gTG9jYXRpb24uQk9VTkRBUlkgfVxuICByZXR1cm4gdGhpcy5fcHRMb2NhdG9yLmxvY2F0ZShwdCwgdGhpcy5fZylcbn07XG5GdXp6eVBvaW50TG9jYXRvci5wcm90b3R5cGUuZXh0cmFjdExpbmV3b3JrID0gZnVuY3Rpb24gZXh0cmFjdExpbmV3b3JrIChnKSB7XG4gIHZhciBleHRyYWN0ZXIgPSBuZXcgUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIoKTtcbiAgZy5hcHBseShleHRyYWN0ZXIpO1xuICB2YXIgbGluZXdvcmsgPSBleHRyYWN0ZXIuZ2V0TGluZXdvcmsoKTtcbiAgdmFyIGxpbmVzID0gR2VvbWV0cnlGYWN0b3J5LnRvTGluZVN0cmluZ0FycmF5KGxpbmV3b3JrKTtcbiAgcmV0dXJuIGcuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhsaW5lcylcbn07XG5GdXp6eVBvaW50TG9jYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbkZ1enp5UG9pbnRMb2NhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEZ1enp5UG9pbnRMb2NhdG9yXG59O1xuXG52YXIgUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIgPSBmdW5jdGlvbiBQb2x5Z29uYWxMaW5ld29ya0V4dHJhY3RlciAoKSB7XG4gIHRoaXMuX2xpbmV3b3JrID0gbnVsbDtcbiAgdGhpcy5fbGluZXdvcmsgPSBuZXcgQXJyYXlMaXN0KCk7XG59O1xuUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIucHJvdG90eXBlLmdldExpbmV3b3JrID0gZnVuY3Rpb24gZ2V0TGluZXdvcmsgKCkge1xuICByZXR1cm4gdGhpcy5fbGluZXdvcmtcbn07XG5Qb2x5Z29uYWxMaW5ld29ya0V4dHJhY3Rlci5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChnKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGcgaW5zdGFuY2VvZiBQb2x5Z29uKSB7XG4gICAgdmFyIHBvbHkgPSBnO1xuICAgIHRoaXMuX2xpbmV3b3JrLmFkZChwb2x5LmdldEV4dGVyaW9yUmluZygpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7IGkrKykge1xuICAgICAgdGhpcyQxLl9saW5ld29yay5hZGQocG9seS5nZXRJbnRlcmlvclJpbmdOKGkpKTtcbiAgICB9XG4gIH1cbn07XG5Qb2x5Z29uYWxMaW5ld29ya0V4dHJhY3Rlci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbR2VvbWV0cnlGaWx0ZXJdXG59O1xuUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXIucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gZ2V0Q2xhc3MgKCkge1xuICByZXR1cm4gUG9seWdvbmFsTGluZXdvcmtFeHRyYWN0ZXJcbn07XG5cbnZhciBPZmZzZXRQb2ludEdlbmVyYXRvciA9IGZ1bmN0aW9uIE9mZnNldFBvaW50R2VuZXJhdG9yICgpIHtcbiAgdGhpcy5fZyA9IG51bGw7XG4gIHRoaXMuX2RvTGVmdCA9IHRydWU7XG4gIHRoaXMuX2RvUmlnaHQgPSB0cnVlO1xuICB2YXIgZyA9IGFyZ3VtZW50c1swXTtcbiAgdGhpcy5fZyA9IGc7XG59O1xuT2Zmc2V0UG9pbnRHZW5lcmF0b3IucHJvdG90eXBlLmV4dHJhY3RQb2ludHMgPSBmdW5jdGlvbiBleHRyYWN0UG9pbnRzIChsaW5lLCBvZmZzZXREaXN0YW5jZSwgb2Zmc2V0UHRzKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIHB0cyA9IGxpbmUuZ2V0Q29vcmRpbmF0ZXMoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdGhpcyQxLmNvbXB1dGVPZmZzZXRQb2ludHMocHRzW2ldLCBwdHNbaSArIDFdLCBvZmZzZXREaXN0YW5jZSwgb2Zmc2V0UHRzKTtcbiAgfVxufTtcbk9mZnNldFBvaW50R2VuZXJhdG9yLnByb3RvdHlwZS5zZXRTaWRlc1RvR2VuZXJhdGUgPSBmdW5jdGlvbiBzZXRTaWRlc1RvR2VuZXJhdGUgKGRvTGVmdCwgZG9SaWdodCkge1xuICB0aGlzLl9kb0xlZnQgPSBkb0xlZnQ7XG4gIHRoaXMuX2RvUmlnaHQgPSBkb1JpZ2h0O1xufTtcbk9mZnNldFBvaW50R2VuZXJhdG9yLnByb3RvdHlwZS5nZXRQb2ludHMgPSBmdW5jdGlvbiBnZXRQb2ludHMgKG9mZnNldERpc3RhbmNlKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgdmFyIG9mZnNldFB0cyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgdmFyIGxpbmVzID0gTGluZWFyQ29tcG9uZW50RXh0cmFjdGVyLmdldExpbmVzKHRoaXMuX2cpO1xuICBmb3IgKHZhciBpID0gbGluZXMuaXRlcmF0b3IoKTsgaS5oYXNOZXh0KCk7KSB7XG4gICAgdmFyIGxpbmUgPSBpLm5leHQoKTtcbiAgICB0aGlzJDEuZXh0cmFjdFBvaW50cyhsaW5lLCBvZmZzZXREaXN0YW5jZSwgb2Zmc2V0UHRzKTtcbiAgfVxuICByZXR1cm4gb2Zmc2V0UHRzXG59O1xuT2Zmc2V0UG9pbnRHZW5lcmF0b3IucHJvdG90eXBlLmNvbXB1dGVPZmZzZXRQb2ludHMgPSBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0UG9pbnRzIChwMCwgcDEsIG9mZnNldERpc3RhbmNlLCBvZmZzZXRQdHMpIHtcbiAgdmFyIGR4ID0gcDEueCAtIHAwLng7XG4gIHZhciBkeSA9IHAxLnkgLSBwMC55O1xuICB2YXIgbGVuID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgdmFyIHV4ID0gb2Zmc2V0RGlzdGFuY2UgKiBkeCAvIGxlbjtcbiAgdmFyIHV5ID0gb2Zmc2V0RGlzdGFuY2UgKiBkeSAvIGxlbjtcbiAgdmFyIG1pZFggPSAocDEueCArIHAwLngpIC8gMjtcbiAgdmFyIG1pZFkgPSAocDEueSArIHAwLnkpIC8gMjtcbiAgaWYgKHRoaXMuX2RvTGVmdCkge1xuICAgIHZhciBvZmZzZXRMZWZ0ID0gbmV3IENvb3JkaW5hdGUobWlkWCAtIHV5LCBtaWRZICsgdXgpO1xuICAgIG9mZnNldFB0cy5hZGQob2Zmc2V0TGVmdCk7XG4gIH1cbiAgaWYgKHRoaXMuX2RvUmlnaHQpIHtcbiAgICB2YXIgb2Zmc2V0UmlnaHQgPSBuZXcgQ29vcmRpbmF0ZShtaWRYICsgdXksIG1pZFkgLSB1eCk7XG4gICAgb2Zmc2V0UHRzLmFkZChvZmZzZXRSaWdodCk7XG4gIH1cbn07XG5PZmZzZXRQb2ludEdlbmVyYXRvci5wcm90b3R5cGUuaW50ZXJmYWNlc18gPSBmdW5jdGlvbiBpbnRlcmZhY2VzXyAoKSB7XG4gIHJldHVybiBbXVxufTtcbk9mZnNldFBvaW50R2VuZXJhdG9yLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIE9mZnNldFBvaW50R2VuZXJhdG9yXG59O1xuXG52YXIgT3ZlcmxheVJlc3VsdFZhbGlkYXRvciA9IGZ1bmN0aW9uIE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IgKCkge1xuICB0aGlzLl9nZW9tID0gbnVsbDtcbiAgdGhpcy5fbG9jRmluZGVyID0gbnVsbDtcbiAgdGhpcy5fbG9jYXRpb24gPSBuZXcgQXJyYXkoMykuZmlsbChudWxsKTtcbiAgdGhpcy5faW52YWxpZExvY2F0aW9uID0gbnVsbDtcbiAgdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSA9IE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IuVE9MRVJBTkNFO1xuICB0aGlzLl90ZXN0Q29vcmRzID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgYSA9IGFyZ3VtZW50c1swXTtcbiAgdmFyIGIgPSBhcmd1bWVudHNbMV07XG4gIHZhciByZXN1bHQgPSBhcmd1bWVudHNbMl07XG4gIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgPSBPdmVybGF5UmVzdWx0VmFsaWRhdG9yLmNvbXB1dGVCb3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlKGEsIGIpO1xuICB0aGlzLl9nZW9tID0gW2EsIGIsIHJlc3VsdF07XG4gIHRoaXMuX2xvY0ZpbmRlciA9IFtuZXcgRnV6enlQb2ludExvY2F0b3IodGhpcy5fZ2VvbVswXSwgdGhpcy5fYm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSksIG5ldyBGdXp6eVBvaW50TG9jYXRvcih0aGlzLl9nZW9tWzFdLCB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlKSwgbmV3IEZ1enp5UG9pbnRMb2NhdG9yKHRoaXMuX2dlb21bMl0sIHRoaXMuX2JvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UpXTtcbn07XG5cbnZhciBzdGF0aWNBY2Nlc3NvcnMkNDYgPSB7IFRPTEVSQU5DRTogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUucmVwb3J0UmVzdWx0ID0gZnVuY3Rpb24gcmVwb3J0UmVzdWx0IChvdmVybGF5T3AsIGxvY2F0aW9uLCBleHBlY3RlZEludGVyaW9yKSB7XG4gIFN5c3RlbS5vdXQucHJpbnRsbignT3ZlcmxheSByZXN1bHQgaW52YWxpZCAtIEE6JyArIExvY2F0aW9uLnRvTG9jYXRpb25TeW1ib2wobG9jYXRpb25bMF0pICsgJyBCOicgKyBMb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sKGxvY2F0aW9uWzFdKSArICcgZXhwZWN0ZWQ6JyArIChleHBlY3RlZEludGVyaW9yID8gJ2knIDogJ2UnKSArICcgYWN0dWFsOicgKyBMb2NhdGlvbi50b0xvY2F0aW9uU3ltYm9sKGxvY2F0aW9uWzJdKSk7XG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKG92ZXJsYXlPcCkge1xuICB0aGlzLmFkZFRlc3RQdHModGhpcy5fZ2VvbVswXSk7XG4gIHRoaXMuYWRkVGVzdFB0cyh0aGlzLl9nZW9tWzFdKTtcbiAgdmFyIGlzVmFsaWQgPSB0aGlzLmNoZWNrVmFsaWQob3ZlcmxheU9wKTtcbiAgcmV0dXJuIGlzVmFsaWRcbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5jaGVja1ZhbGlkID0gZnVuY3Rpb24gY2hlY2tWYWxpZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgb3ZlcmxheU9wID0gYXJndW1lbnRzWzBdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fdGVzdENvb3Jkcy5zaXplKCk7IGkrKykge1xuICAgICAgdmFyIHB0ID0gdGhpcyQxLl90ZXN0Q29vcmRzLmdldChpKTtcbiAgICAgIGlmICghdGhpcyQxLmNoZWNrVmFsaWQob3ZlcmxheU9wLCBwdCkpIHtcbiAgICAgICAgdGhpcyQxLl9pbnZhbGlkTG9jYXRpb24gPSBwdDtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBvdmVybGF5T3AkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgcHQkMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB0aGlzLl9sb2NhdGlvblswXSA9IHRoaXMuX2xvY0ZpbmRlclswXS5nZXRMb2NhdGlvbihwdCQxKTtcbiAgICB0aGlzLl9sb2NhdGlvblsxXSA9IHRoaXMuX2xvY0ZpbmRlclsxXS5nZXRMb2NhdGlvbihwdCQxKTtcbiAgICB0aGlzLl9sb2NhdGlvblsyXSA9IHRoaXMuX2xvY0ZpbmRlclsyXS5nZXRMb2NhdGlvbihwdCQxKTtcbiAgICBpZiAoT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5oYXNMb2NhdGlvbih0aGlzLl9sb2NhdGlvbiwgTG9jYXRpb24uQk9VTkRBUlkpKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gdGhpcy5pc1ZhbGlkUmVzdWx0KG92ZXJsYXlPcCQxLCB0aGlzLl9sb2NhdGlvbilcbiAgfVxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmFkZFRlc3RQdHMgPSBmdW5jdGlvbiBhZGRUZXN0UHRzIChnKSB7XG4gIHZhciBwdEdlbiA9IG5ldyBPZmZzZXRQb2ludEdlbmVyYXRvcihnKTtcbiAgdGhpcy5fdGVzdENvb3Jkcy5hZGRBbGwocHRHZW4uZ2V0UG9pbnRzKDUgKiB0aGlzLl9ib3VuZGFyeURpc3RhbmNlVG9sZXJhbmNlKSk7XG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuaXNWYWxpZFJlc3VsdCA9IGZ1bmN0aW9uIGlzVmFsaWRSZXN1bHQgKG92ZXJsYXlPcCwgbG9jYXRpb24pIHtcbiAgdmFyIGV4cGVjdGVkSW50ZXJpb3IgPSBPdmVybGF5T3AuaXNSZXN1bHRPZk9wKGxvY2F0aW9uWzBdLCBsb2NhdGlvblsxXSwgb3ZlcmxheU9wKTtcbiAgdmFyIHJlc3VsdEluSW50ZXJpb3IgPSBsb2NhdGlvblsyXSA9PT0gTG9jYXRpb24uSU5URVJJT1I7XG4gIHZhciBpc1ZhbGlkID0gIShleHBlY3RlZEludGVyaW9yIF4gcmVzdWx0SW5JbnRlcmlvcik7XG4gIGlmICghaXNWYWxpZCkgeyB0aGlzLnJlcG9ydFJlc3VsdChvdmVybGF5T3AsIGxvY2F0aW9uLCBleHBlY3RlZEludGVyaW9yKTsgfVxuICByZXR1cm4gaXNWYWxpZFxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IucHJvdG90eXBlLmdldEludmFsaWRMb2NhdGlvbiA9IGZ1bmN0aW9uIGdldEludmFsaWRMb2NhdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9pbnZhbGlkTG9jYXRpb25cbn07XG5PdmVybGF5UmVzdWx0VmFsaWRhdG9yLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBPdmVybGF5UmVzdWx0VmFsaWRhdG9yXG59O1xuT3ZlcmxheVJlc3VsdFZhbGlkYXRvci5oYXNMb2NhdGlvbiA9IGZ1bmN0aW9uIGhhc0xvY2F0aW9uIChsb2NhdGlvbiwgbG9jKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKGxvY2F0aW9uW2ldID09PSBsb2MpIHsgcmV0dXJuIHRydWUgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IuY29tcHV0ZUJvdW5kYXJ5RGlzdGFuY2VUb2xlcmFuY2UgPSBmdW5jdGlvbiBjb21wdXRlQm91bmRhcnlEaXN0YW5jZVRvbGVyYW5jZSAoZzAsIGcxKSB7XG4gIHJldHVybiBNYXRoLm1pbihHZW9tZXRyeVNuYXBwZXIuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UoZzApLCBHZW9tZXRyeVNuYXBwZXIuY29tcHV0ZVNpemVCYXNlZFNuYXBUb2xlcmFuY2UoZzEpKVxufTtcbk92ZXJsYXlSZXN1bHRWYWxpZGF0b3IuaXNWYWxpZCA9IGZ1bmN0aW9uIGlzVmFsaWQgKGEsIGIsIG92ZXJsYXlPcCwgcmVzdWx0KSB7XG4gIHZhciB2YWxpZGF0b3IgPSBuZXcgT3ZlcmxheVJlc3VsdFZhbGlkYXRvcihhLCBiLCByZXN1bHQpO1xuICByZXR1cm4gdmFsaWRhdG9yLmlzVmFsaWQob3ZlcmxheU9wKVxufTtcbnN0YXRpY0FjY2Vzc29ycyQ0Ni5UT0xFUkFOQ0UuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMC4wMDAwMDEgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIE92ZXJsYXlSZXN1bHRWYWxpZGF0b3IsIHN0YXRpY0FjY2Vzc29ycyQ0NiApO1xuXG4vLyBvcGVyYXRpb24ub3ZlcmxheVxuXG52YXIgR2VvbWV0cnlDb21iaW5lciA9IGZ1bmN0aW9uIEdlb21ldHJ5Q29tYmluZXIgKGdlb21zKSB7XG4gIHRoaXMuX2dlb21GYWN0b3J5ID0gbnVsbDtcbiAgdGhpcy5fc2tpcEVtcHR5ID0gZmFsc2U7XG4gIHRoaXMuX2lucHV0R2VvbXMgPSBudWxsO1xuICB0aGlzLl9nZW9tRmFjdG9yeSA9IEdlb21ldHJ5Q29tYmluZXIuZXh0cmFjdEZhY3RvcnkoZ2VvbXMpO1xuICB0aGlzLl9pbnB1dEdlb21zID0gZ2VvbXM7XG59O1xuR2VvbWV0cnlDb21iaW5lci5wcm90b3R5cGUuZXh0cmFjdEVsZW1lbnRzID0gZnVuY3Rpb24gZXh0cmFjdEVsZW1lbnRzIChnZW9tLCBlbGVtcykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIGlmIChnZW9tID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmdldE51bUdlb21ldHJpZXMoKTsgaSsrKSB7XG4gICAgdmFyIGVsZW1HZW9tID0gZ2VvbS5nZXRHZW9tZXRyeU4oaSk7XG4gICAgaWYgKHRoaXMkMS5fc2tpcEVtcHR5ICYmIGVsZW1HZW9tLmlzRW1wdHkoKSkgeyBjb250aW51ZSB9XG4gICAgZWxlbXMuYWRkKGVsZW1HZW9tKTtcbiAgfVxufTtcbkdlb21ldHJ5Q29tYmluZXIucHJvdG90eXBlLmNvbWJpbmUgPSBmdW5jdGlvbiBjb21iaW5lICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICB2YXIgZWxlbXMgPSBuZXcgQXJyYXlMaXN0KCk7XG4gIGZvciAodmFyIGkgPSB0aGlzLl9pbnB1dEdlb21zLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBnID0gaS5uZXh0KCk7XG4gICAgdGhpcyQxLmV4dHJhY3RFbGVtZW50cyhnLCBlbGVtcyk7XG4gIH1cbiAgaWYgKGVsZW1zLnNpemUoKSA9PT0gMCkge1xuICAgIGlmICh0aGlzLl9nZW9tRmFjdG9yeSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKVxuICAgIH1cbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KGVsZW1zKVxufTtcbkdlb21ldHJ5Q29tYmluZXIucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5HZW9tZXRyeUNvbWJpbmVyLnByb3RvdHlwZS5nZXRDbGFzcyA9IGZ1bmN0aW9uIGdldENsYXNzICgpIHtcbiAgcmV0dXJuIEdlb21ldHJ5Q29tYmluZXJcbn07XG5HZW9tZXRyeUNvbWJpbmVyLmNvbWJpbmUgPSBmdW5jdGlvbiBjb21iaW5lICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbXMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGNvbWJpbmVyID0gbmV3IEdlb21ldHJ5Q29tYmluZXIoZ2VvbXMpO1xuICAgIHJldHVybiBjb21iaW5lci5jb21iaW5lKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIGcwID0gYXJndW1lbnRzWzBdO1xuICAgIHZhciBnMSA9IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgY29tYmluZXIkMSA9IG5ldyBHZW9tZXRyeUNvbWJpbmVyKEdlb21ldHJ5Q29tYmluZXIuY3JlYXRlTGlzdChnMCwgZzEpKTtcbiAgICByZXR1cm4gY29tYmluZXIkMS5jb21iaW5lKClcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIGcwJDEgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGcxJDEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGcyID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBjb21iaW5lciQyID0gbmV3IEdlb21ldHJ5Q29tYmluZXIoR2VvbWV0cnlDb21iaW5lci5jcmVhdGVMaXN0KGcwJDEsIGcxJDEsIGcyKSk7XG4gICAgcmV0dXJuIGNvbWJpbmVyJDIuY29tYmluZSgpXG4gIH1cbn07XG5HZW9tZXRyeUNvbWJpbmVyLmV4dHJhY3RGYWN0b3J5ID0gZnVuY3Rpb24gZXh0cmFjdEZhY3RvcnkgKGdlb21zKSB7XG4gIGlmIChnZW9tcy5pc0VtcHR5KCkpIHsgcmV0dXJuIG51bGwgfVxuICByZXR1cm4gZ2VvbXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpXG59O1xuR2VvbWV0cnlDb21iaW5lci5jcmVhdGVMaXN0ID0gZnVuY3Rpb24gY3JlYXRlTGlzdCAoKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgdmFyIG9iajAgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIG9iajEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGxpc3QgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgbGlzdC5hZGQob2JqMCk7XG4gICAgbGlzdC5hZGQob2JqMSk7XG4gICAgcmV0dXJuIGxpc3RcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgdmFyIG9iajAkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgb2JqMSQxID0gYXJndW1lbnRzWzFdO1xuICAgIHZhciBvYmoyID0gYXJndW1lbnRzWzJdO1xuICAgIHZhciBsaXN0JDEgPSBuZXcgQXJyYXlMaXN0KCk7XG4gICAgbGlzdCQxLmFkZChvYmowJDEpO1xuICAgIGxpc3QkMS5hZGQob2JqMSQxKTtcbiAgICBsaXN0JDEuYWRkKG9iajIpO1xuICAgIHJldHVybiBsaXN0JDFcbiAgfVxufTtcblxudmFyIENhc2NhZGVkUG9seWdvblVuaW9uID0gZnVuY3Rpb24gQ2FzY2FkZWRQb2x5Z29uVW5pb24gKCkge1xuICB0aGlzLl9pbnB1dFBvbHlzID0gbnVsbDtcbiAgdGhpcy5fZ2VvbUZhY3RvcnkgPSBudWxsO1xuICB2YXIgcG9seXMgPSBhcmd1bWVudHNbMF07XG4gIHRoaXMuX2lucHV0UG9seXMgPSBwb2x5cztcbiAgaWYgKHRoaXMuX2lucHV0UG9seXMgPT09IG51bGwpIHsgdGhpcy5faW5wdXRQb2x5cyA9IG5ldyBBcnJheUxpc3QoKTsgfVxufTtcblxudmFyIHN0YXRpY0FjY2Vzc29ycyQ0NyA9IHsgU1RSVFJFRV9OT0RFX0NBUEFDSVRZOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUucmVkdWNlVG9HZW9tZXRyaWVzID0gZnVuY3Rpb24gcmVkdWNlVG9HZW9tZXRyaWVzIChnZW9tVHJlZSkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBnZW9tcyA9IG5ldyBBcnJheUxpc3QoKTtcbiAgZm9yICh2YXIgaSA9IGdlb21UcmVlLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBvID0gaS5uZXh0KCk7XG4gICAgdmFyIGdlb20gPSBudWxsO1xuICAgIGlmIChoYXNJbnRlcmZhY2UobywgTGlzdCkpIHtcbiAgICAgIGdlb20gPSB0aGlzJDEudW5pb25UcmVlKG8pO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIEdlb21ldHJ5KSB7XG4gICAgICBnZW9tID0gbztcbiAgICB9XG4gICAgZ2VvbXMuYWRkKGdlb20pO1xuICB9XG4gIHJldHVybiBnZW9tc1xufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5leHRyYWN0QnlFbnZlbG9wZSA9IGZ1bmN0aW9uIGV4dHJhY3RCeUVudmVsb3BlIChlbnYsIGdlb20sIGRpc2pvaW50R2VvbXMpIHtcbiAgdmFyIGludGVyc2VjdGluZ0dlb21zID0gbmV3IEFycmF5TGlzdCgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGdlb20uZ2V0TnVtR2VvbWV0cmllcygpOyBpKyspIHtcbiAgICB2YXIgZWxlbSA9IGdlb20uZ2V0R2VvbWV0cnlOKGkpO1xuICAgIGlmIChlbGVtLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGVudikpIHsgaW50ZXJzZWN0aW5nR2VvbXMuYWRkKGVsZW0pOyB9IGVsc2UgeyBkaXNqb2ludEdlb21zLmFkZChlbGVtKTsgfVxuICB9XG4gIHJldHVybiB0aGlzLl9nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KGludGVyc2VjdGluZ0dlb21zKVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS51bmlvbk9wdGltaXplZCA9IGZ1bmN0aW9uIHVuaW9uT3B0aW1pemVkIChnMCwgZzEpIHtcbiAgdmFyIGcwRW52ID0gZzAuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO1xuICB2YXIgZzFFbnYgPSBnMS5nZXRFbnZlbG9wZUludGVybmFsKCk7XG4gIGlmICghZzBFbnYuaW50ZXJzZWN0cyhnMUVudikpIHtcbiAgICB2YXIgY29tYm8gPSBHZW9tZXRyeUNvbWJpbmVyLmNvbWJpbmUoZzAsIGcxKTtcbiAgICByZXR1cm4gY29tYm9cbiAgfVxuICBpZiAoZzAuZ2V0TnVtR2VvbWV0cmllcygpIDw9IDEgJiYgZzEuZ2V0TnVtR2VvbWV0cmllcygpIDw9IDEpIHsgcmV0dXJuIHRoaXMudW5pb25BY3R1YWwoZzAsIGcxKSB9XG4gIHZhciBjb21tb25FbnYgPSBnMEVudi5pbnRlcnNlY3Rpb24oZzFFbnYpO1xuICByZXR1cm4gdGhpcy51bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb24oZzAsIGcxLCBjb21tb25FbnYpXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24gdW5pb24gKCkge1xuICBpZiAodGhpcy5faW5wdXRQb2x5cyA9PT0gbnVsbCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3VuaW9uKCkgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UnKSB9XG4gIGlmICh0aGlzLl9pbnB1dFBvbHlzLmlzRW1wdHkoKSkgeyByZXR1cm4gbnVsbCB9XG4gIHRoaXMuX2dlb21GYWN0b3J5ID0gdGhpcy5faW5wdXRQb2x5cy5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCk7XG4gIHZhciBpbmRleCA9IG5ldyBTVFJ0cmVlKENhc2NhZGVkUG9seWdvblVuaW9uLlNUUlRSRUVfTk9ERV9DQVBBQ0lUWSk7XG4gIGZvciAodmFyIGkgPSB0aGlzLl9pbnB1dFBvbHlzLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBpdGVtID0gaS5uZXh0KCk7XG4gICAgaW5kZXguaW5zZXJ0KGl0ZW0uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLCBpdGVtKTtcbiAgfVxuICB0aGlzLl9pbnB1dFBvbHlzID0gbnVsbDtcbiAgdmFyIGl0ZW1UcmVlID0gaW5kZXguaXRlbXNUcmVlKCk7XG4gIHZhciB1bmlvbkFsbCA9IHRoaXMudW5pb25UcmVlKGl0ZW1UcmVlKTtcbiAgcmV0dXJuIHVuaW9uQWxsXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLmJpbmFyeVVuaW9uID0gZnVuY3Rpb24gYmluYXJ5VW5pb24gKCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgIHZhciBnZW9tcyA9IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gdGhpcy5iaW5hcnlVbmlvbihnZW9tcywgMCwgZ2VvbXMuc2l6ZSgpKVxuICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICB2YXIgZ2VvbXMkMSA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgc3RhcnQgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGVuZCA9IGFyZ3VtZW50c1syXTtcbiAgICBpZiAoZW5kIC0gc3RhcnQgPD0gMSkge1xuICAgICAgdmFyIGcwID0gQ2FzY2FkZWRQb2x5Z29uVW5pb24uZ2V0R2VvbWV0cnkoZ2VvbXMkMSwgc3RhcnQpO1xuICAgICAgcmV0dXJuIHRoaXMudW5pb25TYWZlKGcwLCBudWxsKVxuICAgIH0gZWxzZSBpZiAoZW5kIC0gc3RhcnQgPT09IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLnVuaW9uU2FmZShDYXNjYWRlZFBvbHlnb25Vbmlvbi5nZXRHZW9tZXRyeShnZW9tcyQxLCBzdGFydCksIENhc2NhZGVkUG9seWdvblVuaW9uLmdldEdlb21ldHJ5KGdlb21zJDEsIHN0YXJ0ICsgMSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtaWQgPSBNYXRoLnRydW5jKChlbmQgKyBzdGFydCkgLyAyKTtcbiAgICAgIHZhciBnMCQxID0gdGhpcy5iaW5hcnlVbmlvbihnZW9tcyQxLCBzdGFydCwgbWlkKTtcbiAgICAgIHZhciBnMSA9IHRoaXMuYmluYXJ5VW5pb24oZ2VvbXMkMSwgbWlkLCBlbmQpO1xuICAgICAgcmV0dXJuIHRoaXMudW5pb25TYWZlKGcwJDEsIGcxKVxuICAgIH1cbiAgfVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5yZXBlYXRlZFVuaW9uID0gZnVuY3Rpb24gcmVwZWF0ZWRVbmlvbiAoZ2VvbXMpIHtcbiAgdmFyIHVuaW9uID0gbnVsbDtcbiAgZm9yICh2YXIgaSA9IGdlb21zLml0ZXJhdG9yKCk7IGkuaGFzTmV4dCgpOykge1xuICAgIHZhciBnID0gaS5uZXh0KCk7XG4gICAgaWYgKHVuaW9uID09PSBudWxsKSB7IHVuaW9uID0gZy5jb3B5KCk7IH0gZWxzZSB7IHVuaW9uID0gdW5pb24udW5pb24oZyk7IH1cbiAgfVxuICByZXR1cm4gdW5pb25cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb25TYWZlID0gZnVuY3Rpb24gdW5pb25TYWZlIChnMCwgZzEpIHtcbiAgaWYgKGcwID09PSBudWxsICYmIGcxID09PSBudWxsKSB7IHJldHVybiBudWxsIH1cbiAgaWYgKGcwID09PSBudWxsKSB7IHJldHVybiBnMS5jb3B5KCkgfVxuICBpZiAoZzEgPT09IG51bGwpIHsgcmV0dXJuIGcwLmNvcHkoKSB9XG4gIHJldHVybiB0aGlzLnVuaW9uT3B0aW1pemVkKGcwLCBnMSlcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUudW5pb25BY3R1YWwgPSBmdW5jdGlvbiB1bmlvbkFjdHVhbCAoZzAsIGcxKSB7XG4gIHJldHVybiBDYXNjYWRlZFBvbHlnb25Vbmlvbi5yZXN0cmljdFRvUG9seWdvbnMoZzAudW5pb24oZzEpKVxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS51bmlvblRyZWUgPSBmdW5jdGlvbiB1bmlvblRyZWUgKGdlb21UcmVlKSB7XG4gIHZhciBnZW9tcyA9IHRoaXMucmVkdWNlVG9HZW9tZXRyaWVzKGdlb21UcmVlKTtcbiAgdmFyIHVuaW9uID0gdGhpcy5iaW5hcnlVbmlvbihnZW9tcyk7XG4gIHJldHVybiB1bmlvblxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS51bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb24gPSBmdW5jdGlvbiB1bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb24gKGcwLCBnMSwgY29tbW9uKSB7XG4gIHZhciBkaXNqb2ludFBvbHlzID0gbmV3IEFycmF5TGlzdCgpO1xuICB2YXIgZzBJbnQgPSB0aGlzLmV4dHJhY3RCeUVudmVsb3BlKGNvbW1vbiwgZzAsIGRpc2pvaW50UG9seXMpO1xuICB2YXIgZzFJbnQgPSB0aGlzLmV4dHJhY3RCeUVudmVsb3BlKGNvbW1vbiwgZzEsIGRpc2pvaW50UG9seXMpO1xuICB2YXIgdW5pb24gPSB0aGlzLnVuaW9uQWN0dWFsKGcwSW50LCBnMUludCk7XG4gIGRpc2pvaW50UG9seXMuYWRkKHVuaW9uKTtcbiAgdmFyIG92ZXJhbGxVbmlvbiA9IEdlb21ldHJ5Q29tYmluZXIuY29tYmluZShkaXNqb2ludFBvbHlzKTtcbiAgcmV0dXJuIG92ZXJhbGxVbmlvblxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnByb3RvdHlwZS5idWZmZXJVbmlvbiA9IGZ1bmN0aW9uIGJ1ZmZlclVuaW9uICgpIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgZ2VvbXMgPSBhcmd1bWVudHNbMF07XG4gICAgdmFyIGZhY3RvcnkgPSBnZW9tcy5nZXQoMCkuZ2V0RmFjdG9yeSgpO1xuICAgIHZhciBnQ29sbCA9IGZhY3RvcnkuYnVpbGRHZW9tZXRyeShnZW9tcyk7XG4gICAgdmFyIHVuaW9uQWxsID0gZ0NvbGwuYnVmZmVyKDAuMCk7XG4gICAgcmV0dXJuIHVuaW9uQWxsXG4gIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgIHZhciBnMCA9IGFyZ3VtZW50c1swXTtcbiAgICB2YXIgZzEgPSBhcmd1bWVudHNbMV07XG4gICAgdmFyIGZhY3RvcnkkMSA9IGcwLmdldEZhY3RvcnkoKTtcbiAgICB2YXIgZ0NvbGwkMSA9IGZhY3RvcnkkMS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oW2cwLCBnMV0pO1xuICAgIHZhciB1bmlvbkFsbCQxID0gZ0NvbGwkMS5idWZmZXIoMC4wKTtcbiAgICByZXR1cm4gdW5pb25BbGwkMVxuICB9XG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24ucHJvdG90eXBlLmludGVyZmFjZXNfID0gZnVuY3Rpb24gaW50ZXJmYWNlc18gKCkge1xuICByZXR1cm4gW11cbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBDYXNjYWRlZFBvbHlnb25VbmlvblxufTtcbkNhc2NhZGVkUG9seWdvblVuaW9uLnJlc3RyaWN0VG9Qb2x5Z29ucyA9IGZ1bmN0aW9uIHJlc3RyaWN0VG9Qb2x5Z29ucyAoZykge1xuICBpZiAoaGFzSW50ZXJmYWNlKGcsIFBvbHlnb25hbCkpIHtcbiAgICByZXR1cm4gZ1xuICB9XG4gIHZhciBwb2x5Z29ucyA9IFBvbHlnb25FeHRyYWN0ZXIuZ2V0UG9seWdvbnMoZyk7XG4gIGlmIChwb2x5Z29ucy5zaXplKCkgPT09IDEpIHsgcmV0dXJuIHBvbHlnb25zLmdldCgwKSB9XG4gIHJldHVybiBnLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oR2VvbWV0cnlGYWN0b3J5LnRvUG9seWdvbkFycmF5KHBvbHlnb25zKSlcbn07XG5DYXNjYWRlZFBvbHlnb25Vbmlvbi5nZXRHZW9tZXRyeSA9IGZ1bmN0aW9uIGdldEdlb21ldHJ5IChsaXN0LCBpbmRleCkge1xuICBpZiAoaW5kZXggPj0gbGlzdC5zaXplKCkpIHsgcmV0dXJuIG51bGwgfVxuICByZXR1cm4gbGlzdC5nZXQoaW5kZXgpXG59O1xuQ2FzY2FkZWRQb2x5Z29uVW5pb24udW5pb24gPSBmdW5jdGlvbiB1bmlvbiAocG9seXMpIHtcbiAgdmFyIG9wID0gbmV3IENhc2NhZGVkUG9seWdvblVuaW9uKHBvbHlzKTtcbiAgcmV0dXJuIG9wLnVuaW9uKClcbn07XG5zdGF0aWNBY2Nlc3NvcnMkNDcuU1RSVFJFRV9OT0RFX0NBUEFDSVRZLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQgfTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIENhc2NhZGVkUG9seWdvblVuaW9uLCBzdGF0aWNBY2Nlc3NvcnMkNDcgKTtcblxudmFyIFVuaW9uT3AgPSBmdW5jdGlvbiBVbmlvbk9wICgpIHt9O1xuXG5Vbmlvbk9wLnByb3RvdHlwZS5pbnRlcmZhY2VzXyA9IGZ1bmN0aW9uIGludGVyZmFjZXNfICgpIHtcbiAgcmV0dXJuIFtdXG59O1xuVW5pb25PcC5wcm90b3R5cGUuZ2V0Q2xhc3MgPSBmdW5jdGlvbiBnZXRDbGFzcyAoKSB7XG4gIHJldHVybiBVbmlvbk9wXG59O1xuVW5pb25PcC51bmlvbiA9IGZ1bmN0aW9uIHVuaW9uIChnLCBvdGhlcikge1xuICBpZiAoZy5pc0VtcHR5KCkgfHwgb3RoZXIuaXNFbXB0eSgpKSB7XG4gICAgaWYgKGcuaXNFbXB0eSgpICYmIG90aGVyLmlzRW1wdHkoKSkgeyByZXR1cm4gT3ZlcmxheU9wLmNyZWF0ZUVtcHR5UmVzdWx0KE92ZXJsYXlPcC5VTklPTiwgZywgb3RoZXIsIGcuZ2V0RmFjdG9yeSgpKSB9XG4gICAgaWYgKGcuaXNFbXB0eSgpKSB7IHJldHVybiBvdGhlci5jb3B5KCkgfVxuICAgIGlmIChvdGhlci5pc0VtcHR5KCkpIHsgcmV0dXJuIGcuY29weSgpIH1cbiAgfVxuICBnLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGcpO1xuICBnLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKG90aGVyKTtcbiAgcmV0dXJuIFNuYXBJZk5lZWRlZE92ZXJsYXlPcC5vdmVybGF5T3AoZywgb3RoZXIsIE92ZXJsYXlPcC5VTklPTilcbn07XG5cbi8vIG9wZXJhdGlvbi51bmlvblxuXG4vLyBvcGVyYXRpb25cblxuLyoqXG4gKiBQb2x5ZmlsbCBmb3IgSUUgc3VwcG9ydFxuICovXG5cbmV4cG9ydHMuR2VvSlNPTlJlYWRlciA9IEdlb0pTT05SZWFkZXI7XG5leHBvcnRzLkdlb0pTT05Xcml0ZXIgPSBHZW9KU09OV3JpdGVyO1xuZXhwb3J0cy5PdmVybGF5T3AgPSBPdmVybGF5T3A7XG5leHBvcnRzLlVuaW9uT3AgPSBVbmlvbk9wO1xuZXhwb3J0cy5CdWZmZXJPcCA9IEJ1ZmZlck9wO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/turf-jsts@1.2.3/node_modules/turf-jsts/jsts.js\n");

/***/ })

};
;
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/splaytree@3.1.2";
exports.ids = ["vendor-chunks/splaytree@3.1.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/splaytree@3.1.2/node_modules/splaytree/dist/splay.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/.pnpm/splaytree@3.1.2/node_modules/splaytree/dist/splay.js ***!
  \*********************************************************************************/
/***/ (function(module) {

eval("/**\n * splaytree v3.1.2\n * Fast Splay tree for Node and browser\n *\n * @author Alexander Milevski <info@w8r.name>\n * @license MIT\n * @preserve\n */\n\n(function (global, factory) {\n     true ? module.exports = factory() :\n    0;\n}(this, (function () { 'use strict';\n\n    /*! *****************************************************************************\r\n    Copyright (c) Microsoft Corporation. All rights reserved.\r\n    Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\n    this file except in compliance with the License. You may obtain a copy of the\r\n    License at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\n    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\n    MERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\n    See the Apache Version 2.0 License for specific language governing permissions\r\n    and limitations under the License.\r\n    ***************************************************************************** */\r\n\r\n    function __generator(thisArg, body) {\r\n        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n        return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n        function verb(n) { return function (v) { return step([n, v]); }; }\r\n        function step(op) {\r\n            if (f) throw new TypeError(\"Generator is already executing.\");\r\n            while (_) try {\r\n                if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n                if (y = 0, t) op = [op[0] & 2, t.value];\r\n                switch (op[0]) {\r\n                    case 0: case 1: t = op; break;\r\n                    case 4: _.label++; return { value: op[1], done: false };\r\n                    case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                    case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                    default:\r\n                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                        if (t[2]) _.ops.pop();\r\n                        _.trys.pop(); continue;\r\n                }\r\n                op = body.call(thisArg, _);\r\n            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n        }\r\n    }\n\n    var Node = /** @class */ (function () {\r\n        function Node(key, data) {\r\n            this.next = null;\r\n            this.key = key;\r\n            this.data = data;\r\n            this.left = null;\r\n            this.right = null;\r\n        }\r\n        return Node;\r\n    }());\n\n    /* follows \"An implementation of top-down splaying\"\r\n     * by D. Sleator <sleator@cs.cmu.edu> March 1992\r\n     */\r\n    function DEFAULT_COMPARE(a, b) {\r\n        return a > b ? 1 : a < b ? -1 : 0;\r\n    }\r\n    /**\r\n     * Simple top down splay, not requiring i to be in the tree t.\r\n     */\r\n    function splay(i, t, comparator) {\r\n        var N = new Node(null, null);\r\n        var l = N;\r\n        var r = N;\r\n        while (true) {\r\n            var cmp = comparator(i, t.key);\r\n            //if (i < t.key) {\r\n            if (cmp < 0) {\r\n                if (t.left === null)\r\n                    break;\r\n                //if (i < t.left.key) {\r\n                if (comparator(i, t.left.key) < 0) {\r\n                    var y = t.left; /* rotate right */\r\n                    t.left = y.right;\r\n                    y.right = t;\r\n                    t = y;\r\n                    if (t.left === null)\r\n                        break;\r\n                }\r\n                r.left = t; /* link right */\r\n                r = t;\r\n                t = t.left;\r\n                //} else if (i > t.key) {\r\n            }\r\n            else if (cmp > 0) {\r\n                if (t.right === null)\r\n                    break;\r\n                //if (i > t.right.key) {\r\n                if (comparator(i, t.right.key) > 0) {\r\n                    var y = t.right; /* rotate left */\r\n                    t.right = y.left;\r\n                    y.left = t;\r\n                    t = y;\r\n                    if (t.right === null)\r\n                        break;\r\n                }\r\n                l.right = t; /* link left */\r\n                l = t;\r\n                t = t.right;\r\n            }\r\n            else\r\n                break;\r\n        }\r\n        /* assemble */\r\n        l.right = t.left;\r\n        r.left = t.right;\r\n        t.left = N.right;\r\n        t.right = N.left;\r\n        return t;\r\n    }\r\n    function insert(i, data, t, comparator) {\r\n        var node = new Node(i, data);\r\n        if (t === null) {\r\n            node.left = node.right = null;\r\n            return node;\r\n        }\r\n        t = splay(i, t, comparator);\r\n        var cmp = comparator(i, t.key);\r\n        if (cmp < 0) {\r\n            node.left = t.left;\r\n            node.right = t;\r\n            t.left = null;\r\n        }\r\n        else if (cmp >= 0) {\r\n            node.right = t.right;\r\n            node.left = t;\r\n            t.right = null;\r\n        }\r\n        return node;\r\n    }\r\n    function split(key, v, comparator) {\r\n        var left = null;\r\n        var right = null;\r\n        if (v) {\r\n            v = splay(key, v, comparator);\r\n            var cmp = comparator(v.key, key);\r\n            if (cmp === 0) {\r\n                left = v.left;\r\n                right = v.right;\r\n            }\r\n            else if (cmp < 0) {\r\n                right = v.right;\r\n                v.right = null;\r\n                left = v;\r\n            }\r\n            else {\r\n                left = v.left;\r\n                v.left = null;\r\n                right = v;\r\n            }\r\n        }\r\n        return { left: left, right: right };\r\n    }\r\n    function merge(left, right, comparator) {\r\n        if (right === null)\r\n            return left;\r\n        if (left === null)\r\n            return right;\r\n        right = splay(left.key, right, comparator);\r\n        right.left = left;\r\n        return right;\r\n    }\r\n    /**\r\n     * Prints level of the tree\r\n     */\r\n    function printRow(root, prefix, isTail, out, printNode) {\r\n        if (root) {\r\n            out(\"\" + prefix + (isTail ? '└── ' : '├── ') + printNode(root) + \"\\n\");\r\n            var indent = prefix + (isTail ? '    ' : '│   ');\r\n            if (root.left)\r\n                printRow(root.left, indent, false, out, printNode);\r\n            if (root.right)\r\n                printRow(root.right, indent, true, out, printNode);\r\n        }\r\n    }\r\n    var Tree = /** @class */ (function () {\r\n        function Tree(comparator) {\r\n            if (comparator === void 0) { comparator = DEFAULT_COMPARE; }\r\n            this._root = null;\r\n            this._size = 0;\r\n            this._comparator = comparator;\r\n        }\r\n        /**\r\n         * Inserts a key, allows duplicates\r\n         */\r\n        Tree.prototype.insert = function (key, data) {\r\n            this._size++;\r\n            return this._root = insert(key, data, this._root, this._comparator);\r\n        };\r\n        /**\r\n         * Adds a key, if it is not present in the tree\r\n         */\r\n        Tree.prototype.add = function (key, data) {\r\n            var node = new Node(key, data);\r\n            if (this._root === null) {\r\n                node.left = node.right = null;\r\n                this._size++;\r\n                this._root = node;\r\n            }\r\n            var comparator = this._comparator;\r\n            var t = splay(key, this._root, comparator);\r\n            var cmp = comparator(key, t.key);\r\n            if (cmp === 0)\r\n                this._root = t;\r\n            else {\r\n                if (cmp < 0) {\r\n                    node.left = t.left;\r\n                    node.right = t;\r\n                    t.left = null;\r\n                }\r\n                else if (cmp > 0) {\r\n                    node.right = t.right;\r\n                    node.left = t;\r\n                    t.right = null;\r\n                }\r\n                this._size++;\r\n                this._root = node;\r\n            }\r\n            return this._root;\r\n        };\r\n        /**\r\n         * @param  {Key} key\r\n         * @return {Node|null}\r\n         */\r\n        Tree.prototype.remove = function (key) {\r\n            this._root = this._remove(key, this._root, this._comparator);\r\n        };\r\n        /**\r\n         * Deletes i from the tree if it's there\r\n         */\r\n        Tree.prototype._remove = function (i, t, comparator) {\r\n            var x;\r\n            if (t === null)\r\n                return null;\r\n            t = splay(i, t, comparator);\r\n            var cmp = comparator(i, t.key);\r\n            if (cmp === 0) { /* found it */\r\n                if (t.left === null) {\r\n                    x = t.right;\r\n                }\r\n                else {\r\n                    x = splay(i, t.left, comparator);\r\n                    x.right = t.right;\r\n                }\r\n                this._size--;\r\n                return x;\r\n            }\r\n            return t; /* It wasn't there */\r\n        };\r\n        /**\r\n         * Removes and returns the node with smallest key\r\n         */\r\n        Tree.prototype.pop = function () {\r\n            var node = this._root;\r\n            if (node) {\r\n                while (node.left)\r\n                    node = node.left;\r\n                this._root = splay(node.key, this._root, this._comparator);\r\n                this._root = this._remove(node.key, this._root, this._comparator);\r\n                return { key: node.key, data: node.data };\r\n            }\r\n            return null;\r\n        };\r\n        /**\r\n         * Find without splaying\r\n         */\r\n        Tree.prototype.findStatic = function (key) {\r\n            var current = this._root;\r\n            var compare = this._comparator;\r\n            while (current) {\r\n                var cmp = compare(key, current.key);\r\n                if (cmp === 0)\r\n                    return current;\r\n                else if (cmp < 0)\r\n                    current = current.left;\r\n                else\r\n                    current = current.right;\r\n            }\r\n            return null;\r\n        };\r\n        Tree.prototype.find = function (key) {\r\n            if (this._root) {\r\n                this._root = splay(key, this._root, this._comparator);\r\n                if (this._comparator(key, this._root.key) !== 0)\r\n                    return null;\r\n            }\r\n            return this._root;\r\n        };\r\n        Tree.prototype.contains = function (key) {\r\n            var current = this._root;\r\n            var compare = this._comparator;\r\n            while (current) {\r\n                var cmp = compare(key, current.key);\r\n                if (cmp === 0)\r\n                    return true;\r\n                else if (cmp < 0)\r\n                    current = current.left;\r\n                else\r\n                    current = current.right;\r\n            }\r\n            return false;\r\n        };\r\n        Tree.prototype.forEach = function (visitor, ctx) {\r\n            var current = this._root;\r\n            var Q = []; /* Initialize stack s */\r\n            var done = false;\r\n            while (!done) {\r\n                if (current !== null) {\r\n                    Q.push(current);\r\n                    current = current.left;\r\n                }\r\n                else {\r\n                    if (Q.length !== 0) {\r\n                        current = Q.pop();\r\n                        visitor.call(ctx, current);\r\n                        current = current.right;\r\n                    }\r\n                    else\r\n                        done = true;\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Walk key range from `low` to `high`. Stops if `fn` returns a value.\r\n         */\r\n        Tree.prototype.range = function (low, high, fn, ctx) {\r\n            var Q = [];\r\n            var compare = this._comparator;\r\n            var node = this._root;\r\n            var cmp;\r\n            while (Q.length !== 0 || node) {\r\n                if (node) {\r\n                    Q.push(node);\r\n                    node = node.left;\r\n                }\r\n                else {\r\n                    node = Q.pop();\r\n                    cmp = compare(node.key, high);\r\n                    if (cmp > 0) {\r\n                        break;\r\n                    }\r\n                    else if (compare(node.key, low) >= 0) {\r\n                        if (fn.call(ctx, node))\r\n                            return this; // stop if smth is returned\r\n                    }\r\n                    node = node.right;\r\n                }\r\n            }\r\n            return this;\r\n        };\r\n        /**\r\n         * Returns array of keys\r\n         */\r\n        Tree.prototype.keys = function () {\r\n            var keys = [];\r\n            this.forEach(function (_a) {\r\n                var key = _a.key;\r\n                return keys.push(key);\r\n            });\r\n            return keys;\r\n        };\r\n        /**\r\n         * Returns array of all the data in the nodes\r\n         */\r\n        Tree.prototype.values = function () {\r\n            var values = [];\r\n            this.forEach(function (_a) {\r\n                var data = _a.data;\r\n                return values.push(data);\r\n            });\r\n            return values;\r\n        };\r\n        Tree.prototype.min = function () {\r\n            if (this._root)\r\n                return this.minNode(this._root).key;\r\n            return null;\r\n        };\r\n        Tree.prototype.max = function () {\r\n            if (this._root)\r\n                return this.maxNode(this._root).key;\r\n            return null;\r\n        };\r\n        Tree.prototype.minNode = function (t) {\r\n            if (t === void 0) { t = this._root; }\r\n            if (t)\r\n                while (t.left)\r\n                    t = t.left;\r\n            return t;\r\n        };\r\n        Tree.prototype.maxNode = function (t) {\r\n            if (t === void 0) { t = this._root; }\r\n            if (t)\r\n                while (t.right)\r\n                    t = t.right;\r\n            return t;\r\n        };\r\n        /**\r\n         * Returns node at given index\r\n         */\r\n        Tree.prototype.at = function (index) {\r\n            var current = this._root;\r\n            var done = false;\r\n            var i = 0;\r\n            var Q = [];\r\n            while (!done) {\r\n                if (current) {\r\n                    Q.push(current);\r\n                    current = current.left;\r\n                }\r\n                else {\r\n                    if (Q.length > 0) {\r\n                        current = Q.pop();\r\n                        if (i === index)\r\n                            return current;\r\n                        i++;\r\n                        current = current.right;\r\n                    }\r\n                    else\r\n                        done = true;\r\n                }\r\n            }\r\n            return null;\r\n        };\r\n        Tree.prototype.next = function (d) {\r\n            var root = this._root;\r\n            var successor = null;\r\n            if (d.right) {\r\n                successor = d.right;\r\n                while (successor.left)\r\n                    successor = successor.left;\r\n                return successor;\r\n            }\r\n            var comparator = this._comparator;\r\n            while (root) {\r\n                var cmp = comparator(d.key, root.key);\r\n                if (cmp === 0)\r\n                    break;\r\n                else if (cmp < 0) {\r\n                    successor = root;\r\n                    root = root.left;\r\n                }\r\n                else\r\n                    root = root.right;\r\n            }\r\n            return successor;\r\n        };\r\n        Tree.prototype.prev = function (d) {\r\n            var root = this._root;\r\n            var predecessor = null;\r\n            if (d.left !== null) {\r\n                predecessor = d.left;\r\n                while (predecessor.right)\r\n                    predecessor = predecessor.right;\r\n                return predecessor;\r\n            }\r\n            var comparator = this._comparator;\r\n            while (root) {\r\n                var cmp = comparator(d.key, root.key);\r\n                if (cmp === 0)\r\n                    break;\r\n                else if (cmp < 0)\r\n                    root = root.left;\r\n                else {\r\n                    predecessor = root;\r\n                    root = root.right;\r\n                }\r\n            }\r\n            return predecessor;\r\n        };\r\n        Tree.prototype.clear = function () {\r\n            this._root = null;\r\n            this._size = 0;\r\n            return this;\r\n        };\r\n        Tree.prototype.toList = function () {\r\n            return toList(this._root);\r\n        };\r\n        /**\r\n         * Bulk-load items. Both array have to be same size\r\n         */\r\n        Tree.prototype.load = function (keys, values, presort) {\r\n            if (values === void 0) { values = []; }\r\n            if (presort === void 0) { presort = false; }\r\n            var size = keys.length;\r\n            var comparator = this._comparator;\r\n            // sort if needed\r\n            if (presort)\r\n                sort(keys, values, 0, size - 1, comparator);\r\n            if (this._root === null) { // empty tree\r\n                this._root = loadRecursive(keys, values, 0, size);\r\n                this._size = size;\r\n            }\r\n            else { // that re-builds the whole tree from two in-order traversals\r\n                var mergedList = mergeLists(this.toList(), createList(keys, values), comparator);\r\n                size = this._size + size;\r\n                this._root = sortedListToBST({ head: mergedList }, 0, size);\r\n            }\r\n            return this;\r\n        };\r\n        Tree.prototype.isEmpty = function () { return this._root === null; };\r\n        Object.defineProperty(Tree.prototype, \"size\", {\r\n            get: function () { return this._size; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(Tree.prototype, \"root\", {\r\n            get: function () { return this._root; },\r\n            enumerable: true,\r\n            configurable: true\r\n        });\r\n        Tree.prototype.toString = function (printNode) {\r\n            if (printNode === void 0) { printNode = function (n) { return String(n.key); }; }\r\n            var out = [];\r\n            printRow(this._root, '', true, function (v) { return out.push(v); }, printNode);\r\n            return out.join('');\r\n        };\r\n        Tree.prototype.update = function (key, newKey, newData) {\r\n            var comparator = this._comparator;\r\n            var _a = split(key, this._root, comparator), left = _a.left, right = _a.right;\r\n            if (comparator(key, newKey) < 0) {\r\n                right = insert(newKey, newData, right, comparator);\r\n            }\r\n            else {\r\n                left = insert(newKey, newData, left, comparator);\r\n            }\r\n            this._root = merge(left, right, comparator);\r\n        };\r\n        Tree.prototype.split = function (key) {\r\n            return split(key, this._root, this._comparator);\r\n        };\r\n        Tree.prototype[Symbol.iterator] = function () {\r\n            var current, Q, done;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        current = this._root;\r\n                        Q = [];\r\n                        done = false;\r\n                        _a.label = 1;\r\n                    case 1:\r\n                        if (!!done) return [3 /*break*/, 6];\r\n                        if (!(current !== null)) return [3 /*break*/, 2];\r\n                        Q.push(current);\r\n                        current = current.left;\r\n                        return [3 /*break*/, 5];\r\n                    case 2:\r\n                        if (!(Q.length !== 0)) return [3 /*break*/, 4];\r\n                        current = Q.pop();\r\n                        return [4 /*yield*/, current];\r\n                    case 3:\r\n                        _a.sent();\r\n                        current = current.right;\r\n                        return [3 /*break*/, 5];\r\n                    case 4:\r\n                        done = true;\r\n                        _a.label = 5;\r\n                    case 5: return [3 /*break*/, 1];\r\n                    case 6: return [2 /*return*/];\r\n                }\r\n            });\r\n        };\r\n        return Tree;\r\n    }());\r\n    function loadRecursive(keys, values, start, end) {\r\n        var size = end - start;\r\n        if (size > 0) {\r\n            var middle = start + Math.floor(size / 2);\r\n            var key = keys[middle];\r\n            var data = values[middle];\r\n            var node = new Node(key, data);\r\n            node.left = loadRecursive(keys, values, start, middle);\r\n            node.right = loadRecursive(keys, values, middle + 1, end);\r\n            return node;\r\n        }\r\n        return null;\r\n    }\r\n    function createList(keys, values) {\r\n        var head = new Node(null, null);\r\n        var p = head;\r\n        for (var i = 0; i < keys.length; i++) {\r\n            p = p.next = new Node(keys[i], values[i]);\r\n        }\r\n        p.next = null;\r\n        return head.next;\r\n    }\r\n    function toList(root) {\r\n        var current = root;\r\n        var Q = [];\r\n        var done = false;\r\n        var head = new Node(null, null);\r\n        var p = head;\r\n        while (!done) {\r\n            if (current) {\r\n                Q.push(current);\r\n                current = current.left;\r\n            }\r\n            else {\r\n                if (Q.length > 0) {\r\n                    current = p = p.next = Q.pop();\r\n                    current = current.right;\r\n                }\r\n                else\r\n                    done = true;\r\n            }\r\n        }\r\n        p.next = null; // that'll work even if the tree was empty\r\n        return head.next;\r\n    }\r\n    function sortedListToBST(list, start, end) {\r\n        var size = end - start;\r\n        if (size > 0) {\r\n            var middle = start + Math.floor(size / 2);\r\n            var left = sortedListToBST(list, start, middle);\r\n            var root = list.head;\r\n            root.left = left;\r\n            list.head = list.head.next;\r\n            root.right = sortedListToBST(list, middle + 1, end);\r\n            return root;\r\n        }\r\n        return null;\r\n    }\r\n    function mergeLists(l1, l2, compare) {\r\n        var head = new Node(null, null); // dummy\r\n        var p = head;\r\n        var p1 = l1;\r\n        var p2 = l2;\r\n        while (p1 !== null && p2 !== null) {\r\n            if (compare(p1.key, p2.key) < 0) {\r\n                p.next = p1;\r\n                p1 = p1.next;\r\n            }\r\n            else {\r\n                p.next = p2;\r\n                p2 = p2.next;\r\n            }\r\n            p = p.next;\r\n        }\r\n        if (p1 !== null) {\r\n            p.next = p1;\r\n        }\r\n        else if (p2 !== null) {\r\n            p.next = p2;\r\n        }\r\n        return head.next;\r\n    }\r\n    function sort(keys, values, left, right, compare) {\r\n        if (left >= right)\r\n            return;\r\n        var pivot = keys[(left + right) >> 1];\r\n        var i = left - 1;\r\n        var j = right + 1;\r\n        while (true) {\r\n            do\r\n                i++;\r\n            while (compare(keys[i], pivot) < 0);\r\n            do\r\n                j--;\r\n            while (compare(keys[j], pivot) > 0);\r\n            if (i >= j)\r\n                break;\r\n            var tmp = keys[i];\r\n            keys[i] = keys[j];\r\n            keys[j] = tmp;\r\n            tmp = values[i];\r\n            values[i] = values[j];\r\n            values[j] = tmp;\r\n        }\r\n        sort(keys, values, left, j, compare);\r\n        sort(keys, values, j + 1, right, compare);\r\n    }\n\n    return Tree;\n\n})));\n//# sourceMappingURL=splay.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3BsYXl0cmVlQDMuMS4yL25vZGVfbW9kdWxlcy9zcGxheXRyZWUvZGlzdC9zcGxheS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxLQUE0RDtBQUNoRSxJQUFJLENBQzhCO0FBQ2xDLENBQUMsc0JBQXNCOztBQUV2QjtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDNUcscUJBQXFCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUM1SiwyQkFBMkIsc0JBQXNCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qyx1Q0FBdUMsU0FBUztBQUNoRCx1Q0FBdUMsV0FBVyxVQUFVO0FBQzVELDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0Esa0hBQWtILE9BQU87QUFDekgscUZBQXFGLGlCQUFpQjtBQUN0Ryw2REFBNkQsZ0JBQWdCLFFBQVE7QUFDckYsbURBQW1ELGdCQUFnQixnQkFBZ0I7QUFDbkY7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLGNBQWMsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUMxRCx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsK0NBQStDLGtCQUFrQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0MsMkJBQTJCO0FBQ25FO0FBQ0EsMERBQTBELHFCQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZnZhbHVlLWZyb250ZW5kLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3NwbGF5dHJlZUAzLjEuMi9ub2RlX21vZHVsZXMvc3BsYXl0cmVlL2Rpc3Qvc3BsYXkuanM/MzczOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHNwbGF5dHJlZSB2My4xLjJcbiAqIEZhc3QgU3BsYXkgdHJlZSBmb3IgTm9kZSBhbmQgYnJvd3NlclxuICpcbiAqIEBhdXRob3IgQWxleGFuZGVyIE1pbGV2c2tpIDxpbmZvQHc4ci5uYW1lPlxuICogQGxpY2Vuc2UgTUlUXG4gKiBAcHJlc2VydmVcbiAqL1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIChnbG9iYWwuU3BsYXlUcmVlID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbiAgICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuICAgIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG4gICAgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGVcclxuICAgIExpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG4gICAgVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG4gICAgS0lORCwgRUlUSEVSIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIFdJVEhPVVQgTElNSVRBVElPTiBBTlkgSU1QTElFRFxyXG4gICAgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuICAgIE1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG4gICAgU2VlIHRoZSBBcGFjaGUgVmVyc2lvbiAyLjAgTGljZW5zZSBmb3Igc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zXHJcbiAgICBhbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbiAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuICAgIGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cblxuICAgIHZhciBOb2RlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIE5vZGUoa2V5LCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHRoaXMubmV4dCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMua2V5ID0ga2V5O1xyXG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE5vZGU7XHJcbiAgICB9KCkpO1xuXG4gICAgLyogZm9sbG93cyBcIkFuIGltcGxlbWVudGF0aW9uIG9mIHRvcC1kb3duIHNwbGF5aW5nXCJcclxuICAgICAqIGJ5IEQuIFNsZWF0b3IgPHNsZWF0b3JAY3MuY211LmVkdT4gTWFyY2ggMTk5MlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBERUZBVUxUX0NPTVBBUkUoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhID4gYiA/IDEgOiBhIDwgYiA/IC0xIDogMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGxlIHRvcCBkb3duIHNwbGF5LCBub3QgcmVxdWlyaW5nIGkgdG8gYmUgaW4gdGhlIHRyZWUgdC5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gc3BsYXkoaSwgdCwgY29tcGFyYXRvcikge1xyXG4gICAgICAgIHZhciBOID0gbmV3IE5vZGUobnVsbCwgbnVsbCk7XHJcbiAgICAgICAgdmFyIGwgPSBOO1xyXG4gICAgICAgIHZhciByID0gTjtcclxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xyXG4gICAgICAgICAgICB2YXIgY21wID0gY29tcGFyYXRvcihpLCB0LmtleSk7XHJcbiAgICAgICAgICAgIC8vaWYgKGkgPCB0LmtleSkge1xyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHQubGVmdCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIC8vaWYgKGkgPCB0LmxlZnQua2V5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyYXRvcihpLCB0LmxlZnQua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IHQubGVmdDsgLyogcm90YXRlIHJpZ2h0ICovXHJcbiAgICAgICAgICAgICAgICAgICAgdC5sZWZ0ID0geS5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB5LnJpZ2h0ID0gdDtcclxuICAgICAgICAgICAgICAgICAgICB0ID0geTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodC5sZWZ0ID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHIubGVmdCA9IHQ7IC8qIGxpbmsgcmlnaHQgKi9cclxuICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgdCA9IHQubGVmdDtcclxuICAgICAgICAgICAgICAgIC8vfSBlbHNlIGlmIChpID4gdC5rZXkpIHtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjbXAgPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodC5yaWdodCA9PT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIC8vaWYgKGkgPiB0LnJpZ2h0LmtleSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmF0b3IoaSwgdC5yaWdodC5rZXkpID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB5ID0gdC5yaWdodDsgLyogcm90YXRlIGxlZnQgKi9cclxuICAgICAgICAgICAgICAgICAgICB0LnJpZ2h0ID0geS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIHkubGVmdCA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQucmlnaHQgPT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbC5yaWdodCA9IHQ7IC8qIGxpbmsgbGVmdCAqL1xyXG4gICAgICAgICAgICAgICAgbCA9IHQ7XHJcbiAgICAgICAgICAgICAgICB0ID0gdC5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgLyogYXNzZW1ibGUgKi9cclxuICAgICAgICBsLnJpZ2h0ID0gdC5sZWZ0O1xyXG4gICAgICAgIHIubGVmdCA9IHQucmlnaHQ7XHJcbiAgICAgICAgdC5sZWZ0ID0gTi5yaWdodDtcclxuICAgICAgICB0LnJpZ2h0ID0gTi5sZWZ0O1xyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gaW5zZXJ0KGksIGRhdGEsIHQsIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICB2YXIgbm9kZSA9IG5ldyBOb2RlKGksIGRhdGEpO1xyXG4gICAgICAgIGlmICh0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIG5vZGUubGVmdCA9IG5vZGUucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdCA9IHNwbGF5KGksIHQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGksIHQua2V5KTtcclxuICAgICAgICBpZiAoY21wIDwgMCkge1xyXG4gICAgICAgICAgICBub2RlLmxlZnQgPSB0LmxlZnQ7XHJcbiAgICAgICAgICAgIG5vZGUucmlnaHQgPSB0O1xyXG4gICAgICAgICAgICB0LmxlZnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbXAgPj0gMCkge1xyXG4gICAgICAgICAgICBub2RlLnJpZ2h0ID0gdC5yaWdodDtcclxuICAgICAgICAgICAgbm9kZS5sZWZ0ID0gdDtcclxuICAgICAgICAgICAgdC5yaWdodCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gc3BsaXQoa2V5LCB2LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgdmFyIGxlZnQgPSBudWxsO1xyXG4gICAgICAgIHZhciByaWdodCA9IG51bGw7XHJcbiAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgdiA9IHNwbGF5KGtleSwgdiwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKHYua2V5LCBrZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdi5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgcmlnaHQgPSB2LnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdi5yaWdodDtcclxuICAgICAgICAgICAgICAgIHYucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IHY7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0ID0gdi5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgdi5sZWZ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gdjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4geyBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlKGxlZnQsIHJpZ2h0LCBjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKHJpZ2h0ID09PSBudWxsKVxyXG4gICAgICAgICAgICByZXR1cm4gbGVmdDtcclxuICAgICAgICBpZiAobGVmdCA9PT0gbnVsbClcclxuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0O1xyXG4gICAgICAgIHJpZ2h0ID0gc3BsYXkobGVmdC5rZXksIHJpZ2h0LCBjb21wYXJhdG9yKTtcclxuICAgICAgICByaWdodC5sZWZ0ID0gbGVmdDtcclxuICAgICAgICByZXR1cm4gcmlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByaW50cyBsZXZlbCBvZiB0aGUgdHJlZVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBwcmludFJvdyhyb290LCBwcmVmaXgsIGlzVGFpbCwgb3V0LCBwcmludE5vZGUpIHtcclxuICAgICAgICBpZiAocm9vdCkge1xyXG4gICAgICAgICAgICBvdXQoXCJcIiArIHByZWZpeCArIChpc1RhaWwgPyAn4pSU4pSA4pSAICcgOiAn4pSc4pSA4pSAICcpICsgcHJpbnROb2RlKHJvb3QpICsgXCJcXG5cIik7XHJcbiAgICAgICAgICAgIHZhciBpbmRlbnQgPSBwcmVmaXggKyAoaXNUYWlsID8gJyAgICAnIDogJ+KUgiAgICcpO1xyXG4gICAgICAgICAgICBpZiAocm9vdC5sZWZ0KVxyXG4gICAgICAgICAgICAgICAgcHJpbnRSb3cocm9vdC5sZWZ0LCBpbmRlbnQsIGZhbHNlLCBvdXQsIHByaW50Tm9kZSk7XHJcbiAgICAgICAgICAgIGlmIChyb290LnJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgcHJpbnRSb3cocm9vdC5yaWdodCwgaW5kZW50LCB0cnVlLCBvdXQsIHByaW50Tm9kZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gVHJlZShjb21wYXJhdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yID09PSB2b2lkIDApIHsgY29tcGFyYXRvciA9IERFRkFVTFRfQ09NUEFSRTsgfVxyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBhcmF0b3IgPSBjb21wYXJhdG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbnNlcnRzIGEga2V5LCBhbGxvd3MgZHVwbGljYXRlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmluc2VydCA9IGZ1bmN0aW9uIChrZXksIGRhdGEpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdCA9IGluc2VydChrZXksIGRhdGEsIHRoaXMuX3Jvb3QsIHRoaXMuX2NvbXBhcmF0b3IpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWRkcyBhIGtleSwgaWYgaXQgaXMgbm90IHByZXNlbnQgaW4gdGhlIHRyZWVcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoa2V5LCBkYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gbmV3IE5vZGUoa2V5LCBkYXRhKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUubGVmdCA9IG5vZGUucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgdCA9IHNwbGF5KGtleSwgdGhpcy5fcm9vdCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGtleSwgdC5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHQ7XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSB0LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yaWdodCA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdC5sZWZ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnJpZ2h0ID0gdC5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmxlZnQgPSB0O1xyXG4gICAgICAgICAgICAgICAgICAgIHQucmlnaHQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSsrO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IG5vZGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0gIHtLZXl9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm4ge05vZGV8bnVsbH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSB0aGlzLl9yZW1vdmUoa2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlbGV0ZXMgaSBmcm9tIHRoZSB0cmVlIGlmIGl0J3MgdGhlcmVcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5fcmVtb3ZlID0gZnVuY3Rpb24gKGksIHQsIGNvbXBhcmF0b3IpIHtcclxuICAgICAgICAgICAgdmFyIHg7XHJcbiAgICAgICAgICAgIGlmICh0ID09PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIHQgPSBzcGxheShpLCB0LCBjb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoaSwgdC5rZXkpO1xyXG4gICAgICAgICAgICBpZiAoY21wID09PSAwKSB7IC8qIGZvdW5kIGl0ICovXHJcbiAgICAgICAgICAgICAgICBpZiAodC5sZWZ0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IHQucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB4ID0gc3BsYXkoaSwgdC5sZWZ0LCBjb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICB4LnJpZ2h0ID0gdC5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuX3NpemUtLTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0OyAvKiBJdCB3YXNuJ3QgdGhlcmUgKi9cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJlbW92ZXMgYW5kIHJldHVybnMgdGhlIG5vZGUgd2l0aCBzbWFsbGVzdCBrZXlcclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5fcm9vdDtcclxuICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChub2RlLmxlZnQpXHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUubGVmdDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBzcGxheShub2RlLmtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fcmVtb3ZlKG5vZGUua2V5LCB0aGlzLl9yb290LCB0aGlzLl9jb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7IGtleTogbm9kZS5rZXksIGRhdGE6IG5vZGUuZGF0YSB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmluZCB3aXRob3V0IHNwbGF5aW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUuZmluZFN0YXRpYyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgICAgICB2YXIgY29tcGFyZSA9IHRoaXMuX2NvbXBhcmF0b3I7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY21wID0gY29tcGFyZShrZXksIGN1cnJlbnQua2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChjbXAgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHNwbGF5KGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY29tcGFyYXRvcihrZXksIHRoaXMuX3Jvb3Qua2V5KSAhPT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgIHZhciBjb21wYXJlID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJlKGtleSwgY3VycmVudC5rZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNtcCA9PT0gMClcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNtcCA8IDApXHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQubGVmdDtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKHZpc2l0b3IsIGN0eCkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgIHZhciBRID0gW107IC8qIEluaXRpYWxpemUgc3RhY2sgcyAqL1xyXG4gICAgICAgICAgICB2YXIgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUS5sZW5ndGggIT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpc2l0b3IuY2FsbChjdHgsIGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdhbGsga2V5IHJhbmdlIGZyb20gYGxvd2AgdG8gYGhpZ2hgLiBTdG9wcyBpZiBgZm5gIHJldHVybnMgYSB2YWx1ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5yYW5nZSA9IGZ1bmN0aW9uIChsb3csIGhpZ2gsIGZuLCBjdHgpIHtcclxuICAgICAgICAgICAgdmFyIFEgPSBbXTtcclxuICAgICAgICAgICAgdmFyIGNvbXBhcmUgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgIHZhciBjbXA7XHJcbiAgICAgICAgICAgIHdoaWxlIChRLmxlbmd0aCAhPT0gMCB8fCBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIFEucHVzaChub2RlKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY21wID0gY29tcGFyZShub2RlLmtleSwgaGlnaCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtcCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbXBhcmUobm9kZS5rZXksIGxvdykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm4uY2FsbChjdHgsIG5vZGUpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7IC8vIHN0b3AgaWYgc210aCBpcyByZXR1cm5lZFxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5yaWdodDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYXJyYXkgb2Yga2V5c1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XHJcbiAgICAgICAgICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYS5rZXk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5cy5wdXNoKGtleSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4ga2V5cztcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgYXJyYXkgb2YgYWxsIHRoZSBkYXRhIGluIHRoZSBub2Rlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xyXG4gICAgICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9hLmRhdGE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWVzLnB1c2goZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gdmFsdWVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm9vdClcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbk5vZGUodGhpcy5fcm9vdCkua2V5O1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jvb3QpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYXhOb2RlKHRoaXMuX3Jvb3QpLmtleTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5taW5Ob2RlID0gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgaWYgKHQgPT09IHZvaWQgMCkgeyB0ID0gdGhpcy5fcm9vdDsgfVxyXG4gICAgICAgICAgICBpZiAodClcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0LmxlZnQpXHJcbiAgICAgICAgICAgICAgICAgICAgdCA9IHQubGVmdDtcclxuICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5tYXhOb2RlID0gZnVuY3Rpb24gKHQpIHtcclxuICAgICAgICAgICAgaWYgKHQgPT09IHZvaWQgMCkgeyB0ID0gdGhpcy5fcm9vdDsgfVxyXG4gICAgICAgICAgICBpZiAodClcclxuICAgICAgICAgICAgICAgIHdoaWxlICh0LnJpZ2h0KVxyXG4gICAgICAgICAgICAgICAgICAgIHQgPSB0LnJpZ2h0O1xyXG4gICAgICAgICAgICByZXR1cm4gdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgbm9kZSBhdCBnaXZlbiBpbmRleFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmF0ID0gZnVuY3Rpb24gKGluZGV4KSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5fcm9vdDtcclxuICAgICAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdmFyIGkgPSAwO1xyXG4gICAgICAgICAgICB2YXIgUSA9IFtdO1xyXG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgUS5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoUS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaW5kZXgpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoZCkge1xyXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgIHZhciBzdWNjZXNzb3IgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZC5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgc3VjY2Vzc29yID0gZC5yaWdodDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzdWNjZXNzb3IubGVmdClcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzb3IgPSBzdWNjZXNzb3IubGVmdDtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdWNjZXNzb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmFyIGNvbXBhcmF0b3IgPSB0aGlzLl9jb21wYXJhdG9yO1xyXG4gICAgICAgICAgICB3aGlsZSAocm9vdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGNtcCA9IGNvbXBhcmF0b3IoZC5rZXksIHJvb3Qua2V5KTtcclxuICAgICAgICAgICAgICAgIGlmIChjbXAgPT09IDApXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbXAgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc29yID0gcm9vdDtcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gcm9vdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzdWNjZXNzb3I7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKGQpIHtcclxuICAgICAgICAgICAgdmFyIHJvb3QgPSB0aGlzLl9yb290O1xyXG4gICAgICAgICAgICB2YXIgcHJlZGVjZXNzb3IgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoZC5sZWZ0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBwcmVkZWNlc3NvciA9IGQubGVmdDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChwcmVkZWNlc3Nvci5yaWdodClcclxuICAgICAgICAgICAgICAgICAgICBwcmVkZWNlc3NvciA9IHByZWRlY2Vzc29yLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZWRlY2Vzc29yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICAgICAgd2hpbGUgKHJvb3QpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjbXAgPSBjb21wYXJhdG9yKGQua2V5LCByb290LmtleSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY21wID09PSAwKVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY21wIDwgMClcclxuICAgICAgICAgICAgICAgICAgICByb290ID0gcm9vdC5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJlZGVjZXNzb3IgPSByb290O1xyXG4gICAgICAgICAgICAgICAgICAgIHJvb3QgPSByb290LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBwcmVkZWNlc3NvcjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IDA7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUudG9MaXN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdG9MaXN0KHRoaXMuX3Jvb3QpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVsay1sb2FkIGl0ZW1zLiBCb3RoIGFycmF5IGhhdmUgdG8gYmUgc2FtZSBzaXplXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChrZXlzLCB2YWx1ZXMsIHByZXNvcnQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlcyA9PT0gdm9pZCAwKSB7IHZhbHVlcyA9IFtdOyB9XHJcbiAgICAgICAgICAgIGlmIChwcmVzb3J0ID09PSB2b2lkIDApIHsgcHJlc29ydCA9IGZhbHNlOyB9XHJcbiAgICAgICAgICAgIHZhciBzaXplID0ga2V5cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICAgICAgLy8gc29ydCBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKHByZXNvcnQpXHJcbiAgICAgICAgICAgICAgICBzb3J0KGtleXMsIHZhbHVlcywgMCwgc2l6ZSAtIDEsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcm9vdCA9PT0gbnVsbCkgeyAvLyBlbXB0eSB0cmVlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb290ID0gbG9hZFJlY3Vyc2l2ZShrZXlzLCB2YWx1ZXMsIDAsIHNpemUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7IC8vIHRoYXQgcmUtYnVpbGRzIHRoZSB3aG9sZSB0cmVlIGZyb20gdHdvIGluLW9yZGVyIHRyYXZlcnNhbHNcclxuICAgICAgICAgICAgICAgIHZhciBtZXJnZWRMaXN0ID0gbWVyZ2VMaXN0cyh0aGlzLnRvTGlzdCgpLCBjcmVhdGVMaXN0KGtleXMsIHZhbHVlcyksIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX3NpemUgKyBzaXplO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm9vdCA9IHNvcnRlZExpc3RUb0JTVCh7IGhlYWQ6IG1lcmdlZExpc3QgfSwgMCwgc2l6ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcm9vdCA9PT0gbnVsbDsgfTtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVHJlZS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fc2l6ZTsgfSxcclxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyZWUucHJvdG90eXBlLCBcInJvb3RcIiwge1xyXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX3Jvb3Q7IH0sXHJcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIFRyZWUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKHByaW50Tm9kZSkge1xyXG4gICAgICAgICAgICBpZiAocHJpbnROb2RlID09PSB2b2lkIDApIHsgcHJpbnROb2RlID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuIFN0cmluZyhuLmtleSk7IH07IH1cclxuICAgICAgICAgICAgdmFyIG91dCA9IFtdO1xyXG4gICAgICAgICAgICBwcmludFJvdyh0aGlzLl9yb290LCAnJywgdHJ1ZSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG91dC5wdXNoKHYpOyB9LCBwcmludE5vZGUpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3V0LmpvaW4oJycpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgVHJlZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbmV3S2V5LCBuZXdEYXRhKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wYXJhdG9yID0gdGhpcy5fY29tcGFyYXRvcjtcclxuICAgICAgICAgICAgdmFyIF9hID0gc3BsaXQoa2V5LCB0aGlzLl9yb290LCBjb21wYXJhdG9yKSwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQ7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJhdG9yKGtleSwgbmV3S2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0ID0gaW5zZXJ0KG5ld0tleSwgbmV3RGF0YSwgcmlnaHQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbGVmdCA9IGluc2VydChuZXdLZXksIG5ld0RhdGEsIGxlZnQsIGNvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBtZXJnZShsZWZ0LCByaWdodCwgY29tcGFyYXRvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmVlLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHNwbGl0KGtleSwgdGhpcy5fcm9vdCwgdGhpcy5fY29tcGFyYXRvcik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBUcmVlLnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudCwgUSwgZG9uZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFEgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFkb25lKSByZXR1cm4gWzMgLypicmVhayovLCA2XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY3VycmVudCAhPT0gbnVsbCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBRLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoUS5sZW5ndGggIT09IDApKSByZXR1cm4gWzMgLypicmVhayovLCA0XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IFEucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGN1cnJlbnRdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFRyZWU7XHJcbiAgICB9KCkpO1xyXG4gICAgZnVuY3Rpb24gbG9hZFJlY3Vyc2l2ZShrZXlzLCB2YWx1ZXMsIHN0YXJ0LCBlbmQpIHtcclxuICAgICAgICB2YXIgc2l6ZSA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgIGlmIChzaXplID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgbWlkZGxlID0gc3RhcnQgKyBNYXRoLmZsb29yKHNpemUgLyAyKTtcclxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbbWlkZGxlXTtcclxuICAgICAgICAgICAgdmFyIGRhdGEgPSB2YWx1ZXNbbWlkZGxlXTtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZShrZXksIGRhdGEpO1xyXG4gICAgICAgICAgICBub2RlLmxlZnQgPSBsb2FkUmVjdXJzaXZlKGtleXMsIHZhbHVlcywgc3RhcnQsIG1pZGRsZSk7XHJcbiAgICAgICAgICAgIG5vZGUucmlnaHQgPSBsb2FkUmVjdXJzaXZlKGtleXMsIHZhbHVlcywgbWlkZGxlICsgMSwgZW5kKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdChrZXlzLCB2YWx1ZXMpIHtcclxuICAgICAgICB2YXIgaGVhZCA9IG5ldyBOb2RlKG51bGwsIG51bGwpO1xyXG4gICAgICAgIHZhciBwID0gaGVhZDtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcCA9IHAubmV4dCA9IG5ldyBOb2RlKGtleXNbaV0sIHZhbHVlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHAubmV4dCA9IG51bGw7XHJcbiAgICAgICAgcmV0dXJuIGhlYWQubmV4dDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHRvTGlzdChyb290KSB7XHJcbiAgICAgICAgdmFyIGN1cnJlbnQgPSByb290O1xyXG4gICAgICAgIHZhciBRID0gW107XHJcbiAgICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcclxuICAgICAgICB2YXIgaGVhZCA9IG5ldyBOb2RlKG51bGwsIG51bGwpO1xyXG4gICAgICAgIHZhciBwID0gaGVhZDtcclxuICAgICAgICB3aGlsZSAoIWRvbmUpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIFEucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoUS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHAgPSBwLm5leHQgPSBRLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHAubmV4dCA9IG51bGw7IC8vIHRoYXQnbGwgd29yayBldmVuIGlmIHRoZSB0cmVlIHdhcyBlbXB0eVxyXG4gICAgICAgIHJldHVybiBoZWFkLm5leHQ7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBzb3J0ZWRMaXN0VG9CU1QobGlzdCwgc3RhcnQsIGVuZCkge1xyXG4gICAgICAgIHZhciBzaXplID0gZW5kIC0gc3RhcnQ7XHJcbiAgICAgICAgaWYgKHNpemUgPiAwKSB7XHJcbiAgICAgICAgICAgIHZhciBtaWRkbGUgPSBzdGFydCArIE1hdGguZmxvb3Ioc2l6ZSAvIDIpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHNvcnRlZExpc3RUb0JTVChsaXN0LCBzdGFydCwgbWlkZGxlKTtcclxuICAgICAgICAgICAgdmFyIHJvb3QgPSBsaXN0LmhlYWQ7XHJcbiAgICAgICAgICAgIHJvb3QubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIGxpc3QuaGVhZCA9IGxpc3QuaGVhZC5uZXh0O1xyXG4gICAgICAgICAgICByb290LnJpZ2h0ID0gc29ydGVkTGlzdFRvQlNUKGxpc3QsIG1pZGRsZSArIDEsIGVuZCk7XHJcbiAgICAgICAgICAgIHJldHVybiByb290O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIG1lcmdlTGlzdHMobDEsIGwyLCBjb21wYXJlKSB7XHJcbiAgICAgICAgdmFyIGhlYWQgPSBuZXcgTm9kZShudWxsLCBudWxsKTsgLy8gZHVtbXlcclxuICAgICAgICB2YXIgcCA9IGhlYWQ7XHJcbiAgICAgICAgdmFyIHAxID0gbDE7XHJcbiAgICAgICAgdmFyIHAyID0gbDI7XHJcbiAgICAgICAgd2hpbGUgKHAxICE9PSBudWxsICYmIHAyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmIChjb21wYXJlKHAxLmtleSwgcDIua2V5KSA8IDApIHtcclxuICAgICAgICAgICAgICAgIHAubmV4dCA9IHAxO1xyXG4gICAgICAgICAgICAgICAgcDEgPSBwMS5uZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcC5uZXh0ID0gcDI7XHJcbiAgICAgICAgICAgICAgICBwMiA9IHAyLm5leHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcCA9IHAubmV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHAxICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHAubmV4dCA9IHAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChwMiAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBwLm5leHQgPSBwMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGhlYWQubmV4dDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNvcnQoa2V5cywgdmFsdWVzLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xyXG4gICAgICAgIGlmIChsZWZ0ID49IHJpZ2h0KVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgdmFyIHBpdm90ID0ga2V5c1sobGVmdCArIHJpZ2h0KSA+PiAxXTtcclxuICAgICAgICB2YXIgaSA9IGxlZnQgLSAxO1xyXG4gICAgICAgIHZhciBqID0gcmlnaHQgKyAxO1xyXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgICAgIGRvXHJcbiAgICAgICAgICAgICAgICBpKys7XHJcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGtleXNbaV0sIHBpdm90KSA8IDApO1xyXG4gICAgICAgICAgICBkb1xyXG4gICAgICAgICAgICAgICAgai0tO1xyXG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShrZXlzW2pdLCBwaXZvdCkgPiAwKTtcclxuICAgICAgICAgICAgaWYgKGkgPj0gailcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB2YXIgdG1wID0ga2V5c1tpXTtcclxuICAgICAgICAgICAga2V5c1tpXSA9IGtleXNbal07XHJcbiAgICAgICAgICAgIGtleXNbal0gPSB0bXA7XHJcbiAgICAgICAgICAgIHRtcCA9IHZhbHVlc1tpXTtcclxuICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWVzW2pdO1xyXG4gICAgICAgICAgICB2YWx1ZXNbal0gPSB0bXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNvcnQoa2V5cywgdmFsdWVzLCBsZWZ0LCBqLCBjb21wYXJlKTtcclxuICAgICAgICBzb3J0KGtleXMsIHZhbHVlcywgaiArIDEsIHJpZ2h0LCBjb21wYXJlKTtcclxuICAgIH1cblxuICAgIHJldHVybiBUcmVlO1xuXG59KSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3BsYXkuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/splaytree@3.1.2/node_modules/splaytree/dist/splay.js\n");

/***/ })

};
;
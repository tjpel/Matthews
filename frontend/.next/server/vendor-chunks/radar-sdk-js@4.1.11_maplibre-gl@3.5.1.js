"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/radar-sdk-js@4.1.11_maplibre-gl@3.5.1";
exports.ids = ["vendor-chunks/radar-sdk-js@4.1.11_maplibre-gl@3.5.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/radar-sdk-js@4.1.11_maplibre-gl@3.5.1/node_modules/radar-sdk-js/dist/radar.css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/radar-sdk-js@4.1.11_maplibre-gl@3.5.1/node_modules/radar-sdk-js/dist/radar.css ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"254e2445372a\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmFkYXItc2RrLWpzQDQuMS4xMV9tYXBsaWJyZS1nbEAzLjUuMS9ub2RlX21vZHVsZXMvcmFkYXItc2RrLWpzL2Rpc3QvcmFkYXIuY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbWZ2YWx1ZS1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy8ucG5wbS9yYWRhci1zZGstanNANC4xLjExX21hcGxpYnJlLWdsQDMuNS4xL25vZGVfbW9kdWxlcy9yYWRhci1zZGstanMvZGlzdC9yYWRhci5jc3M/M2RmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjI1NGUyNDQ1MzcyYVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/radar-sdk-js@4.1.11_maplibre-gl@3.5.1/node_modules/radar-sdk-js/dist/radar.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/radar-sdk-js@4.1.11_maplibre-gl@3.5.1/node_modules/radar-sdk-js/dist/radar.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/radar-sdk-js@4.1.11_maplibre-gl@3.5.1/node_modules/radar-sdk-js/dist/radar.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Radar)\n/* harmony export */ });\n/* harmony import */ var maplibre_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! maplibre-gl */ \"(ssr)/./node_modules/.pnpm/maplibre-gl@3.5.1/node_modules/maplibre-gl/dist/maplibre-gl.js\");\n\n\nvar Config = /** @class */ (function () {\n    function Config() {\n    }\n    Config.setup = function (options) {\n        if (options === void 0) { options = {}; }\n        Config.options = options;\n    };\n    Config.get = function () {\n        return Config.options || {};\n    };\n    Config.clear = function () {\n        Config.options = {};\n    };\n    Config.defaultOptions = {\n        live: false,\n        logLevel: 'error',\n        host: 'https://api.radar.io',\n        version: 'v1',\n        debug: false,\n    };\n    return Config;\n}());\n\nvar LOG_LEVELS = {\n    none: 0,\n    error: 1,\n    warn: 2,\n    info: 3,\n    debug: 4,\n};\n// get the numeric level for logLevel option\nvar getLevel = function () {\n    // disable logging in tests\n    if (window && window.RADAR_TEST_ENV) {\n        return LOG_LEVELS.none;\n    }\n    var _a = Config.get(), logLevel = _a.logLevel, debug = _a.debug;\n    if (debug) {\n        return LOG_LEVELS.debug;\n    }\n    if (logLevel) {\n        return LOG_LEVELS[logLevel];\n    }\n    return LOG_LEVELS.error; // default to error-level logging if not set\n};\nvar Logger = /** @class */ (function () {\n    function Logger() {\n    }\n    Logger.debug = function (message) {\n        if (getLevel() === LOG_LEVELS.debug) {\n            console.log(\"Radar SDK (debug): \".concat(message.trim()));\n        }\n    };\n    Logger.info = function (message) {\n        if (getLevel() >= LOG_LEVELS.info) {\n            console.log(\"Radar SDK: \".concat(message.trim()));\n        }\n    };\n    Logger.warn = function (message) {\n        if (getLevel() >= LOG_LEVELS.warn) {\n            console.warn(\"Radar SDK: \".concat(message.trim()));\n        }\n    };\n    Logger.error = function (message) {\n        if (getLevel() >= LOG_LEVELS.error) {\n            console.error(\"Radar SDK: \".concat(message.trim()));\n        }\n    };\n    return Logger;\n}());\n\nvar Storage = /** @class */ (function () {\n    function Storage() {\n    }\n    Object.defineProperty(Storage, \"USER_ID\", {\n        // local storage key definitions for identifying track users\n        get: function () {\n            return 'radar-userId';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Storage, \"DEVICE_ID\", {\n        get: function () {\n            return 'radar-deviceId';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Storage, \"INSTALL_ID\", {\n        get: function () {\n            return 'radar-installId';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Storage, \"SESSION_ID\", {\n        get: function () {\n            return 'radar-sessionId';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Storage, \"DESCRIPTION\", {\n        get: function () {\n            return 'radar-description';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Storage, \"METADATA\", {\n        get: function () {\n            return 'radar-metadata';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Storage, \"CACHED_LOCATION\", {\n        get: function () {\n            return 'radar-cached-location';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Storage, \"TRIP_OPTIONS\", {\n        get: function () {\n            return 'radar-trip-options';\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Storage.getStorage = function () {\n        var storage = window === null || window === void 0 ? void 0 : window.localStorage;\n        if (!storage) {\n            Logger.warn('localStorage not available.');\n        }\n        return storage;\n    };\n    Storage.setItem = function (key, value) {\n        var storage = this.getStorage();\n        if (!storage) {\n            return;\n        }\n        if (value === undefined || value === null) {\n            return;\n        }\n        storage.setItem(key, value);\n    };\n    Storage.getItem = function (key) {\n        var storage = this.getStorage();\n        if (!storage) {\n            return null;\n        }\n        var value = storage.getItem(key);\n        if (value !== undefined && value !== null) {\n            return value;\n        }\n        return null;\n    };\n    Storage.getJSON = function (key) {\n        var item = this.getItem(key);\n        if (!item) {\n            return null;\n        }\n        try {\n            return JSON.parse(item);\n        }\n        catch (err) {\n            Logger.warn(\"could not getJSON from storage for key: \".concat(key));\n            return null;\n        }\n    };\n    Storage.removeItem = function (key) {\n        var storage = this.getStorage();\n        if (!storage) {\n            return null;\n        }\n        storage.removeItem(key);\n    };\n    Storage.clear = function () {\n        var storage = this.getStorage();\n        if (!storage) {\n            return null;\n        }\n        storage.clear();\n    };\n    return Storage;\n}());\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar RadarError = /** @class */ (function (_super) {\n    __extends(RadarError, _super);\n    function RadarError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.status = ''; // to be overridden (support for legacy status)\n        return _this;\n    }\n    return RadarError;\n}(Error));\nvar RadarPublishableKeyError = /** @class */ (function (_super) {\n    __extends(RadarPublishableKeyError, _super);\n    function RadarPublishableKeyError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'RadarPublishableKeyError';\n        _this.status = 'ERROR_PUBLISHABLE_KEY';\n        return _this;\n    }\n    return RadarPublishableKeyError;\n}(RadarError));\nvar RadarLocationError = /** @class */ (function (_super) {\n    __extends(RadarLocationError, _super);\n    function RadarLocationError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'RadarLocationError';\n        _this.status = 'ERROR_LOCATION';\n        return _this;\n    }\n    return RadarLocationError;\n}(RadarError));\nvar RadarLocationPermissionsError = /** @class */ (function (_super) {\n    __extends(RadarLocationPermissionsError, _super);\n    function RadarLocationPermissionsError(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'RadarLocationPermissionsError';\n        _this.status = 'ERROR_PERMISSIONS';\n        return _this;\n    }\n    return RadarLocationPermissionsError;\n}(RadarError));\nvar RadarDesktopAppError = /** @class */ (function (_super) {\n    __extends(RadarDesktopAppError, _super);\n    function RadarDesktopAppError() {\n        var _this = _super.call(this, 'Desktop app not running.') || this;\n        _this.name = 'RadarDesktopAppError';\n        _this.status = 'ERROR_DESKTOP_APP';\n        return _this;\n    }\n    return RadarDesktopAppError;\n}(RadarError));\n// HTTP Errors\nvar RadarBadRequestError = /** @class */ (function (_super) {\n    __extends(RadarBadRequestError, _super);\n    function RadarBadRequestError(response) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Bad request.') || this;\n        _this.name = 'RadarBadRequestError';\n        _this.code = 400;\n        _this.response = response;\n        _this.status = 'ERROR_BAD_REQUEST';\n        return _this;\n    }\n    return RadarBadRequestError;\n}(RadarError));\nvar RadarUnauthorizedError = /** @class */ (function (_super) {\n    __extends(RadarUnauthorizedError, _super);\n    function RadarUnauthorizedError(response) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Unauthorized.') || this;\n        _this.name = 'RadarUnauthorizedError';\n        _this.code = 401;\n        _this.response = response;\n        _this.status = 'ERROR_UNAUTHORIZED';\n        return _this;\n    }\n    return RadarUnauthorizedError;\n}(RadarError));\nvar RadarPaymentRequiredError = /** @class */ (function (_super) {\n    __extends(RadarPaymentRequiredError, _super);\n    function RadarPaymentRequiredError(response) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Payment required.') || this;\n        _this.name = 'RadarPaymentRequiredError';\n        _this.code = 402;\n        _this.response = response;\n        _this.status = 'ERROR_PAYMENT_REQUIRED';\n        return _this;\n    }\n    return RadarPaymentRequiredError;\n}(RadarError));\nvar RadarForbiddenError = /** @class */ (function (_super) {\n    __extends(RadarForbiddenError, _super);\n    function RadarForbiddenError(response) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Forbidden.') || this;\n        _this.name = 'RadarForbiddenError';\n        _this.code = 403;\n        _this.response = response;\n        _this.status = 'ERROR_FORBIDDEN';\n        return _this;\n    }\n    return RadarForbiddenError;\n}(RadarError));\nvar RadarNotFoundError = /** @class */ (function (_super) {\n    __extends(RadarNotFoundError, _super);\n    function RadarNotFoundError(response) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Not found.') || this;\n        _this.name = 'RadarNotFoundError';\n        _this.code = 404;\n        _this.response = response;\n        _this.status = 'ERROR_NOT_FOUND';\n        return _this;\n    }\n    return RadarNotFoundError;\n}(RadarError));\nvar RadarRateLimitError = /** @class */ (function (_super) {\n    __extends(RadarRateLimitError, _super);\n    function RadarRateLimitError(response) {\n        var _this = this;\n        var _a, _b;\n        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Rate limit exceeded.') || this;\n        _this.name = 'RadarRateLimitError';\n        _this.code = 429;\n        _this.response = response;\n        _this.type = (_b = response === null || response === void 0 ? void 0 : response.meta) === null || _b === void 0 ? void 0 : _b.type;\n        _this.status = 'ERROR_RATE_LIMIT';\n        return _this;\n    }\n    return RadarRateLimitError;\n}(RadarError));\nvar RadarServerError = /** @class */ (function (_super) {\n    __extends(RadarServerError, _super);\n    function RadarServerError(response) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Internal server error.') || this;\n        _this.name = 'RadarServerError';\n        _this.response = response;\n        _this.status = 'ERROR_SERVER';\n        return _this;\n    }\n    return RadarServerError;\n}(RadarError));\nvar RadarTimeoutError = /** @class */ (function (_super) {\n    __extends(RadarTimeoutError, _super);\n    function RadarTimeoutError() {\n        var _this = _super.call(this, 'Request timed out.') || this;\n        _this.name = 'RadarTimeoutError';\n        _this.status = 'ERROR_TIMED_OUT';\n        return _this;\n    }\n    return RadarTimeoutError;\n}(RadarError));\nvar RadarUnknownError = /** @class */ (function (_super) {\n    __extends(RadarUnknownError, _super);\n    function RadarUnknownError(response) {\n        var _this = this;\n        var _a;\n        _this = _super.call(this, ((_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.message) || 'Something went wrong.') || this;\n        _this.name = 'RadarUnknownError';\n        _this.response = response;\n        _this.status = 'ERROR_UNKNOWN';\n        return _this;\n    }\n    return RadarUnknownError;\n}(RadarError));\nvar RadarAutocompleteContainerNotFound = /** @class */ (function (_super) {\n    __extends(RadarAutocompleteContainerNotFound, _super);\n    function RadarAutocompleteContainerNotFound(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'RadarAutocompleteContainerNotFound';\n        _this.status = 'CONTAINER_NOT_FOUND';\n        return _this;\n    }\n    return RadarAutocompleteContainerNotFound;\n}(RadarError));\n\n// https://developer.mozilla.org/en-US/docs/Web/API/GeolocationPositionError\nvar PERMISSION_ERROR_MESSAGES = {\n    1: 'Permission denied.',\n    2: 'Position unavailable.',\n    3: 'Timeout.',\n};\nvar DEFAULT_POSITION_OPTIONS = {\n    maximumAge: 0,\n    timeout: 1000 * 30,\n    enableHighAccuracy: true,\n};\n// set \"enableHighAccuracy\" for navigator only when desiredAccuracy is \"high\"\nvar useHighAccuracy = function (desiredAccuracy) { return (Boolean(desiredAccuracy === 'high')); };\nvar Navigator = /** @class */ (function () {\n    function Navigator() {\n    }\n    Navigator.getCurrentPosition = function (overrides) {\n        if (overrides === void 0) { overrides = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        var options = Config.get();\n                        if (!navigator || !navigator.geolocation) {\n                            return reject(new RadarLocationError('navigator.geolocation is not available.'));\n                        }\n                        // use cached location if available and options are set\n                        if (options.cacheLocationMinutes) {\n                            try {\n                                var rawCachedLocation = Storage.getItem(Storage.CACHED_LOCATION);\n                                if (rawCachedLocation) {\n                                    var cachedLocation = JSON.parse(rawCachedLocation);\n                                    var _a = cachedLocation || {}, latitude = _a.latitude, longitude = _a.longitude, accuracy = _a.accuracy, expiresAt = _a.expiresAt;\n                                    if (Date.now() < parseInt(expiresAt)) {\n                                        if (latitude && longitude && accuracy) {\n                                            return resolve({ latitude: latitude, longitude: longitude, accuracy: accuracy });\n                                        }\n                                    }\n                                }\n                            }\n                            catch (e) {\n                                Logger.warn('could not load cached location.');\n                            }\n                        }\n                        // set options from config\n                        var positionOptions = Object.assign({}, DEFAULT_POSITION_OPTIONS);\n                        if (options.locationMaximumAge !== undefined) {\n                            positionOptions.maximumAge = options.locationMaximumAge;\n                        }\n                        if (options.locationTimeout !== undefined) {\n                            positionOptions.timeout = options.locationTimeout;\n                        }\n                        if (options.desiredAccuracy !== undefined) {\n                            positionOptions.enableHighAccuracy = useHighAccuracy(options.desiredAccuracy);\n                        }\n                        // set options from overrides\n                        if (overrides.desiredAccuracy !== undefined) {\n                            positionOptions.enableHighAccuracy = useHighAccuracy(overrides.desiredAccuracy);\n                        }\n                        Logger.info(\"Using geolocation options: \".concat(JSON.stringify(positionOptions)));\n                        // get current location from browser\n                        navigator.geolocation.getCurrentPosition(function (position) {\n                            if (!position || !position.coords) {\n                                return reject(new RadarLocationError('device location return empty coordinates.'));\n                            }\n                            var _a = position.coords, latitude = _a.latitude, longitude = _a.longitude, accuracy = _a.accuracy;\n                            // cache location if option is set\n                            if (options.cacheLocationMinutes) {\n                                var cacheLocationMinutes = Number.parseFloat(options.cacheLocationMinutes);\n                                var updatedAt = Date.now();\n                                var expiresAt = updatedAt + (cacheLocationMinutes * 60 * 1000); // convert to ms\n                                var lastLocation = { latitude: latitude, longitude: longitude, accuracy: accuracy, updatedAt: updatedAt, expiresAt: expiresAt };\n                                Storage.setItem(Storage.CACHED_LOCATION, JSON.stringify(lastLocation));\n                            }\n                            return resolve({ latitude: latitude, longitude: longitude, accuracy: accuracy });\n                        }, function (err) {\n                            if (err && err.code) {\n                                var message = PERMISSION_ERROR_MESSAGES[err.code.toString()] || 'unknown';\n                                return reject(new RadarLocationPermissionsError(message));\n                            }\n                            return reject(new RadarLocationError('Could not determine location.'));\n                        }, positionOptions);\n                    })];\n            });\n        });\n    };\n    Navigator.getPermissionStatus = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        if (!navigator || !navigator.permissions) {\n                            return reject(new RadarLocationError('navigator.permissions is not available.'));\n                        }\n                        navigator.permissions.query({ name: 'geolocation' }).then(function (permissionsStatus) {\n                            var locationAuthorization = 'NOT_DETERMINED';\n                            switch (permissionsStatus.state) {\n                                case 'granted':\n                                    locationAuthorization = 'GRANTED_FOREGROUND';\n                                    break;\n                                case 'denied':\n                                    locationAuthorization = 'DENIED';\n                                    break;\n                                case 'prompt':\n                                    locationAuthorization = 'NOT_DETERMINED';\n                                    break;\n                            }\n                            return resolve(locationAuthorization);\n                        });\n                    })];\n            });\n        });\n    };\n    return Navigator;\n}());\n\nvar SDK_VERSION = '4.1.11';\n\nvar Http = /** @class */ (function () {\n    function Http() {\n    }\n    Http.request = function (_a) {\n        var method = _a.method, path = _a.path, data = _a.data, host = _a.host;\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_b) {\n                return [2 /*return*/, new Promise(function (resolve, reject) {\n                        var options = Config.get();\n                        // check for publishableKey on request\n                        var publishableKey = options.publishableKey;\n                        if (!publishableKey) {\n                            reject(new RadarPublishableKeyError('publishableKey not set.'));\n                            return;\n                        }\n                        // setup request URL\n                        var urlHost = host || options.host;\n                        var version = options.version;\n                        var url = \"\".concat(urlHost, \"/\").concat(version, \"/\").concat(path);\n                        // remove undefined values from request data\n                        var body = {};\n                        Object.keys(data || {}).forEach(function (key) {\n                            var value = data[key];\n                            if (value !== undefined) {\n                                body[key] = value;\n                            }\n                        });\n                        // convert data to querystring for GET requests\n                        if (method === 'GET') {\n                            var params = Object.keys(body).map(function (key) { return (\"\".concat(key, \"=\").concat(encodeURIComponent(body[key]))); });\n                            if (params.length > 0) {\n                                var queryString = params.join('&');\n                                url = \"\".concat(url, \"?\").concat(queryString);\n                            }\n                            body = undefined; // dont send body for GET request\n                        }\n                        var xhr = new XMLHttpRequest();\n                        xhr.open(method, url, true);\n                        // set headers\n                        xhr.setRequestHeader('Authorization', publishableKey);\n                        xhr.setRequestHeader('Content-Type', 'application/json');\n                        xhr.setRequestHeader('X-Radar-Device-Type', 'Web');\n                        xhr.setRequestHeader('X-Radar-SDK-Version', SDK_VERSION);\n                        // set custom headers if present\n                        if (typeof options.getRequestHeaders === 'function') {\n                            var headers_1 = options.getRequestHeaders();\n                            Object.keys(headers_1 || {}).forEach(function (key) {\n                                xhr.setRequestHeader(key, headers_1[key]);\n                            });\n                        }\n                        xhr.onload = function () {\n                            var _a;\n                            var response;\n                            try {\n                                response = JSON.parse(xhr.response);\n                            }\n                            catch (e) {\n                                return reject(new RadarServerError(response));\n                            }\n                            var error = (_a = response === null || response === void 0 ? void 0 : response.meta) === null || _a === void 0 ? void 0 : _a.error;\n                            if (error === 'ERROR_PERMISSIONS') {\n                                return reject(new RadarLocationPermissionsError('Location permissions not granted.'));\n                            }\n                            else if (error === 'ERROR_LOCATION') {\n                                return reject(new RadarLocationError('Could not determine location.'));\n                            }\n                            else if (error === 'ERROR_NETWORK') {\n                                return reject(new RadarTimeoutError());\n                            }\n                            if (xhr.status == 200) {\n                                return resolve(response);\n                            }\n                            if (options.debug) {\n                                Logger.debug(\"API call failed: \".concat(url));\n                                Logger.debug(JSON.stringify(response));\n                            }\n                            if (xhr.status === 400) {\n                                reject(new RadarBadRequestError(response));\n                            }\n                            else if (xhr.status === 401) {\n                                reject(new RadarUnauthorizedError(response));\n                            }\n                            else if (xhr.status === 402) {\n                                reject(new RadarPaymentRequiredError(response));\n                            }\n                            else if (xhr.status === 403) {\n                                reject(new RadarForbiddenError(response));\n                            }\n                            else if (xhr.status === 404) {\n                                reject(new RadarNotFoundError(response));\n                            }\n                            else if (xhr.status === 429) {\n                                reject(new RadarRateLimitError(response));\n                            }\n                            else if (500 <= xhr.status && xhr.status < 600) {\n                                reject(new RadarServerError(response));\n                            }\n                            else {\n                                reject(new RadarUnknownError(response));\n                            }\n                        };\n                        xhr.onerror = function () {\n                            if (host && host === 'https://radar-verify.com:52516') {\n                                reject(new RadarDesktopAppError());\n                            }\n                            else {\n                                reject(new RadarServerError());\n                            }\n                        };\n                        xhr.ontimeout = function () {\n                            reject(new RadarTimeoutError());\n                        };\n                        xhr.send(JSON.stringify(body));\n                    })];\n            });\n        });\n    };\n    return Http;\n}());\n\nvar AddressesAPI = /** @class */ (function () {\n    function AddressesAPI() {\n    }\n    AddressesAPI.validateAddress = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, response, address, result, validateAddressRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'addresses/validate',\n                                data: params,\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        address = response.address, result = response.result;\n                        validateAddressRes = {\n                            address: address,\n                            result: result,\n                        };\n                        if (options.debug) {\n                            validateAddressRes.response = response;\n                        }\n                        return [2 /*return*/, validateAddressRes];\n                }\n            });\n        });\n    };\n    return AddressesAPI;\n}());\n\nvar generateUUID = function () {\n    var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (char) {\n        var r = Math.random() * 16 | 0;\n        var v = (char == 'x') ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n    return uuid;\n};\nvar Device = /** @class */ (function () {\n    function Device() {\n    }\n    Device.getDeviceId = function () {\n        // use existing deviceId if present\n        var deviceId = Storage.getItem(Storage.DEVICE_ID);\n        if (deviceId) {\n            return deviceId;\n        }\n        // generate new deviceId\n        var uuid = generateUUID();\n        Storage.setItem(Storage.DEVICE_ID, uuid);\n        return uuid;\n    };\n    Device.getInstallId = function () {\n        // use existing installId if present\n        var deviceId = Storage.getItem(Storage.INSTALL_ID);\n        if (deviceId) {\n            return deviceId;\n        }\n        // generate new installId\n        var uuid = generateUUID();\n        Storage.setItem(Storage.INSTALL_ID, uuid);\n        return uuid;\n    };\n    return Device;\n}());\n\nvar SESSION_TIMEOUT_SECS = 300; // 5 mins\nvar isValid = function (sessionId) {\n    var now = Math.trunc(Date.now() / 1000);\n    var session = Number.parseInt(sessionId);\n    var diff = Math.abs(now - session);\n    return diff < SESSION_TIMEOUT_SECS;\n};\nvar Session = /** @class */ (function () {\n    function Session() {\n    }\n    Session.getSessionId = function () {\n        var sessionId = Storage.getItem(Storage.SESSION_ID);\n        // reuse session if still within 5 min threshold\n        if (sessionId && isValid(sessionId)) {\n            return sessionId;\n        }\n        // create new session if does not already exist or expired\n        var newSessionId = Math.trunc(Date.now() / 1000).toString(); // unix ts in seconds\n        Storage.setItem(Storage.SESSION_ID, newSessionId);\n        return newSessionId;\n    };\n    return Session;\n}());\n\nvar ConfigAPI = /** @class */ (function () {\n    function ConfigAPI() {\n    }\n    ConfigAPI.getConfig = function (params) {\n        if (params === void 0) { params = {}; }\n        return __awaiter(this, void 0, void 0, function () {\n            var options, deviceId, installId, sessionId, locationAuthorization, data, err_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        if (options.version != 'v1') {\n                            Logger.info('Skipping /config call.');\n                            return [2 /*return*/];\n                        }\n                        deviceId = params.deviceId || Device.getDeviceId();\n                        installId = params.installId || Device.getInstallId();\n                        sessionId = Session.getSessionId();\n                        return [4 /*yield*/, Navigator.getPermissionStatus()];\n                    case 1:\n                        locationAuthorization = _a.sent();\n                        data = {\n                            deviceId: deviceId,\n                            installId: installId,\n                            sessionId: sessionId,\n                            locationAuthorization: locationAuthorization,\n                        };\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'config',\n                                data: data,\n                            })];\n                    case 3:\n                        _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_1 = _a.sent();\n                        Logger.warn(\"Error calling /config: \".concat(err_1.message));\n                        return [3 /*break*/, 5];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return ConfigAPI;\n}());\n\nvar ContextAPI = /** @class */ (function () {\n    function ContextAPI() {\n    }\n    ContextAPI.getContext = function (location) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, latitude, longitude, accuracy, response, geofences, place, country, state, dma, postalCode, contextRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        if (!(!location.latitude || !location.longitude)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Navigator.getCurrentPosition()];\n                    case 1:\n                        location = _a.sent();\n                        _a.label = 2;\n                    case 2:\n                        latitude = location.latitude, longitude = location.longitude, accuracy = location.accuracy;\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'context',\n                                data: {\n                                    coordinates: \"\".concat(latitude, \",\").concat(longitude),\n                                    accuracy: accuracy,\n                                },\n                            })];\n                    case 3:\n                        response = _a.sent();\n                        geofences = response.geofences, place = response.place, country = response.country, state = response.state, dma = response.dma, postalCode = response.postalCode;\n                        contextRes = {\n                            location: location,\n                            geofences: geofences,\n                            place: place,\n                            country: country,\n                            state: state,\n                            dma: dma,\n                            postalCode: postalCode,\n                        };\n                        if (options.debug) {\n                            contextRes.response = response;\n                        }\n                        return [2 /*return*/, contextRes];\n                }\n            });\n        });\n    };\n    return ContextAPI;\n}());\n\nvar ConversionsAPI = /** @class */ (function () {\n    function ConversionsAPI() {\n    }\n    ConversionsAPI.logConversion = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, name, userId, deviceId, installId, metadata, createdAt, data, response, conversionRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        name = params.name;\n                        userId = params.userId || Storage.getItem(Storage.USER_ID);\n                        deviceId = params.deviceId || Device.getDeviceId();\n                        installId = params.installId || Device.getInstallId();\n                        metadata = params.metadata || {};\n                        createdAt = params.createdAt;\n                        if (params.revenue) {\n                            metadata.revenue = params.revenue;\n                        }\n                        data = {\n                            name: name,\n                            userId: userId,\n                            deviceId: deviceId,\n                            installId: installId,\n                            metadata: metadata,\n                        };\n                        if (typeof createdAt === 'string') {\n                            data.createdAt = createdAt;\n                        }\n                        else if (createdAt instanceof Date) {\n                            data.createdAt = createdAt.toISOString();\n                        }\n                        else {\n                            data.createdAt = (new Date()).toISOString();\n                        }\n                        return [4 /*yield*/, Http.request({\n                                method: 'POST',\n                                path: 'events',\n                                data: data,\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        conversionRes = {\n                            event: response.event,\n                        };\n                        if (options.debug) {\n                            conversionRes.response = response;\n                        }\n                        return [2 /*return*/, conversionRes];\n                }\n            });\n        });\n    };\n    return ConversionsAPI;\n}());\n\nvar Geocoding = /** @class */ (function () {\n    function Geocoding() {\n    }\n    Geocoding.forwardGeocode = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, query, layers, country, response, forwardGeocodeRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        query = params.query, layers = params.layers, country = params.country;\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'geocode/forward',\n                                data: {\n                                    query: query,\n                                    layers: layers,\n                                    country: country,\n                                },\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        forwardGeocodeRes = {\n                            addresses: response.addresses,\n                        };\n                        if (options.debug) {\n                            forwardGeocodeRes.response = response;\n                        }\n                        return [2 /*return*/, forwardGeocodeRes];\n                }\n            });\n        });\n    };\n    Geocoding.reverseGeocode = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, latitude, longitude, layers, location_1, response, reverseGeocodeRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        latitude = params.latitude, longitude = params.longitude, layers = params.layers;\n                        if (!(!latitude || !longitude)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Navigator.getCurrentPosition()];\n                    case 1:\n                        location_1 = _a.sent();\n                        latitude = location_1.latitude;\n                        longitude = location_1.longitude;\n                        _a.label = 2;\n                    case 2: return [4 /*yield*/, Http.request({\n                            method: 'GET',\n                            path: 'geocode/reverse',\n                            data: {\n                                coordinates: \"\".concat(latitude, \",\").concat(longitude),\n                                layers: layers,\n                            },\n                        })];\n                    case 3:\n                        response = _a.sent();\n                        reverseGeocodeRes = {\n                            addresses: response.addresses,\n                        };\n                        if (options.debug) {\n                            reverseGeocodeRes.response = response;\n                        }\n                        return [2 /*return*/, reverseGeocodeRes];\n                }\n            });\n        });\n    };\n    Geocoding.ipGeocode = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, response, ipGeocodeRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'geocode/ip',\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        ipGeocodeRes = {\n                            ip: response.ip,\n                            address: response.address,\n                            proxy: response.proxy,\n                        };\n                        if (options.debug) {\n                            ipGeocodeRes.response = response;\n                        }\n                        return [2 /*return*/, ipGeocodeRes];\n                }\n            });\n        });\n    };\n    return Geocoding;\n}());\n\nvar RoutingAPI = /** @class */ (function () {\n    function RoutingAPI() {\n    }\n    RoutingAPI.distance = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, origin, destination, modes, units, geometry, geometryPoints, _a, latitude, longitude, latitude, longitude, latitude, longitude, response, distanceRes;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        options = Config.get();\n                        origin = params.origin, destination = params.destination, modes = params.modes, units = params.units, geometry = params.geometry, geometryPoints = params.geometryPoints;\n                        if (!!origin) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Navigator.getCurrentPosition()];\n                    case 1:\n                        _a = _b.sent(), latitude = _a.latitude, longitude = _a.longitude;\n                        origin = \"\".concat(latitude, \",\").concat(longitude);\n                        return [3 /*break*/, 3];\n                    case 2:\n                        if (typeof origin !== 'string') { // origin is \"Location\" object\n                            latitude = origin.latitude, longitude = origin.longitude;\n                            origin = \"\".concat(latitude, \",\").concat(longitude);\n                        }\n                        _b.label = 3;\n                    case 3:\n                        if (typeof destination !== 'string') {\n                            latitude = destination.latitude, longitude = destination.longitude;\n                            destination = \"\".concat(latitude, \",\").concat(longitude);\n                        }\n                        if (Array.isArray(modes)) {\n                            modes = modes.join(',');\n                        }\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'route/distance',\n                                data: {\n                                    origin: origin,\n                                    destination: destination,\n                                    modes: modes,\n                                    units: units,\n                                    geometry: geometry,\n                                    geometryPoints: geometryPoints,\n                                },\n                            })];\n                    case 4:\n                        response = _b.sent();\n                        distanceRes = {\n                            routes: response.routes,\n                        };\n                        if (options.debug) {\n                            distanceRes.response = response;\n                        }\n                        return [2 /*return*/, distanceRes];\n                }\n            });\n        });\n    };\n    RoutingAPI.matrix = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, origins, destinations, mode, units, _a, latitude, longitude, originStrings, i, response, matrixRes;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        options = Config.get();\n                        origins = params.origins, destinations = params.destinations, mode = params.mode, units = params.units;\n                        if (!!origins) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Navigator.getCurrentPosition()];\n                    case 1:\n                        _a = _b.sent(), latitude = _a.latitude, longitude = _a.longitude;\n                        originStrings = [];\n                        for (i = 0; i < destinations.length; i++) {\n                            originStrings.push(\"\".concat(latitude, \",\").concat(longitude));\n                        }\n                        origins = originStrings.join('|');\n                        return [3 /*break*/, 3];\n                    case 2:\n                        if (Array.isArray(origins)) { // origin is a list of \"Location\" objects\n                            origins = origins.map(function (location) { return \"\".concat(location.latitude, \",\").concat(location.longitude); }).join('|');\n                        }\n                        _b.label = 3;\n                    case 3:\n                        // convert array to pipe-delimited string\n                        if (Array.isArray(destinations)) {\n                            destinations = destinations.map(function (location) { return \"\".concat(location.latitude, \",\").concat(location.longitude); }).join('|');\n                        }\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'route/matrix',\n                                data: {\n                                    origins: origins,\n                                    destinations: destinations,\n                                    mode: mode,\n                                    units: units,\n                                },\n                            })];\n                    case 4:\n                        response = _b.sent();\n                        matrixRes = {\n                            origins: response.origins,\n                            destinations: response.destinations,\n                            matrix: response.matrix,\n                        };\n                        if (options.debug) {\n                            matrixRes.response = response;\n                        }\n                        return [2 /*return*/, matrixRes];\n                }\n            });\n        });\n    };\n    return RoutingAPI;\n}());\n\nvar SearchAPI = /** @class */ (function () {\n    function SearchAPI() {\n    }\n    SearchAPI.autocomplete = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, query, near, limit, layers, countryCode, expandUnits, response, autocompleteRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        query = params.query, near = params.near, limit = params.limit, layers = params.layers, countryCode = params.countryCode, expandUnits = params.expandUnits;\n                        // near can be provided as a string or Location object\n                        // if \"near\" is not provided, request will fallback to IP based location\n                        if (near && typeof near !== 'string') {\n                            if (near.latitude && near.longitude) {\n                                near = \"\".concat(near.latitude, \",\").concat(near.longitude);\n                            }\n                        }\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'search/autocomplete',\n                                data: {\n                                    query: query,\n                                    near: near,\n                                    limit: limit,\n                                    layers: layers,\n                                    countryCode: countryCode,\n                                    expandUnits: expandUnits,\n                                },\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        autocompleteRes = {\n                            addresses: response.addresses,\n                        };\n                        if (options.debug) {\n                            autocompleteRes.response = response;\n                        }\n                        return [2 /*return*/, autocompleteRes];\n                }\n            });\n        });\n    };\n    SearchAPI.searchGeofences = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, near, radius, tags, metadata, limit, _a, latitude, longitude, latitude, longitude, response, geofencesSearchRes;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        options = Config.get();\n                        near = params.near, radius = params.radius, tags = params.tags, metadata = params.metadata, limit = params.limit;\n                        if (!!near) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Navigator.getCurrentPosition()];\n                    case 1:\n                        _a = _b.sent(), latitude = _a.latitude, longitude = _a.longitude;\n                        near = \"\".concat(latitude, \",\").concat(longitude);\n                        return [3 /*break*/, 3];\n                    case 2:\n                        if (typeof near !== 'string') { // near is \"Location\" object\n                            latitude = near.latitude, longitude = near.longitude;\n                            near = \"\".concat(latitude, \",\").concat(longitude);\n                        }\n                        _b.label = 3;\n                    case 3:\n                        // convert arrays to comma-strings\n                        if (Array.isArray(tags)) {\n                            tags = tags.join(',');\n                        }\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'search/geofences',\n                                data: {\n                                    near: near,\n                                    radius: radius,\n                                    tags: tags,\n                                    metadata: metadata,\n                                    limit: limit,\n                                },\n                            })];\n                    case 4:\n                        response = _b.sent();\n                        geofencesSearchRes = {\n                            geofences: response.geofences,\n                        };\n                        if (options.debug) {\n                            geofencesSearchRes.response = response;\n                        }\n                        return [2 /*return*/, geofencesSearchRes];\n                }\n            });\n        });\n    };\n    SearchAPI.searchPlaces = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, near, radius, chains, categories, groups, limit, _a, latitude, longitude, latitude, longitude, response, placeSearchRes;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        options = Config.get();\n                        near = params.near, radius = params.radius, chains = params.chains, categories = params.categories, groups = params.groups, limit = params.limit;\n                        if (!!near) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Navigator.getCurrentPosition()];\n                    case 1:\n                        _a = _b.sent(), latitude = _a.latitude, longitude = _a.longitude;\n                        near = \"\".concat(latitude, \",\").concat(longitude);\n                        return [3 /*break*/, 3];\n                    case 2:\n                        if (typeof near !== 'string') { // near is \"Location\" object\n                            latitude = near.latitude, longitude = near.longitude;\n                            near = \"\".concat(latitude, \",\").concat(longitude);\n                        }\n                        _b.label = 3;\n                    case 3:\n                        // convert arrays to comma-strings\n                        if (Array.isArray(chains)) {\n                            chains = chains.join(',');\n                        }\n                        if (Array.isArray(categories)) {\n                            categories = categories.join(',');\n                        }\n                        if (Array.isArray(groups)) {\n                            groups = groups.join(',');\n                        }\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'search/places',\n                                data: {\n                                    near: near,\n                                    radius: radius,\n                                    chains: chains,\n                                    categories: categories,\n                                    groups: groups,\n                                    limit: limit,\n                                },\n                            })];\n                    case 4:\n                        response = _b.sent();\n                        placeSearchRes = {\n                            places: response.places,\n                        };\n                        if (options.debug) {\n                            placeSearchRes.response = response;\n                        }\n                        return [2 /*return*/, placeSearchRes];\n                }\n            });\n        });\n    };\n    return SearchAPI;\n}());\n\n// https://stackoverflow.com/a/44198641\nvar isValidDate = function (date) { return date && Object.prototype.toString.call(date) === '[object Date]' && !isNaN(date); };\nvar TripsAPI = /** @class */ (function () {\n    function TripsAPI() {\n    }\n    TripsAPI.setTripOptions = function (tripOptions) {\n        if (!tripOptions) {\n            TripsAPI.clearTripOptions();\n            return;\n        }\n        var tripOptionsString = JSON.stringify(tripOptions);\n        Logger.debug(\"Saving trip options: \".concat(tripOptionsString));\n        Storage.setItem(Storage.TRIP_OPTIONS, tripOptionsString);\n    };\n    TripsAPI.getTripOptions = function () {\n        var tripOptions = Storage.getItem(Storage.TRIP_OPTIONS);\n        if (tripOptions) {\n            tripOptions = JSON.parse(tripOptions);\n        }\n        return tripOptions;\n    };\n    TripsAPI.clearTripOptions = function () {\n        Storage.removeItem(Storage.TRIP_OPTIONS);\n    };\n    TripsAPI.startTrip = function (tripOptions) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, userId, externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, data, response, tripRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        tripOptions = tripOptions || TripsAPI.getTripOptions();\n                        if (!tripOptions) {\n                            Logger.warn('tripOptions not set when calling \"startTrip\"');\n                        }\n                        userId = tripOptions.userId || Storage.getItem(Storage.USER_ID);\n                        if (userId && userId !== Storage.getItem(Storage.USER_ID)) {\n                            // set as userId for tracking if provided\n                            Storage.setItem(Storage.USER_ID, userId);\n                        }\n                        externalId = tripOptions.externalId, destinationGeofenceTag = tripOptions.destinationGeofenceTag, destinationGeofenceExternalId = tripOptions.destinationGeofenceExternalId, mode = tripOptions.mode, metadata = tripOptions.metadata, approachingThreshold = tripOptions.approachingThreshold, scheduledArrivalAt = tripOptions.scheduledArrivalAt;\n                        data = {\n                            userId: userId,\n                            externalId: externalId,\n                            destinationGeofenceTag: destinationGeofenceTag,\n                            destinationGeofenceExternalId: destinationGeofenceExternalId,\n                            mode: mode,\n                            metadata: metadata,\n                            approachingThreshold: approachingThreshold,\n                        };\n                        if (isValidDate(scheduledArrivalAt)) {\n                            data.scheduledArrivalAt = scheduledArrivalAt === null || scheduledArrivalAt === void 0 ? void 0 : scheduledArrivalAt.toJSON();\n                        }\n                        else {\n                            if (scheduledArrivalAt) {\n                                Logger.warn('Invalid date format for scheduledArrivalAt');\n                            }\n                            data.scheduledArrivalAt = undefined;\n                        }\n                        return [4 /*yield*/, Http.request({\n                                method: 'POST',\n                                path: 'trips',\n                                data: data,\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        // save trip options\n                        TripsAPI.setTripOptions(tripOptions);\n                        tripRes = {\n                            trip: response.trip,\n                            events: response.events,\n                        };\n                        if (options.debug) {\n                            tripRes.response = response;\n                        }\n                        return [2 /*return*/, tripRes];\n                }\n            });\n        });\n    };\n    TripsAPI.updateTrip = function (tripOptions, status) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, externalId, destinationGeofenceTag, destinationGeofenceExternalId, mode, metadata, approachingThreshold, scheduledArrivalAt, data, response, tripRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        tripOptions = tripOptions || TripsAPI.getTripOptions();\n                        if (!tripOptions) {\n                            Logger.warn('tripOptions not set when calling \"startTrip\"');\n                        }\n                        externalId = tripOptions.externalId, destinationGeofenceTag = tripOptions.destinationGeofenceTag, destinationGeofenceExternalId = tripOptions.destinationGeofenceExternalId, mode = tripOptions.mode, metadata = tripOptions.metadata, approachingThreshold = tripOptions.approachingThreshold, scheduledArrivalAt = tripOptions.scheduledArrivalAt;\n                        data = {\n                            status: status,\n                            externalId: externalId,\n                            destinationGeofenceTag: destinationGeofenceTag,\n                            destinationGeofenceExternalId: destinationGeofenceExternalId,\n                            mode: mode,\n                            metadata: metadata,\n                            approachingThreshold: approachingThreshold,\n                        };\n                        if (isValidDate(scheduledArrivalAt)) {\n                            data.scheduledArrivalAt = scheduledArrivalAt === null || scheduledArrivalAt === void 0 ? void 0 : scheduledArrivalAt.toJSON();\n                        }\n                        else {\n                            if (scheduledArrivalAt) {\n                                Logger.warn('Invalid date format for scheduledArrivalAt');\n                            }\n                            data.scheduledArrivalAt = undefined;\n                        }\n                        return [4 /*yield*/, Http.request({\n                                method: 'PATCH',\n                                path: \"trips/\".concat(externalId, \"/update\"),\n                                data: data,\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        tripRes = {\n                            trip: response.trip,\n                            events: response.events,\n                        };\n                        if (options.debug) {\n                            tripRes.response = response;\n                        }\n                        return [2 /*return*/, tripRes];\n                }\n            });\n        });\n    };\n    TripsAPI.completeTrip = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var tripOptions, tripResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tripOptions = TripsAPI.getTripOptions();\n                        return [4 /*yield*/, TripsAPI.updateTrip(tripOptions, 'completed')];\n                    case 1:\n                        tripResponse = _a.sent();\n                        // clear local trip options\n                        TripsAPI.clearTripOptions();\n                        return [2 /*return*/, tripResponse];\n                }\n            });\n        });\n    };\n    TripsAPI.cancelTrip = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var tripOptions, tripResponse;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        tripOptions = TripsAPI.getTripOptions();\n                        return [4 /*yield*/, TripsAPI.updateTrip(tripOptions, 'canceled')];\n                    case 1:\n                        tripResponse = _a.sent();\n                        // clear local trip options\n                        TripsAPI.clearTripOptions();\n                        return [2 /*return*/, tripResponse];\n                }\n            });\n        });\n    };\n    return TripsAPI;\n}());\n\nvar TrackAPI = /** @class */ (function () {\n    function TrackAPI() {\n    }\n    TrackAPI.trackOnce = function (params) {\n        return __awaiter(this, void 0, void 0, function () {\n            var options, latitude, longitude, accuracy, desiredAccuracy, deviceLocation, locationAuthorization, err_1, userId, deviceId, installId, sessionId, deviceType, description, metadata, tripOptions, body, response, user, events, location, trackRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        latitude = params.latitude, longitude = params.longitude, accuracy = params.accuracy, desiredAccuracy = params.desiredAccuracy;\n                        if (!(!latitude || !longitude)) return [3 /*break*/, 2];\n                        return [4 /*yield*/, Navigator.getCurrentPosition({ desiredAccuracy: desiredAccuracy })];\n                    case 1:\n                        deviceLocation = _a.sent();\n                        latitude = deviceLocation.latitude;\n                        longitude = deviceLocation.longitude;\n                        accuracy = deviceLocation.accuracy;\n                        _a.label = 2;\n                    case 2:\n                        _a.trys.push([2, 4, , 5]);\n                        return [4 /*yield*/, Navigator.getPermissionStatus()];\n                    case 3:\n                        locationAuthorization = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_1 = _a.sent();\n                        Logger.warn(\"Location authorization error: \".concat(err_1.message));\n                        return [3 /*break*/, 5];\n                    case 5:\n                        userId = params.userId || Storage.getItem(Storage.USER_ID);\n                        deviceId = params.deviceId || Device.getDeviceId();\n                        installId = params.installId || Device.getInstallId();\n                        sessionId = Session.getSessionId();\n                        deviceType = params.deviceType || 'Web';\n                        description = params.description || Storage.getItem(Storage.DESCRIPTION);\n                        // save userId for trip tracking\n                        if (!userId) {\n                            Logger.warn('userId not provided for trackOnce.');\n                        }\n                        else {\n                            Storage.setItem(Storage.USER_ID, userId);\n                        }\n                        metadata = params.metadata || Storage.getJSON(Storage.METADATA);\n                        tripOptions = params.tripOptions || TripsAPI.getTripOptions();\n                        if (tripOptions) {\n                            tripOptions.version = '2';\n                        }\n                        body = __assign(__assign({}, params), { locationAuthorization: locationAuthorization, accuracy: accuracy, description: description, deviceId: deviceId, deviceType: deviceType, foreground: true, installId: installId, sessionId: sessionId, latitude: latitude, longitude: longitude, metadata: metadata, sdkVersion: SDK_VERSION, stopped: true, userId: userId, tripOptions: tripOptions });\n                        return [4 /*yield*/, Http.request({\n                                method: 'POST',\n                                path: 'track',\n                                data: body,\n                            })];\n                    case 6:\n                        response = _a.sent();\n                        user = response.user, events = response.events;\n                        location = { latitude: latitude, longitude: longitude, accuracy: accuracy };\n                        trackRes = {\n                            user: user,\n                            events: events,\n                            location: location,\n                        };\n                        if (options.debug) {\n                            trackRes.response = response;\n                        }\n                        return [2 /*return*/, trackRes];\n                }\n            });\n        });\n    };\n    return TrackAPI;\n}());\n\nvar VerifyAPI = /** @class */ (function () {\n    function VerifyAPI() {\n    }\n    VerifyAPI.trackVerified = function (params, encrypted) {\n        if (encrypted === void 0) { encrypted = false; }\n        return __awaiter(this, void 0, void 0, function () {\n            var options, userId, deviceId, installId, sessionId, description, metadata, body, userAgent, mac, response, user, events, token, location, trackTokenRes, trackRes;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        options = Config.get();\n                        userId = params.userId || Storage.getItem(Storage.USER_ID);\n                        deviceId = params.deviceId || Device.getDeviceId();\n                        installId = params.installId || Device.getInstallId();\n                        sessionId = Session.getSessionId();\n                        description = params.description || Storage.getItem(Storage.DESCRIPTION);\n                        // save userId\n                        if (!userId) {\n                            Logger.warn('userId not provided for trackVerified.');\n                        }\n                        else {\n                            Storage.setItem(Storage.USER_ID, userId);\n                        }\n                        metadata = params.metadata || Storage.getJSON(Storage.METADATA);\n                        body = __assign(__assign({}, params), { description: description, deviceId: deviceId, foreground: true, installId: installId, sessionId: sessionId, metadata: metadata, sdkVersion: SDK_VERSION, stopped: true, userId: userId, encrypted: encrypted });\n                        userAgent = navigator.userAgent;\n                        mac = userAgent && userAgent.toLowerCase().includes('mac');\n                        return [4 /*yield*/, Http.request({\n                                method: 'GET',\n                                path: 'verify',\n                                data: body,\n                                host: mac ? 'https://radar-verify.com:52516' : 'http://localhost:52516',\n                            })];\n                    case 1:\n                        response = _a.sent();\n                        user = response.user, events = response.events, token = response.token;\n                        if (user && user.location && user.location.coordinates && user.locationAccuracy) {\n                            location = {\n                                latitude: user.location.coordinates[1],\n                                longitude: user.location.coordinates[0],\n                                accuracy: user.locationAccuracy,\n                            };\n                        }\n                        if (encrypted) {\n                            trackTokenRes = {\n                                token: token,\n                            };\n                            if (options.debug) {\n                                trackTokenRes.response = response;\n                            }\n                            return [2 /*return*/, trackTokenRes];\n                        }\n                        trackRes = {\n                            user: user,\n                            events: events,\n                            location: location,\n                        };\n                        if (options.debug) {\n                            trackRes.response = response;\n                        }\n                        return [2 /*return*/, trackRes];\n                }\n            });\n        });\n    };\n    return VerifyAPI;\n}());\n\nvar DEFAULT_STYLE = 'radar-default-v1';\nvar RADAR_STYLES = [\n    'radar-default-v1',\n    'radar-light-v1',\n    'radar-dark-v1',\n];\nvar RADAR_LOGO_URL = 'https://api.radar.io/maps/static/images/logo.svg';\nvar defaultMaplibreOptions = {\n    minZoom: 1,\n    maxZoom: 20,\n    attributionControl: false,\n    dragRotate: false,\n    touchPitch: false,\n    maplibreLogo: false,\n};\nvar defaultMarkerOptions = {\n    color: '#000257',\n};\nvar createStyleURL = function (options, style) {\n    if (style === void 0) { style = DEFAULT_STYLE; }\n    return (\"\".concat(options.host, \"/maps/styles/\").concat(style, \"?publishableKey=\").concat(options.publishableKey));\n};\n// use formatted style URL if using one of Radar's out-of-the-box styles\nvar getStyle = function (options, mapOptions) {\n    var style = mapOptions.style;\n    if (!style || (typeof style === 'string' && RADAR_STYLES.includes(style))) {\n        return createStyleURL(options, mapOptions.style);\n    }\n    return mapOptions.style;\n};\nvar MapUI = /** @class */ (function () {\n    function MapUI() {\n    }\n    MapUI.getMapLibre = function () {\n        return maplibre_gl__WEBPACK_IMPORTED_MODULE_0__;\n    };\n    MapUI.createMap = function (mapOptions) {\n        var options = Config.get();\n        if (!options.publishableKey) {\n            Logger.warn('publishableKey not set. Call Radar.initialize() with key before creating a new map.');\n        }\n        // configure maplibre options\n        var style = getStyle(options, mapOptions);\n        var maplibreOptions = Object.assign({}, defaultMaplibreOptions, mapOptions, { style: style });\n        Logger.debug(\"initialize map with options: \".concat(JSON.stringify(maplibreOptions)));\n        // set container\n        maplibreOptions.container = mapOptions.container;\n        // custom request handler for Radar styles\n        maplibreOptions.transformRequest = function (url, resourceType) {\n            if (resourceType === 'Style' && RADAR_STYLES.includes(url)) {\n                var radarStyleURL = createStyleURL(options, url);\n                return { url: radarStyleURL };\n            }\n            else {\n                return { url: url };\n            }\n        };\n        // create map\n        var map = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Map(maplibreOptions);\n        var container = map.getContainer();\n        if (!container.style.width && !container.style.height) {\n            Logger.warn('map container does not have a set \"width\" or \"height\"');\n        }\n        // add radar logo\n        var img = document.createElement('img');\n        img.src = RADAR_LOGO_URL;\n        var link = document.createElement('a');\n        link.id = 'radar-map-logo';\n        link.href = 'https://radar.com?ref=powered_by_radar';\n        link.target = '_blank';\n        link.style.position = 'absolute';\n        link.style.bottom = '0';\n        link.style.left = '5px';\n        link.style.width = '80px';\n        link.style.height = '38px';\n        link.appendChild(img);\n        map.getContainer().appendChild(link);\n        // add attribution\n        var attribution = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.AttributionControl({ compact: false });\n        map.addControl(attribution, 'bottom-right');\n        // add zoom controls\n        var nav = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.NavigationControl({ showCompass: false });\n        map.addControl(nav, 'bottom-right');\n        // handle map resize actions\n        var onResize = function () {\n            var attrib = document.querySelector('.maplibregl-ctrl-attrib');\n            if (attrib) {\n                var width = map.getContainer().clientWidth;\n                if (width < 380) {\n                    attrib.classList.add('hidden');\n                }\n                else {\n                    attrib.classList.remove('hidden');\n                }\n            }\n        };\n        map.on('resize', onResize);\n        map.on('load', onResize);\n        return map;\n    };\n    MapUI.createMarker = function (markerOptions) {\n        if (markerOptions === void 0) { markerOptions = {}; }\n        var maplibreOptions = Object.assign({}, defaultMarkerOptions);\n        if (markerOptions.color) {\n            maplibreOptions.color = markerOptions.color;\n        }\n        if (markerOptions.element) {\n            maplibreOptions.element = markerOptions.element;\n        }\n        if (markerOptions.scale) {\n            maplibreOptions.scale = markerOptions.scale;\n        }\n        var marker = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Marker(maplibreOptions);\n        // set popup text or HTML\n        if (markerOptions.text) {\n            var popup = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup({ offset: 35 }).setText(markerOptions.text);\n            marker.setPopup(popup);\n        }\n        else if (markerOptions.html) {\n            var popup = new maplibre_gl__WEBPACK_IMPORTED_MODULE_0__.Popup({ offset: 35 }).setHTML(markerOptions.html);\n            marker.setPopup(popup);\n        }\n        return marker;\n    };\n    return MapUI;\n}());\n\nvar CLASSNAMES = {\n    WRAPPER: 'radar-autocomplete-wrapper',\n    INPUT: 'radar-autocomplete-input',\n    SEARCH_ICON: 'radar-autocomplete-search-icon',\n    RESULTS_LIST: 'radar-autocomplete-results-list',\n    RESULTS_ITEM: 'radar-autocomplete-results-item',\n    RESULTS_MARKER: 'radar-autocomplete-results-marker',\n    SELECTED_ITEM: 'radar-autocomplete-results-item-selected',\n    POWERED_BY_RADAR: 'radar-powered',\n    NO_RESULTS: 'radar-no-results',\n};\nvar ARIA = {\n    EXPANDED: 'aria-expanded',\n};\nvar defaultAutocompleteOptions = {\n    container: 'autocomplete',\n    debounceMS: 200,\n    minCharacters: 3,\n    limit: 8,\n    placeholder: 'Search address',\n    responsive: true,\n    disabled: false,\n    showMarkers: true,\n    hideResultsOnBlur: true,\n};\n// determine whether to use px or CSS string\nvar formatCSSValue = function (value) {\n    if (typeof value === 'number') {\n        return \"\".concat(value, \"px\");\n    }\n    return value;\n};\nvar DEFAULT_WIDTH = 400;\nvar setWidth = function (input, options) {\n    // if responsive and width is provided, treat it as maxWidth\n    if (options.responsive) {\n        input.style.width = '100%';\n        if (options.width) {\n            input.style.maxWidth = formatCSSValue(options.width);\n        }\n        return;\n    }\n    // if not responsive, set fixed width and unset maxWidth\n    input.style.width = formatCSSValue(options.width || DEFAULT_WIDTH);\n    input.style.removeProperty('max-width');\n};\nvar setHeight = function (resultsList, options) {\n    if (options.maxHeight) {\n        resultsList.style.maxHeight = formatCSSValue(options.maxHeight);\n        resultsList.style.overflowY = 'auto'; /* allow overflow when maxHeight is applied */\n    }\n};\nvar getMarkerIcon = function (color) {\n    if (color === void 0) { color = \"#ACBDC8\"; }\n    var fill = color.replace('#', '%23');\n    var svg = \"<svg width=\\\"16\\\" height=\\\"16\\\" viewBox=\\\"0 0 16 16\\\" fill=\\\"none\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n    <path d=\\\"M12.5704 6.57036C12.5704 4.11632 10.6342 2.11257 8.21016 2C8.14262 2 8.06757 2 8.00003 2C7.93249 2 7.85744 2 7.7899 2C5.35838 2.11257 3.42967 4.11632 3.42967 6.57036C3.42967 6.60037 3.42967 6.6379 3.42967 6.66792C3.42967 6.69794 3.42967 6.73546 3.42967 6.76548C3.42967 9.46717 7.09196 13.3621 7.4672 13.7598C7.61729 13.9174 7.84994 14 8.00003 14C8.15012 14 8.38277 13.9174 8.53286 13.7598C8.9156 13.3621 12.5704 9.46717 12.5704 6.76548C12.5704 6.72795 12.5704 6.69794 12.5704 6.66792C12.5704 6.6379 12.5704 6.60037 12.5704 6.57036ZM7.99252 8.28893C7.04693 8.28893 6.27395 7.52345 6.27395 6.57036C6.27395 5.61726 7.03943 4.85178 7.99252 4.85178C8.94562 4.85178 9.7111 5.61726 9.7111 6.57036C9.7111 7.52345 8.94562 8.28893 7.99252 8.28893Z\\\" fill=\\\"\".concat(fill, \"\\\"/>\\n  </svg>\").trim();\n    return \"data:image/svg+xml;charset=utf-8,\".concat(svg);\n};\nvar AutocompleteUI = /** @class */ (function () {\n    function AutocompleteUI(options) {\n        if (options === void 0) { options = {}; }\n        this.config = Object.assign({}, defaultAutocompleteOptions, options);\n        // setup state\n        this.isOpen = false;\n        this.debouncedFetchResults = this.debounce(this.fetchResults, this.config.debounceMS);\n        this.results = [];\n        this.highlightedIndex = -1;\n        // set threshold alias\n        if (this.config.threshold !== undefined) {\n            this.config.minCharacters = this.config.threshold;\n            Logger.warn('AutocompleteUI option \"threshold\" is deprecated, use \"minCharacters\" instead.');\n        }\n        if (options.near) {\n            if (typeof options.near === 'string') {\n                this.near = options.near;\n            }\n            else {\n                this.near = \"\".concat(options.near.latitude, \",\").concat(options.near.longitude);\n            }\n        }\n        // get container element\n        var containerEL;\n        if (typeof this.config.container === 'string') { // lookup container element by ID\n            containerEL = document.getElementById(this.config.container);\n        }\n        else { // use provided element\n            containerEL = this.config.container; // HTMLElement\n        }\n        if (!containerEL) {\n            throw new RadarAutocompleteContainerNotFound(\"Could not find container element: \".concat(this.config.container));\n        }\n        this.container = containerEL;\n        // create wrapper for input and result list\n        this.wrapper = document.createElement('div');\n        this.wrapper.classList.add(CLASSNAMES.WRAPPER);\n        this.wrapper.style.display = this.config.responsive ? 'block' : 'inline-block';\n        setWidth(this.wrapper, this.config);\n        // result list element\n        this.resultsList = document.createElement('ul');\n        this.resultsList.classList.add(CLASSNAMES.RESULTS_LIST);\n        setHeight(this.resultsList, this.config);\n        if (containerEL.nodeName === 'INPUT') {\n            // if an <input> element is provided, use that as the inputField,\n            // and append the resultList to it's parent container\n            this.inputField = containerEL;\n            // append to dom\n            this.wrapper.appendChild(this.resultsList);\n            containerEL.parentNode.appendChild(this.wrapper);\n        }\n        else {\n            // if container is not an input, create new input and append to container\n            // create new input\n            this.inputField = document.createElement('input');\n            this.inputField.classList.add(CLASSNAMES.INPUT);\n            this.inputField.placeholder = this.config.placeholder;\n            this.inputField.type = 'text';\n            this.inputField.disabled = this.config.disabled;\n            // search icon\n            var searchIcon = document.createElement('div');\n            searchIcon.classList.add(CLASSNAMES.SEARCH_ICON);\n            // append to DOM\n            this.wrapper.appendChild(this.inputField);\n            this.wrapper.appendChild(this.resultsList);\n            this.wrapper.appendChild(searchIcon);\n            this.container.appendChild(this.wrapper);\n        }\n        // setup event listeners\n        this.inputField.addEventListener('input', this.handleInput.bind(this));\n        this.inputField.addEventListener('keydown', this.handleKeyboardNavigation.bind(this));\n        if (this.config.hideResultsOnBlur) {\n            this.inputField.addEventListener('blur', this.close.bind(this), true);\n        }\n        Logger.debug(\"AutocompleteUI iniailized with options: \".concat(JSON.stringify(this.config)));\n    }\n    // create a new AutocompleteUI instance\n    AutocompleteUI.createAutocomplete = function (autocompleteOptions) {\n        return new AutocompleteUI(autocompleteOptions);\n    };\n    AutocompleteUI.prototype.handleInput = function () {\n        var _this = this;\n        // Fetch autocomplete results and display them\n        var query = this.inputField.value;\n        if (query.length < this.config.minCharacters) {\n            return;\n        }\n        this.debouncedFetchResults(query)\n            .then(function (results) {\n            var onResults = _this.config.onResults;\n            if (onResults) {\n                onResults(results);\n            }\n            _this.displayResults(results);\n        })\n            .catch(function (error) {\n            Logger.warn(\"Autocomplete ui error: \".concat(error.message));\n            var onError = _this.config.onError;\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n    AutocompleteUI.prototype.debounce = function (fn, delay) {\n        var _this = this;\n        var timeoutId;\n        var resolveFn;\n        var rejectFn;\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            clearTimeout(timeoutId);\n            timeoutId = setTimeout(function () {\n                var result = fn.apply(_this, args);\n                if (result instanceof Promise) {\n                    result\n                        .then(function (value) {\n                        if (resolveFn) {\n                            resolveFn(value);\n                        }\n                    })\n                        .catch(function (error) {\n                        if (rejectFn) {\n                            rejectFn(error);\n                        }\n                    });\n                }\n            }, delay);\n            return new Promise(function (resolve, reject) {\n                resolveFn = resolve;\n                rejectFn = reject;\n            });\n        };\n    };\n    AutocompleteUI.prototype.fetchResults = function (query) {\n        return __awaiter(this, void 0, void 0, function () {\n            var _a, limit, layers, countryCode, expandUnits, onRequest, params, addresses;\n            return __generator(this, function (_b) {\n                switch (_b.label) {\n                    case 0:\n                        _a = this.config, limit = _a.limit, layers = _a.layers, countryCode = _a.countryCode, expandUnits = _a.expandUnits, onRequest = _a.onRequest;\n                        params = {\n                            query: query,\n                            limit: limit,\n                            layers: layers,\n                            countryCode: countryCode,\n                            expandUnits: expandUnits,\n                        };\n                        if (this.near) {\n                            params.near = this.near;\n                        }\n                        if (onRequest) {\n                            onRequest(params);\n                        }\n                        return [4 /*yield*/, SearchAPI.autocomplete(params)];\n                    case 1:\n                        addresses = (_b.sent()).addresses;\n                        return [2 /*return*/, addresses];\n                }\n            });\n        });\n    };\n    AutocompleteUI.prototype.displayResults = function (results) {\n        var _this = this;\n        // Clear the previous results\n        this.clearResultsList();\n        this.results = results;\n        var marker;\n        if (this.config.showMarkers) {\n            marker = document.createElement('img');\n            marker.classList.add(CLASSNAMES.RESULTS_MARKER);\n            marker.setAttribute('src', getMarkerIcon(this.config.markerColor));\n        }\n        // Create and append list items for each result\n        results.forEach(function (result, index) {\n            var li = document.createElement('li');\n            li.classList.add(CLASSNAMES.RESULTS_ITEM);\n            // construct result with bolded label\n            var listContent;\n            if (result.formattedAddress.includes(result.addressLabel) && result.layer !== 'postalCode') {\n                // if addressLabel is contained in the formatted address, bold the address label\n                var regex = new RegExp(\"(\".concat(result.addressLabel, \"),?\"));\n                listContent = result.formattedAddress.replace(regex, '<b>$1</b>');\n            }\n            else {\n                // otherwise append the address or place label to formatted address\n                var label = result.placeLabel || result.addressLabel;\n                listContent = \"<b>\".concat(label, \"</b> \").concat(result.formattedAddress);\n            }\n            li.innerHTML = listContent;\n            // prepend marker if enabled\n            if (marker) {\n                li.prepend(marker.cloneNode());\n            }\n            // add click handler to each result, use mousedown to fire before blur event\n            li.addEventListener('mousedown', function () {\n                _this.select(index);\n            });\n            _this.resultsList.appendChild(li);\n        });\n        this.open();\n        if (results.length > 0) {\n            var link = document.createElement('a');\n            link.href = 'https://radar.com?ref=powered_by_radar';\n            link.target = '_blank';\n            this.poweredByLink = link;\n            var poweredByText = document.createElement('span');\n            poweredByText.textContent = 'Powered by';\n            link.appendChild(poweredByText);\n            var radarLogo = document.createElement('span');\n            radarLogo.id = 'radar-powered-logo';\n            link.appendChild(radarLogo);\n            var poweredByContainer = document.createElement('div');\n            poweredByContainer.classList.add(CLASSNAMES.POWERED_BY_RADAR);\n            poweredByContainer.appendChild(link);\n            this.resultsList.appendChild(poweredByContainer);\n        }\n        else {\n            var noResultsText = document.createElement('div');\n            noResultsText.classList.add(CLASSNAMES.NO_RESULTS);\n            noResultsText.textContent = 'No results';\n            this.resultsList.appendChild(noResultsText);\n        }\n    };\n    AutocompleteUI.prototype.open = function () {\n        if (this.isOpen) {\n            return;\n        }\n        this.wrapper.setAttribute(ARIA.EXPANDED, 'true');\n        this.resultsList.removeAttribute('hidden');\n        this.isOpen = true;\n    };\n    AutocompleteUI.prototype.close = function (e) {\n        var _this = this;\n        if (!this.isOpen) {\n            return;\n        }\n        // run this code async to allow link click to propagate before blur\n        // (add 100ms delay if closed from link click)\n        var linkClick = e && (e.relatedTarget === this.poweredByLink);\n        setTimeout(function () {\n            _this.wrapper.removeAttribute(ARIA.EXPANDED);\n            _this.resultsList.setAttribute('hidden', '');\n            _this.highlightedIndex = -1;\n            _this.isOpen = false;\n            _this.clearResultsList();\n        }, linkClick ? 100 : 0);\n    };\n    AutocompleteUI.prototype.goTo = function (index) {\n        if (!this.isOpen || !this.results.length) {\n            return;\n        }\n        // wrap around\n        if (index < 0) {\n            index = this.results.length - 1;\n        }\n        else if (index >= this.results.length) {\n            index = 0;\n        }\n        var resultItems = this.resultsList.getElementsByTagName('li');\n        if (this.highlightedIndex > -1) {\n            // clear class names on previously highlighted item\n            resultItems[this.highlightedIndex].classList.remove(CLASSNAMES.SELECTED_ITEM);\n        }\n        // add class name to newly highlighted item\n        resultItems[index].classList.add(CLASSNAMES.SELECTED_ITEM);\n        this.highlightedIndex = index;\n    };\n    AutocompleteUI.prototype.handleKeyboardNavigation = function (event) {\n        // fallback to deprecated \"keyCode\" if event.code not set\n        var code = event.code !== undefined ? event.code : event.keyCode;\n        // allow event to propagate if result list is not open\n        if (!this.isOpen) {\n            return;\n        }\n        switch (code) {\n            // Next item\n            case 'Tab':\n            case 'ArrowDown':\n            case 40:\n                event.preventDefault();\n                this.goTo(this.highlightedIndex + 1);\n                break;\n            // Prev item\n            case 'ArrowUp':\n            case 38:\n                event.preventDefault();\n                this.goTo(this.highlightedIndex - 1);\n                break;\n            // Select\n            case 'Enter':\n            case 13:\n                this.select(this.highlightedIndex);\n                break;\n            // Close\n            case 'Esc':\n            case 27:\n                this.close();\n                break;\n        }\n    };\n    AutocompleteUI.prototype.select = function (index) {\n        var result = this.results[index];\n        if (!result) {\n            Logger.warn(\"No autocomplete result found at index: \".concat(index));\n            return;\n        }\n        var inputValue;\n        if (result.formattedAddress.includes(result.addressLabel)) {\n            inputValue = result.formattedAddress;\n        }\n        else {\n            var label = result.placeLabel || result.addressLabel;\n            inputValue = \"\".concat(label, \", \").concat(result.formattedAddress);\n        }\n        this.inputField.value = inputValue;\n        var onSelection = this.config.onSelection;\n        if (onSelection) {\n            onSelection(result);\n        }\n        // clear results list\n        this.close();\n    };\n    AutocompleteUI.prototype.clearResultsList = function () {\n        this.resultsList.innerHTML = '';\n        this.results = [];\n    };\n    // remove elements from DOM\n    AutocompleteUI.prototype.remove = function () {\n        Logger.debug('AutocompleteUI removed.');\n        this.inputField.remove();\n        this.resultsList.remove();\n        this.wrapper.remove();\n    };\n    AutocompleteUI.prototype.setNear = function (near) {\n        if (near === undefined || near === null) {\n            this.near = undefined;\n        }\n        else if (typeof near === 'string') {\n            this.near = near;\n        }\n        else {\n            this.near = \"\".concat(near.latitude, \",\").concat(near.longitude);\n        }\n        return this;\n    };\n    AutocompleteUI.prototype.setPlaceholder = function (placeholder) {\n        this.config.placeholder = placeholder;\n        this.inputField.placeholder = placeholder;\n        return this;\n    };\n    AutocompleteUI.prototype.setDisabled = function (disabled) {\n        this.config.disabled = disabled;\n        this.inputField.disabled = disabled;\n        return this;\n    };\n    AutocompleteUI.prototype.setResponsive = function (responsive) {\n        this.config.responsive = responsive;\n        setWidth(this.wrapper, this.config);\n        return this;\n    };\n    AutocompleteUI.prototype.setWidth = function (width) {\n        this.config.width = width;\n        setWidth(this.wrapper, this.config);\n        return this;\n    };\n    AutocompleteUI.prototype.setMaxHeight = function (height) {\n        this.config.maxHeight = height;\n        setHeight(this.resultsList, this.config);\n        return this;\n    };\n    AutocompleteUI.prototype.setMinCharacters = function (minCharacters) {\n        this.config.minCharacters = minCharacters;\n        this.config.threshold = minCharacters;\n        return this;\n    };\n    AutocompleteUI.prototype.setLimit = function (limit) {\n        this.config.limit = limit;\n        return this;\n    };\n    AutocompleteUI.prototype.setShowMarkers = function (showMarkers) {\n        this.config.showMarkers = showMarkers;\n        if (showMarkers) {\n            var marker = document.createElement('img');\n            marker.classList.add(CLASSNAMES.RESULTS_MARKER);\n            marker.setAttribute('src', getMarkerIcon(this.config.markerColor));\n            var resultItems = this.resultsList.getElementsByTagName('li');\n            for (var i = 0; i < resultItems.length; i++) {\n                var currentMarker = resultItems[i].getElementsByClassName(CLASSNAMES.RESULTS_MARKER)[0];\n                if (!currentMarker) {\n                    resultItems[i].prepend(marker.cloneNode());\n                }\n            }\n        }\n        else {\n            var resultItems = this.resultsList.getElementsByTagName('li');\n            for (var i = 0; i < resultItems.length; i++) {\n                var marker = resultItems[i].getElementsByClassName(CLASSNAMES.RESULTS_MARKER)[0];\n                if (marker) {\n                    marker.remove();\n                }\n            }\n        }\n        return this;\n    };\n    AutocompleteUI.prototype.setMarkerColor = function (color) {\n        this.config.markerColor = color;\n        var marker = this.resultsList.getElementsByClassName(CLASSNAMES.RESULTS_MARKER);\n        for (var i = 0; i < marker.length; i++) {\n            marker[i].setAttribute('src', getMarkerIcon(color));\n        }\n        return this;\n    };\n    AutocompleteUI.prototype.setHideResultsOnBlur = function (hideResultsOnBlur) {\n        this.config.hideResultsOnBlur = hideResultsOnBlur;\n        if (hideResultsOnBlur) {\n            this.inputField.addEventListener('blur', this.close.bind(this), true);\n        }\n        else {\n            this.inputField.removeEventListener('blur', this.close.bind(this), true);\n        }\n        return this;\n    };\n    return AutocompleteUI;\n}());\n\nvar isSecretKey = function (key) { return (key.includes('_sk_')); };\nvar isLiveKey = function (key) { return (key.includes('_live_')); };\nvar Radar = /** @class */ (function () {\n    function Radar() {\n    }\n    Object.defineProperty(Radar, \"VERSION\", {\n        get: function () {\n            return SDK_VERSION;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Radar, \"ui\", {\n        // \"ui\" namespace\n        get: function () {\n            return {\n                maplibregl: MapUI.getMapLibre(),\n                map: MapUI.createMap,\n                marker: MapUI.createMarker,\n                autocomplete: AutocompleteUI.createAutocomplete,\n            };\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Radar.initialize = function (publishableKey, options) {\n        if (options === void 0) { options = {}; }\n        if (!publishableKey) {\n            throw new RadarPublishableKeyError('Publishable key required in initialization.');\n        }\n        if (isSecretKey(publishableKey)) {\n            throw new RadarPublishableKeyError('Secret keys are not allowed. Please use your Radar publishable key.');\n        }\n        // store settings in global config\n        var live = isLiveKey(publishableKey);\n        var logLevel = live ? 'error' : 'info';\n        var debug = !live;\n        var radarOptions = Object.assign(Config.defaultOptions, {\n            publishableKey: publishableKey,\n            live: live,\n            logLevel: logLevel,\n            debug: debug,\n        }, options);\n        Config.setup(radarOptions);\n        Logger.info(\"initialized with \".concat(live ? 'live' : 'test', \" publishableKey.\"));\n        if (options.debug) {\n            Logger.info(\"using options: \".concat(JSON.stringify(options)));\n        }\n        // NOTE(jasonl): this allows us to run jest tests\n        // without having to mock the ConfigAPI.getConfig call\n        if (!(window === null || window === void 0 ? void 0 : window.RADAR_TEST_ENV)) {\n            ConfigAPI.getConfig();\n        }\n    };\n    Radar.clear = function () {\n        Config.clear();\n    };\n    ///////////////////////\n    // geofencing platform\n    ///////////////////////\n    Radar.setUserId = function (userId) {\n        if (!userId) {\n            Storage.removeItem(Storage.USER_ID);\n            return;\n        }\n        Storage.setItem(Storage.USER_ID, String(userId).trim());\n    };\n    Radar.setDescription = function (description) {\n        if (!description) {\n            Storage.removeItem(Storage.DESCRIPTION);\n            return;\n        }\n        Storage.setItem(Storage.DESCRIPTION, String(description).trim());\n    };\n    Radar.setMetadata = function (metadata) {\n        if (!metadata) {\n            Storage.removeItem(Storage.METADATA);\n            return;\n        }\n        Storage.setItem(Storage.METADATA, JSON.stringify(metadata));\n    };\n    Radar.getLocation = function () {\n        return Navigator.getCurrentPosition();\n    };\n    Radar.trackOnce = function (params) {\n        if (params === void 0) { params = {}; }\n        try {\n            return TrackAPI.trackOnce(params);\n        }\n        finally {\n            ConfigAPI.getConfig(params); // call with updated permissions\n        }\n    };\n    Radar.trackVerified = function (params) {\n        if (params === void 0) { params = {}; }\n        return VerifyAPI.trackVerified(params);\n    };\n    Radar.trackVerifiedToken = function (params) {\n        if (params === void 0) { params = {}; }\n        return VerifyAPI.trackVerified(params, true);\n    };\n    Radar.getContext = function (params) {\n        return ContextAPI.getContext(params);\n    };\n    Radar.setTripOptions = function (tripOptions) {\n        TripsAPI.setTripOptions(tripOptions);\n    };\n    Radar.clearTripOptions = function () {\n        TripsAPI.clearTripOptions();\n    };\n    Radar.getTripOptions = function () {\n        return TripsAPI.getTripOptions();\n    };\n    Radar.startTrip = function (tripOptions) {\n        return TripsAPI.startTrip(tripOptions);\n    };\n    Radar.updateTrip = function (tripOptions) {\n        return TripsAPI.updateTrip(tripOptions);\n    };\n    Radar.completeTrip = function () {\n        return TripsAPI.completeTrip();\n    };\n    Radar.cancelTrip = function () {\n        return TripsAPI.cancelTrip();\n    };\n    Radar.logConversion = function (params) {\n        return ConversionsAPI.logConversion(params);\n    };\n    /////////////////\n    // maps platform\n    /////////////////\n    Radar.forwardGeocode = function (params) {\n        return Geocoding.forwardGeocode(params);\n    };\n    Radar.reverseGeocode = function (params) {\n        return Geocoding.reverseGeocode(params);\n    };\n    Radar.ipGeocode = function () {\n        return Geocoding.ipGeocode();\n    };\n    Radar.autocomplete = function (params) {\n        return SearchAPI.autocomplete(params);\n    };\n    Radar.searchGeofences = function (params) {\n        return SearchAPI.searchGeofences(params);\n    };\n    Radar.searchPlaces = function (params) {\n        return SearchAPI.searchPlaces(params);\n    };\n    Radar.validateAddress = function (params) {\n        return AddressesAPI.validateAddress(params);\n    };\n    Radar.distance = function (params) {\n        return RoutingAPI.distance(params);\n    };\n    Radar.matrix = function (params) {\n        return RoutingAPI.matrix(params);\n    };\n    return Radar;\n}());\n\n\n//# sourceMappingURL=radar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmFkYXItc2RrLWpzQDQuMS4xMV9tYXBsaWJyZS1nbEAzLjUuMS9ub2RlX21vZHVsZXMvcmFkYXItc2RrLWpzL2Rpc3QvcmFkYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFO0FBQ0E7QUFDQSw2REFBNkQsOERBQThEO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0c7QUFDaEcscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSw2Q0FBNkMsOERBQThEO0FBQzNHLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QscUJBQXFCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsZ0ZBQWdGLHFFQUFxRTtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCx3RUFBd0Usc0VBQXNFO0FBQzlJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysc0VBQXNFO0FBQ3hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxrQ0FBa0M7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxhQUFhLHNWQUFzVjtBQUN0WjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGFBQWEsOE1BQThNO0FBQzlRO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdDQUFVO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDLGNBQWM7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsNENBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkRBQTZCLEdBQUcsZ0JBQWdCO0FBQzlFO0FBQ0E7QUFDQSxzQkFBc0IsMERBQTRCLEdBQUcsb0JBQW9CO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsK0NBQWlCO0FBQzFDO0FBQ0E7QUFDQSw0QkFBNEIsOENBQWdCLEdBQUcsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsOENBQWdCLEdBQUcsWUFBWTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBLGVBQWU7QUFDZixpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qix1QkFBdUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix3QkFBd0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxtQ0FBbUM7QUFDbkMsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUUyQjtBQUM1QiIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vcmFkYXItc2RrLWpzQDQuMS4xMV9tYXBsaWJyZS1nbEAzLjUuMS9ub2RlX21vZHVsZXMvcmFkYXItc2RrLWpzL2Rpc3QvcmFkYXIuanM/ZjRkMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWFwbGlicmVnbCBmcm9tICdtYXBsaWJyZS1nbCc7XG5cbnZhciBDb25maWcgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uZmlnKCkge1xuICAgIH1cbiAgICBDb25maWcuc2V0dXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBDb25maWcub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfTtcbiAgICBDb25maWcuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gQ29uZmlnLm9wdGlvbnMgfHwge307XG4gICAgfTtcbiAgICBDb25maWcuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIENvbmZpZy5vcHRpb25zID0ge307XG4gICAgfTtcbiAgICBDb25maWcuZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgICAgIGxpdmU6IGZhbHNlLFxuICAgICAgICBsb2dMZXZlbDogJ2Vycm9yJyxcbiAgICAgICAgaG9zdDogJ2h0dHBzOi8vYXBpLnJhZGFyLmlvJyxcbiAgICAgICAgdmVyc2lvbjogJ3YxJyxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgIH07XG4gICAgcmV0dXJuIENvbmZpZztcbn0oKSk7XG5cbnZhciBMT0dfTEVWRUxTID0ge1xuICAgIG5vbmU6IDAsXG4gICAgZXJyb3I6IDEsXG4gICAgd2FybjogMixcbiAgICBpbmZvOiAzLFxuICAgIGRlYnVnOiA0LFxufTtcbi8vIGdldCB0aGUgbnVtZXJpYyBsZXZlbCBmb3IgbG9nTGV2ZWwgb3B0aW9uXG52YXIgZ2V0TGV2ZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZGlzYWJsZSBsb2dnaW5nIGluIHRlc3RzXG4gICAgaWYgKHdpbmRvdyAmJiB3aW5kb3cuUkFEQVJfVEVTVF9FTlYpIHtcbiAgICAgICAgcmV0dXJuIExPR19MRVZFTFMubm9uZTtcbiAgICB9XG4gICAgdmFyIF9hID0gQ29uZmlnLmdldCgpLCBsb2dMZXZlbCA9IF9hLmxvZ0xldmVsLCBkZWJ1ZyA9IF9hLmRlYnVnO1xuICAgIGlmIChkZWJ1Zykge1xuICAgICAgICByZXR1cm4gTE9HX0xFVkVMUy5kZWJ1ZztcbiAgICB9XG4gICAgaWYgKGxvZ0xldmVsKSB7XG4gICAgICAgIHJldHVybiBMT0dfTEVWRUxTW2xvZ0xldmVsXTtcbiAgICB9XG4gICAgcmV0dXJuIExPR19MRVZFTFMuZXJyb3I7IC8vIGRlZmF1bHQgdG8gZXJyb3ItbGV2ZWwgbG9nZ2luZyBpZiBub3Qgc2V0XG59O1xudmFyIExvZ2dlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMb2dnZXIoKSB7XG4gICAgfVxuICAgIExvZ2dlci5kZWJ1ZyA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChnZXRMZXZlbCgpID09PSBMT0dfTEVWRUxTLmRlYnVnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlJhZGFyIFNESyAoZGVidWcpOiBcIi5jb25jYXQobWVzc2FnZS50cmltKCkpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLmluZm8gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2V0TGV2ZWwoKSA+PSBMT0dfTEVWRUxTLmluZm8pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUmFkYXIgU0RLOiBcIi5jb25jYXQobWVzc2FnZS50cmltKCkpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLndhcm4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAoZ2V0TGV2ZWwoKSA+PSBMT0dfTEVWRUxTLndhcm4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlJhZGFyIFNESzogXCIuY29uY2F0KG1lc3NhZ2UudHJpbSgpKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIExvZ2dlci5lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChnZXRMZXZlbCgpID49IExPR19MRVZFTFMuZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJSYWRhciBTREs6IFwiLmNvbmNhdChtZXNzYWdlLnRyaW0oKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpKTtcblxudmFyIFN0b3JhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3RvcmFnZSgpIHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0b3JhZ2UsIFwiVVNFUl9JRFwiLCB7XG4gICAgICAgIC8vIGxvY2FsIHN0b3JhZ2Uga2V5IGRlZmluaXRpb25zIGZvciBpZGVudGlmeWluZyB0cmFjayB1c2Vyc1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAncmFkYXItdXNlcklkJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yYWdlLCBcIkRFVklDRV9JRFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdyYWRhci1kZXZpY2VJZCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmFnZSwgXCJJTlNUQUxMX0lEXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JhZGFyLWluc3RhbGxJZCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmFnZSwgXCJTRVNTSU9OX0lEXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3JhZGFyLXNlc3Npb25JZCc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmFnZSwgXCJERVNDUklQVElPTlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdyYWRhci1kZXNjcmlwdGlvbic7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmFnZSwgXCJNRVRBREFUQVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdyYWRhci1tZXRhZGF0YSc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RvcmFnZSwgXCJDQUNIRURfTE9DQVRJT05cIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAncmFkYXItY2FjaGVkLWxvY2F0aW9uJztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdG9yYWdlLCBcIlRSSVBfT1BUSU9OU1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuICdyYWRhci10cmlwLW9wdGlvbnMnO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RvcmFnZS5nZXRTdG9yYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oJ2xvY2FsU3RvcmFnZSBub3QgYXZhaWxhYmxlLicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yYWdlO1xuICAgIH07XG4gICAgU3RvcmFnZS5zZXRJdGVtID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLmdldFN0b3JhZ2UoKTtcbiAgICAgICAgaWYgKCFzdG9yYWdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfTtcbiAgICBTdG9yYWdlLmdldEl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5nZXRTdG9yYWdlKCk7XG4gICAgICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlID0gc3RvcmFnZS5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdG9yYWdlLmdldEpTT04gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5nZXRJdGVtKGtleSk7XG4gICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKFwiY291bGQgbm90IGdldEpTT04gZnJvbSBzdG9yYWdlIGZvciBrZXk6IFwiLmNvbmNhdChrZXkpKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdG9yYWdlLnJlbW92ZUl0ZW0gPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5nZXRTdG9yYWdlKCk7XG4gICAgICAgIGlmICghc3RvcmFnZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgfTtcbiAgICBTdG9yYWdlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuZ2V0U3RvcmFnZSgpO1xuICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2UuY2xlYXIoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdG9yYWdlO1xufSgpKTtcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxuXG52YXIgUmFkYXJFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkYXJFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWRhckVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gJyc7IC8vIHRvIGJlIG92ZXJyaWRkZW4gKHN1cHBvcnQgZm9yIGxlZ2FjeSBzdGF0dXMpXG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJhZGFyRXJyb3I7XG59KEVycm9yKSk7XG52YXIgUmFkYXJQdWJsaXNoYWJsZUtleUVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYWRhclB1Ymxpc2hhYmxlS2V5RXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFkYXJQdWJsaXNoYWJsZUtleUVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdSYWRhclB1Ymxpc2hhYmxlS2V5RXJyb3InO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSAnRVJST1JfUFVCTElTSEFCTEVfS0VZJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmFkYXJQdWJsaXNoYWJsZUtleUVycm9yO1xufShSYWRhckVycm9yKSk7XG52YXIgUmFkYXJMb2NhdGlvbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYWRhckxvY2F0aW9uRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFkYXJMb2NhdGlvbkVycm9yKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdSYWRhckxvY2F0aW9uRXJyb3InO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSAnRVJST1JfTE9DQVRJT04nO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSYWRhckxvY2F0aW9uRXJyb3I7XG59KFJhZGFyRXJyb3IpKTtcbnZhciBSYWRhckxvY2F0aW9uUGVybWlzc2lvbnNFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkYXJMb2NhdGlvblBlcm1pc3Npb25zRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFkYXJMb2NhdGlvblBlcm1pc3Npb25zRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ1JhZGFyTG9jYXRpb25QZXJtaXNzaW9uc0Vycm9yJztcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gJ0VSUk9SX1BFUk1JU1NJT05TJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmFkYXJMb2NhdGlvblBlcm1pc3Npb25zRXJyb3I7XG59KFJhZGFyRXJyb3IpKTtcbnZhciBSYWRhckRlc2t0b3BBcHBFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkYXJEZXNrdG9wQXBwRXJyb3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmFkYXJEZXNrdG9wQXBwRXJyb3IoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICdEZXNrdG9wIGFwcCBub3QgcnVubmluZy4nKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ1JhZGFyRGVza3RvcEFwcEVycm9yJztcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gJ0VSUk9SX0RFU0tUT1BfQVBQJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmFkYXJEZXNrdG9wQXBwRXJyb3I7XG59KFJhZGFyRXJyb3IpKTtcbi8vIEhUVFAgRXJyb3JzXG52YXIgUmFkYXJCYWRSZXF1ZXN0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhZGFyQmFkUmVxdWVzdEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhZGFyQmFkUmVxdWVzdEVycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1ldGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnQmFkIHJlcXVlc3QuJykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdSYWRhckJhZFJlcXVlc3RFcnJvcic7XG4gICAgICAgIF90aGlzLmNvZGUgPSA0MDA7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9ICdFUlJPUl9CQURfUkVRVUVTVCc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJhZGFyQmFkUmVxdWVzdEVycm9yO1xufShSYWRhckVycm9yKSk7XG52YXIgUmFkYXJVbmF1dGhvcml6ZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkYXJVbmF1dGhvcml6ZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWRhclVuYXV0aG9yaXplZEVycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1ldGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnVW5hdXRob3JpemVkLicpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSAnUmFkYXJVbmF1dGhvcml6ZWRFcnJvcic7XG4gICAgICAgIF90aGlzLmNvZGUgPSA0MDE7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9ICdFUlJPUl9VTkFVVEhPUklaRUQnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSYWRhclVuYXV0aG9yaXplZEVycm9yO1xufShSYWRhckVycm9yKSk7XG52YXIgUmFkYXJQYXltZW50UmVxdWlyZWRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkYXJQYXltZW50UmVxdWlyZWRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWRhclBheW1lbnRSZXF1aXJlZEVycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1ldGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnUGF5bWVudCByZXF1aXJlZC4nKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5uYW1lID0gJ1JhZGFyUGF5bWVudFJlcXVpcmVkRXJyb3InO1xuICAgICAgICBfdGhpcy5jb2RlID0gNDAyO1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSAnRVJST1JfUEFZTUVOVF9SRVFVSVJFRCc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJhZGFyUGF5bWVudFJlcXVpcmVkRXJyb3I7XG59KFJhZGFyRXJyb3IpKTtcbnZhciBSYWRhckZvcmJpZGRlbkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYWRhckZvcmJpZGRlbkVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhZGFyRm9yYmlkZGVuRXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UubWV0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICdGb3JiaWRkZW4uJykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdSYWRhckZvcmJpZGRlbkVycm9yJztcbiAgICAgICAgX3RoaXMuY29kZSA9IDQwMztcbiAgICAgICAgX3RoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gJ0VSUk9SX0ZPUkJJRERFTic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJhZGFyRm9yYmlkZGVuRXJyb3I7XG59KFJhZGFyRXJyb3IpKTtcbnZhciBSYWRhck5vdEZvdW5kRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhZGFyTm90Rm91bmRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWRhck5vdEZvdW5kRXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsICgoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UubWV0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1lc3NhZ2UpIHx8ICdOb3QgZm91bmQuJykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdSYWRhck5vdEZvdW5kRXJyb3InO1xuICAgICAgICBfdGhpcy5jb2RlID0gNDA0O1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSAnRVJST1JfTk9UX0ZPVU5EJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmFkYXJOb3RGb3VuZEVycm9yO1xufShSYWRhckVycm9yKSk7XG52YXIgUmFkYXJSYXRlTGltaXRFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkYXJSYXRlTGltaXRFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWRhclJhdGVMaW1pdEVycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJ1JhdGUgbGltaXQgZXhjZWVkZWQuJykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdSYWRhclJhdGVMaW1pdEVycm9yJztcbiAgICAgICAgX3RoaXMuY29kZSA9IDQyOTtcbiAgICAgICAgX3RoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgX3RoaXMudHlwZSA9IChfYiA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHlwZTtcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gJ0VSUk9SX1JBVEVfTElNSVQnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSYWRhclJhdGVMaW1pdEVycm9yO1xufShSYWRhckVycm9yKSk7XG52YXIgUmFkYXJTZXJ2ZXJFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkYXJTZXJ2ZXJFcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWRhclNlcnZlckVycm9yKHJlc3BvbnNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAoKF9hID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLm1ldGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB8fCAnSW50ZXJuYWwgc2VydmVyIGVycm9yLicpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSAnUmFkYXJTZXJ2ZXJFcnJvcic7XG4gICAgICAgIF90aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9ICdFUlJPUl9TRVJWRVInO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSYWRhclNlcnZlckVycm9yO1xufShSYWRhckVycm9yKSk7XG52YXIgUmFkYXJUaW1lb3V0RXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJhZGFyVGltZW91dEVycm9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJhZGFyVGltZW91dEVycm9yKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCAnUmVxdWVzdCB0aW1lZCBvdXQuJykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdSYWRhclRpbWVvdXRFcnJvcic7XG4gICAgICAgIF90aGlzLnN0YXR1cyA9ICdFUlJPUl9USU1FRF9PVVQnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSYWRhclRpbWVvdXRFcnJvcjtcbn0oUmFkYXJFcnJvcikpO1xudmFyIFJhZGFyVW5rbm93bkVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSYWRhclVua25vd25FcnJvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWRhclVua25vd25FcnJvcihyZXNwb25zZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgKChfYSA9IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5tZXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJ1NvbWV0aGluZyB3ZW50IHdyb25nLicpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm5hbWUgPSAnUmFkYXJVbmtub3duRXJyb3InO1xuICAgICAgICBfdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICBfdGhpcy5zdGF0dXMgPSAnRVJST1JfVU5LTk9XTic7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFJhZGFyVW5rbm93bkVycm9yO1xufShSYWRhckVycm9yKSk7XG52YXIgUmFkYXJBdXRvY29tcGxldGVDb250YWluZXJOb3RGb3VuZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmFkYXJBdXRvY29tcGxldGVDb250YWluZXJOb3RGb3VuZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSYWRhckF1dG9jb21wbGV0ZUNvbnRhaW5lck5vdEZvdW5kKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9ICdSYWRhckF1dG9jb21wbGV0ZUNvbnRhaW5lck5vdEZvdW5kJztcbiAgICAgICAgX3RoaXMuc3RhdHVzID0gJ0NPTlRBSU5FUl9OT1RfRk9VTkQnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBSYWRhckF1dG9jb21wbGV0ZUNvbnRhaW5lck5vdEZvdW5kO1xufShSYWRhckVycm9yKSk7XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9HZW9sb2NhdGlvblBvc2l0aW9uRXJyb3JcbnZhciBQRVJNSVNTSU9OX0VSUk9SX01FU1NBR0VTID0ge1xuICAgIDE6ICdQZXJtaXNzaW9uIGRlbmllZC4nLFxuICAgIDI6ICdQb3NpdGlvbiB1bmF2YWlsYWJsZS4nLFxuICAgIDM6ICdUaW1lb3V0LicsXG59O1xudmFyIERFRkFVTFRfUE9TSVRJT05fT1BUSU9OUyA9IHtcbiAgICBtYXhpbXVtQWdlOiAwLFxuICAgIHRpbWVvdXQ6IDEwMDAgKiAzMCxcbiAgICBlbmFibGVIaWdoQWNjdXJhY3k6IHRydWUsXG59O1xuLy8gc2V0IFwiZW5hYmxlSGlnaEFjY3VyYWN5XCIgZm9yIG5hdmlnYXRvciBvbmx5IHdoZW4gZGVzaXJlZEFjY3VyYWN5IGlzIFwiaGlnaFwiXG52YXIgdXNlSGlnaEFjY3VyYWN5ID0gZnVuY3Rpb24gKGRlc2lyZWRBY2N1cmFjeSkgeyByZXR1cm4gKEJvb2xlYW4oZGVzaXJlZEFjY3VyYWN5ID09PSAnaGlnaCcpKTsgfTtcbnZhciBOYXZpZ2F0b3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTmF2aWdhdG9yKCkge1xuICAgIH1cbiAgICBOYXZpZ2F0b3IuZ2V0Q3VycmVudFBvc2l0aW9uID0gZnVuY3Rpb24gKG92ZXJyaWRlcykge1xuICAgICAgICBpZiAob3ZlcnJpZGVzID09PSB2b2lkIDApIHsgb3ZlcnJpZGVzID0ge307IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbmF2aWdhdG9yIHx8ICFuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBSYWRhckxvY2F0aW9uRXJyb3IoJ25hdmlnYXRvci5nZW9sb2NhdGlvbiBpcyBub3QgYXZhaWxhYmxlLicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVzZSBjYWNoZWQgbG9jYXRpb24gaWYgYXZhaWxhYmxlIGFuZCBvcHRpb25zIGFyZSBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhY2hlTG9jYXRpb25NaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJhd0NhY2hlZExvY2F0aW9uID0gU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2UuQ0FDSEVEX0xPQ0FUSU9OKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhd0NhY2hlZExvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2FjaGVkTG9jYXRpb24gPSBKU09OLnBhcnNlKHJhd0NhY2hlZExvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYSA9IGNhY2hlZExvY2F0aW9uIHx8IHt9LCBsYXRpdHVkZSA9IF9hLmxhdGl0dWRlLCBsb25naXR1ZGUgPSBfYS5sb25naXR1ZGUsIGFjY3VyYWN5ID0gX2EuYWNjdXJhY3ksIGV4cGlyZXNBdCA9IF9hLmV4cGlyZXNBdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChEYXRlLm5vdygpIDwgcGFyc2VJbnQoZXhwaXJlc0F0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXRpdHVkZSAmJiBsb25naXR1ZGUgJiYgYWNjdXJhY3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBsYXRpdHVkZTogbGF0aXR1ZGUsIGxvbmdpdHVkZTogbG9uZ2l0dWRlLCBhY2N1cmFjeTogYWNjdXJhY3kgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci53YXJuKCdjb3VsZCBub3QgbG9hZCBjYWNoZWQgbG9jYXRpb24uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IG9wdGlvbnMgZnJvbSBjb25maWdcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1BPU0lUSU9OX09QVElPTlMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25NYXhpbXVtQWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk9wdGlvbnMubWF4aW11bUFnZSA9IG9wdGlvbnMubG9jYXRpb25NYXhpbXVtQWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubG9jYXRpb25UaW1lb3V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk9wdGlvbnMudGltZW91dCA9IG9wdGlvbnMubG9jYXRpb25UaW1lb3V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVzaXJlZEFjY3VyYWN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbk9wdGlvbnMuZW5hYmxlSGlnaEFjY3VyYWN5ID0gdXNlSGlnaEFjY3VyYWN5KG9wdGlvbnMuZGVzaXJlZEFjY3VyYWN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBvcHRpb25zIGZyb20gb3ZlcnJpZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmRlc2lyZWRBY2N1cmFjeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25PcHRpb25zLmVuYWJsZUhpZ2hBY2N1cmFjeSA9IHVzZUhpZ2hBY2N1cmFjeShvdmVycmlkZXMuZGVzaXJlZEFjY3VyYWN5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci5pbmZvKFwiVXNpbmcgZ2VvbG9jYXRpb24gb3B0aW9uczogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHBvc2l0aW9uT3B0aW9ucykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCBjdXJyZW50IGxvY2F0aW9uIGZyb20gYnJvd3NlclxuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbihmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBvc2l0aW9uIHx8ICFwb3NpdGlvbi5jb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUmFkYXJMb2NhdGlvbkVycm9yKCdkZXZpY2UgbG9jYXRpb24gcmV0dXJuIGVtcHR5IGNvb3JkaW5hdGVzLicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hID0gcG9zaXRpb24uY29vcmRzLCBsYXRpdHVkZSA9IF9hLmxhdGl0dWRlLCBsb25naXR1ZGUgPSBfYS5sb25naXR1ZGUsIGFjY3VyYWN5ID0gX2EuYWNjdXJhY3k7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FjaGUgbG9jYXRpb24gaWYgb3B0aW9uIGlzIHNldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNhY2hlTG9jYXRpb25NaW51dGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYWNoZUxvY2F0aW9uTWludXRlcyA9IE51bWJlci5wYXJzZUZsb2F0KG9wdGlvbnMuY2FjaGVMb2NhdGlvbk1pbnV0ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4cGlyZXNBdCA9IHVwZGF0ZWRBdCArIChjYWNoZUxvY2F0aW9uTWludXRlcyAqIDYwICogMTAwMCk7IC8vIGNvbnZlcnQgdG8gbXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhc3RMb2NhdGlvbiA9IHsgbGF0aXR1ZGU6IGxhdGl0dWRlLCBsb25naXR1ZGU6IGxvbmdpdHVkZSwgYWNjdXJhY3k6IGFjY3VyYWN5LCB1cGRhdGVkQXQ6IHVwZGF0ZWRBdCwgZXhwaXJlc0F0OiBleHBpcmVzQXQgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2UuQ0FDSEVEX0xPQ0FUSU9OLCBKU09OLnN0cmluZ2lmeShsYXN0TG9jYXRpb24pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoeyBsYXRpdHVkZTogbGF0aXR1ZGUsIGxvbmdpdHVkZTogbG9uZ2l0dWRlLCBhY2N1cmFjeTogYWNjdXJhY3kgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFBFUk1JU1NJT05fRVJST1JfTUVTU0FHRVNbZXJyLmNvZGUudG9TdHJpbmcoKV0gfHwgJ3Vua25vd24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBSYWRhckxvY2F0aW9uUGVybWlzc2lvbnNFcnJvcihtZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFJhZGFyTG9jYXRpb25FcnJvcignQ291bGQgbm90IGRldGVybWluZSBsb2NhdGlvbi4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBwb3NpdGlvbk9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBOYXZpZ2F0b3IuZ2V0UGVybWlzc2lvblN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW5hdmlnYXRvciB8fCAhbmF2aWdhdG9yLnBlcm1pc3Npb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUmFkYXJMb2NhdGlvbkVycm9yKCduYXZpZ2F0b3IucGVybWlzc2lvbnMgaXMgbm90IGF2YWlsYWJsZS4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoeyBuYW1lOiAnZ2VvbG9jYXRpb24nIH0pLnRoZW4oZnVuY3Rpb24gKHBlcm1pc3Npb25zU3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uQXV0aG9yaXphdGlvbiA9ICdOT1RfREVURVJNSU5FRCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwZXJtaXNzaW9uc1N0YXR1cy5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdncmFudGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uQXV0aG9yaXphdGlvbiA9ICdHUkFOVEVEX0ZPUkVHUk9VTkQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2RlbmllZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbkF1dGhvcml6YXRpb24gPSAnREVOSUVEJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9tcHQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25BdXRob3JpemF0aW9uID0gJ05PVF9ERVRFUk1JTkVEJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShsb2NhdGlvbkF1dGhvcml6YXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBOYXZpZ2F0b3I7XG59KCkpO1xuXG52YXIgU0RLX1ZFUlNJT04gPSAnNC4xLjExJztcblxudmFyIEh0dHAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSHR0cCgpIHtcbiAgICB9XG4gICAgSHR0cC5yZXF1ZXN0ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBfYS5tZXRob2QsIHBhdGggPSBfYS5wYXRoLCBkYXRhID0gX2EuZGF0YSwgaG9zdCA9IF9hLmhvc3Q7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgcHVibGlzaGFibGVLZXkgb24gcmVxdWVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHB1Ymxpc2hhYmxlS2V5ID0gb3B0aW9ucy5wdWJsaXNoYWJsZUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcHVibGlzaGFibGVLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFJhZGFyUHVibGlzaGFibGVLZXlFcnJvcigncHVibGlzaGFibGVLZXkgbm90IHNldC4nKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0dXAgcmVxdWVzdCBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmxIb3N0ID0gaG9zdCB8fCBvcHRpb25zLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmVyc2lvbiA9IG9wdGlvbnMudmVyc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBcIlwiLmNvbmNhdCh1cmxIb3N0LCBcIi9cIikuY29uY2F0KHZlcnNpb24sIFwiL1wiKS5jb25jYXQocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgdW5kZWZpbmVkIHZhbHVlcyBmcm9tIHJlcXVlc3QgZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHkgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgZGF0YSB0byBxdWVyeXN0cmluZyBmb3IgR0VUIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhib2R5KS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKFwiXCIuY29uY2F0KGtleSwgXCI9XCIpLmNvbmNhdChlbmNvZGVVUklDb21wb25lbnQoYm9keVtrZXldKSkpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5U3RyaW5nID0gcGFyYW1zLmpvaW4oJyYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJcIi5jb25jYXQodXJsLCBcIj9cIikuY29uY2F0KHF1ZXJ5U3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IHVuZGVmaW5lZDsgLy8gZG9udCBzZW5kIGJvZHkgZm9yIEdFVCByZXF1ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgaGVhZGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCBwdWJsaXNoYWJsZUtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC1UeXBlJywgJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdYLVJhZGFyLURldmljZS1UeXBlJywgJ1dlYicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ1gtUmFkYXItU0RLLVZlcnNpb24nLCBTREtfVkVSU0lPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgY3VzdG9tIGhlYWRlcnMgaWYgcHJlc2VudFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmdldFJlcXVlc3RIZWFkZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlcnNfMSA9IG9wdGlvbnMuZ2V0UmVxdWVzdEhlYWRlcnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzXzEgfHwge30pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNfMVtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChuZXcgUmFkYXJTZXJ2ZXJFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXJyb3IgPSAoX2EgPSByZXNwb25zZSA9PT0gbnVsbCB8fCByZXNwb25zZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2UubWV0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciA9PT0gJ0VSUk9SX1BFUk1JU1NJT05TJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBSYWRhckxvY2F0aW9uUGVybWlzc2lvbnNFcnJvcignTG9jYXRpb24gcGVybWlzc2lvbnMgbm90IGdyYW50ZWQuJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gJ0VSUk9SX0xPQ0FUSU9OJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBSYWRhckxvY2F0aW9uRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgbG9jYXRpb24uJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnJvciA9PT0gJ0VSUk9SX05FVFdPUksnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IFJhZGFyVGltZW91dEVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuZGVidWcoXCJBUEkgY2FsbCBmYWlsZWQ6IFwiLmNvbmNhdCh1cmwpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmRlYnVnKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBSYWRhckJhZFJlcXVlc3RFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4aHIuc3RhdHVzID09PSA0MDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBSYWRhclVuYXV0aG9yaXplZEVycm9yKHJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHhoci5zdGF0dXMgPT09IDQwMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFJhZGFyUGF5bWVudFJlcXVpcmVkRXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeGhyLnN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJGb3JiaWRkZW5FcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh4aHIuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBSYWRhck5vdEZvdW5kRXJyb3IocmVzcG9uc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoeGhyLnN0YXR1cyA9PT0gNDI5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJSYXRlTGltaXRFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICg1MDAgPD0geGhyLnN0YXR1cyAmJiB4aHIuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJTZXJ2ZXJFcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBSYWRhclVua25vd25FcnJvcihyZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdCAmJiBob3N0ID09PSAnaHR0cHM6Ly9yYWRhci12ZXJpZnkuY29tOjUyNTE2Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IFJhZGFyRGVza3RvcEFwcEVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBSYWRhclNlcnZlckVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB4aHIub250aW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgUmFkYXJUaW1lb3V0RXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgeGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkoYm9keSkpO1xuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gSHR0cDtcbn0oKSk7XG5cbnZhciBBZGRyZXNzZXNBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWRkcmVzc2VzQVBJKCkge1xuICAgIH1cbiAgICBBZGRyZXNzZXNBUEkudmFsaWRhdGVBZGRyZXNzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucywgcmVzcG9uc2UsIGFkZHJlc3MsIHJlc3VsdCwgdmFsaWRhdGVBZGRyZXNzUmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdhZGRyZXNzZXMvdmFsaWRhdGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSByZXNwb25zZS5hZGRyZXNzLCByZXN1bHQgPSByZXNwb25zZS5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFkZHJlc3NSZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRlQWRkcmVzc1Jlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHZhbGlkYXRlQWRkcmVzc1Jlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFkZHJlc3Nlc0FQSTtcbn0oKSk7XG5cbnZhciBnZW5lcmF0ZVVVSUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHV1aWQgPSAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uIChjaGFyKSB7XG4gICAgICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcbiAgICAgICAgdmFyIHYgPSAoY2hhciA9PSAneCcpID8gciA6IChyICYgMHgzIHwgMHg4KTtcbiAgICAgICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICAgIH0pO1xuICAgIHJldHVybiB1dWlkO1xufTtcbnZhciBEZXZpY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGV2aWNlKCkge1xuICAgIH1cbiAgICBEZXZpY2UuZ2V0RGV2aWNlSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHVzZSBleGlzdGluZyBkZXZpY2VJZCBpZiBwcmVzZW50XG4gICAgICAgIHZhciBkZXZpY2VJZCA9IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLkRFVklDRV9JRCk7XG4gICAgICAgIGlmIChkZXZpY2VJZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRldmljZUlkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdlbmVyYXRlIG5ldyBkZXZpY2VJZFxuICAgICAgICB2YXIgdXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5ERVZJQ0VfSUQsIHV1aWQpO1xuICAgICAgICByZXR1cm4gdXVpZDtcbiAgICB9O1xuICAgIERldmljZS5nZXRJbnN0YWxsSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHVzZSBleGlzdGluZyBpbnN0YWxsSWQgaWYgcHJlc2VudFxuICAgICAgICB2YXIgZGV2aWNlSWQgPSBTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5JTlNUQUxMX0lEKTtcbiAgICAgICAgaWYgKGRldmljZUlkKSB7XG4gICAgICAgICAgICByZXR1cm4gZGV2aWNlSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2VuZXJhdGUgbmV3IGluc3RhbGxJZFxuICAgICAgICB2YXIgdXVpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5JTlNUQUxMX0lELCB1dWlkKTtcbiAgICAgICAgcmV0dXJuIHV1aWQ7XG4gICAgfTtcbiAgICByZXR1cm4gRGV2aWNlO1xufSgpKTtcblxudmFyIFNFU1NJT05fVElNRU9VVF9TRUNTID0gMzAwOyAvLyA1IG1pbnNcbnZhciBpc1ZhbGlkID0gZnVuY3Rpb24gKHNlc3Npb25JZCkge1xuICAgIHZhciBub3cgPSBNYXRoLnRydW5jKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICB2YXIgc2Vzc2lvbiA9IE51bWJlci5wYXJzZUludChzZXNzaW9uSWQpO1xuICAgIHZhciBkaWZmID0gTWF0aC5hYnMobm93IC0gc2Vzc2lvbik7XG4gICAgcmV0dXJuIGRpZmYgPCBTRVNTSU9OX1RJTUVPVVRfU0VDUztcbn07XG52YXIgU2Vzc2lvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZXNzaW9uKCkge1xuICAgIH1cbiAgICBTZXNzaW9uLmdldFNlc3Npb25JZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlc3Npb25JZCA9IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLlNFU1NJT05fSUQpO1xuICAgICAgICAvLyByZXVzZSBzZXNzaW9uIGlmIHN0aWxsIHdpdGhpbiA1IG1pbiB0aHJlc2hvbGRcbiAgICAgICAgaWYgKHNlc3Npb25JZCAmJiBpc1ZhbGlkKHNlc3Npb25JZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXNzaW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBzZXNzaW9uIGlmIGRvZXMgbm90IGFscmVhZHkgZXhpc3Qgb3IgZXhwaXJlZFxuICAgICAgICB2YXIgbmV3U2Vzc2lvbklkID0gTWF0aC50cnVuYyhEYXRlLm5vdygpIC8gMTAwMCkudG9TdHJpbmcoKTsgLy8gdW5peCB0cyBpbiBzZWNvbmRzXG4gICAgICAgIFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlLlNFU1NJT05fSUQsIG5ld1Nlc3Npb25JZCk7XG4gICAgICAgIHJldHVybiBuZXdTZXNzaW9uSWQ7XG4gICAgfTtcbiAgICByZXR1cm4gU2Vzc2lvbjtcbn0oKSk7XG5cbnZhciBDb25maWdBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uZmlnQVBJKCkge1xuICAgIH1cbiAgICBDb25maWdBUEkuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMsIGRldmljZUlkLCBpbnN0YWxsSWQsIHNlc3Npb25JZCwgbG9jYXRpb25BdXRob3JpemF0aW9uLCBkYXRhLCBlcnJfMTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy52ZXJzaW9uICE9ICd2MScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIuaW5mbygnU2tpcHBpbmcgL2NvbmZpZyBjYWxsLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZUlkID0gcGFyYW1zLmRldmljZUlkIHx8IERldmljZS5nZXREZXZpY2VJZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFsbElkID0gcGFyYW1zLmluc3RhbGxJZCB8fCBEZXZpY2UuZ2V0SW5zdGFsbElkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBTZXNzaW9uLmdldFNlc3Npb25JZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgTmF2aWdhdG9yLmdldFBlcm1pc3Npb25TdGF0dXMoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uQXV0aG9yaXphdGlvbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQ6IGRldmljZUlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbGxJZDogaW5zdGFsbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZDogc2Vzc2lvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uQXV0aG9yaXphdGlvbjogbG9jYXRpb25BdXRob3JpemF0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFsyLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdjb25maWcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycl8xID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLndhcm4oXCJFcnJvciBjYWxsaW5nIC9jb25maWc6IFwiLmNvbmNhdChlcnJfMS5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiByZXR1cm4gWzIgLypyZXR1cm4qL107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmZpZ0FQSTtcbn0oKSk7XG5cbnZhciBDb250ZXh0QVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnRleHRBUEkoKSB7XG4gICAgfVxuICAgIENvbnRleHRBUEkuZ2V0Q29udGV4dCA9IGZ1bmN0aW9uIChsb2NhdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucywgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgYWNjdXJhY3ksIHJlc3BvbnNlLCBnZW9mZW5jZXMsIHBsYWNlLCBjb3VudHJ5LCBzdGF0ZSwgZG1hLCBwb3N0YWxDb2RlLCBjb250ZXh0UmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFsb2NhdGlvbi5sYXRpdHVkZSB8fCAhbG9jYXRpb24ubG9uZ2l0dWRlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBOYXZpZ2F0b3IuZ2V0Q3VycmVudFBvc2l0aW9uKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGUgPSBsb2NhdGlvbi5sYXRpdHVkZSwgbG9uZ2l0dWRlID0gbG9jYXRpb24ubG9uZ2l0dWRlLCBhY2N1cmFjeSA9IGxvY2F0aW9uLmFjY3VyYWN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ2NvbnRleHQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogXCJcIi5jb25jYXQobGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQobG9uZ2l0dWRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VyYWN5OiBhY2N1cmFjeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmVuY2VzID0gcmVzcG9uc2UuZ2VvZmVuY2VzLCBwbGFjZSA9IHJlc3BvbnNlLnBsYWNlLCBjb3VudHJ5ID0gcmVzcG9uc2UuY291bnRyeSwgc3RhdGUgPSByZXNwb25zZS5zdGF0ZSwgZG1hID0gcmVzcG9uc2UuZG1hLCBwb3N0YWxDb2RlID0gcmVzcG9uc2UucG9zdGFsQ29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHRSZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2ZlbmNlczogZ2VvZmVuY2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlOiBwbGFjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudHJ5OiBjb3VudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkbWE6IGRtYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3N0YWxDb2RlOiBwb3N0YWxDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGNvbnRleHRSZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb250ZXh0QVBJO1xufSgpKTtcblxudmFyIENvbnZlcnNpb25zQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbnZlcnNpb25zQVBJKCkge1xuICAgIH1cbiAgICBDb252ZXJzaW9uc0FQSS5sb2dDb252ZXJzaW9uID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucywgbmFtZSwgdXNlcklkLCBkZXZpY2VJZCwgaW5zdGFsbElkLCBtZXRhZGF0YSwgY3JlYXRlZEF0LCBkYXRhLCByZXNwb25zZSwgY29udmVyc2lvblJlcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBwYXJhbXMudXNlcklkIHx8IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLlVTRVJfSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQgPSBwYXJhbXMuZGV2aWNlSWQgfHwgRGV2aWNlLmdldERldmljZUlkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YWxsSWQgPSBwYXJhbXMuaW5zdGFsbElkIHx8IERldmljZS5nZXRJbnN0YWxsSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gcGFyYW1zLm1ldGFkYXRhIHx8IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3JlYXRlZEF0ID0gcGFyYW1zLmNyZWF0ZWRBdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMucmV2ZW51ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhLnJldmVudWUgPSBwYXJhbXMucmV2ZW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VJZDogZGV2aWNlSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFsbElkOiBpbnN0YWxsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY3JlYXRlZEF0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3JlYXRlZEF0ID0gY3JlYXRlZEF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3JlYXRlZEF0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY3JlYXRlZEF0ID0gY3JlYXRlZEF0LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLmNyZWF0ZWRBdCA9IChuZXcgRGF0ZSgpKS50b0lTT1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdldmVudHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJzaW9uUmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiByZXNwb25zZS5ldmVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnNpb25SZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBjb252ZXJzaW9uUmVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29udmVyc2lvbnNBUEk7XG59KCkpO1xuXG52YXIgR2VvY29kaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdlb2NvZGluZygpIHtcbiAgICB9XG4gICAgR2VvY29kaW5nLmZvcndhcmRHZW9jb2RlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucywgcXVlcnksIGxheWVycywgY291bnRyeSwgcmVzcG9uc2UsIGZvcndhcmRHZW9jb2RlUmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5LCBsYXllcnMgPSBwYXJhbXMubGF5ZXJzLCBjb3VudHJ5ID0gcGFyYW1zLmNvdW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnZ2VvY29kZS9mb3J3YXJkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBsYXllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudHJ5OiBjb3VudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3J3YXJkR2VvY29kZVJlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IHJlc3BvbnNlLmFkZHJlc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcndhcmRHZW9jb2RlUmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZm9yd2FyZEdlb2NvZGVSZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdlb2NvZGluZy5yZXZlcnNlR2VvY29kZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMsIGxhdGl0dWRlLCBsb25naXR1ZGUsIGxheWVycywgbG9jYXRpb25fMSwgcmVzcG9uc2UsIHJldmVyc2VHZW9jb2RlUmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGl0dWRlID0gcGFyYW1zLmxhdGl0dWRlLCBsb25naXR1ZGUgPSBwYXJhbXMubG9uZ2l0dWRlLCBsYXllcnMgPSBwYXJhbXMubGF5ZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoIWxhdGl0dWRlIHx8ICFsb25naXR1ZGUpKSByZXR1cm4gWzMgLypicmVhayovLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIE5hdmlnYXRvci5nZXRDdXJyZW50UG9zaXRpb24oKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uXzEgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXRpdHVkZSA9IGxvY2F0aW9uXzEubGF0aXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb25naXR1ZGUgPSBsb2NhdGlvbl8xLmxvbmdpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMjtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOiByZXR1cm4gWzQgLyp5aWVsZCovLCBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ2dlb2NvZGUvcmV2ZXJzZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogXCJcIi5jb25jYXQobGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQobG9uZ2l0dWRlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzOiBsYXllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlR2VvY29kZVJlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IHJlc3BvbnNlLmFkZHJlc3NlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VHZW9jb2RlUmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmV2ZXJzZUdlb2NvZGVSZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEdlb2NvZGluZy5pcEdlb2NvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zLCByZXNwb25zZSwgaXBHZW9jb2RlUmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdnZW9jb2RlL2lwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXBHZW9jb2RlUmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwOiByZXNwb25zZS5pcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiByZXNwb25zZS5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3h5OiByZXNwb25zZS5wcm94eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlwR2VvY29kZVJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGlwR2VvY29kZVJlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEdlb2NvZGluZztcbn0oKSk7XG5cbnZhciBSb3V0aW5nQVBJID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJvdXRpbmdBUEkoKSB7XG4gICAgfVxuICAgIFJvdXRpbmdBUEkuZGlzdGFuY2UgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zLCBvcmlnaW4sIGRlc3RpbmF0aW9uLCBtb2RlcywgdW5pdHMsIGdlb21ldHJ5LCBnZW9tZXRyeVBvaW50cywgX2EsIGxhdGl0dWRlLCBsb25naXR1ZGUsIGxhdGl0dWRlLCBsb25naXR1ZGUsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHJlc3BvbnNlLCBkaXN0YW5jZVJlcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4gPSBwYXJhbXMub3JpZ2luLCBkZXN0aW5hdGlvbiA9IHBhcmFtcy5kZXN0aW5hdGlvbiwgbW9kZXMgPSBwYXJhbXMubW9kZXMsIHVuaXRzID0gcGFyYW1zLnVuaXRzLCBnZW9tZXRyeSA9IHBhcmFtcy5nZW9tZXRyeSwgZ2VvbWV0cnlQb2ludHMgPSBwYXJhbXMuZ2VvbWV0cnlQb2ludHM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISFvcmlnaW4pIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCksIGxhdGl0dWRlID0gX2EubGF0aXR1ZGUsIGxvbmdpdHVkZSA9IF9hLmxvbmdpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbiA9IFwiXCIuY29uY2F0KGxhdGl0dWRlLCBcIixcIikuY29uY2F0KGxvbmdpdHVkZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcmlnaW4gIT09ICdzdHJpbmcnKSB7IC8vIG9yaWdpbiBpcyBcIkxvY2F0aW9uXCIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGUgPSBvcmlnaW4ubGF0aXR1ZGUsIGxvbmdpdHVkZSA9IG9yaWdpbi5sb25naXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luID0gXCJcIi5jb25jYXQobGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQobG9uZ2l0dWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXN0aW5hdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRpdHVkZSA9IGRlc3RpbmF0aW9uLmxhdGl0dWRlLCBsb25naXR1ZGUgPSBkZXN0aW5hdGlvbi5sb25naXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb24gPSBcIlwiLmNvbmNhdChsYXRpdHVkZSwgXCIsXCIpLmNvbmNhdChsb25naXR1ZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZXMgPSBtb2Rlcy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAncm91dGUvZGlzdGFuY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVzOiBtb2RlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5UG9pbnRzOiBnZW9tZXRyeVBvaW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2VSZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVzOiByZXNwb25zZS5yb3V0ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZVJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGRpc3RhbmNlUmVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSb3V0aW5nQVBJLm1hdHJpeCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMsIG9yaWdpbnMsIGRlc3RpbmF0aW9ucywgbW9kZSwgdW5pdHMsIF9hLCBsYXRpdHVkZSwgbG9uZ2l0dWRlLCBvcmlnaW5TdHJpbmdzLCBpLCByZXNwb25zZSwgbWF0cml4UmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbnMgPSBwYXJhbXMub3JpZ2lucywgZGVzdGluYXRpb25zID0gcGFyYW1zLmRlc3RpbmF0aW9ucywgbW9kZSA9IHBhcmFtcy5tb2RlLCB1bml0cyA9IHBhcmFtcy51bml0cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIW9yaWdpbnMpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCksIGxhdGl0dWRlID0gX2EubGF0aXR1ZGUsIGxvbmdpdHVkZSA9IF9hLmxvbmdpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpblN0cmluZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBkZXN0aW5hdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5TdHJpbmdzLnB1c2goXCJcIi5jb25jYXQobGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQobG9uZ2l0dWRlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5zID0gb3JpZ2luU3RyaW5ncy5qb2luKCd8Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2lucykpIHsgLy8gb3JpZ2luIGlzIGEgbGlzdCBvZiBcIkxvY2F0aW9uXCIgb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbnMgPSBvcmlnaW5zLm1hcChmdW5jdGlvbiAobG9jYXRpb24pIHsgcmV0dXJuIFwiXCIuY29uY2F0KGxvY2F0aW9uLmxhdGl0dWRlLCBcIixcIikuY29uY2F0KGxvY2F0aW9uLmxvbmdpdHVkZSk7IH0pLmpvaW4oJ3wnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBhcnJheSB0byBwaXBlLWRlbGltaXRlZCBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlc3RpbmF0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbnMgPSBkZXN0aW5hdGlvbnMubWFwKGZ1bmN0aW9uIChsb2NhdGlvbikgeyByZXR1cm4gXCJcIi5jb25jYXQobG9jYXRpb24ubGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQobG9jYXRpb24ubG9uZ2l0dWRlKTsgfSkuam9pbignfCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ3JvdXRlL21hdHJpeCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbnM6IG9yaWdpbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0aW5hdGlvbnM6IGRlc3RpbmF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0czogdW5pdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeFJlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5zOiByZXNwb25zZS5vcmlnaW5zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uczogcmVzcG9uc2UuZGVzdGluYXRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdHJpeDogcmVzcG9uc2UubWF0cml4LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0cml4UmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbWF0cml4UmVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUm91dGluZ0FQSTtcbn0oKSk7XG5cbnZhciBTZWFyY2hBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2VhcmNoQVBJKCkge1xuICAgIH1cbiAgICBTZWFyY2hBUEkuYXV0b2NvbXBsZXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucywgcXVlcnksIG5lYXIsIGxpbWl0LCBsYXllcnMsIGNvdW50cnlDb2RlLCBleHBhbmRVbml0cywgcmVzcG9uc2UsIGF1dG9jb21wbGV0ZVJlcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgPSBDb25maWcuZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWVyeSA9IHBhcmFtcy5xdWVyeSwgbmVhciA9IHBhcmFtcy5uZWFyLCBsaW1pdCA9IHBhcmFtcy5saW1pdCwgbGF5ZXJzID0gcGFyYW1zLmxheWVycywgY291bnRyeUNvZGUgPSBwYXJhbXMuY291bnRyeUNvZGUsIGV4cGFuZFVuaXRzID0gcGFyYW1zLmV4cGFuZFVuaXRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVhciBjYW4gYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcgb3IgTG9jYXRpb24gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBcIm5lYXJcIiBpcyBub3QgcHJvdmlkZWQsIHJlcXVlc3Qgd2lsbCBmYWxsYmFjayB0byBJUCBiYXNlZCBsb2NhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lYXIgJiYgdHlwZW9mIG5lYXIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5lYXIubGF0aXR1ZGUgJiYgbmVhci5sb25naXR1ZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVhciA9IFwiXCIuY29uY2F0KG5lYXIubGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQobmVhci5sb25naXR1ZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIEh0dHAucmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICdzZWFyY2gvYXV0b2NvbXBsZXRlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnk6IHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmVhcjogbmVhcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyczogbGF5ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRyeUNvZGU6IGNvdW50cnlDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kVW5pdHM6IGV4cGFuZFVuaXRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdXRvY29tcGxldGVSZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiByZXNwb25zZS5hZGRyZXNzZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdXRvY29tcGxldGVSZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBhdXRvY29tcGxldGVSZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlYXJjaEFQSS5zZWFyY2hHZW9mZW5jZXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zLCBuZWFyLCByYWRpdXMsIHRhZ3MsIG1ldGFkYXRhLCBsaW1pdCwgX2EsIGxhdGl0dWRlLCBsb25naXR1ZGUsIGxhdGl0dWRlLCBsb25naXR1ZGUsIHJlc3BvbnNlLCBnZW9mZW5jZXNTZWFyY2hSZXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gQ29uZmlnLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVhciA9IHBhcmFtcy5uZWFyLCByYWRpdXMgPSBwYXJhbXMucmFkaXVzLCB0YWdzID0gcGFyYW1zLnRhZ3MsIG1ldGFkYXRhID0gcGFyYW1zLm1ldGFkYXRhLCBsaW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIW5lYXIpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCksIGxhdGl0dWRlID0gX2EubGF0aXR1ZGUsIGxvbmdpdHVkZSA9IF9hLmxvbmdpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lYXIgPSBcIlwiLmNvbmNhdChsYXRpdHVkZSwgXCIsXCIpLmNvbmNhdChsb25naXR1ZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVhciAhPT0gJ3N0cmluZycpIHsgLy8gbmVhciBpcyBcIkxvY2F0aW9uXCIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGUgPSBuZWFyLmxhdGl0dWRlLCBsb25naXR1ZGUgPSBuZWFyLmxvbmdpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWFyID0gXCJcIi5jb25jYXQobGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQobG9uZ2l0dWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBhcnJheXMgdG8gY29tbWEtc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFncykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YWdzID0gdGFncy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiAnc2VhcmNoL2dlb2ZlbmNlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5lYXI6IG5lYXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZ3M6IHRhZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRhZGF0YTogbWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW1pdDogbGltaXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2ZlbmNlc1NlYXJjaFJlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9mZW5jZXM6IHJlc3BvbnNlLmdlb2ZlbmNlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2ZlbmNlc1NlYXJjaFJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGdlb2ZlbmNlc1NlYXJjaFJlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2VhcmNoQVBJLnNlYXJjaFBsYWNlcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMsIG5lYXIsIHJhZGl1cywgY2hhaW5zLCBjYXRlZ29yaWVzLCBncm91cHMsIGxpbWl0LCBfYSwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgbGF0aXR1ZGUsIGxvbmdpdHVkZSwgcmVzcG9uc2UsIHBsYWNlU2VhcmNoUmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lYXIgPSBwYXJhbXMubmVhciwgcmFkaXVzID0gcGFyYW1zLnJhZGl1cywgY2hhaW5zID0gcGFyYW1zLmNoYWlucywgY2F0ZWdvcmllcyA9IHBhcmFtcy5jYXRlZ29yaWVzLCBncm91cHMgPSBwYXJhbXMuZ3JvdXBzLCBsaW1pdCA9IHBhcmFtcy5saW1pdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIW5lYXIpIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbigpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSBfYi5zZW50KCksIGxhdGl0dWRlID0gX2EubGF0aXR1ZGUsIGxvbmdpdHVkZSA9IF9hLmxvbmdpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lYXIgPSBcIlwiLmNvbmNhdChsYXRpdHVkZSwgXCIsXCIpLmNvbmNhdChsb25naXR1ZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVhciAhPT0gJ3N0cmluZycpIHsgLy8gbmVhciBpcyBcIkxvY2F0aW9uXCIgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF0aXR1ZGUgPSBuZWFyLmxhdGl0dWRlLCBsb25naXR1ZGUgPSBuZWFyLmxvbmdpdHVkZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWFyID0gXCJcIi5jb25jYXQobGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQobG9uZ2l0dWRlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF9iLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBhcnJheXMgdG8gY29tbWEtc3RyaW5nc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hhaW5zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWlucyA9IGNoYWlucy5qb2luKCcsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjYXRlZ29yaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzLmpvaW4oJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGdyb3VwcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHMgPSBncm91cHMuam9pbignLCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ3NlYXJjaC9wbGFjZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZWFyOiBuZWFyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFpbnM6IGNoYWlucyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbWl0OiBsaW1pdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VTZWFyY2hSZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2VzOiByZXNwb25zZS5wbGFjZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZVNlYXJjaFJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBsYWNlU2VhcmNoUmVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU2VhcmNoQVBJO1xufSgpKTtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ0MTk4NjQxXG52YXIgaXNWYWxpZERhdGUgPSBmdW5jdGlvbiAoZGF0ZSkgeyByZXR1cm4gZGF0ZSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0ZSkgPT09ICdbb2JqZWN0IERhdGVdJyAmJiAhaXNOYU4oZGF0ZSk7IH07XG52YXIgVHJpcHNBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJpcHNBUEkoKSB7XG4gICAgfVxuICAgIFRyaXBzQVBJLnNldFRyaXBPcHRpb25zID0gZnVuY3Rpb24gKHRyaXBPcHRpb25zKSB7XG4gICAgICAgIGlmICghdHJpcE9wdGlvbnMpIHtcbiAgICAgICAgICAgIFRyaXBzQVBJLmNsZWFyVHJpcE9wdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdHJpcE9wdGlvbnNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeSh0cmlwT3B0aW9ucyk7XG4gICAgICAgIExvZ2dlci5kZWJ1ZyhcIlNhdmluZyB0cmlwIG9wdGlvbnM6IFwiLmNvbmNhdCh0cmlwT3B0aW9uc1N0cmluZykpO1xuICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5UUklQX09QVElPTlMsIHRyaXBPcHRpb25zU3RyaW5nKTtcbiAgICB9O1xuICAgIFRyaXBzQVBJLmdldFRyaXBPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJpcE9wdGlvbnMgPSBTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5UUklQX09QVElPTlMpO1xuICAgICAgICBpZiAodHJpcE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRyaXBPcHRpb25zID0gSlNPTi5wYXJzZSh0cmlwT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaXBPcHRpb25zO1xuICAgIH07XG4gICAgVHJpcHNBUEkuY2xlYXJUcmlwT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgU3RvcmFnZS5yZW1vdmVJdGVtKFN0b3JhZ2UuVFJJUF9PUFRJT05TKTtcbiAgICB9O1xuICAgIFRyaXBzQVBJLnN0YXJ0VHJpcCA9IGZ1bmN0aW9uICh0cmlwT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucywgdXNlcklkLCBleHRlcm5hbElkLCBkZXN0aW5hdGlvbkdlb2ZlbmNlVGFnLCBkZXN0aW5hdGlvbkdlb2ZlbmNlRXh0ZXJuYWxJZCwgbW9kZSwgbWV0YWRhdGEsIGFwcHJvYWNoaW5nVGhyZXNob2xkLCBzY2hlZHVsZWRBcnJpdmFsQXQsIGRhdGEsIHJlc3BvbnNlLCB0cmlwUmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaXBPcHRpb25zID0gdHJpcE9wdGlvbnMgfHwgVHJpcHNBUEkuZ2V0VHJpcE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJpcE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIud2FybigndHJpcE9wdGlvbnMgbm90IHNldCB3aGVuIGNhbGxpbmcgXCJzdGFydFRyaXBcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gdHJpcE9wdGlvbnMudXNlcklkIHx8IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLlVTRVJfSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJJZCAmJiB1c2VySWQgIT09IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLlVTRVJfSUQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IGFzIHVzZXJJZCBmb3IgdHJhY2tpbmcgaWYgcHJvdmlkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5VU0VSX0lELCB1c2VySWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxJZCA9IHRyaXBPcHRpb25zLmV4dGVybmFsSWQsIGRlc3RpbmF0aW9uR2VvZmVuY2VUYWcgPSB0cmlwT3B0aW9ucy5kZXN0aW5hdGlvbkdlb2ZlbmNlVGFnLCBkZXN0aW5hdGlvbkdlb2ZlbmNlRXh0ZXJuYWxJZCA9IHRyaXBPcHRpb25zLmRlc3RpbmF0aW9uR2VvZmVuY2VFeHRlcm5hbElkLCBtb2RlID0gdHJpcE9wdGlvbnMubW9kZSwgbWV0YWRhdGEgPSB0cmlwT3B0aW9ucy5tZXRhZGF0YSwgYXBwcm9hY2hpbmdUaHJlc2hvbGQgPSB0cmlwT3B0aW9ucy5hcHByb2FjaGluZ1RocmVzaG9sZCwgc2NoZWR1bGVkQXJyaXZhbEF0ID0gdHJpcE9wdGlvbnMuc2NoZWR1bGVkQXJyaXZhbEF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQ6IHVzZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbElkOiBleHRlcm5hbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uR2VvZmVuY2VUYWc6IGRlc3RpbmF0aW9uR2VvZmVuY2VUYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25HZW9mZW5jZUV4dGVybmFsSWQ6IGRlc3RpbmF0aW9uR2VvZmVuY2VFeHRlcm5hbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcHJvYWNoaW5nVGhyZXNob2xkOiBhcHByb2FjaGluZ1RocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZERhdGUoc2NoZWR1bGVkQXJyaXZhbEF0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2NoZWR1bGVkQXJyaXZhbEF0ID0gc2NoZWR1bGVkQXJyaXZhbEF0ID09PSBudWxsIHx8IHNjaGVkdWxlZEFycml2YWxBdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZWR1bGVkQXJyaXZhbEF0LnRvSlNPTigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlZEFycml2YWxBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIud2FybignSW52YWxpZCBkYXRlIGZvcm1hdCBmb3Igc2NoZWR1bGVkQXJyaXZhbEF0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2NoZWR1bGVkQXJyaXZhbEF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6ICd0cmlwcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgdHJpcCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmlwc0FQSS5zZXRUcmlwT3B0aW9ucyh0cmlwT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlwUmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaXA6IHJlc3BvbnNlLnRyaXAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiByZXNwb25zZS5ldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlwUmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJpcFJlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVHJpcHNBUEkudXBkYXRlVHJpcCA9IGZ1bmN0aW9uICh0cmlwT3B0aW9ucywgc3RhdHVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zLCBleHRlcm5hbElkLCBkZXN0aW5hdGlvbkdlb2ZlbmNlVGFnLCBkZXN0aW5hdGlvbkdlb2ZlbmNlRXh0ZXJuYWxJZCwgbW9kZSwgbWV0YWRhdGEsIGFwcHJvYWNoaW5nVGhyZXNob2xkLCBzY2hlZHVsZWRBcnJpdmFsQXQsIGRhdGEsIHJlc3BvbnNlLCB0cmlwUmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaXBPcHRpb25zID0gdHJpcE9wdGlvbnMgfHwgVHJpcHNBUEkuZ2V0VHJpcE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJpcE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIud2FybigndHJpcE9wdGlvbnMgbm90IHNldCB3aGVuIGNhbGxpbmcgXCJzdGFydFRyaXBcIicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZXJuYWxJZCA9IHRyaXBPcHRpb25zLmV4dGVybmFsSWQsIGRlc3RpbmF0aW9uR2VvZmVuY2VUYWcgPSB0cmlwT3B0aW9ucy5kZXN0aW5hdGlvbkdlb2ZlbmNlVGFnLCBkZXN0aW5hdGlvbkdlb2ZlbmNlRXh0ZXJuYWxJZCA9IHRyaXBPcHRpb25zLmRlc3RpbmF0aW9uR2VvZmVuY2VFeHRlcm5hbElkLCBtb2RlID0gdHJpcE9wdGlvbnMubW9kZSwgbWV0YWRhdGEgPSB0cmlwT3B0aW9ucy5tZXRhZGF0YSwgYXBwcm9hY2hpbmdUaHJlc2hvbGQgPSB0cmlwT3B0aW9ucy5hcHByb2FjaGluZ1RocmVzaG9sZCwgc2NoZWR1bGVkQXJyaXZhbEF0ID0gdHJpcE9wdGlvbnMuc2NoZWR1bGVkQXJyaXZhbEF0O1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHRlcm5hbElkOiBleHRlcm5hbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uR2VvZmVuY2VUYWc6IGRlc3RpbmF0aW9uR2VvZmVuY2VUYWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdGluYXRpb25HZW9mZW5jZUV4dGVybmFsSWQ6IGRlc3RpbmF0aW9uR2VvZmVuY2VFeHRlcm5hbElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6IG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcHJvYWNoaW5nVGhyZXNob2xkOiBhcHByb2FjaGluZ1RocmVzaG9sZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZERhdGUoc2NoZWR1bGVkQXJyaXZhbEF0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2NoZWR1bGVkQXJyaXZhbEF0ID0gc2NoZWR1bGVkQXJyaXZhbEF0ID09PSBudWxsIHx8IHNjaGVkdWxlZEFycml2YWxBdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2NoZWR1bGVkQXJyaXZhbEF0LnRvSlNPTigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjaGVkdWxlZEFycml2YWxBdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIud2FybignSW52YWxpZCBkYXRlIGZvcm1hdCBmb3Igc2NoZWR1bGVkQXJyaXZhbEF0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuc2NoZWR1bGVkQXJyaXZhbEF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUEFUQ0gnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBcInRyaXBzL1wiLmNvbmNhdChleHRlcm5hbElkLCBcIi91cGRhdGVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaXBSZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpcDogcmVzcG9uc2UudHJpcCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IHJlc3BvbnNlLmV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaXBSZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cmlwUmVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUcmlwc0FQSS5jb21wbGV0ZVRyaXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0cmlwT3B0aW9ucywgdHJpcFJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpcE9wdGlvbnMgPSBUcmlwc0FQSS5nZXRUcmlwT3B0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgVHJpcHNBUEkudXBkYXRlVHJpcCh0cmlwT3B0aW9ucywgJ2NvbXBsZXRlZCcpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpcFJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgbG9jYWwgdHJpcCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmlwc0FQSS5jbGVhclRyaXBPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJpcFJlc3BvbnNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUcmlwc0FQSS5jYW5jZWxUcmlwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdHJpcE9wdGlvbnMsIHRyaXBSZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaXBPcHRpb25zID0gVHJpcHNBUEkuZ2V0VHJpcE9wdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFRyaXBzQVBJLnVwZGF0ZVRyaXAodHJpcE9wdGlvbnMsICdjYW5jZWxlZCcpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpcFJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2xlYXIgbG9jYWwgdHJpcCBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICBUcmlwc0FQSS5jbGVhclRyaXBPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJpcFJlc3BvbnNlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVHJpcHNBUEk7XG59KCkpO1xuXG52YXIgVHJhY2tBUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhY2tBUEkoKSB7XG4gICAgfVxuICAgIFRyYWNrQVBJLnRyYWNrT25jZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMsIGxhdGl0dWRlLCBsb25naXR1ZGUsIGFjY3VyYWN5LCBkZXNpcmVkQWNjdXJhY3ksIGRldmljZUxvY2F0aW9uLCBsb2NhdGlvbkF1dGhvcml6YXRpb24sIGVycl8xLCB1c2VySWQsIGRldmljZUlkLCBpbnN0YWxsSWQsIHNlc3Npb25JZCwgZGV2aWNlVHlwZSwgZGVzY3JpcHRpb24sIG1ldGFkYXRhLCB0cmlwT3B0aW9ucywgYm9keSwgcmVzcG9uc2UsIHVzZXIsIGV2ZW50cywgbG9jYXRpb24sIHRyYWNrUmVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucyA9IENvbmZpZy5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGl0dWRlID0gcGFyYW1zLmxhdGl0dWRlLCBsb25naXR1ZGUgPSBwYXJhbXMubG9uZ2l0dWRlLCBhY2N1cmFjeSA9IHBhcmFtcy5hY2N1cmFjeSwgZGVzaXJlZEFjY3VyYWN5ID0gcGFyYW1zLmRlc2lyZWRBY2N1cmFjeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCFsYXRpdHVkZSB8fCAhbG9uZ2l0dWRlKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBOYXZpZ2F0b3IuZ2V0Q3VycmVudFBvc2l0aW9uKHsgZGVzaXJlZEFjY3VyYWN5OiBkZXNpcmVkQWNjdXJhY3kgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VMb2NhdGlvbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhdGl0dWRlID0gZGV2aWNlTG9jYXRpb24ubGF0aXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb25naXR1ZGUgPSBkZXZpY2VMb2NhdGlvbi5sb25naXR1ZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1cmFjeSA9IGRldmljZUxvY2F0aW9uLmFjY3VyYWN5O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzIsIDQsICwgNV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgTmF2aWdhdG9yLmdldFBlcm1pc3Npb25TdGF0dXMoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uQXV0aG9yaXphdGlvbiA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJfMSA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ2dlci53YXJuKFwiTG9jYXRpb24gYXV0aG9yaXphdGlvbiBlcnJvcjogXCIuY29uY2F0KGVycl8xLm1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VySWQgPSBwYXJhbXMudXNlcklkIHx8IFN0b3JhZ2UuZ2V0SXRlbShTdG9yYWdlLlVTRVJfSUQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGV2aWNlSWQgPSBwYXJhbXMuZGV2aWNlSWQgfHwgRGV2aWNlLmdldERldmljZUlkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0YWxsSWQgPSBwYXJhbXMuaW5zdGFsbElkIHx8IERldmljZS5nZXRJbnN0YWxsSWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlc3Npb25JZCA9IFNlc3Npb24uZ2V0U2Vzc2lvbklkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXZpY2VUeXBlID0gcGFyYW1zLmRldmljZVR5cGUgfHwgJ1dlYic7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbiA9IHBhcmFtcy5kZXNjcmlwdGlvbiB8fCBTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5ERVNDUklQVElPTik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHVzZXJJZCBmb3IgdHJpcCB0cmFja2luZ1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VySWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBMb2dnZXIud2FybigndXNlcklkIG5vdCBwcm92aWRlZCBmb3IgdHJhY2tPbmNlLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2UuVVNFUl9JRCwgdXNlcklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhID0gcGFyYW1zLm1ldGFkYXRhIHx8IFN0b3JhZ2UuZ2V0SlNPTihTdG9yYWdlLk1FVEFEQVRBKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyaXBPcHRpb25zID0gcGFyYW1zLnRyaXBPcHRpb25zIHx8IFRyaXBzQVBJLmdldFRyaXBPcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJpcE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlwT3B0aW9ucy52ZXJzaW9uID0gJzInO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7IGxvY2F0aW9uQXV0aG9yaXphdGlvbjogbG9jYXRpb25BdXRob3JpemF0aW9uLCBhY2N1cmFjeTogYWNjdXJhY3ksIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiwgZGV2aWNlSWQ6IGRldmljZUlkLCBkZXZpY2VUeXBlOiBkZXZpY2VUeXBlLCBmb3JlZ3JvdW5kOiB0cnVlLCBpbnN0YWxsSWQ6IGluc3RhbGxJZCwgc2Vzc2lvbklkOiBzZXNzaW9uSWQsIGxhdGl0dWRlOiBsYXRpdHVkZSwgbG9uZ2l0dWRlOiBsb25naXR1ZGUsIG1ldGFkYXRhOiBtZXRhZGF0YSwgc2RrVmVyc2lvbjogU0RLX1ZFUlNJT04sIHN0b3BwZWQ6IHRydWUsIHVzZXJJZDogdXNlcklkLCB0cmlwT3B0aW9uczogdHJpcE9wdGlvbnMgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBIdHRwLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ3RyYWNrJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlciA9IHJlc3BvbnNlLnVzZXIsIGV2ZW50cyA9IHJlc3BvbnNlLmV2ZW50cztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0geyBsYXRpdHVkZTogbGF0aXR1ZGUsIGxvbmdpdHVkZTogbG9uZ2l0dWRlLCBhY2N1cmFjeTogYWNjdXJhY3kgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZXI6IHVzZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzOiBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tSZXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0cmFja1Jlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYWNrQVBJO1xufSgpKTtcblxudmFyIFZlcmlmeUFQSSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWZXJpZnlBUEkoKSB7XG4gICAgfVxuICAgIFZlcmlmeUFQSS50cmFja1ZlcmlmaWVkID0gZnVuY3Rpb24gKHBhcmFtcywgZW5jcnlwdGVkKSB7XG4gICAgICAgIGlmIChlbmNyeXB0ZWQgPT09IHZvaWQgMCkgeyBlbmNyeXB0ZWQgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucywgdXNlcklkLCBkZXZpY2VJZCwgaW5zdGFsbElkLCBzZXNzaW9uSWQsIGRlc2NyaXB0aW9uLCBtZXRhZGF0YSwgYm9keSwgdXNlckFnZW50LCBtYWMsIHJlc3BvbnNlLCB1c2VyLCBldmVudHMsIHRva2VuLCBsb2NhdGlvbiwgdHJhY2tUb2tlblJlcywgdHJhY2tSZXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zID0gQ29uZmlnLmdldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdXNlcklkID0gcGFyYW1zLnVzZXJJZCB8fCBTdG9yYWdlLmdldEl0ZW0oU3RvcmFnZS5VU0VSX0lEKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRldmljZUlkID0gcGFyYW1zLmRldmljZUlkIHx8IERldmljZS5nZXREZXZpY2VJZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFsbElkID0gcGFyYW1zLmluc3RhbGxJZCB8fCBEZXZpY2UuZ2V0SW5zdGFsbElkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQgPSBTZXNzaW9uLmdldFNlc3Npb25JZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPSBwYXJhbXMuZGVzY3JpcHRpb24gfHwgU3RvcmFnZS5nZXRJdGVtKFN0b3JhZ2UuREVTQ1JJUFRJT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSB1c2VySWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXNlcklkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLndhcm4oJ3VzZXJJZCBub3QgcHJvdmlkZWQgZm9yIHRyYWNrVmVyaWZpZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5VU0VSX0lELCB1c2VySWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0YWRhdGEgPSBwYXJhbXMubWV0YWRhdGEgfHwgU3RvcmFnZS5nZXRKU09OKFN0b3JhZ2UuTUVUQURBVEEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYm9keSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbXMpLCB7IGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiwgZGV2aWNlSWQ6IGRldmljZUlkLCBmb3JlZ3JvdW5kOiB0cnVlLCBpbnN0YWxsSWQ6IGluc3RhbGxJZCwgc2Vzc2lvbklkOiBzZXNzaW9uSWQsIG1ldGFkYXRhOiBtZXRhZGF0YSwgc2RrVmVyc2lvbjogU0RLX1ZFUlNJT04sIHN0b3BwZWQ6IHRydWUsIHVzZXJJZDogdXNlcklkLCBlbmNyeXB0ZWQ6IGVuY3J5cHRlZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWMgPSB1c2VyQWdlbnQgJiYgdXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ21hYycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgSHR0cC5yZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogJ3ZlcmlmeScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGJvZHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q6IG1hYyA/ICdodHRwczovL3JhZGFyLXZlcmlmeS5jb206NTI1MTYnIDogJ2h0dHA6Ly9sb2NhbGhvc3Q6NTI1MTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1c2VyID0gcmVzcG9uc2UudXNlciwgZXZlbnRzID0gcmVzcG9uc2UuZXZlbnRzLCB0b2tlbiA9IHJlc3BvbnNlLnRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXIgJiYgdXNlci5sb2NhdGlvbiAmJiB1c2VyLmxvY2F0aW9uLmNvb3JkaW5hdGVzICYmIHVzZXIubG9jYXRpb25BY2N1cmFjeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXRpdHVkZTogdXNlci5sb2NhdGlvbi5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9uZ2l0dWRlOiB1c2VyLmxvY2F0aW9uLmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2N1cmFjeTogdXNlci5sb2NhdGlvbkFjY3VyYWN5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW5jcnlwdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUb2tlblJlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUb2tlblJlcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJhY2tUb2tlblJlc107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFja1JlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VyOiB1c2VyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrUmVzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJhY2tSZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBWZXJpZnlBUEk7XG59KCkpO1xuXG52YXIgREVGQVVMVF9TVFlMRSA9ICdyYWRhci1kZWZhdWx0LXYxJztcbnZhciBSQURBUl9TVFlMRVMgPSBbXG4gICAgJ3JhZGFyLWRlZmF1bHQtdjEnLFxuICAgICdyYWRhci1saWdodC12MScsXG4gICAgJ3JhZGFyLWRhcmstdjEnLFxuXTtcbnZhciBSQURBUl9MT0dPX1VSTCA9ICdodHRwczovL2FwaS5yYWRhci5pby9tYXBzL3N0YXRpYy9pbWFnZXMvbG9nby5zdmcnO1xudmFyIGRlZmF1bHRNYXBsaWJyZU9wdGlvbnMgPSB7XG4gICAgbWluWm9vbTogMSxcbiAgICBtYXhab29tOiAyMCxcbiAgICBhdHRyaWJ1dGlvbkNvbnRyb2w6IGZhbHNlLFxuICAgIGRyYWdSb3RhdGU6IGZhbHNlLFxuICAgIHRvdWNoUGl0Y2g6IGZhbHNlLFxuICAgIG1hcGxpYnJlTG9nbzogZmFsc2UsXG59O1xudmFyIGRlZmF1bHRNYXJrZXJPcHRpb25zID0ge1xuICAgIGNvbG9yOiAnIzAwMDI1NycsXG59O1xudmFyIGNyZWF0ZVN0eWxlVVJMID0gZnVuY3Rpb24gKG9wdGlvbnMsIHN0eWxlKSB7XG4gICAgaWYgKHN0eWxlID09PSB2b2lkIDApIHsgc3R5bGUgPSBERUZBVUxUX1NUWUxFOyB9XG4gICAgcmV0dXJuIChcIlwiLmNvbmNhdChvcHRpb25zLmhvc3QsIFwiL21hcHMvc3R5bGVzL1wiKS5jb25jYXQoc3R5bGUsIFwiP3B1Ymxpc2hhYmxlS2V5PVwiKS5jb25jYXQob3B0aW9ucy5wdWJsaXNoYWJsZUtleSkpO1xufTtcbi8vIHVzZSBmb3JtYXR0ZWQgc3R5bGUgVVJMIGlmIHVzaW5nIG9uZSBvZiBSYWRhcidzIG91dC1vZi10aGUtYm94IHN0eWxlc1xudmFyIGdldFN0eWxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG1hcE9wdGlvbnMpIHtcbiAgICB2YXIgc3R5bGUgPSBtYXBPcHRpb25zLnN0eWxlO1xuICAgIGlmICghc3R5bGUgfHwgKHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgJiYgUkFEQVJfU1RZTEVTLmluY2x1ZGVzKHN0eWxlKSkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0eWxlVVJMKG9wdGlvbnMsIG1hcE9wdGlvbnMuc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gbWFwT3B0aW9ucy5zdHlsZTtcbn07XG52YXIgTWFwVUkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFwVUkoKSB7XG4gICAgfVxuICAgIE1hcFVJLmdldE1hcExpYnJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbWFwbGlicmVnbDtcbiAgICB9O1xuICAgIE1hcFVJLmNyZWF0ZU1hcCA9IGZ1bmN0aW9uIChtYXBPcHRpb25zKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gQ29uZmlnLmdldCgpO1xuICAgICAgICBpZiAoIW9wdGlvbnMucHVibGlzaGFibGVLZXkpIHtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKCdwdWJsaXNoYWJsZUtleSBub3Qgc2V0LiBDYWxsIFJhZGFyLmluaXRpYWxpemUoKSB3aXRoIGtleSBiZWZvcmUgY3JlYXRpbmcgYSBuZXcgbWFwLicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbmZpZ3VyZSBtYXBsaWJyZSBvcHRpb25zXG4gICAgICAgIHZhciBzdHlsZSA9IGdldFN0eWxlKG9wdGlvbnMsIG1hcE9wdGlvbnMpO1xuICAgICAgICB2YXIgbWFwbGlicmVPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE1hcGxpYnJlT3B0aW9ucywgbWFwT3B0aW9ucywgeyBzdHlsZTogc3R5bGUgfSk7XG4gICAgICAgIExvZ2dlci5kZWJ1ZyhcImluaXRpYWxpemUgbWFwIHdpdGggb3B0aW9uczogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KG1hcGxpYnJlT3B0aW9ucykpKTtcbiAgICAgICAgLy8gc2V0IGNvbnRhaW5lclxuICAgICAgICBtYXBsaWJyZU9wdGlvbnMuY29udGFpbmVyID0gbWFwT3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgIC8vIGN1c3RvbSByZXF1ZXN0IGhhbmRsZXIgZm9yIFJhZGFyIHN0eWxlc1xuICAgICAgICBtYXBsaWJyZU9wdGlvbnMudHJhbnNmb3JtUmVxdWVzdCA9IGZ1bmN0aW9uICh1cmwsIHJlc291cmNlVHlwZSkge1xuICAgICAgICAgICAgaWYgKHJlc291cmNlVHlwZSA9PT0gJ1N0eWxlJyAmJiBSQURBUl9TVFlMRVMuaW5jbHVkZXModXJsKSkge1xuICAgICAgICAgICAgICAgIHZhciByYWRhclN0eWxlVVJMID0gY3JlYXRlU3R5bGVVUkwob3B0aW9ucywgdXJsKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB1cmw6IHJhZGFyU3R5bGVVUkwgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHVybDogdXJsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGNyZWF0ZSBtYXBcbiAgICAgICAgdmFyIG1hcCA9IG5ldyBtYXBsaWJyZWdsLk1hcChtYXBsaWJyZU9wdGlvbnMpO1xuICAgICAgICB2YXIgY29udGFpbmVyID0gbWFwLmdldENvbnRhaW5lcigpO1xuICAgICAgICBpZiAoIWNvbnRhaW5lci5zdHlsZS53aWR0aCAmJiAhY29udGFpbmVyLnN0eWxlLmhlaWdodCkge1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oJ21hcCBjb250YWluZXIgZG9lcyBub3QgaGF2ZSBhIHNldCBcIndpZHRoXCIgb3IgXCJoZWlnaHRcIicpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCByYWRhciBsb2dvXG4gICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgaW1nLnNyYyA9IFJBREFSX0xPR09fVVJMO1xuICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgbGluay5pZCA9ICdyYWRhci1tYXAtbG9nbyc7XG4gICAgICAgIGxpbmsuaHJlZiA9ICdodHRwczovL3JhZGFyLmNvbT9yZWY9cG93ZXJlZF9ieV9yYWRhcic7XG4gICAgICAgIGxpbmsudGFyZ2V0ID0gJ19ibGFuayc7XG4gICAgICAgIGxpbmsuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBsaW5rLnN0eWxlLmJvdHRvbSA9ICcwJztcbiAgICAgICAgbGluay5zdHlsZS5sZWZ0ID0gJzVweCc7XG4gICAgICAgIGxpbmsuc3R5bGUud2lkdGggPSAnODBweCc7XG4gICAgICAgIGxpbmsuc3R5bGUuaGVpZ2h0ID0gJzM4cHgnO1xuICAgICAgICBsaW5rLmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgIG1hcC5nZXRDb250YWluZXIoKS5hcHBlbmRDaGlsZChsaW5rKTtcbiAgICAgICAgLy8gYWRkIGF0dHJpYnV0aW9uXG4gICAgICAgIHZhciBhdHRyaWJ1dGlvbiA9IG5ldyBtYXBsaWJyZWdsLkF0dHJpYnV0aW9uQ29udHJvbCh7IGNvbXBhY3Q6IGZhbHNlIH0pO1xuICAgICAgICBtYXAuYWRkQ29udHJvbChhdHRyaWJ1dGlvbiwgJ2JvdHRvbS1yaWdodCcpO1xuICAgICAgICAvLyBhZGQgem9vbSBjb250cm9sc1xuICAgICAgICB2YXIgbmF2ID0gbmV3IG1hcGxpYnJlZ2wuTmF2aWdhdGlvbkNvbnRyb2woeyBzaG93Q29tcGFzczogZmFsc2UgfSk7XG4gICAgICAgIG1hcC5hZGRDb250cm9sKG5hdiwgJ2JvdHRvbS1yaWdodCcpO1xuICAgICAgICAvLyBoYW5kbGUgbWFwIHJlc2l6ZSBhY3Rpb25zXG4gICAgICAgIHZhciBvblJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhdHRyaWIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcubWFwbGlicmVnbC1jdHJsLWF0dHJpYicpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYikge1xuICAgICAgICAgICAgICAgIHZhciB3aWR0aCA9IG1hcC5nZXRDb250YWluZXIoKS5jbGllbnRXaWR0aDtcbiAgICAgICAgICAgICAgICBpZiAod2lkdGggPCAzODApIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmliLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmliLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbWFwLm9uKCdyZXNpemUnLCBvblJlc2l6ZSk7XG4gICAgICAgIG1hcC5vbignbG9hZCcsIG9uUmVzaXplKTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9O1xuICAgIE1hcFVJLmNyZWF0ZU1hcmtlciA9IGZ1bmN0aW9uIChtYXJrZXJPcHRpb25zKSB7XG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zID09PSB2b2lkIDApIHsgbWFya2VyT3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBtYXBsaWJyZU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0TWFya2VyT3B0aW9ucyk7XG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zLmNvbG9yKSB7XG4gICAgICAgICAgICBtYXBsaWJyZU9wdGlvbnMuY29sb3IgPSBtYXJrZXJPcHRpb25zLmNvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIG1hcGxpYnJlT3B0aW9ucy5lbGVtZW50ID0gbWFya2VyT3B0aW9ucy5lbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXJrZXJPcHRpb25zLnNjYWxlKSB7XG4gICAgICAgICAgICBtYXBsaWJyZU9wdGlvbnMuc2NhbGUgPSBtYXJrZXJPcHRpb25zLnNjYWxlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgbWFwbGlicmVnbC5NYXJrZXIobWFwbGlicmVPcHRpb25zKTtcbiAgICAgICAgLy8gc2V0IHBvcHVwIHRleHQgb3IgSFRNTFxuICAgICAgICBpZiAobWFya2VyT3B0aW9ucy50ZXh0KSB7XG4gICAgICAgICAgICB2YXIgcG9wdXAgPSBuZXcgbWFwbGlicmVnbC5Qb3B1cCh7IG9mZnNldDogMzUgfSkuc2V0VGV4dChtYXJrZXJPcHRpb25zLnRleHQpO1xuICAgICAgICAgICAgbWFya2VyLnNldFBvcHVwKHBvcHVwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXJrZXJPcHRpb25zLmh0bWwpIHtcbiAgICAgICAgICAgIHZhciBwb3B1cCA9IG5ldyBtYXBsaWJyZWdsLlBvcHVwKHsgb2Zmc2V0OiAzNSB9KS5zZXRIVE1MKG1hcmtlck9wdGlvbnMuaHRtbCk7XG4gICAgICAgICAgICBtYXJrZXIuc2V0UG9wdXAocG9wdXApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwVUk7XG59KCkpO1xuXG52YXIgQ0xBU1NOQU1FUyA9IHtcbiAgICBXUkFQUEVSOiAncmFkYXItYXV0b2NvbXBsZXRlLXdyYXBwZXInLFxuICAgIElOUFVUOiAncmFkYXItYXV0b2NvbXBsZXRlLWlucHV0JyxcbiAgICBTRUFSQ0hfSUNPTjogJ3JhZGFyLWF1dG9jb21wbGV0ZS1zZWFyY2gtaWNvbicsXG4gICAgUkVTVUxUU19MSVNUOiAncmFkYXItYXV0b2NvbXBsZXRlLXJlc3VsdHMtbGlzdCcsXG4gICAgUkVTVUxUU19JVEVNOiAncmFkYXItYXV0b2NvbXBsZXRlLXJlc3VsdHMtaXRlbScsXG4gICAgUkVTVUxUU19NQVJLRVI6ICdyYWRhci1hdXRvY29tcGxldGUtcmVzdWx0cy1tYXJrZXInLFxuICAgIFNFTEVDVEVEX0lURU06ICdyYWRhci1hdXRvY29tcGxldGUtcmVzdWx0cy1pdGVtLXNlbGVjdGVkJyxcbiAgICBQT1dFUkVEX0JZX1JBREFSOiAncmFkYXItcG93ZXJlZCcsXG4gICAgTk9fUkVTVUxUUzogJ3JhZGFyLW5vLXJlc3VsdHMnLFxufTtcbnZhciBBUklBID0ge1xuICAgIEVYUEFOREVEOiAnYXJpYS1leHBhbmRlZCcsXG59O1xudmFyIGRlZmF1bHRBdXRvY29tcGxldGVPcHRpb25zID0ge1xuICAgIGNvbnRhaW5lcjogJ2F1dG9jb21wbGV0ZScsXG4gICAgZGVib3VuY2VNUzogMjAwLFxuICAgIG1pbkNoYXJhY3RlcnM6IDMsXG4gICAgbGltaXQ6IDgsXG4gICAgcGxhY2Vob2xkZXI6ICdTZWFyY2ggYWRkcmVzcycsXG4gICAgcmVzcG9uc2l2ZTogdHJ1ZSxcbiAgICBkaXNhYmxlZDogZmFsc2UsXG4gICAgc2hvd01hcmtlcnM6IHRydWUsXG4gICAgaGlkZVJlc3VsdHNPbkJsdXI6IHRydWUsXG59O1xuLy8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gdXNlIHB4IG9yIENTUyBzdHJpbmdcbnZhciBmb3JtYXRDU1NWYWx1ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdCh2YWx1ZSwgXCJweFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBERUZBVUxUX1dJRFRIID0gNDAwO1xudmFyIHNldFdpZHRoID0gZnVuY3Rpb24gKGlucHV0LCBvcHRpb25zKSB7XG4gICAgLy8gaWYgcmVzcG9uc2l2ZSBhbmQgd2lkdGggaXMgcHJvdmlkZWQsIHRyZWF0IGl0IGFzIG1heFdpZHRoXG4gICAgaWYgKG9wdGlvbnMucmVzcG9uc2l2ZSkge1xuICAgICAgICBpbnB1dC5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgaWYgKG9wdGlvbnMud2lkdGgpIHtcbiAgICAgICAgICAgIGlucHV0LnN0eWxlLm1heFdpZHRoID0gZm9ybWF0Q1NTVmFsdWUob3B0aW9ucy53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBpZiBub3QgcmVzcG9uc2l2ZSwgc2V0IGZpeGVkIHdpZHRoIGFuZCB1bnNldCBtYXhXaWR0aFxuICAgIGlucHV0LnN0eWxlLndpZHRoID0gZm9ybWF0Q1NTVmFsdWUob3B0aW9ucy53aWR0aCB8fCBERUZBVUxUX1dJRFRIKTtcbiAgICBpbnB1dC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnbWF4LXdpZHRoJyk7XG59O1xudmFyIHNldEhlaWdodCA9IGZ1bmN0aW9uIChyZXN1bHRzTGlzdCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLm1heEhlaWdodCkge1xuICAgICAgICByZXN1bHRzTGlzdC5zdHlsZS5tYXhIZWlnaHQgPSBmb3JtYXRDU1NWYWx1ZShvcHRpb25zLm1heEhlaWdodCk7XG4gICAgICAgIHJlc3VsdHNMaXN0LnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJzsgLyogYWxsb3cgb3ZlcmZsb3cgd2hlbiBtYXhIZWlnaHQgaXMgYXBwbGllZCAqL1xuICAgIH1cbn07XG52YXIgZ2V0TWFya2VySWNvbiA9IGZ1bmN0aW9uIChjb2xvcikge1xuICAgIGlmIChjb2xvciA9PT0gdm9pZCAwKSB7IGNvbG9yID0gXCIjQUNCREM4XCI7IH1cbiAgICB2YXIgZmlsbCA9IGNvbG9yLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG4gICAgdmFyIHN2ZyA9IFwiPHN2ZyB3aWR0aD1cXFwiMTZcXFwiIGhlaWdodD1cXFwiMTZcXFwiIHZpZXdCb3g9XFxcIjAgMCAxNiAxNlxcXCIgZmlsbD1cXFwibm9uZVxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG4gICAgPHBhdGggZD1cXFwiTTEyLjU3MDQgNi41NzAzNkMxMi41NzA0IDQuMTE2MzIgMTAuNjM0MiAyLjExMjU3IDguMjEwMTYgMkM4LjE0MjYyIDIgOC4wNjc1NyAyIDguMDAwMDMgMkM3LjkzMjQ5IDIgNy44NTc0NCAyIDcuNzg5OSAyQzUuMzU4MzggMi4xMTI1NyAzLjQyOTY3IDQuMTE2MzIgMy40Mjk2NyA2LjU3MDM2QzMuNDI5NjcgNi42MDAzNyAzLjQyOTY3IDYuNjM3OSAzLjQyOTY3IDYuNjY3OTJDMy40Mjk2NyA2LjY5Nzk0IDMuNDI5NjcgNi43MzU0NiAzLjQyOTY3IDYuNzY1NDhDMy40Mjk2NyA5LjQ2NzE3IDcuMDkxOTYgMTMuMzYyMSA3LjQ2NzIgMTMuNzU5OEM3LjYxNzI5IDEzLjkxNzQgNy44NDk5NCAxNCA4LjAwMDAzIDE0QzguMTUwMTIgMTQgOC4zODI3NyAxMy45MTc0IDguNTMyODYgMTMuNzU5OEM4LjkxNTYgMTMuMzYyMSAxMi41NzA0IDkuNDY3MTcgMTIuNTcwNCA2Ljc2NTQ4QzEyLjU3MDQgNi43Mjc5NSAxMi41NzA0IDYuNjk3OTQgMTIuNTcwNCA2LjY2NzkyQzEyLjU3MDQgNi42Mzc5IDEyLjU3MDQgNi42MDAzNyAxMi41NzA0IDYuNTcwMzZaTTcuOTkyNTIgOC4yODg5M0M3LjA0NjkzIDguMjg4OTMgNi4yNzM5NSA3LjUyMzQ1IDYuMjczOTUgNi41NzAzNkM2LjI3Mzk1IDUuNjE3MjYgNy4wMzk0MyA0Ljg1MTc4IDcuOTkyNTIgNC44NTE3OEM4Ljk0NTYyIDQuODUxNzggOS43MTExIDUuNjE3MjYgOS43MTExIDYuNTcwMzZDOS43MTExIDcuNTIzNDUgOC45NDU2MiA4LjI4ODkzIDcuOTkyNTIgOC4yODg5M1pcXFwiIGZpbGw9XFxcIlwiLmNvbmNhdChmaWxsLCBcIlxcXCIvPlxcbiAgPC9zdmc+XCIpLnRyaW0oKTtcbiAgICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOCxcIi5jb25jYXQoc3ZnKTtcbn07XG52YXIgQXV0b2NvbXBsZXRlVUkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXV0b2NvbXBsZXRlVUkob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLmNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRBdXRvY29tcGxldGVPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgLy8gc2V0dXAgc3RhdGVcbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZWJvdW5jZWRGZXRjaFJlc3VsdHMgPSB0aGlzLmRlYm91bmNlKHRoaXMuZmV0Y2hSZXN1bHRzLCB0aGlzLmNvbmZpZy5kZWJvdW5jZU1TKTtcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gW107XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA9IC0xO1xuICAgICAgICAvLyBzZXQgdGhyZXNob2xkIGFsaWFzXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jb25maWcubWluQ2hhcmFjdGVycyA9IHRoaXMuY29uZmlnLnRocmVzaG9sZDtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKCdBdXRvY29tcGxldGVVSSBvcHRpb24gXCJ0aHJlc2hvbGRcIiBpcyBkZXByZWNhdGVkLCB1c2UgXCJtaW5DaGFyYWN0ZXJzXCIgaW5zdGVhZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5uZWFyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubmVhciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lYXIgPSBvcHRpb25zLm5lYXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lYXIgPSBcIlwiLmNvbmNhdChvcHRpb25zLm5lYXIubGF0aXR1ZGUsIFwiLFwiKS5jb25jYXQob3B0aW9ucy5uZWFyLmxvbmdpdHVkZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNvbnRhaW5lciBlbGVtZW50XG4gICAgICAgIHZhciBjb250YWluZXJFTDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5jb250YWluZXIgPT09ICdzdHJpbmcnKSB7IC8vIGxvb2t1cCBjb250YWluZXIgZWxlbWVudCBieSBJRFxuICAgICAgICAgICAgY29udGFpbmVyRUwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmNvbmZpZy5jb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyB1c2UgcHJvdmlkZWQgZWxlbWVudFxuICAgICAgICAgICAgY29udGFpbmVyRUwgPSB0aGlzLmNvbmZpZy5jb250YWluZXI7IC8vIEhUTUxFbGVtZW50XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb250YWluZXJFTCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhZGFyQXV0b2NvbXBsZXRlQ29udGFpbmVyTm90Rm91bmQoXCJDb3VsZCBub3QgZmluZCBjb250YWluZXIgZWxlbWVudDogXCIuY29uY2F0KHRoaXMuY29uZmlnLmNvbnRhaW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyRUw7XG4gICAgICAgIC8vIGNyZWF0ZSB3cmFwcGVyIGZvciBpbnB1dCBhbmQgcmVzdWx0IGxpc3RcbiAgICAgICAgdGhpcy53cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMud3JhcHBlci5jbGFzc0xpc3QuYWRkKENMQVNTTkFNRVMuV1JBUFBFUik7XG4gICAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5kaXNwbGF5ID0gdGhpcy5jb25maWcucmVzcG9uc2l2ZSA/ICdibG9jaycgOiAnaW5saW5lLWJsb2NrJztcbiAgICAgICAgc2V0V2lkdGgodGhpcy53cmFwcGVyLCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIC8vIHJlc3VsdCBsaXN0IGVsZW1lbnRcbiAgICAgICAgdGhpcy5yZXN1bHRzTGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIHRoaXMucmVzdWx0c0xpc3QuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLlJFU1VMVFNfTElTVCk7XG4gICAgICAgIHNldEhlaWdodCh0aGlzLnJlc3VsdHNMaXN0LCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIGlmIChjb250YWluZXJFTC5ub2RlTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICAgICAgLy8gaWYgYW4gPGlucHV0PiBlbGVtZW50IGlzIHByb3ZpZGVkLCB1c2UgdGhhdCBhcyB0aGUgaW5wdXRGaWVsZCxcbiAgICAgICAgICAgIC8vIGFuZCBhcHBlbmQgdGhlIHJlc3VsdExpc3QgdG8gaXQncyBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQgPSBjb250YWluZXJFTDtcbiAgICAgICAgICAgIC8vIGFwcGVuZCB0byBkb21cbiAgICAgICAgICAgIHRoaXMud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLnJlc3VsdHNMaXN0KTtcbiAgICAgICAgICAgIGNvbnRhaW5lckVMLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQodGhpcy53cmFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIGNvbnRhaW5lciBpcyBub3QgYW4gaW5wdXQsIGNyZWF0ZSBuZXcgaW5wdXQgYW5kIGFwcGVuZCB0byBjb250YWluZXJcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBuZXcgaW5wdXRcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLklOUFVUKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5wbGFjZWhvbGRlciA9IHRoaXMuY29uZmlnLnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnR5cGUgPSAndGV4dCc7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZGlzYWJsZWQgPSB0aGlzLmNvbmZpZy5kaXNhYmxlZDtcbiAgICAgICAgICAgIC8vIHNlYXJjaCBpY29uXG4gICAgICAgICAgICB2YXIgc2VhcmNoSWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc2VhcmNoSWNvbi5jbGFzc0xpc3QuYWRkKENMQVNTTkFNRVMuU0VBUkNIX0lDT04pO1xuICAgICAgICAgICAgLy8gYXBwZW5kIHRvIERPTVxuICAgICAgICAgICAgdGhpcy53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuaW5wdXRGaWVsZCk7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQodGhpcy5yZXN1bHRzTGlzdCk7XG4gICAgICAgICAgICB0aGlzLndyYXBwZXIuYXBwZW5kQ2hpbGQoc2VhcmNoSWNvbik7XG4gICAgICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLndyYXBwZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLmhhbmRsZUlucHV0LmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5Ym9hcmROYXZpZ2F0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICBpZiAodGhpcy5jb25maWcuaGlkZVJlc3VsdHNPbkJsdXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5jbG9zZS5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBMb2dnZXIuZGVidWcoXCJBdXRvY29tcGxldGVVSSBpbmlhaWxpemVkIHdpdGggb3B0aW9uczogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KHRoaXMuY29uZmlnKSkpO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgYSBuZXcgQXV0b2NvbXBsZXRlVUkgaW5zdGFuY2VcbiAgICBBdXRvY29tcGxldGVVSS5jcmVhdGVBdXRvY29tcGxldGUgPSBmdW5jdGlvbiAoYXV0b2NvbXBsZXRlT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEF1dG9jb21wbGV0ZVVJKGF1dG9jb21wbGV0ZU9wdGlvbnMpO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlVUkucHJvdG90eXBlLmhhbmRsZUlucHV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvLyBGZXRjaCBhdXRvY29tcGxldGUgcmVzdWx0cyBhbmQgZGlzcGxheSB0aGVtXG4gICAgICAgIHZhciBxdWVyeSA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZTtcbiAgICAgICAgaWYgKHF1ZXJ5Lmxlbmd0aCA8IHRoaXMuY29uZmlnLm1pbkNoYXJhY3RlcnMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlYm91bmNlZEZldGNoUmVzdWx0cyhxdWVyeSlcbiAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICB2YXIgb25SZXN1bHRzID0gX3RoaXMuY29uZmlnLm9uUmVzdWx0cztcbiAgICAgICAgICAgIGlmIChvblJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBvblJlc3VsdHMocmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5kaXNwbGF5UmVzdWx0cyhyZXN1bHRzKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIExvZ2dlci53YXJuKFwiQXV0b2NvbXBsZXRlIHVpIGVycm9yOiBcIi5jb25jYXQoZXJyb3IubWVzc2FnZSkpO1xuICAgICAgICAgICAgdmFyIG9uRXJyb3IgPSBfdGhpcy5jb25maWcub25FcnJvcjtcbiAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlVUkucHJvdG90eXBlLmRlYm91bmNlID0gZnVuY3Rpb24gKGZuLCBkZWxheSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdGltZW91dElkO1xuICAgICAgICB2YXIgcmVzb2x2ZUZuO1xuICAgICAgICB2YXIgcmVqZWN0Rm47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBmbi5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlRm4odmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlamVjdEZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0Rm4oZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVGbiA9IHJlc29sdmU7XG4gICAgICAgICAgICAgICAgcmVqZWN0Rm4gPSByZWplY3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZVVJLnByb3RvdHlwZS5mZXRjaFJlc3VsdHMgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBsaW1pdCwgbGF5ZXJzLCBjb3VudHJ5Q29kZSwgZXhwYW5kVW5pdHMsIG9uUmVxdWVzdCwgcGFyYW1zLCBhZGRyZXNzZXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYSA9IHRoaXMuY29uZmlnLCBsaW1pdCA9IF9hLmxpbWl0LCBsYXllcnMgPSBfYS5sYXllcnMsIGNvdW50cnlDb2RlID0gX2EuY291bnRyeUNvZGUsIGV4cGFuZFVuaXRzID0gX2EuZXhwYW5kVW5pdHMsIG9uUmVxdWVzdCA9IF9hLm9uUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGltaXQ6IGxpbWl0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyczogbGF5ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50cnlDb2RlOiBjb3VudHJ5Q29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRVbml0czogZXhwYW5kVW5pdHMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMubmVhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy5uZWFyID0gdGhpcy5uZWFyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdChwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgU2VhcmNoQVBJLmF1dG9jb21wbGV0ZShwYXJhbXMpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gKF9iLnNlbnQoKSkuYWRkcmVzc2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGFkZHJlc3Nlc107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlVUkucHJvdG90eXBlLmRpc3BsYXlSZXN1bHRzID0gZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gQ2xlYXIgdGhlIHByZXZpb3VzIHJlc3VsdHNcbiAgICAgICAgdGhpcy5jbGVhclJlc3VsdHNMaXN0KCk7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICAgIHZhciBtYXJrZXI7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5zaG93TWFya2Vycykge1xuICAgICAgICAgICAgbWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICBtYXJrZXIuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLlJFU1VMVFNfTUFSS0VSKTtcbiAgICAgICAgICAgIG1hcmtlci5zZXRBdHRyaWJ1dGUoJ3NyYycsIGdldE1hcmtlckljb24odGhpcy5jb25maWcubWFya2VyQ29sb3IpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYW5kIGFwcGVuZCBsaXN0IGl0ZW1zIGZvciBlYWNoIHJlc3VsdFxuICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsaSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKENMQVNTTkFNRVMuUkVTVUxUU19JVEVNKTtcbiAgICAgICAgICAgIC8vIGNvbnN0cnVjdCByZXN1bHQgd2l0aCBib2xkZWQgbGFiZWxcbiAgICAgICAgICAgIHZhciBsaXN0Q29udGVudDtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZm9ybWF0dGVkQWRkcmVzcy5pbmNsdWRlcyhyZXN1bHQuYWRkcmVzc0xhYmVsKSAmJiByZXN1bHQubGF5ZXIgIT09ICdwb3N0YWxDb2RlJykge1xuICAgICAgICAgICAgICAgIC8vIGlmIGFkZHJlc3NMYWJlbCBpcyBjb250YWluZWQgaW4gdGhlIGZvcm1hdHRlZCBhZGRyZXNzLCBib2xkIHRoZSBhZGRyZXNzIGxhYmVsXG4gICAgICAgICAgICAgICAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cChcIihcIi5jb25jYXQocmVzdWx0LmFkZHJlc3NMYWJlbCwgXCIpLD9cIikpO1xuICAgICAgICAgICAgICAgIGxpc3RDb250ZW50ID0gcmVzdWx0LmZvcm1hdHRlZEFkZHJlc3MucmVwbGFjZShyZWdleCwgJzxiPiQxPC9iPicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGFwcGVuZCB0aGUgYWRkcmVzcyBvciBwbGFjZSBsYWJlbCB0byBmb3JtYXR0ZWQgYWRkcmVzc1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IHJlc3VsdC5wbGFjZUxhYmVsIHx8IHJlc3VsdC5hZGRyZXNzTGFiZWw7XG4gICAgICAgICAgICAgICAgbGlzdENvbnRlbnQgPSBcIjxiPlwiLmNvbmNhdChsYWJlbCwgXCI8L2I+IFwiKS5jb25jYXQocmVzdWx0LmZvcm1hdHRlZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGkuaW5uZXJIVE1MID0gbGlzdENvbnRlbnQ7XG4gICAgICAgICAgICAvLyBwcmVwZW5kIG1hcmtlciBpZiBlbmFibGVkXG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGkucHJlcGVuZChtYXJrZXIuY2xvbmVOb2RlKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWRkIGNsaWNrIGhhbmRsZXIgdG8gZWFjaCByZXN1bHQsIHVzZSBtb3VzZWRvd24gdG8gZmlyZSBiZWZvcmUgYmx1ciBldmVudFxuICAgICAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlbGVjdChpbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF90aGlzLnJlc3VsdHNMaXN0LmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgICAgICAgIGxpbmsuaHJlZiA9ICdodHRwczovL3JhZGFyLmNvbT9yZWY9cG93ZXJlZF9ieV9yYWRhcic7XG4gICAgICAgICAgICBsaW5rLnRhcmdldCA9ICdfYmxhbmsnO1xuICAgICAgICAgICAgdGhpcy5wb3dlcmVkQnlMaW5rID0gbGluaztcbiAgICAgICAgICAgIHZhciBwb3dlcmVkQnlUZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgcG93ZXJlZEJ5VGV4dC50ZXh0Q29udGVudCA9ICdQb3dlcmVkIGJ5JztcbiAgICAgICAgICAgIGxpbmsuYXBwZW5kQ2hpbGQocG93ZXJlZEJ5VGV4dCk7XG4gICAgICAgICAgICB2YXIgcmFkYXJMb2dvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgcmFkYXJMb2dvLmlkID0gJ3JhZGFyLXBvd2VyZWQtbG9nbyc7XG4gICAgICAgICAgICBsaW5rLmFwcGVuZENoaWxkKHJhZGFyTG9nbyk7XG4gICAgICAgICAgICB2YXIgcG93ZXJlZEJ5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwb3dlcmVkQnlDb250YWluZXIuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLlBPV0VSRURfQllfUkFEQVIpO1xuICAgICAgICAgICAgcG93ZXJlZEJ5Q29udGFpbmVyLmFwcGVuZENoaWxkKGxpbmspO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHRzTGlzdC5hcHBlbmRDaGlsZChwb3dlcmVkQnlDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG5vUmVzdWx0c1RleHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG5vUmVzdWx0c1RleHQuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLk5PX1JFU1VMVFMpO1xuICAgICAgICAgICAgbm9SZXN1bHRzVGV4dC50ZXh0Q29udGVudCA9ICdObyByZXN1bHRzJztcbiAgICAgICAgICAgIHRoaXMucmVzdWx0c0xpc3QuYXBwZW5kQ2hpbGQobm9SZXN1bHRzVGV4dCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZVVJLnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndyYXBwZXIuc2V0QXR0cmlidXRlKEFSSUEuRVhQQU5ERUQsICd0cnVlJyk7XG4gICAgICAgIHRoaXMucmVzdWx0c0xpc3QucmVtb3ZlQXR0cmlidXRlKCdoaWRkZW4nKTtcbiAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlVUkucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJ1biB0aGlzIGNvZGUgYXN5bmMgdG8gYWxsb3cgbGluayBjbGljayB0byBwcm9wYWdhdGUgYmVmb3JlIGJsdXJcbiAgICAgICAgLy8gKGFkZCAxMDBtcyBkZWxheSBpZiBjbG9zZWQgZnJvbSBsaW5rIGNsaWNrKVxuICAgICAgICB2YXIgbGlua0NsaWNrID0gZSAmJiAoZS5yZWxhdGVkVGFyZ2V0ID09PSB0aGlzLnBvd2VyZWRCeUxpbmspO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLndyYXBwZXIucmVtb3ZlQXR0cmlidXRlKEFSSUEuRVhQQU5ERUQpO1xuICAgICAgICAgICAgX3RoaXMucmVzdWx0c0xpc3Quc2V0QXR0cmlidXRlKCdoaWRkZW4nLCAnJyk7XG4gICAgICAgICAgICBfdGhpcy5oaWdobGlnaHRlZEluZGV4ID0gLTE7XG4gICAgICAgICAgICBfdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgICAgIF90aGlzLmNsZWFyUmVzdWx0c0xpc3QoKTtcbiAgICAgICAgfSwgbGlua0NsaWNrID8gMTAwIDogMCk7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVVSS5wcm90b3R5cGUuZ29UbyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuIHx8ICF0aGlzLnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gd3JhcCBhcm91bmRcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLnJlc3VsdHMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbmRleCA+PSB0aGlzLnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdEl0ZW1zID0gdGhpcy5yZXN1bHRzTGlzdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKTtcbiAgICAgICAgaWYgKHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICAvLyBjbGVhciBjbGFzcyBuYW1lcyBvbiBwcmV2aW91c2x5IGhpZ2hsaWdodGVkIGl0ZW1cbiAgICAgICAgICAgIHJlc3VsdEl0ZW1zW3RoaXMuaGlnaGxpZ2h0ZWRJbmRleF0uY2xhc3NMaXN0LnJlbW92ZShDTEFTU05BTUVTLlNFTEVDVEVEX0lURU0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFkZCBjbGFzcyBuYW1lIHRvIG5ld2x5IGhpZ2hsaWdodGVkIGl0ZW1cbiAgICAgICAgcmVzdWx0SXRlbXNbaW5kZXhdLmNsYXNzTGlzdC5hZGQoQ0xBU1NOQU1FUy5TRUxFQ1RFRF9JVEVNKTtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlZEluZGV4ID0gaW5kZXg7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVVSS5wcm90b3R5cGUuaGFuZGxlS2V5Ym9hcmROYXZpZ2F0aW9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIGZhbGxiYWNrIHRvIGRlcHJlY2F0ZWQgXCJrZXlDb2RlXCIgaWYgZXZlbnQuY29kZSBub3Qgc2V0XG4gICAgICAgIHZhciBjb2RlID0gZXZlbnQuY29kZSAhPT0gdW5kZWZpbmVkID8gZXZlbnQuY29kZSA6IGV2ZW50LmtleUNvZGU7XG4gICAgICAgIC8vIGFsbG93IGV2ZW50IHRvIHByb3BhZ2F0ZSBpZiByZXN1bHQgbGlzdCBpcyBub3Qgb3BlblxuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjb2RlKSB7XG4gICAgICAgICAgICAvLyBOZXh0IGl0ZW1cbiAgICAgICAgICAgIGNhc2UgJ1RhYic6XG4gICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgY2FzZSA0MDpcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ29Ubyh0aGlzLmhpZ2hsaWdodGVkSW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIFByZXYgaXRlbVxuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5nb1RvKHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCAtIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gU2VsZWN0XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KHRoaXMuaGlnaGxpZ2h0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAvLyBDbG9zZVxuICAgICAgICAgICAgY2FzZSAnRXNjJzpcbiAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVVSS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdHNbaW5kZXhdO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgTG9nZ2VyLndhcm4oXCJObyBhdXRvY29tcGxldGUgcmVzdWx0IGZvdW5kIGF0IGluZGV4OiBcIi5jb25jYXQoaW5kZXgpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5wdXRWYWx1ZTtcbiAgICAgICAgaWYgKHJlc3VsdC5mb3JtYXR0ZWRBZGRyZXNzLmluY2x1ZGVzKHJlc3VsdC5hZGRyZXNzTGFiZWwpKSB7XG4gICAgICAgICAgICBpbnB1dFZhbHVlID0gcmVzdWx0LmZvcm1hdHRlZEFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSByZXN1bHQucGxhY2VMYWJlbCB8fCByZXN1bHQuYWRkcmVzc0xhYmVsO1xuICAgICAgICAgICAgaW5wdXRWYWx1ZSA9IFwiXCIuY29uY2F0KGxhYmVsLCBcIiwgXCIpLmNvbmNhdChyZXN1bHQuZm9ybWF0dGVkQWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gaW5wdXRWYWx1ZTtcbiAgICAgICAgdmFyIG9uU2VsZWN0aW9uID0gdGhpcy5jb25maWcub25TZWxlY3Rpb247XG4gICAgICAgIGlmIChvblNlbGVjdGlvbikge1xuICAgICAgICAgICAgb25TZWxlY3Rpb24ocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjbGVhciByZXN1bHRzIGxpc3RcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlVUkucHJvdG90eXBlLmNsZWFyUmVzdWx0c0xpc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzdWx0c0xpc3QuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIHRoaXMucmVzdWx0cyA9IFtdO1xuICAgIH07XG4gICAgLy8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gRE9NXG4gICAgQXV0b2NvbXBsZXRlVUkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgTG9nZ2VyLmRlYnVnKCdBdXRvY29tcGxldGVVSSByZW1vdmVkLicpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMucmVzdWx0c0xpc3QucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMud3JhcHBlci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZVVJLnByb3RvdHlwZS5zZXROZWFyID0gZnVuY3Rpb24gKG5lYXIpIHtcbiAgICAgICAgaWYgKG5lYXIgPT09IHVuZGVmaW5lZCB8fCBuZWFyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5lYXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIG5lYXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm5lYXIgPSBuZWFyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZWFyID0gXCJcIi5jb25jYXQobmVhci5sYXRpdHVkZSwgXCIsXCIpLmNvbmNhdChuZWFyLmxvbmdpdHVkZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVVSS5wcm90b3R5cGUuc2V0UGxhY2Vob2xkZXIgPSBmdW5jdGlvbiAocGxhY2Vob2xkZXIpIHtcbiAgICAgICAgdGhpcy5jb25maWcucGxhY2Vob2xkZXIgPSBwbGFjZWhvbGRlcjtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gcGxhY2Vob2xkZXI7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlVUkucHJvdG90eXBlLnNldERpc2FibGVkID0gZnVuY3Rpb24gKGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZVVJLnByb3RvdHlwZS5zZXRSZXNwb25zaXZlID0gZnVuY3Rpb24gKHJlc3BvbnNpdmUpIHtcbiAgICAgICAgdGhpcy5jb25maWcucmVzcG9uc2l2ZSA9IHJlc3BvbnNpdmU7XG4gICAgICAgIHNldFdpZHRoKHRoaXMud3JhcHBlciwgdGhpcy5jb25maWcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZVVJLnByb3RvdHlwZS5zZXRXaWR0aCA9IGZ1bmN0aW9uICh3aWR0aCkge1xuICAgICAgICB0aGlzLmNvbmZpZy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBzZXRXaWR0aCh0aGlzLndyYXBwZXIsIHRoaXMuY29uZmlnKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVVSS5wcm90b3R5cGUuc2V0TWF4SGVpZ2h0ID0gZnVuY3Rpb24gKGhlaWdodCkge1xuICAgICAgICB0aGlzLmNvbmZpZy5tYXhIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHNldEhlaWdodCh0aGlzLnJlc3VsdHNMaXN0LCB0aGlzLmNvbmZpZyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQXV0b2NvbXBsZXRlVUkucHJvdG90eXBlLnNldE1pbkNoYXJhY3RlcnMgPSBmdW5jdGlvbiAobWluQ2hhcmFjdGVycykge1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5DaGFyYWN0ZXJzID0gbWluQ2hhcmFjdGVycztcbiAgICAgICAgdGhpcy5jb25maWcudGhyZXNob2xkID0gbWluQ2hhcmFjdGVycztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVVSS5wcm90b3R5cGUuc2V0TGltaXQgPSBmdW5jdGlvbiAobGltaXQpIHtcbiAgICAgICAgdGhpcy5jb25maWcubGltaXQgPSBsaW1pdDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVVSS5wcm90b3R5cGUuc2V0U2hvd01hcmtlcnMgPSBmdW5jdGlvbiAoc2hvd01hcmtlcnMpIHtcbiAgICAgICAgdGhpcy5jb25maWcuc2hvd01hcmtlcnMgPSBzaG93TWFya2VycztcbiAgICAgICAgaWYgKHNob3dNYXJrZXJzKSB7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICBtYXJrZXIuY2xhc3NMaXN0LmFkZChDTEFTU05BTUVTLlJFU1VMVFNfTUFSS0VSKTtcbiAgICAgICAgICAgIG1hcmtlci5zZXRBdHRyaWJ1dGUoJ3NyYycsIGdldE1hcmtlckljb24odGhpcy5jb25maWcubWFya2VyQ29sb3IpKTtcbiAgICAgICAgICAgIHZhciByZXN1bHRJdGVtcyA9IHRoaXMucmVzdWx0c0xpc3QuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRNYXJrZXIgPSByZXN1bHRJdGVtc1tpXS5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKENMQVNTTkFNRVMuUkVTVUxUU19NQVJLRVIpWzBdO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudE1hcmtlcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRJdGVtc1tpXS5wcmVwZW5kKG1hcmtlci5jbG9uZU5vZGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJlc3VsdEl0ZW1zID0gdGhpcy5yZXN1bHRzTGlzdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnbGknKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0SXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFya2VyID0gcmVzdWx0SXRlbXNbaV0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShDTEFTU05BTUVTLlJFU1VMVFNfTUFSS0VSKVswXTtcbiAgICAgICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBdXRvY29tcGxldGVVSS5wcm90b3R5cGUuc2V0TWFya2VyQ29sb3IgPSBmdW5jdGlvbiAoY29sb3IpIHtcbiAgICAgICAgdGhpcy5jb25maWcubWFya2VyQ29sb3IgPSBjb2xvcjtcbiAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMucmVzdWx0c0xpc3QuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShDTEFTU05BTUVTLlJFU1VMVFNfTUFSS0VSKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG1hcmtlcltpXS5zZXRBdHRyaWJ1dGUoJ3NyYycsIGdldE1hcmtlckljb24oY29sb3IpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEF1dG9jb21wbGV0ZVVJLnByb3RvdHlwZS5zZXRIaWRlUmVzdWx0c09uQmx1ciA9IGZ1bmN0aW9uIChoaWRlUmVzdWx0c09uQmx1cikge1xuICAgICAgICB0aGlzLmNvbmZpZy5oaWRlUmVzdWx0c09uQmx1ciA9IGhpZGVSZXN1bHRzT25CbHVyO1xuICAgICAgICBpZiAoaGlkZVJlc3VsdHNPbkJsdXIpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5jbG9zZS5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5jbG9zZS5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBBdXRvY29tcGxldGVVSTtcbn0oKSk7XG5cbnZhciBpc1NlY3JldEtleSA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIChrZXkuaW5jbHVkZXMoJ19za18nKSk7IH07XG52YXIgaXNMaXZlS2V5ID0gZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gKGtleS5pbmNsdWRlcygnX2xpdmVfJykpOyB9O1xudmFyIFJhZGFyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJhZGFyKCkge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmFkYXIsIFwiVkVSU0lPTlwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIFNES19WRVJTSU9OO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJhZGFyLCBcInVpXCIsIHtcbiAgICAgICAgLy8gXCJ1aVwiIG5hbWVzcGFjZVxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWFwbGlicmVnbDogTWFwVUkuZ2V0TWFwTGlicmUoKSxcbiAgICAgICAgICAgICAgICBtYXA6IE1hcFVJLmNyZWF0ZU1hcCxcbiAgICAgICAgICAgICAgICBtYXJrZXI6IE1hcFVJLmNyZWF0ZU1hcmtlcixcbiAgICAgICAgICAgICAgICBhdXRvY29tcGxldGU6IEF1dG9jb21wbGV0ZVVJLmNyZWF0ZUF1dG9jb21wbGV0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBSYWRhci5pbml0aWFsaXplID0gZnVuY3Rpb24gKHB1Ymxpc2hhYmxlS2V5LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIGlmICghcHVibGlzaGFibGVLZXkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYWRhclB1Ymxpc2hhYmxlS2V5RXJyb3IoJ1B1Ymxpc2hhYmxlIGtleSByZXF1aXJlZCBpbiBpbml0aWFsaXphdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTZWNyZXRLZXkocHVibGlzaGFibGVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFkYXJQdWJsaXNoYWJsZUtleUVycm9yKCdTZWNyZXQga2V5cyBhcmUgbm90IGFsbG93ZWQuIFBsZWFzZSB1c2UgeW91ciBSYWRhciBwdWJsaXNoYWJsZSBrZXkuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RvcmUgc2V0dGluZ3MgaW4gZ2xvYmFsIGNvbmZpZ1xuICAgICAgICB2YXIgbGl2ZSA9IGlzTGl2ZUtleShwdWJsaXNoYWJsZUtleSk7XG4gICAgICAgIHZhciBsb2dMZXZlbCA9IGxpdmUgPyAnZXJyb3InIDogJ2luZm8nO1xuICAgICAgICB2YXIgZGVidWcgPSAhbGl2ZTtcbiAgICAgICAgdmFyIHJhZGFyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oQ29uZmlnLmRlZmF1bHRPcHRpb25zLCB7XG4gICAgICAgICAgICBwdWJsaXNoYWJsZUtleTogcHVibGlzaGFibGVLZXksXG4gICAgICAgICAgICBsaXZlOiBsaXZlLFxuICAgICAgICAgICAgbG9nTGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICAgICAgZGVidWc6IGRlYnVnLFxuICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgQ29uZmlnLnNldHVwKHJhZGFyT3B0aW9ucyk7XG4gICAgICAgIExvZ2dlci5pbmZvKFwiaW5pdGlhbGl6ZWQgd2l0aCBcIi5jb25jYXQobGl2ZSA/ICdsaXZlJyA6ICd0ZXN0JywgXCIgcHVibGlzaGFibGVLZXkuXCIpKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZGVidWcpIHtcbiAgICAgICAgICAgIExvZ2dlci5pbmZvKFwidXNpbmcgb3B0aW9uczogXCIuY29uY2F0KEpTT04uc3RyaW5naWZ5KG9wdGlvbnMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URShqYXNvbmwpOiB0aGlzIGFsbG93cyB1cyB0byBydW4gamVzdCB0ZXN0c1xuICAgICAgICAvLyB3aXRob3V0IGhhdmluZyB0byBtb2NrIHRoZSBDb25maWdBUEkuZ2V0Q29uZmlnIGNhbGxcbiAgICAgICAgaWYgKCEod2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LlJBREFSX1RFU1RfRU5WKSkge1xuICAgICAgICAgICAgQ29uZmlnQVBJLmdldENvbmZpZygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSYWRhci5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgQ29uZmlnLmNsZWFyKCk7XG4gICAgfTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIGdlb2ZlbmNpbmcgcGxhdGZvcm1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIFJhZGFyLnNldFVzZXJJZCA9IGZ1bmN0aW9uICh1c2VySWQpIHtcbiAgICAgICAgaWYgKCF1c2VySWQpIHtcbiAgICAgICAgICAgIFN0b3JhZ2UucmVtb3ZlSXRlbShTdG9yYWdlLlVTRVJfSUQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFN0b3JhZ2Uuc2V0SXRlbShTdG9yYWdlLlVTRVJfSUQsIFN0cmluZyh1c2VySWQpLnRyaW0oKSk7XG4gICAgfTtcbiAgICBSYWRhci5zZXREZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgICAgICBpZiAoIWRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBTdG9yYWdlLnJlbW92ZUl0ZW0oU3RvcmFnZS5ERVNDUklQVElPTik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgU3RvcmFnZS5zZXRJdGVtKFN0b3JhZ2UuREVTQ1JJUFRJT04sIFN0cmluZyhkZXNjcmlwdGlvbikudHJpbSgpKTtcbiAgICB9O1xuICAgIFJhZGFyLnNldE1ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhKSB7XG4gICAgICAgIGlmICghbWV0YWRhdGEpIHtcbiAgICAgICAgICAgIFN0b3JhZ2UucmVtb3ZlSXRlbShTdG9yYWdlLk1FVEFEQVRBKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBTdG9yYWdlLnNldEl0ZW0oU3RvcmFnZS5NRVRBREFUQSwgSlNPTi5zdHJpbmdpZnkobWV0YWRhdGEpKTtcbiAgICB9O1xuICAgIFJhZGFyLmdldExvY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gTmF2aWdhdG9yLmdldEN1cnJlbnRQb3NpdGlvbigpO1xuICAgIH07XG4gICAgUmFkYXIudHJhY2tPbmNlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBUcmFja0FQSS50cmFja09uY2UocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIENvbmZpZ0FQSS5nZXRDb25maWcocGFyYW1zKTsgLy8gY2FsbCB3aXRoIHVwZGF0ZWQgcGVybWlzc2lvbnNcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmFkYXIudHJhY2tWZXJpZmllZCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcyA9PT0gdm9pZCAwKSB7IHBhcmFtcyA9IHt9OyB9XG4gICAgICAgIHJldHVybiBWZXJpZnlBUEkudHJhY2tWZXJpZmllZChwYXJhbXMpO1xuICAgIH07XG4gICAgUmFkYXIudHJhY2tWZXJpZmllZFRva2VuID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICBpZiAocGFyYW1zID09PSB2b2lkIDApIHsgcGFyYW1zID0ge307IH1cbiAgICAgICAgcmV0dXJuIFZlcmlmeUFQSS50cmFja1ZlcmlmaWVkKHBhcmFtcywgdHJ1ZSk7XG4gICAgfTtcbiAgICBSYWRhci5nZXRDb250ZXh0ID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gQ29udGV4dEFQSS5nZXRDb250ZXh0KHBhcmFtcyk7XG4gICAgfTtcbiAgICBSYWRhci5zZXRUcmlwT3B0aW9ucyA9IGZ1bmN0aW9uICh0cmlwT3B0aW9ucykge1xuICAgICAgICBUcmlwc0FQSS5zZXRUcmlwT3B0aW9ucyh0cmlwT3B0aW9ucyk7XG4gICAgfTtcbiAgICBSYWRhci5jbGVhclRyaXBPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBUcmlwc0FQSS5jbGVhclRyaXBPcHRpb25zKCk7XG4gICAgfTtcbiAgICBSYWRhci5nZXRUcmlwT3B0aW9ucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFRyaXBzQVBJLmdldFRyaXBPcHRpb25zKCk7XG4gICAgfTtcbiAgICBSYWRhci5zdGFydFRyaXAgPSBmdW5jdGlvbiAodHJpcE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFRyaXBzQVBJLnN0YXJ0VHJpcCh0cmlwT3B0aW9ucyk7XG4gICAgfTtcbiAgICBSYWRhci51cGRhdGVUcmlwID0gZnVuY3Rpb24gKHRyaXBPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBUcmlwc0FQSS51cGRhdGVUcmlwKHRyaXBPcHRpb25zKTtcbiAgICB9O1xuICAgIFJhZGFyLmNvbXBsZXRlVHJpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFRyaXBzQVBJLmNvbXBsZXRlVHJpcCgpO1xuICAgIH07XG4gICAgUmFkYXIuY2FuY2VsVHJpcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFRyaXBzQVBJLmNhbmNlbFRyaXAoKTtcbiAgICB9O1xuICAgIFJhZGFyLmxvZ0NvbnZlcnNpb24gPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBDb252ZXJzaW9uc0FQSS5sb2dDb252ZXJzaW9uKHBhcmFtcyk7XG4gICAgfTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIG1hcHMgcGxhdGZvcm1cbiAgICAvLy8vLy8vLy8vLy8vLy8vL1xuICAgIFJhZGFyLmZvcndhcmRHZW9jb2RlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gR2VvY29kaW5nLmZvcndhcmRHZW9jb2RlKHBhcmFtcyk7XG4gICAgfTtcbiAgICBSYWRhci5yZXZlcnNlR2VvY29kZSA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIEdlb2NvZGluZy5yZXZlcnNlR2VvY29kZShwYXJhbXMpO1xuICAgIH07XG4gICAgUmFkYXIuaXBHZW9jb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gR2VvY29kaW5nLmlwR2VvY29kZSgpO1xuICAgIH07XG4gICAgUmFkYXIuYXV0b2NvbXBsZXRlID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gU2VhcmNoQVBJLmF1dG9jb21wbGV0ZShwYXJhbXMpO1xuICAgIH07XG4gICAgUmFkYXIuc2VhcmNoR2VvZmVuY2VzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gU2VhcmNoQVBJLnNlYXJjaEdlb2ZlbmNlcyhwYXJhbXMpO1xuICAgIH07XG4gICAgUmFkYXIuc2VhcmNoUGxhY2VzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gU2VhcmNoQVBJLnNlYXJjaFBsYWNlcyhwYXJhbXMpO1xuICAgIH07XG4gICAgUmFkYXIudmFsaWRhdGVBZGRyZXNzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gQWRkcmVzc2VzQVBJLnZhbGlkYXRlQWRkcmVzcyhwYXJhbXMpO1xuICAgIH07XG4gICAgUmFkYXIuZGlzdGFuY2UgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBSb3V0aW5nQVBJLmRpc3RhbmNlKHBhcmFtcyk7XG4gICAgfTtcbiAgICBSYWRhci5tYXRyaXggPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBSb3V0aW5nQVBJLm1hdHJpeChwYXJhbXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhZGFyO1xufSgpKTtcblxuZXhwb3J0IHsgUmFkYXIgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmFkYXIuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/radar-sdk-js@4.1.11_maplibre-gl@3.5.1/node_modules/radar-sdk-js/dist/radar.js\n");

/***/ })

};
;
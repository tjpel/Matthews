/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/geojson-equality@0.1.6";
exports.ids = ["vendor-chunks/geojson-equality@0.1.6"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/geojson-equality@0.1.6/node_modules/geojson-equality/index.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/geojson-equality@0.1.6/node_modules/geojson-equality/index.js ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("//index.js\nvar deepEqual = __webpack_require__(/*! deep-equal */ \"(ssr)/./node_modules/.pnpm/deep-equal@1.1.1/node_modules/deep-equal/index.js\");\n\nvar Equality = function(opt) {\n  this.precision = opt && opt.precision ? opt.precision : 17;\n  this.direction = opt && opt.direction ? opt.direction : false;\n  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;\n  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;\n};\n\nEquality.prototype.compare = function(g1,g2) {\n  if (g1.type !== g2.type || !sameLength(g1,g2)) return false;\n\n  switch(g1.type) {\n  case 'Point':\n    return this.compareCoord(g1.coordinates, g2.coordinates);\n    break;\n  case 'LineString':\n    return this.compareLine(g1.coordinates, g2.coordinates,0,false);\n    break;\n  case 'Polygon':\n    return this.comparePolygon(g1,g2);\n    break;\n  case 'Feature':\n    return this.compareFeature(g1, g2);\n  default:\n    if (g1.type.indexOf('Multi') === 0) {\n      var context = this;\n      var g1s = explode(g1);\n      var g2s = explode(g2);\n      return g1s.every(function(g1part) {\n        return this.some(function(g2part) {\n          return context.compare(g1part,g2part);\n        });\n      },g2s);\n    }\n  }\n  return false;\n};\n\nfunction explode(g) {\n  return g.coordinates.map(function(part) {\n    return {\n      type: g.type.replace('Multi', ''),\n      coordinates: part}\n  });\n}\n//compare length of coordinates/array\nfunction sameLength(g1,g2) {\n   return g1.hasOwnProperty('coordinates') ?\n    g1.coordinates.length === g2.coordinates.length\n    : g1.length === g2.length;\n}\n\n// compare the two coordinates [x,y]\nEquality.prototype.compareCoord = function(c1,c2) {\n  if (c1.length !== c2.length) {\n    return false;\n  }\n\n  for (var i=0; i < c1.length; i++) {\n    if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {\n      return false;\n    }\n  }\n  return true;\n};\n\nEquality.prototype.compareLine = function(path1,path2,ind,isPoly) {\n  if (!sameLength(path1,path2)) return false;\n  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);\n  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);\n  if (isPoly && !this.compareCoord(p1[0],p2[0])) {\n    // fix start index of both to same point\n    p2 = this.fixStartIndex(p2,p1);\n    if(!p2) return;\n  }\n  // for linestring ind =0 and for polygon ind =1\n  var sameDirection = this.compareCoord(p1[ind],p2[ind]);\n  if (this.direction || sameDirection\n  ) {\n    return this.comparePath(p1, p2);\n  } else {\n    if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])\n    ) {\n      return this.comparePath(p1.slice().reverse(), p2);\n    }\n    return false;\n  }\n};\nEquality.prototype.fixStartIndex = function(sourcePath,targetPath) {\n  //make sourcePath first point same as of targetPath\n  var correctPath,ind = -1;\n  for (var i=0; i< sourcePath.length; i++) {\n    if(this.compareCoord(sourcePath[i],targetPath[0])) {\n      ind = i;\n      break;\n    }\n  }\n  if (ind >= 0) {\n    correctPath = [].concat(\n      sourcePath.slice(ind,sourcePath.length),\n      sourcePath.slice(1,ind+1));\n  }\n  return correctPath;\n};\nEquality.prototype.comparePath = function (p1,p2) {\n  var cont = this;\n  return p1.every(function(c,i) {\n    return cont.compareCoord(c,this[i]);\n  },p2);\n};\n\nEquality.prototype.comparePolygon = function(g1,g2) {\n  if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {\n    var holes1 = g1.coordinates.slice(1,g1.coordinates.length);\n    var holes2 = g2.coordinates.slice(1,g2.coordinates.length);\n    var cont = this;\n    return holes1.every(function(h1) {\n      return this.some(function(h2) {\n        return cont.compareLine(h1,h2,1,true);\n      });\n    },holes2);\n  } else {\n    return false;\n  }\n};\n\nEquality.prototype.compareFeature = function(g1,g2) {\n  if (\n    g1.id !== g2.id ||\n    !this.objectComparator(g1.properties, g2.properties) ||\n    !this.compareBBox(g1,g2)\n  ) {\n    return false;\n  }\n  return this.compare(g1.geometry, g2.geometry);\n};\n\nEquality.prototype.compareBBox = function(g1,g2) {\n  if (\n    (!g1.bbox && !g2.bbox) || \n    (\n      g1.bbox && g2.bbox &&\n      this.compareCoord(g1.bbox, g2.bbox)\n    )\n  )  {\n    return true;\n  }\n  return false;\n};\nEquality.prototype.removePseudo = function(path) {\n  //TODO to be implement\n  return path;\n};\n\nfunction objectComparator(obj1, obj2) {\n  return deepEqual(obj1, obj2, {strict: true});\n}\n\nmodule.exports = Equality;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZ2VvanNvbi1lcXVhbGl0eUAwLjEuNi9ub2RlX21vZHVsZXMvZ2VvanNvbi1lcXVhbGl0eS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGdHQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3Qzs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vZ2VvanNvbi1lcXVhbGl0eUAwLjEuNi9ub2RlX21vZHVsZXMvZ2VvanNvbi1lcXVhbGl0eS9pbmRleC5qcz9mZmVkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vaW5kZXguanNcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBFcXVhbGl0eSA9IGZ1bmN0aW9uKG9wdCkge1xuICB0aGlzLnByZWNpc2lvbiA9IG9wdCAmJiBvcHQucHJlY2lzaW9uID8gb3B0LnByZWNpc2lvbiA6IDE3O1xuICB0aGlzLmRpcmVjdGlvbiA9IG9wdCAmJiBvcHQuZGlyZWN0aW9uID8gb3B0LmRpcmVjdGlvbiA6IGZhbHNlO1xuICB0aGlzLnBzZXVkb05vZGUgPSBvcHQgJiYgb3B0LnBzZXVkb05vZGUgPyBvcHQucHNldWRvTm9kZSA6IGZhbHNlO1xuICB0aGlzLm9iamVjdENvbXBhcmF0b3IgPSBvcHQgJiYgb3B0Lm9iamVjdENvbXBhcmF0b3IgPyBvcHQub2JqZWN0Q29tcGFyYXRvciA6IG9iamVjdENvbXBhcmF0b3I7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmIChnMS50eXBlICE9PSBnMi50eXBlIHx8ICFzYW1lTGVuZ3RoKGcxLGcyKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaChnMS50eXBlKSB7XG4gIGNhc2UgJ1BvaW50JzpcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlQ29vcmQoZzEuY29vcmRpbmF0ZXMsIGcyLmNvb3JkaW5hdGVzKTtcbiAgICBicmVhaztcbiAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZUxpbmUoZzEuY29vcmRpbmF0ZXMsIGcyLmNvb3JkaW5hdGVzLDAsZmFsc2UpO1xuICAgIGJyZWFrO1xuICBjYXNlICdQb2x5Z29uJzpcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlUG9seWdvbihnMSxnMik7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0ZlYXR1cmUnOlxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVGZWF0dXJlKGcxLCBnMik7XG4gIGRlZmF1bHQ6XG4gICAgaWYgKGcxLnR5cGUuaW5kZXhPZignTXVsdGknKSA9PT0gMCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgdmFyIGcxcyA9IGV4cGxvZGUoZzEpO1xuICAgICAgdmFyIGcycyA9IGV4cGxvZGUoZzIpO1xuICAgICAgcmV0dXJuIGcxcy5ldmVyeShmdW5jdGlvbihnMXBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbihnMnBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wYXJlKGcxcGFydCxnMnBhcnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sZzJzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gZXhwbG9kZShnKSB7XG4gIHJldHVybiBnLmNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGcudHlwZS5yZXBsYWNlKCdNdWx0aScsICcnKSxcbiAgICAgIGNvb3JkaW5hdGVzOiBwYXJ0fVxuICB9KTtcbn1cbi8vY29tcGFyZSBsZW5ndGggb2YgY29vcmRpbmF0ZXMvYXJyYXlcbmZ1bmN0aW9uIHNhbWVMZW5ndGgoZzEsZzIpIHtcbiAgIHJldHVybiBnMS5oYXNPd25Qcm9wZXJ0eSgnY29vcmRpbmF0ZXMnKSA/XG4gICAgZzEuY29vcmRpbmF0ZXMubGVuZ3RoID09PSBnMi5jb29yZGluYXRlcy5sZW5ndGhcbiAgICA6IGcxLmxlbmd0aCA9PT0gZzIubGVuZ3RoO1xufVxuXG4vLyBjb21wYXJlIHRoZSB0d28gY29vcmRpbmF0ZXMgW3gseV1cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlQ29vcmQgPSBmdW5jdGlvbihjMSxjMikge1xuICBpZiAoYzEubGVuZ3RoICE9PSBjMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpPTA7IGkgPCBjMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjMVtpXS50b0ZpeGVkKHRoaXMucHJlY2lzaW9uKSAhPT0gYzJbaV0udG9GaXhlZCh0aGlzLnByZWNpc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZUxpbmUgPSBmdW5jdGlvbihwYXRoMSxwYXRoMixpbmQsaXNQb2x5KSB7XG4gIGlmICghc2FtZUxlbmd0aChwYXRoMSxwYXRoMikpIHJldHVybiBmYWxzZTtcbiAgdmFyIHAxID0gdGhpcy5wc2V1ZG9Ob2RlID8gcGF0aDEgOiB0aGlzLnJlbW92ZVBzZXVkbyhwYXRoMSk7XG4gIHZhciBwMiA9IHRoaXMucHNldWRvTm9kZSA/IHBhdGgyIDogdGhpcy5yZW1vdmVQc2V1ZG8ocGF0aDIpO1xuICBpZiAoaXNQb2x5ICYmICF0aGlzLmNvbXBhcmVDb29yZChwMVswXSxwMlswXSkpIHtcbiAgICAvLyBmaXggc3RhcnQgaW5kZXggb2YgYm90aCB0byBzYW1lIHBvaW50XG4gICAgcDIgPSB0aGlzLmZpeFN0YXJ0SW5kZXgocDIscDEpO1xuICAgIGlmKCFwMikgcmV0dXJuO1xuICB9XG4gIC8vIGZvciBsaW5lc3RyaW5nIGluZCA9MCBhbmQgZm9yIHBvbHlnb24gaW5kID0xXG4gIHZhciBzYW1lRGlyZWN0aW9uID0gdGhpcy5jb21wYXJlQ29vcmQocDFbaW5kXSxwMltpbmRdKTtcbiAgaWYgKHRoaXMuZGlyZWN0aW9uIHx8IHNhbWVEaXJlY3Rpb25cbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVBhdGgocDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jb21wYXJlQ29vcmQocDFbaW5kXSxwMltwMi5sZW5ndGggLSAoMStpbmQpXSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVQYXRoKHAxLnNsaWNlKCkucmV2ZXJzZSgpLCBwMik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbkVxdWFsaXR5LnByb3RvdHlwZS5maXhTdGFydEluZGV4ID0gZnVuY3Rpb24oc291cmNlUGF0aCx0YXJnZXRQYXRoKSB7XG4gIC8vbWFrZSBzb3VyY2VQYXRoIGZpcnN0IHBvaW50IHNhbWUgYXMgb2YgdGFyZ2V0UGF0aFxuICB2YXIgY29ycmVjdFBhdGgsaW5kID0gLTE7XG4gIGZvciAodmFyIGk9MDsgaTwgc291cmNlUGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGlmKHRoaXMuY29tcGFyZUNvb3JkKHNvdXJjZVBhdGhbaV0sdGFyZ2V0UGF0aFswXSkpIHtcbiAgICAgIGluZCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGluZCA+PSAwKSB7XG4gICAgY29ycmVjdFBhdGggPSBbXS5jb25jYXQoXG4gICAgICBzb3VyY2VQYXRoLnNsaWNlKGluZCxzb3VyY2VQYXRoLmxlbmd0aCksXG4gICAgICBzb3VyY2VQYXRoLnNsaWNlKDEsaW5kKzEpKTtcbiAgfVxuICByZXR1cm4gY29ycmVjdFBhdGg7XG59O1xuRXF1YWxpdHkucHJvdG90eXBlLmNvbXBhcmVQYXRoID0gZnVuY3Rpb24gKHAxLHAyKSB7XG4gIHZhciBjb250ID0gdGhpcztcbiAgcmV0dXJuIHAxLmV2ZXJ5KGZ1bmN0aW9uKGMsaSkge1xuICAgIHJldHVybiBjb250LmNvbXBhcmVDb29yZChjLHRoaXNbaV0pO1xuICB9LHAyKTtcbn07XG5cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlUG9seWdvbiA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmICh0aGlzLmNvbXBhcmVMaW5lKGcxLmNvb3JkaW5hdGVzWzBdLGcyLmNvb3JkaW5hdGVzWzBdLDEsdHJ1ZSkpIHtcbiAgICB2YXIgaG9sZXMxID0gZzEuY29vcmRpbmF0ZXMuc2xpY2UoMSxnMS5jb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHZhciBob2xlczIgPSBnMi5jb29yZGluYXRlcy5zbGljZSgxLGcyLmNvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgdmFyIGNvbnQgPSB0aGlzO1xuICAgIHJldHVybiBob2xlczEuZXZlcnkoZnVuY3Rpb24oaDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24oaDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQuY29tcGFyZUxpbmUoaDEsaDIsMSx0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0saG9sZXMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlRmVhdHVyZSA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmIChcbiAgICBnMS5pZCAhPT0gZzIuaWQgfHxcbiAgICAhdGhpcy5vYmplY3RDb21wYXJhdG9yKGcxLnByb3BlcnRpZXMsIGcyLnByb3BlcnRpZXMpIHx8XG4gICAgIXRoaXMuY29tcGFyZUJCb3goZzEsZzIpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGhpcy5jb21wYXJlKGcxLmdlb21ldHJ5LCBnMi5nZW9tZXRyeSk7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZUJCb3ggPSBmdW5jdGlvbihnMSxnMikge1xuICBpZiAoXG4gICAgKCFnMS5iYm94ICYmICFnMi5iYm94KSB8fCBcbiAgICAoXG4gICAgICBnMS5iYm94ICYmIGcyLmJib3ggJiZcbiAgICAgIHRoaXMuY29tcGFyZUNvb3JkKGcxLmJib3gsIGcyLmJib3gpXG4gICAgKVxuICApICB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbkVxdWFsaXR5LnByb3RvdHlwZS5yZW1vdmVQc2V1ZG8gPSBmdW5jdGlvbihwYXRoKSB7XG4gIC8vVE9ETyB0byBiZSBpbXBsZW1lbnRcbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5mdW5jdGlvbiBvYmplY3RDb21wYXJhdG9yKG9iajEsIG9iajIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChvYmoxLCBvYmoyLCB7c3RyaWN0OiB0cnVlfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXF1YWxpdHk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/geojson-equality@0.1.6/node_modules/geojson-equality/index.js\n");

/***/ })

};
;
"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turf+shortest-path@6.5.0";
exports.ids = ["vendor-chunks/@turf+shortest-path@6.5.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@turf+shortest-path@6.5.0/node_modules/@turf/shortest-path/dist/es/index.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+shortest-path@6.5.0/node_modules/@turf/shortest-path/dist/es/index.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _turf_bbox__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/bbox */ \"(ssr)/./node_modules/.pnpm/@turf+bbox@6.5.0/node_modules/@turf/bbox/dist/es/index.js\");\n/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/boolean-point-in-polygon */ \"(ssr)/./node_modules/.pnpm/@turf+boolean-point-in-polygon@6.5.0/node_modules/@turf/boolean-point-in-polygon/dist/es/index.js\");\n/* harmony import */ var _turf_distance__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @turf/distance */ \"(ssr)/./node_modules/.pnpm/@turf+distance@6.5.0/node_modules/@turf/distance/dist/es/index.js\");\n/* harmony import */ var _turf_transform_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @turf/transform-scale */ \"(ssr)/./node_modules/.pnpm/@turf+transform-scale@6.5.0/node_modules/@turf/transform-scale/dist/es/index.js\");\n/* harmony import */ var _turf_clean_coords__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @turf/clean-coords */ \"(ssr)/./node_modules/.pnpm/@turf+clean-coords@6.5.0/node_modules/@turf/clean-coords/dist/es/index.js\");\n/* harmony import */ var _turf_bbox_polygon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @turf/bbox-polygon */ \"(ssr)/./node_modules/.pnpm/@turf+bbox-polygon@6.5.0/node_modules/@turf/bbox-polygon/dist/es/index.js\");\n/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @turf/invariant */ \"(ssr)/./node_modules/.pnpm/@turf+invariant@6.5.0/node_modules/@turf/invariant/dist/es/index.js\");\n/* harmony import */ var _turf_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @turf/helpers */ \"(ssr)/./node_modules/.pnpm/@turf+helpers@6.5.0/node_modules/@turf/helpers/dist/es/index.js\");\n\n\n\n\n\n\n\n\n\n// javascript-astar 0.4.1\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a Binary Heap.\n// Includes Binary Heap (with modifications) from Marijn Haverbeke.\n// http://eloquentjavascript.net/appendix2.html\n\nfunction pathTo(node) {\n  var curr = node,\n    path = [];\n  while (curr.parent) {\n    path.unshift(curr);\n    curr = curr.parent;\n  }\n  return path;\n}\n\nfunction getHeap() {\n  return new BinaryHeap(function (node) {\n    return node.f;\n  });\n}\n\n/**\n * Astar\n * @private\n */\nvar astar = {\n  /**\n   * Perform an A* Search on a graph given a start and end node.\n   *\n   * @private\n   * @memberof astar\n   * @param {Graph} graph Graph\n   * @param {GridNode} start Start\n   * @param {GridNode} end End\n   * @param {Object} [options] Options\n   * @param {bool} [options.closest] Specifies whether to return the path to the closest node if the target is unreachable.\n   * @param {Function} [options.heuristic] Heuristic function (see astar.heuristics).\n   * @returns {Object} Search\n   */\n  search: function (graph, start, end, options) {\n    graph.cleanDirty();\n    options = options || {};\n    var heuristic = options.heuristic || astar.heuristics.manhattan,\n      closest = options.closest || false;\n\n    var openHeap = getHeap(),\n      closestNode = start; // set the start node to be the closest if required\n\n    start.h = heuristic(start, end);\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      var currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        return pathTo(currentNode);\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbors.\n      currentNode.closed = true;\n\n      // Find all neighbors for the current node.\n      var neighbors = graph.neighbors(currentNode);\n\n      for (var i = 0, il = neighbors.length; i < il; ++i) {\n        var neighbor = neighbors[i];\n\n        if (neighbor.closed || neighbor.isWall()) {\n          // Not a valid node to process, skip to next neighbor.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbor is the shortest one we have seen yet.\n        var gScore = currentNode.g + neighbor.getCost(currentNode),\n          beenVisited = neighbor.visited;\n\n        if (!beenVisited || gScore < neighbor.g) {\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbor.visited = true;\n          neighbor.parent = currentNode;\n          neighbor.h = neighbor.h || heuristic(neighbor, end);\n          neighbor.g = gScore;\n          neighbor.f = neighbor.g + neighbor.h;\n          graph.markDirty(neighbor);\n          if (closest) {\n            // If the neighbour is closer than the current closestNode or if it's equally close but has\n            // a cheaper path than the current closest node then it becomes the closest node\n            if (\n              neighbor.h < closestNode.h ||\n              (neighbor.h === closestNode.h && neighbor.g < closestNode.g)\n            ) {\n              closestNode = neighbor;\n            }\n          }\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbor);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbor);\n          }\n        }\n      }\n    }\n\n    if (closest) {\n      return pathTo(closestNode);\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  },\n  // See list of heuristics: http://theory.stanford.edu/~amitp/GameProgramming/Heuristics.html\n  heuristics: {\n    manhattan: function (pos0, pos1) {\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return d1 + d2;\n    },\n    diagonal: function (pos0, pos1) {\n      var D = 1;\n      var D2 = Math.sqrt(2);\n      var d1 = Math.abs(pos1.x - pos0.x);\n      var d2 = Math.abs(pos1.y - pos0.y);\n      return D * (d1 + d2) + (D2 - 2 * D) * Math.min(d1, d2);\n    },\n  },\n  cleanNode: function (node) {\n    node.f = 0;\n    node.g = 0;\n    node.h = 0;\n    node.visited = false;\n    node.closed = false;\n    node.parent = null;\n  },\n};\n\n/**\n * A graph memory structure\n *\n * @private\n * @param {Array} gridIn 2D array of input weights\n * @param {Object} [options] Options\n * @param {boolean} [options.diagonal] Specifies whether diagonal moves are allowed\n * @returns {void} Graph\n */\nfunction Graph(gridIn, options) {\n  options = options || {};\n  this.nodes = [];\n  this.diagonal = !!options.diagonal;\n  this.grid = [];\n  for (var x = 0; x < gridIn.length; x++) {\n    this.grid[x] = [];\n\n    for (var y = 0, row = gridIn[x]; y < row.length; y++) {\n      var node = new GridNode(x, y, row[y]);\n      this.grid[x][y] = node;\n      this.nodes.push(node);\n    }\n  }\n  this.init();\n}\n\nGraph.prototype.init = function () {\n  this.dirtyNodes = [];\n  for (var i = 0; i < this.nodes.length; i++) {\n    astar.cleanNode(this.nodes[i]);\n  }\n};\n\nGraph.prototype.cleanDirty = function () {\n  for (var i = 0; i < this.dirtyNodes.length; i++) {\n    astar.cleanNode(this.dirtyNodes[i]);\n  }\n  this.dirtyNodes = [];\n};\n\nGraph.prototype.markDirty = function (node) {\n  this.dirtyNodes.push(node);\n};\n\nGraph.prototype.neighbors = function (node) {\n  var ret = [],\n    x = node.x,\n    y = node.y,\n    grid = this.grid;\n\n  // West\n  if (grid[x - 1] && grid[x - 1][y]) {\n    ret.push(grid[x - 1][y]);\n  }\n\n  // East\n  if (grid[x + 1] && grid[x + 1][y]) {\n    ret.push(grid[x + 1][y]);\n  }\n\n  // South\n  if (grid[x] && grid[x][y - 1]) {\n    ret.push(grid[x][y - 1]);\n  }\n\n  // North\n  if (grid[x] && grid[x][y + 1]) {\n    ret.push(grid[x][y + 1]);\n  }\n\n  if (this.diagonal) {\n    // Southwest\n    if (grid[x - 1] && grid[x - 1][y - 1]) {\n      ret.push(grid[x - 1][y - 1]);\n    }\n\n    // Southeast\n    if (grid[x + 1] && grid[x + 1][y - 1]) {\n      ret.push(grid[x + 1][y - 1]);\n    }\n\n    // Northwest\n    if (grid[x - 1] && grid[x - 1][y + 1]) {\n      ret.push(grid[x - 1][y + 1]);\n    }\n\n    // Northeast\n    if (grid[x + 1] && grid[x + 1][y + 1]) {\n      ret.push(grid[x + 1][y + 1]);\n    }\n  }\n\n  return ret;\n};\n\nGraph.prototype.toString = function () {\n  var graphString = [],\n    nodes = this.grid, // when using grid\n    rowDebug,\n    row,\n    y,\n    l;\n  for (var x = 0, len = nodes.length; x < len; x++) {\n    rowDebug = [];\n    row = nodes[x];\n    for (y = 0, l = row.length; y < l; y++) {\n      rowDebug.push(row[y].weight);\n    }\n    graphString.push(rowDebug.join(\" \"));\n  }\n  return graphString.join(\"\\n\");\n};\n\nfunction GridNode(x, y, weight) {\n  this.x = x;\n  this.y = y;\n  this.weight = weight;\n}\n\nGridNode.prototype.toString = function () {\n  return \"[\" + this.x + \" \" + this.y + \"]\";\n};\n\nGridNode.prototype.getCost = function (fromNeighbor) {\n  // Take diagonal weight into consideration.\n  if (fromNeighbor && fromNeighbor.x !== this.x && fromNeighbor.y !== this.y) {\n    return this.weight * 1.41421;\n  }\n  return this.weight;\n};\n\nGridNode.prototype.isWall = function () {\n  return this.weight === 0;\n};\n\nfunction BinaryHeap(scoreFunction) {\n  this.content = [];\n  this.scoreFunction = scoreFunction;\n}\n\nBinaryHeap.prototype = {\n  push: function (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  },\n  pop: function () {\n    // Store the first element so we can return it later.\n    var result = this.content[0];\n    // Get the element at the end of the array.\n    var end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  },\n  remove: function (node) {\n    var i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    var end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  },\n  size: function () {\n    return this.content.length;\n  },\n  rescoreElement: function (node) {\n    this.sinkDown(this.content.indexOf(node));\n  },\n  sinkDown: function (n) {\n    // Fetch the element that has to be sunk.\n    var element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = ((n + 1) >> 1) - 1,\n        parent = this.content[parentN];\n      // Swap the elements if the parent is greater.\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n        // Found a parent that is less, no need to sink any further.\n      } else {\n        break;\n      }\n    }\n  },\n  bubbleUp: function (n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element, if any.\n      var swap = null,\n        child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n        // Otherwise, we are done.\n      } else {\n        break;\n      }\n    }\n  },\n};\n\n/**\n * Returns the shortest {@link LineString|path} from {@link Point|start} to {@link Point|end} without colliding with\n * any {@link Feature} in {@link FeatureCollection<Polygon>| obstacles}\n *\n * @name shortestPath\n * @param {Coord} start point\n * @param {Coord} end point\n * @param {Object} [options={}] optional parameters\n * @param {Geometry|Feature|FeatureCollection<Polygon>} [options.obstacles] areas which path cannot travel\n * @param {number} [options.minDistance] minimum distance between shortest path and obstacles\n * @param {string} [options.units='kilometers'] unit in which resolution & minimum distance will be expressed in; it can be degrees, radians, miles, kilometers, ...\n * @param {number} [options.resolution=100] distance between matrix points on which the path will be calculated\n * @returns {Feature<LineString>} shortest path between start and end\n * @example\n * var start = [-5, -6];\n * var end = [9, -6];\n * var options = {\n *   obstacles: turf.polygon([[[0, -7], [5, -7], [5, -3], [0, -3], [0, -7]]])\n * };\n *\n * var path = turf.shortestPath(start, end, options);\n *\n * //addToMap\n * var addToMap = [start, end, options.obstacles, path];\n */\nfunction shortestPath(start, end, options) {\n  // Optional parameters\n  options = options || {};\n  if (!(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.isObject)(options)) throw new Error(\"options is invalid\");\n  var resolution = options.resolution;\n  var minDistance = options.minDistance;\n  var obstacles = options.obstacles || (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.featureCollection)([]);\n\n  // validation\n  if (!start) throw new Error(\"start is required\");\n  if (!end) throw new Error(\"end is required\");\n  if ((resolution && !(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.isNumber)(resolution)) || resolution <= 0)\n    throw new Error(\"options.resolution must be a number, greater than 0\");\n  if (minDistance)\n    throw new Error(\"options.minDistance is not yet implemented\");\n\n  // Normalize Inputs\n  var startCoord = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_6__.getCoord)(start);\n  var endCoord = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_6__.getCoord)(end);\n  start = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.point)(startCoord);\n  end = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.point)(endCoord);\n\n  // Handle obstacles\n  switch ((0,_turf_invariant__WEBPACK_IMPORTED_MODULE_6__.getType)(obstacles)) {\n    case \"FeatureCollection\":\n      if (obstacles.features.length === 0)\n        return (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.lineString)([startCoord, endCoord]);\n      break;\n    case \"Polygon\":\n      obstacles = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.featureCollection)([(0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.feature)((0,_turf_invariant__WEBPACK_IMPORTED_MODULE_6__.getGeom)(obstacles))]);\n      break;\n    default:\n      throw new Error(\"invalid obstacles\");\n  }\n\n  // define path grid area\n  var collection = obstacles;\n  collection.features.push(start);\n  collection.features.push(end);\n  var box = (0,_turf_bbox__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_turf_transform_scale__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,_turf_bbox_polygon__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((0,_turf_bbox__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(collection)), 1.15)); // extend 15%\n  if (!resolution) {\n    var width = (0,_turf_distance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([box[0], box[1]], [box[2], box[1]], options);\n    resolution = width / 100;\n  }\n  collection.features.pop();\n  collection.features.pop();\n\n  var west = box[0];\n  var south = box[1];\n  var east = box[2];\n  var north = box[3];\n\n  var xFraction = resolution / (0,_turf_distance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([west, south], [east, south], options);\n  var cellWidth = xFraction * (east - west);\n  var yFraction = resolution / (0,_turf_distance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([west, south], [west, north], options);\n  var cellHeight = yFraction * (north - south);\n\n  var bboxHorizontalSide = east - west;\n  var bboxVerticalSide = north - south;\n  var columns = Math.floor(bboxHorizontalSide / cellWidth);\n  var rows = Math.floor(bboxVerticalSide / cellHeight);\n  // adjust origin of the grid\n  var deltaX = (bboxHorizontalSide - columns * cellWidth) / 2;\n  var deltaY = (bboxVerticalSide - rows * cellHeight) / 2;\n\n  // loop through points only once to speed up process\n  // define matrix grid for A-star algorithm\n  var pointMatrix = [];\n  var matrix = [];\n\n  var closestToStart = [];\n  var closestToEnd = [];\n  var minDistStart = Infinity;\n  var minDistEnd = Infinity;\n  var currentY = north - deltaY;\n  var r = 0;\n  while (currentY >= south) {\n    // var currentY = south + deltaY;\n    var matrixRow = [];\n    var pointMatrixRow = [];\n    var currentX = west + deltaX;\n    var c = 0;\n    while (currentX <= east) {\n      var pt = (0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.point)([currentX, currentY]);\n      var isInsideObstacle = isInside(pt, obstacles);\n      // feed obstacles matrix\n      matrixRow.push(isInsideObstacle ? 0 : 1); // with javascript-astar\n      // matrixRow.push(isInsideObstacle ? 1 : 0); // with astar-andrea\n      // map point's coords\n      pointMatrixRow.push(currentX + \"|\" + currentY);\n      // set closest points\n      var distStart = (0,_turf_distance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(pt, start);\n      // if (distStart < minDistStart) {\n      if (!isInsideObstacle && distStart < minDistStart) {\n        minDistStart = distStart;\n        closestToStart = { x: c, y: r };\n      }\n      var distEnd = (0,_turf_distance__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(pt, end);\n      // if (distEnd < minDistEnd) {\n      if (!isInsideObstacle && distEnd < minDistEnd) {\n        minDistEnd = distEnd;\n        closestToEnd = { x: c, y: r };\n      }\n      currentX += cellWidth;\n      c++;\n    }\n    matrix.push(matrixRow);\n    pointMatrix.push(pointMatrixRow);\n    currentY -= cellHeight;\n    r++;\n  }\n\n  // find path on matrix grid\n\n  // javascript-astar ----------------------\n  var graph = new Graph(matrix, { diagonal: true });\n  var startOnMatrix = graph.grid[closestToStart.y][closestToStart.x];\n  var endOnMatrix = graph.grid[closestToEnd.y][closestToEnd.x];\n  var result = astar.search(graph, startOnMatrix, endOnMatrix);\n\n  var path = [startCoord];\n  result.forEach(function (coord) {\n    var coords = pointMatrix[coord.x][coord.y].split(\"|\");\n    path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  });\n  path.push(endCoord);\n  // ---------------------------------------\n\n  // astar-andrea ------------------------\n  // var result = aStar(matrix, [closestToStart.x, closestToStart.y], [closestToEnd.x, closestToEnd.y], 'DiagonalFree');\n  // var path = [start.geometry.coordinates];\n  // result.forEach(function (coord) {\n  //     var coords = pointMatrix[coord[1]][coord[0]].split('|');\n  //     path.push([+coords[0], +coords[1]]); // make sure coords are numbers\n  // });\n  // path.push(end.geometry.coordinates);\n  // ---------------------------------------\n\n  return (0,_turf_clean_coords__WEBPACK_IMPORTED_MODULE_4__[\"default\"])((0,_turf_helpers__WEBPACK_IMPORTED_MODULE_7__.lineString)(path));\n}\n\n/**\n * Checks if Point is inside any of the Polygons\n *\n * @private\n * @param {Feature<Point>} pt to check\n * @param {FeatureCollection<Polygon>} polygons features\n * @returns {boolean} if inside or not\n */\nfunction isInside(pt, polygons) {\n  for (var i = 0; i < polygons.features.length; i++) {\n    if ((0,_turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(pt, polygons.features[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shortestPath);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrc2hvcnRlc3QtcGF0aEA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvc2hvcnRlc3QtcGF0aC9kaXN0L2VzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUE4QjtBQUNxQztBQUM3QjtBQUNJO0FBQ0c7QUFDQTtBQUNnQjtBQUNxQzs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsVUFBVTtBQUN2QixhQUFhLFFBQVE7QUFDckIsYUFBYSxNQUFNO0FBQ25CLGFBQWEsVUFBVTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxRQUFRO0FBQ3JEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNB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Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsNEJBQTRCO0FBQ3ZDLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QjtBQUNoRCxRQUFRLDBFQUFxQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLFlBQVksRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrc2hvcnRlc3QtcGF0aEA2LjUuMC9ub2RlX21vZHVsZXMvQHR1cmYvc2hvcnRlc3QtcGF0aC9kaXN0L2VzL2luZGV4LmpzP2JkNzEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJib3ggZnJvbSAnQHR1cmYvYmJveCc7XG5pbXBvcnQgYm9vbGVhblBvaW50SW5Qb2x5Z29uIGZyb20gJ0B0dXJmL2Jvb2xlYW4tcG9pbnQtaW4tcG9seWdvbic7XG5pbXBvcnQgZGlzdGFuY2UgZnJvbSAnQHR1cmYvZGlzdGFuY2UnO1xuaW1wb3J0IHNjYWxlIGZyb20gJ0B0dXJmL3RyYW5zZm9ybS1zY2FsZSc7XG5pbXBvcnQgY2xlYW5Db29yZHMgZnJvbSAnQHR1cmYvY2xlYW4tY29vcmRzJztcbmltcG9ydCBiYm94UG9seWdvbiBmcm9tICdAdHVyZi9iYm94LXBvbHlnb24nO1xuaW1wb3J0IHsgZ2V0Q29vcmQsIGdldFR5cGUsIGdldEdlb20gfSBmcm9tICdAdHVyZi9pbnZhcmlhbnQnO1xuaW1wb3J0IHsgaXNPYmplY3QsIGZlYXR1cmVDb2xsZWN0aW9uLCBpc051bWJlciwgcG9pbnQsIGZlYXR1cmUsIGxpbmVTdHJpbmcgfSBmcm9tICdAdHVyZi9oZWxwZXJzJztcblxuLy8gamF2YXNjcmlwdC1hc3RhciAwLjQuMVxuLy8gaHR0cDovL2dpdGh1Yi5jb20vYmdyaW5zL2phdmFzY3JpcHQtYXN0YXJcbi8vIEZyZWVseSBkaXN0cmlidXRhYmxlIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbi8vIEltcGxlbWVudHMgdGhlIGFzdGFyIHNlYXJjaCBhbGdvcml0aG0gaW4gamF2YXNjcmlwdCB1c2luZyBhIEJpbmFyeSBIZWFwLlxuLy8gSW5jbHVkZXMgQmluYXJ5IEhlYXAgKHdpdGggbW9kaWZpY2F0aW9ucykgZnJvbSBNYXJpam4gSGF2ZXJiZWtlLlxuLy8gaHR0cDovL2Vsb3F1ZW50amF2YXNjcmlwdC5uZXQvYXBwZW5kaXgyLmh0bWxcblxuZnVuY3Rpb24gcGF0aFRvKG5vZGUpIHtcbiAgdmFyIGN1cnIgPSBub2RlLFxuICAgIHBhdGggPSBbXTtcbiAgd2hpbGUgKGN1cnIucGFyZW50KSB7XG4gICAgcGF0aC51bnNoaWZ0KGN1cnIpO1xuICAgIGN1cnIgPSBjdXJyLnBhcmVudDtcbiAgfVxuICByZXR1cm4gcGF0aDtcbn1cblxuZnVuY3Rpb24gZ2V0SGVhcCgpIHtcbiAgcmV0dXJuIG5ldyBCaW5hcnlIZWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUuZjtcbiAgfSk7XG59XG5cbi8qKlxuICogQXN0YXJcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBhc3RhciA9IHtcbiAgLyoqXG4gICAqIFBlcmZvcm0gYW4gQSogU2VhcmNoIG9uIGEgZ3JhcGggZ2l2ZW4gYSBzdGFydCBhbmQgZW5kIG5vZGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBtZW1iZXJvZiBhc3RhclxuICAgKiBAcGFyYW0ge0dyYXBofSBncmFwaCBHcmFwaFxuICAgKiBAcGFyYW0ge0dyaWROb2RlfSBzdGFydCBTdGFydFxuICAgKiBAcGFyYW0ge0dyaWROb2RlfSBlbmQgRW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9uc1xuICAgKiBAcGFyYW0ge2Jvb2x9IFtvcHRpb25zLmNsb3Nlc3RdIFNwZWNpZmllcyB3aGV0aGVyIHRvIHJldHVybiB0aGUgcGF0aCB0byB0aGUgY2xvc2VzdCBub2RlIGlmIHRoZSB0YXJnZXQgaXMgdW5yZWFjaGFibGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmhldXJpc3RpY10gSGV1cmlzdGljIGZ1bmN0aW9uIChzZWUgYXN0YXIuaGV1cmlzdGljcykuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFNlYXJjaFxuICAgKi9cbiAgc2VhcmNoOiBmdW5jdGlvbiAoZ3JhcGgsIHN0YXJ0LCBlbmQsIG9wdGlvbnMpIHtcbiAgICBncmFwaC5jbGVhbkRpcnR5KCk7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdmFyIGhldXJpc3RpYyA9IG9wdGlvbnMuaGV1cmlzdGljIHx8IGFzdGFyLmhldXJpc3RpY3MubWFuaGF0dGFuLFxuICAgICAgY2xvc2VzdCA9IG9wdGlvbnMuY2xvc2VzdCB8fCBmYWxzZTtcblxuICAgIHZhciBvcGVuSGVhcCA9IGdldEhlYXAoKSxcbiAgICAgIGNsb3Nlc3ROb2RlID0gc3RhcnQ7IC8vIHNldCB0aGUgc3RhcnQgbm9kZSB0byBiZSB0aGUgY2xvc2VzdCBpZiByZXF1aXJlZFxuXG4gICAgc3RhcnQuaCA9IGhldXJpc3RpYyhzdGFydCwgZW5kKTtcblxuICAgIG9wZW5IZWFwLnB1c2goc3RhcnQpO1xuXG4gICAgd2hpbGUgKG9wZW5IZWFwLnNpemUoKSA+IDApIHtcbiAgICAgIC8vIEdyYWIgdGhlIGxvd2VzdCBmKHgpIHRvIHByb2Nlc3MgbmV4dC4gIEhlYXAga2VlcHMgdGhpcyBzb3J0ZWQgZm9yIHVzLlxuICAgICAgdmFyIGN1cnJlbnROb2RlID0gb3BlbkhlYXAucG9wKCk7XG5cbiAgICAgIC8vIEVuZCBjYXNlIC0tIHJlc3VsdCBoYXMgYmVlbiBmb3VuZCwgcmV0dXJuIHRoZSB0cmFjZWQgcGF0aC5cbiAgICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gZW5kKSB7XG4gICAgICAgIHJldHVybiBwYXRoVG8oY3VycmVudE5vZGUpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3JtYWwgY2FzZSAtLSBtb3ZlIGN1cnJlbnROb2RlIGZyb20gb3BlbiB0byBjbG9zZWQsIHByb2Nlc3MgZWFjaCBvZiBpdHMgbmVpZ2hib3JzLlxuICAgICAgY3VycmVudE5vZGUuY2xvc2VkID0gdHJ1ZTtcblxuICAgICAgLy8gRmluZCBhbGwgbmVpZ2hib3JzIGZvciB0aGUgY3VycmVudCBub2RlLlxuICAgICAgdmFyIG5laWdoYm9ycyA9IGdyYXBoLm5laWdoYm9ycyhjdXJyZW50Tm9kZSk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IG5laWdoYm9ycy5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciBuZWlnaGJvciA9IG5laWdoYm9yc1tpXTtcblxuICAgICAgICBpZiAobmVpZ2hib3IuY2xvc2VkIHx8IG5laWdoYm9yLmlzV2FsbCgpKSB7XG4gICAgICAgICAgLy8gTm90IGEgdmFsaWQgbm9kZSB0byBwcm9jZXNzLCBza2lwIHRvIG5leHQgbmVpZ2hib3IuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZyBzY29yZSBpcyB0aGUgc2hvcnRlc3QgZGlzdGFuY2UgZnJvbSBzdGFydCB0byBjdXJyZW50IG5vZGUuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIHBhdGggd2UgaGF2ZSBhcnJpdmVkIGF0IHRoaXMgbmVpZ2hib3IgaXMgdGhlIHNob3J0ZXN0IG9uZSB3ZSBoYXZlIHNlZW4geWV0LlxuICAgICAgICB2YXIgZ1Njb3JlID0gY3VycmVudE5vZGUuZyArIG5laWdoYm9yLmdldENvc3QoY3VycmVudE5vZGUpLFxuICAgICAgICAgIGJlZW5WaXNpdGVkID0gbmVpZ2hib3IudmlzaXRlZDtcblxuICAgICAgICBpZiAoIWJlZW5WaXNpdGVkIHx8IGdTY29yZSA8IG5laWdoYm9yLmcpIHtcbiAgICAgICAgICAvLyBGb3VuZCBhbiBvcHRpbWFsIChzbyBmYXIpIHBhdGggdG8gdGhpcyBub2RlLiAgVGFrZSBzY29yZSBmb3Igbm9kZSB0byBzZWUgaG93IGdvb2QgaXQgaXMuXG4gICAgICAgICAgbmVpZ2hib3IudmlzaXRlZCA9IHRydWU7XG4gICAgICAgICAgbmVpZ2hib3IucGFyZW50ID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgbmVpZ2hib3IuaCA9IG5laWdoYm9yLmggfHwgaGV1cmlzdGljKG5laWdoYm9yLCBlbmQpO1xuICAgICAgICAgIG5laWdoYm9yLmcgPSBnU2NvcmU7XG4gICAgICAgICAgbmVpZ2hib3IuZiA9IG5laWdoYm9yLmcgKyBuZWlnaGJvci5oO1xuICAgICAgICAgIGdyYXBoLm1hcmtEaXJ0eShuZWlnaGJvcik7XG4gICAgICAgICAgaWYgKGNsb3Nlc3QpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBuZWlnaGJvdXIgaXMgY2xvc2VyIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdE5vZGUgb3IgaWYgaXQncyBlcXVhbGx5IGNsb3NlIGJ1dCBoYXNcbiAgICAgICAgICAgIC8vIGEgY2hlYXBlciBwYXRoIHRoYW4gdGhlIGN1cnJlbnQgY2xvc2VzdCBub2RlIHRoZW4gaXQgYmVjb21lcyB0aGUgY2xvc2VzdCBub2RlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIG5laWdoYm9yLmggPCBjbG9zZXN0Tm9kZS5oIHx8XG4gICAgICAgICAgICAgIChuZWlnaGJvci5oID09PSBjbG9zZXN0Tm9kZS5oICYmIG5laWdoYm9yLmcgPCBjbG9zZXN0Tm9kZS5nKVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNsb3Nlc3ROb2RlID0gbmVpZ2hib3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFiZWVuVmlzaXRlZCkge1xuICAgICAgICAgICAgLy8gUHVzaGluZyB0byBoZWFwIHdpbGwgcHV0IGl0IGluIHByb3BlciBwbGFjZSBiYXNlZCBvbiB0aGUgJ2YnIHZhbHVlLlxuICAgICAgICAgICAgb3BlbkhlYXAucHVzaChuZWlnaGJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgc2VlbiB0aGUgbm9kZSwgYnV0IHNpbmNlIGl0IGhhcyBiZWVuIHJlc2NvcmVkIHdlIG5lZWQgdG8gcmVvcmRlciBpdCBpbiB0aGUgaGVhcFxuICAgICAgICAgICAgb3BlbkhlYXAucmVzY29yZUVsZW1lbnQobmVpZ2hib3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjbG9zZXN0KSB7XG4gICAgICByZXR1cm4gcGF0aFRvKGNsb3Nlc3ROb2RlKTtcbiAgICB9XG5cbiAgICAvLyBObyByZXN1bHQgd2FzIGZvdW5kIC0gZW1wdHkgYXJyYXkgc2lnbmlmaWVzIGZhaWx1cmUgdG8gZmluZCBwYXRoLlxuICAgIHJldHVybiBbXTtcbiAgfSxcbiAgLy8gU2VlIGxpc3Qgb2YgaGV1cmlzdGljczogaHR0cDovL3RoZW9yeS5zdGFuZm9yZC5lZHUvfmFtaXRwL0dhbWVQcm9ncmFtbWluZy9IZXVyaXN0aWNzLmh0bWxcbiAgaGV1cmlzdGljczoge1xuICAgIG1hbmhhdHRhbjogZnVuY3Rpb24gKHBvczAsIHBvczEpIHtcbiAgICAgIHZhciBkMSA9IE1hdGguYWJzKHBvczEueCAtIHBvczAueCk7XG4gICAgICB2YXIgZDIgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MwLnkpO1xuICAgICAgcmV0dXJuIGQxICsgZDI7XG4gICAgfSxcbiAgICBkaWFnb25hbDogZnVuY3Rpb24gKHBvczAsIHBvczEpIHtcbiAgICAgIHZhciBEID0gMTtcbiAgICAgIHZhciBEMiA9IE1hdGguc3FydCgyKTtcbiAgICAgIHZhciBkMSA9IE1hdGguYWJzKHBvczEueCAtIHBvczAueCk7XG4gICAgICB2YXIgZDIgPSBNYXRoLmFicyhwb3MxLnkgLSBwb3MwLnkpO1xuICAgICAgcmV0dXJuIEQgKiAoZDEgKyBkMikgKyAoRDIgLSAyICogRCkgKiBNYXRoLm1pbihkMSwgZDIpO1xuICAgIH0sXG4gIH0sXG4gIGNsZWFuTm9kZTogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLmYgPSAwO1xuICAgIG5vZGUuZyA9IDA7XG4gICAgbm9kZS5oID0gMDtcbiAgICBub2RlLnZpc2l0ZWQgPSBmYWxzZTtcbiAgICBub2RlLmNsb3NlZCA9IGZhbHNlO1xuICAgIG5vZGUucGFyZW50ID0gbnVsbDtcbiAgfSxcbn07XG5cbi8qKlxuICogQSBncmFwaCBtZW1vcnkgc3RydWN0dXJlXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGdyaWRJbiAyRCBhcnJheSBvZiBpbnB1dCB3ZWlnaHRzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZGlhZ29uYWxdIFNwZWNpZmllcyB3aGV0aGVyIGRpYWdvbmFsIG1vdmVzIGFyZSBhbGxvd2VkXG4gKiBAcmV0dXJucyB7dm9pZH0gR3JhcGhcbiAqL1xuZnVuY3Rpb24gR3JhcGgoZ3JpZEluLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB0aGlzLm5vZGVzID0gW107XG4gIHRoaXMuZGlhZ29uYWwgPSAhIW9wdGlvbnMuZGlhZ29uYWw7XG4gIHRoaXMuZ3JpZCA9IFtdO1xuICBmb3IgKHZhciB4ID0gMDsgeCA8IGdyaWRJbi5sZW5ndGg7IHgrKykge1xuICAgIHRoaXMuZ3JpZFt4XSA9IFtdO1xuXG4gICAgZm9yICh2YXIgeSA9IDAsIHJvdyA9IGdyaWRJblt4XTsgeSA8IHJvdy5sZW5ndGg7IHkrKykge1xuICAgICAgdmFyIG5vZGUgPSBuZXcgR3JpZE5vZGUoeCwgeSwgcm93W3ldKTtcbiAgICAgIHRoaXMuZ3JpZFt4XVt5XSA9IG5vZGU7XG4gICAgICB0aGlzLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgfVxuICB9XG4gIHRoaXMuaW5pdCgpO1xufVxuXG5HcmFwaC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5kaXJ0eU5vZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGFzdGFyLmNsZWFuTm9kZSh0aGlzLm5vZGVzW2ldKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLmNsZWFuRGlydHkgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaXJ0eU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgYXN0YXIuY2xlYW5Ob2RlKHRoaXMuZGlydHlOb2Rlc1tpXSk7XG4gIH1cbiAgdGhpcy5kaXJ0eU5vZGVzID0gW107XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubWFya0RpcnR5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdGhpcy5kaXJ0eU5vZGVzLnB1c2gobm9kZSk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubmVpZ2hib3JzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgdmFyIHJldCA9IFtdLFxuICAgIHggPSBub2RlLngsXG4gICAgeSA9IG5vZGUueSxcbiAgICBncmlkID0gdGhpcy5ncmlkO1xuXG4gIC8vIFdlc3RcbiAgaWYgKGdyaWRbeCAtIDFdICYmIGdyaWRbeCAtIDFdW3ldKSB7XG4gICAgcmV0LnB1c2goZ3JpZFt4IC0gMV1beV0pO1xuICB9XG5cbiAgLy8gRWFzdFxuICBpZiAoZ3JpZFt4ICsgMV0gJiYgZ3JpZFt4ICsgMV1beV0pIHtcbiAgICByZXQucHVzaChncmlkW3ggKyAxXVt5XSk7XG4gIH1cblxuICAvLyBTb3V0aFxuICBpZiAoZ3JpZFt4XSAmJiBncmlkW3hdW3kgLSAxXSkge1xuICAgIHJldC5wdXNoKGdyaWRbeF1beSAtIDFdKTtcbiAgfVxuXG4gIC8vIE5vcnRoXG4gIGlmIChncmlkW3hdICYmIGdyaWRbeF1beSArIDFdKSB7XG4gICAgcmV0LnB1c2goZ3JpZFt4XVt5ICsgMV0pO1xuICB9XG5cbiAgaWYgKHRoaXMuZGlhZ29uYWwpIHtcbiAgICAvLyBTb3V0aHdlc3RcbiAgICBpZiAoZ3JpZFt4IC0gMV0gJiYgZ3JpZFt4IC0gMV1beSAtIDFdKSB7XG4gICAgICByZXQucHVzaChncmlkW3ggLSAxXVt5IC0gMV0pO1xuICAgIH1cblxuICAgIC8vIFNvdXRoZWFzdFxuICAgIGlmIChncmlkW3ggKyAxXSAmJiBncmlkW3ggKyAxXVt5IC0gMV0pIHtcbiAgICAgIHJldC5wdXNoKGdyaWRbeCArIDFdW3kgLSAxXSk7XG4gICAgfVxuXG4gICAgLy8gTm9ydGh3ZXN0XG4gICAgaWYgKGdyaWRbeCAtIDFdICYmIGdyaWRbeCAtIDFdW3kgKyAxXSkge1xuICAgICAgcmV0LnB1c2goZ3JpZFt4IC0gMV1beSArIDFdKTtcbiAgICB9XG5cbiAgICAvLyBOb3J0aGVhc3RcbiAgICBpZiAoZ3JpZFt4ICsgMV0gJiYgZ3JpZFt4ICsgMV1beSArIDFdKSB7XG4gICAgICByZXQucHVzaChncmlkW3ggKyAxXVt5ICsgMV0pO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBncmFwaFN0cmluZyA9IFtdLFxuICAgIG5vZGVzID0gdGhpcy5ncmlkLCAvLyB3aGVuIHVzaW5nIGdyaWRcbiAgICByb3dEZWJ1ZyxcbiAgICByb3csXG4gICAgeSxcbiAgICBsO1xuICBmb3IgKHZhciB4ID0gMCwgbGVuID0gbm9kZXMubGVuZ3RoOyB4IDwgbGVuOyB4KyspIHtcbiAgICByb3dEZWJ1ZyA9IFtdO1xuICAgIHJvdyA9IG5vZGVzW3hdO1xuICAgIGZvciAoeSA9IDAsIGwgPSByb3cubGVuZ3RoOyB5IDwgbDsgeSsrKSB7XG4gICAgICByb3dEZWJ1Zy5wdXNoKHJvd1t5XS53ZWlnaHQpO1xuICAgIH1cbiAgICBncmFwaFN0cmluZy5wdXNoKHJvd0RlYnVnLmpvaW4oXCIgXCIpKTtcbiAgfVxuICByZXR1cm4gZ3JhcGhTdHJpbmcuam9pbihcIlxcblwiKTtcbn07XG5cbmZ1bmN0aW9uIEdyaWROb2RlKHgsIHksIHdlaWdodCkge1xuICB0aGlzLnggPSB4O1xuICB0aGlzLnkgPSB5O1xuICB0aGlzLndlaWdodCA9IHdlaWdodDtcbn1cblxuR3JpZE5vZGUucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gXCJbXCIgKyB0aGlzLnggKyBcIiBcIiArIHRoaXMueSArIFwiXVwiO1xufTtcblxuR3JpZE5vZGUucHJvdG90eXBlLmdldENvc3QgPSBmdW5jdGlvbiAoZnJvbU5laWdoYm9yKSB7XG4gIC8vIFRha2UgZGlhZ29uYWwgd2VpZ2h0IGludG8gY29uc2lkZXJhdGlvbi5cbiAgaWYgKGZyb21OZWlnaGJvciAmJiBmcm9tTmVpZ2hib3IueCAhPT0gdGhpcy54ICYmIGZyb21OZWlnaGJvci55ICE9PSB0aGlzLnkpIHtcbiAgICByZXR1cm4gdGhpcy53ZWlnaHQgKiAxLjQxNDIxO1xuICB9XG4gIHJldHVybiB0aGlzLndlaWdodDtcbn07XG5cbkdyaWROb2RlLnByb3RvdHlwZS5pc1dhbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLndlaWdodCA9PT0gMDtcbn07XG5cbmZ1bmN0aW9uIEJpbmFyeUhlYXAoc2NvcmVGdW5jdGlvbikge1xuICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgdGhpcy5zY29yZUZ1bmN0aW9uID0gc2NvcmVGdW5jdGlvbjtcbn1cblxuQmluYXJ5SGVhcC5wcm90b3R5cGUgPSB7XG4gIHB1c2g6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgLy8gQWRkIHRoZSBuZXcgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICB0aGlzLmNvbnRlbnQucHVzaChlbGVtZW50KTtcblxuICAgIC8vIEFsbG93IGl0IHRvIHNpbmsgZG93bi5cbiAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5sZW5ndGggLSAxKTtcbiAgfSxcbiAgcG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RvcmUgdGhlIGZpcnN0IGVsZW1lbnQgc28gd2UgY2FuIHJldHVybiBpdCBsYXRlci5cbiAgICB2YXIgcmVzdWx0ID0gdGhpcy5jb250ZW50WzBdO1xuICAgIC8vIEdldCB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICB2YXIgZW5kID0gdGhpcy5jb250ZW50LnBvcCgpO1xuICAgIC8vIElmIHRoZXJlIGFyZSBhbnkgZWxlbWVudHMgbGVmdCwgcHV0IHRoZSBlbmQgZWxlbWVudCBhdCB0aGVcbiAgICAvLyBzdGFydCwgYW5kIGxldCBpdCBidWJibGUgdXAuXG4gICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmNvbnRlbnRbMF0gPSBlbmQ7XG4gICAgICB0aGlzLmJ1YmJsZVVwKDApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgdmFyIGkgPSB0aGlzLmNvbnRlbnQuaW5kZXhPZihub2RlKTtcblxuICAgIC8vIFdoZW4gaXQgaXMgZm91bmQsIHRoZSBwcm9jZXNzIHNlZW4gaW4gJ3BvcCcgaXMgcmVwZWF0ZWRcbiAgICAvLyB0byBmaWxsIHVwIHRoZSBob2xlLlxuICAgIHZhciBlbmQgPSB0aGlzLmNvbnRlbnQucG9wKCk7XG5cbiAgICBpZiAoaSAhPT0gdGhpcy5jb250ZW50Lmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuY29udGVudFtpXSA9IGVuZDtcblxuICAgICAgaWYgKHRoaXMuc2NvcmVGdW5jdGlvbihlbmQpIDwgdGhpcy5zY29yZUZ1bmN0aW9uKG5vZGUpKSB7XG4gICAgICAgIHRoaXMuc2lua0Rvd24oaSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJ1YmJsZVVwKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc2l6ZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoO1xuICB9LFxuICByZXNjb3JlRWxlbWVudDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICB0aGlzLnNpbmtEb3duKHRoaXMuY29udGVudC5pbmRleE9mKG5vZGUpKTtcbiAgfSxcbiAgc2lua0Rvd246IGZ1bmN0aW9uIChuKSB7XG4gICAgLy8gRmV0Y2ggdGhlIGVsZW1lbnQgdGhhdCBoYXMgdG8gYmUgc3Vuay5cbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuY29udGVudFtuXTtcblxuICAgIC8vIFdoZW4gYXQgMCwgYW4gZWxlbWVudCBjYW4gbm90IHNpbmsgYW55IGZ1cnRoZXIuXG4gICAgd2hpbGUgKG4gPiAwKSB7XG4gICAgICAvLyBDb21wdXRlIHRoZSBwYXJlbnQgZWxlbWVudCdzIGluZGV4LCBhbmQgZmV0Y2ggaXQuXG4gICAgICB2YXIgcGFyZW50TiA9ICgobiArIDEpID4+IDEpIC0gMSxcbiAgICAgICAgcGFyZW50ID0gdGhpcy5jb250ZW50W3BhcmVudE5dO1xuICAgICAgLy8gU3dhcCB0aGUgZWxlbWVudHMgaWYgdGhlIHBhcmVudCBpcyBncmVhdGVyLlxuICAgICAgaWYgKHRoaXMuc2NvcmVGdW5jdGlvbihlbGVtZW50KSA8IHRoaXMuc2NvcmVGdW5jdGlvbihwYXJlbnQpKSB7XG4gICAgICAgIHRoaXMuY29udGVudFtwYXJlbnROXSA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuY29udGVudFtuXSA9IHBhcmVudDtcbiAgICAgICAgLy8gVXBkYXRlICduJyB0byBjb250aW51ZSBhdCB0aGUgbmV3IHBvc2l0aW9uLlxuICAgICAgICBuID0gcGFyZW50TjtcbiAgICAgICAgLy8gRm91bmQgYSBwYXJlbnQgdGhhdCBpcyBsZXNzLCBubyBuZWVkIHRvIHNpbmsgYW55IGZ1cnRoZXIuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIGJ1YmJsZVVwOiBmdW5jdGlvbiAobikge1xuICAgIC8vIExvb2sgdXAgdGhlIHRhcmdldCBlbGVtZW50IGFuZCBpdHMgc2NvcmUuXG4gICAgdmFyIGxlbmd0aCA9IHRoaXMuY29udGVudC5sZW5ndGgsXG4gICAgICBlbGVtZW50ID0gdGhpcy5jb250ZW50W25dLFxuICAgICAgZWxlbVNjb3JlID0gdGhpcy5zY29yZUZ1bmN0aW9uKGVsZW1lbnQpO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIENvbXB1dGUgdGhlIGluZGljZXMgb2YgdGhlIGNoaWxkIGVsZW1lbnRzLlxuICAgICAgdmFyIGNoaWxkMk4gPSAobiArIDEpIDw8IDEsXG4gICAgICAgIGNoaWxkMU4gPSBjaGlsZDJOIC0gMTtcbiAgICAgIC8vIFRoaXMgaXMgdXNlZCB0byBzdG9yZSB0aGUgbmV3IHBvc2l0aW9uIG9mIHRoZSBlbGVtZW50LCBpZiBhbnkuXG4gICAgICB2YXIgc3dhcCA9IG51bGwsXG4gICAgICAgIGNoaWxkMVNjb3JlO1xuICAgICAgLy8gSWYgdGhlIGZpcnN0IGNoaWxkIGV4aXN0cyAoaXMgaW5zaWRlIHRoZSBhcnJheSkuLi5cbiAgICAgIGlmIChjaGlsZDFOIDwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIExvb2sgaXQgdXAgYW5kIGNvbXB1dGUgaXRzIHNjb3JlLlxuICAgICAgICB2YXIgY2hpbGQxID0gdGhpcy5jb250ZW50W2NoaWxkMU5dO1xuICAgICAgICBjaGlsZDFTY29yZSA9IHRoaXMuc2NvcmVGdW5jdGlvbihjaGlsZDEpO1xuXG4gICAgICAgIC8vIElmIHRoZSBzY29yZSBpcyBsZXNzIHRoYW4gb3VyIGVsZW1lbnQncywgd2UgbmVlZCB0byBzd2FwLlxuICAgICAgICBpZiAoY2hpbGQxU2NvcmUgPCBlbGVtU2NvcmUpIHtcbiAgICAgICAgICBzd2FwID0gY2hpbGQxTjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEbyB0aGUgc2FtZSBjaGVja3MgZm9yIHRoZSBvdGhlciBjaGlsZC5cbiAgICAgIGlmIChjaGlsZDJOIDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBjaGlsZDIgPSB0aGlzLmNvbnRlbnRbY2hpbGQyTl0sXG4gICAgICAgICAgY2hpbGQyU2NvcmUgPSB0aGlzLnNjb3JlRnVuY3Rpb24oY2hpbGQyKTtcbiAgICAgICAgaWYgKGNoaWxkMlNjb3JlIDwgKHN3YXAgPT09IG51bGwgPyBlbGVtU2NvcmUgOiBjaGlsZDFTY29yZSkpIHtcbiAgICAgICAgICBzd2FwID0gY2hpbGQyTjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgZWxlbWVudCBuZWVkcyB0byBiZSBtb3ZlZCwgc3dhcCBpdCwgYW5kIGNvbnRpbnVlLlxuICAgICAgaWYgKHN3YXAgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jb250ZW50W25dID0gdGhpcy5jb250ZW50W3N3YXBdO1xuICAgICAgICB0aGlzLmNvbnRlbnRbc3dhcF0gPSBlbGVtZW50O1xuICAgICAgICBuID0gc3dhcDtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBhcmUgZG9uZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2hvcnRlc3Qge0BsaW5rIExpbmVTdHJpbmd8cGF0aH0gZnJvbSB7QGxpbmsgUG9pbnR8c3RhcnR9IHRvIHtAbGluayBQb2ludHxlbmR9IHdpdGhvdXQgY29sbGlkaW5nIHdpdGhcbiAqIGFueSB7QGxpbmsgRmVhdHVyZX0gaW4ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fCBvYnN0YWNsZXN9XG4gKlxuICogQG5hbWUgc2hvcnRlc3RQYXRoXG4gKiBAcGFyYW0ge0Nvb3JkfSBzdGFydCBwb2ludFxuICogQHBhcmFtIHtDb29yZH0gZW5kIHBvaW50XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIG9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gW29wdGlvbnMub2JzdGFjbGVzXSBhcmVhcyB3aGljaCBwYXRoIGNhbm5vdCB0cmF2ZWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5EaXN0YW5jZV0gbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHNob3J0ZXN0IHBhdGggYW5kIG9ic3RhY2xlc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVuaXRzPSdraWxvbWV0ZXJzJ10gdW5pdCBpbiB3aGljaCByZXNvbHV0aW9uICYgbWluaW11bSBkaXN0YW5jZSB3aWxsIGJlIGV4cHJlc3NlZCBpbjsgaXQgY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBraWxvbWV0ZXJzLCAuLi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5yZXNvbHV0aW9uPTEwMF0gZGlzdGFuY2UgYmV0d2VlbiBtYXRyaXggcG9pbnRzIG9uIHdoaWNoIHRoZSBwYXRoIHdpbGwgYmUgY2FsY3VsYXRlZFxuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IHNob3J0ZXN0IHBhdGggYmV0d2VlbiBzdGFydCBhbmQgZW5kXG4gKiBAZXhhbXBsZVxuICogdmFyIHN0YXJ0ID0gWy01LCAtNl07XG4gKiB2YXIgZW5kID0gWzksIC02XTtcbiAqIHZhciBvcHRpb25zID0ge1xuICogICBvYnN0YWNsZXM6IHR1cmYucG9seWdvbihbW1swLCAtN10sIFs1LCAtN10sIFs1LCAtM10sIFswLCAtM10sIFswLCAtN11dXSlcbiAqIH07XG4gKlxuICogdmFyIHBhdGggPSB0dXJmLnNob3J0ZXN0UGF0aChzdGFydCwgZW5kLCBvcHRpb25zKTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbc3RhcnQsIGVuZCwgb3B0aW9ucy5vYnN0YWNsZXMsIHBhdGhdO1xuICovXG5mdW5jdGlvbiBzaG9ydGVzdFBhdGgoc3RhcnQsIGVuZCwgb3B0aW9ucykge1xuICAvLyBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIWlzT2JqZWN0KG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zIGlzIGludmFsaWRcIik7XG4gIHZhciByZXNvbHV0aW9uID0gb3B0aW9ucy5yZXNvbHV0aW9uO1xuICB2YXIgbWluRGlzdGFuY2UgPSBvcHRpb25zLm1pbkRpc3RhbmNlO1xuICB2YXIgb2JzdGFjbGVzID0gb3B0aW9ucy5vYnN0YWNsZXMgfHwgZmVhdHVyZUNvbGxlY3Rpb24oW10pO1xuXG4gIC8vIHZhbGlkYXRpb25cbiAgaWYgKCFzdGFydCkgdGhyb3cgbmV3IEVycm9yKFwic3RhcnQgaXMgcmVxdWlyZWRcIik7XG4gIGlmICghZW5kKSB0aHJvdyBuZXcgRXJyb3IoXCJlbmQgaXMgcmVxdWlyZWRcIik7XG4gIGlmICgocmVzb2x1dGlvbiAmJiAhaXNOdW1iZXIocmVzb2x1dGlvbikpIHx8IHJlc29sdXRpb24gPD0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLnJlc29sdXRpb24gbXVzdCBiZSBhIG51bWJlciwgZ3JlYXRlciB0aGFuIDBcIik7XG4gIGlmIChtaW5EaXN0YW5jZSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLm1pbkRpc3RhbmNlIGlzIG5vdCB5ZXQgaW1wbGVtZW50ZWRcIik7XG5cbiAgLy8gTm9ybWFsaXplIElucHV0c1xuICB2YXIgc3RhcnRDb29yZCA9IGdldENvb3JkKHN0YXJ0KTtcbiAgdmFyIGVuZENvb3JkID0gZ2V0Q29vcmQoZW5kKTtcbiAgc3RhcnQgPSBwb2ludChzdGFydENvb3JkKTtcbiAgZW5kID0gcG9pbnQoZW5kQ29vcmQpO1xuXG4gIC8vIEhhbmRsZSBvYnN0YWNsZXNcbiAgc3dpdGNoIChnZXRUeXBlKG9ic3RhY2xlcykpIHtcbiAgICBjYXNlIFwiRmVhdHVyZUNvbGxlY3Rpb25cIjpcbiAgICAgIGlmIChvYnN0YWNsZXMuZmVhdHVyZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbGluZVN0cmluZyhbc3RhcnRDb29yZCwgZW5kQ29vcmRdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICBvYnN0YWNsZXMgPSBmZWF0dXJlQ29sbGVjdGlvbihbZmVhdHVyZShnZXRHZW9tKG9ic3RhY2xlcykpXSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBvYnN0YWNsZXNcIik7XG4gIH1cblxuICAvLyBkZWZpbmUgcGF0aCBncmlkIGFyZWFcbiAgdmFyIGNvbGxlY3Rpb24gPSBvYnN0YWNsZXM7XG4gIGNvbGxlY3Rpb24uZmVhdHVyZXMucHVzaChzdGFydCk7XG4gIGNvbGxlY3Rpb24uZmVhdHVyZXMucHVzaChlbmQpO1xuICB2YXIgYm94ID0gYmJveChzY2FsZShiYm94UG9seWdvbihiYm94KGNvbGxlY3Rpb24pKSwgMS4xNSkpOyAvLyBleHRlbmQgMTUlXG4gIGlmICghcmVzb2x1dGlvbikge1xuICAgIHZhciB3aWR0aCA9IGRpc3RhbmNlKFtib3hbMF0sIGJveFsxXV0sIFtib3hbMl0sIGJveFsxXV0sIG9wdGlvbnMpO1xuICAgIHJlc29sdXRpb24gPSB3aWR0aCAvIDEwMDtcbiAgfVxuICBjb2xsZWN0aW9uLmZlYXR1cmVzLnBvcCgpO1xuICBjb2xsZWN0aW9uLmZlYXR1cmVzLnBvcCgpO1xuXG4gIHZhciB3ZXN0ID0gYm94WzBdO1xuICB2YXIgc291dGggPSBib3hbMV07XG4gIHZhciBlYXN0ID0gYm94WzJdO1xuICB2YXIgbm9ydGggPSBib3hbM107XG5cbiAgdmFyIHhGcmFjdGlvbiA9IHJlc29sdXRpb24gLyBkaXN0YW5jZShbd2VzdCwgc291dGhdLCBbZWFzdCwgc291dGhdLCBvcHRpb25zKTtcbiAgdmFyIGNlbGxXaWR0aCA9IHhGcmFjdGlvbiAqIChlYXN0IC0gd2VzdCk7XG4gIHZhciB5RnJhY3Rpb24gPSByZXNvbHV0aW9uIC8gZGlzdGFuY2UoW3dlc3QsIHNvdXRoXSwgW3dlc3QsIG5vcnRoXSwgb3B0aW9ucyk7XG4gIHZhciBjZWxsSGVpZ2h0ID0geUZyYWN0aW9uICogKG5vcnRoIC0gc291dGgpO1xuXG4gIHZhciBiYm94SG9yaXpvbnRhbFNpZGUgPSBlYXN0IC0gd2VzdDtcbiAgdmFyIGJib3hWZXJ0aWNhbFNpZGUgPSBub3J0aCAtIHNvdXRoO1xuICB2YXIgY29sdW1ucyA9IE1hdGguZmxvb3IoYmJveEhvcml6b250YWxTaWRlIC8gY2VsbFdpZHRoKTtcbiAgdmFyIHJvd3MgPSBNYXRoLmZsb29yKGJib3hWZXJ0aWNhbFNpZGUgLyBjZWxsSGVpZ2h0KTtcbiAgLy8gYWRqdXN0IG9yaWdpbiBvZiB0aGUgZ3JpZFxuICB2YXIgZGVsdGFYID0gKGJib3hIb3Jpem9udGFsU2lkZSAtIGNvbHVtbnMgKiBjZWxsV2lkdGgpIC8gMjtcbiAgdmFyIGRlbHRhWSA9IChiYm94VmVydGljYWxTaWRlIC0gcm93cyAqIGNlbGxIZWlnaHQpIC8gMjtcblxuICAvLyBsb29wIHRocm91Z2ggcG9pbnRzIG9ubHkgb25jZSB0byBzcGVlZCB1cCBwcm9jZXNzXG4gIC8vIGRlZmluZSBtYXRyaXggZ3JpZCBmb3IgQS1zdGFyIGFsZ29yaXRobVxuICB2YXIgcG9pbnRNYXRyaXggPSBbXTtcbiAgdmFyIG1hdHJpeCA9IFtdO1xuXG4gIHZhciBjbG9zZXN0VG9TdGFydCA9IFtdO1xuICB2YXIgY2xvc2VzdFRvRW5kID0gW107XG4gIHZhciBtaW5EaXN0U3RhcnQgPSBJbmZpbml0eTtcbiAgdmFyIG1pbkRpc3RFbmQgPSBJbmZpbml0eTtcbiAgdmFyIGN1cnJlbnRZID0gbm9ydGggLSBkZWx0YVk7XG4gIHZhciByID0gMDtcbiAgd2hpbGUgKGN1cnJlbnRZID49IHNvdXRoKSB7XG4gICAgLy8gdmFyIGN1cnJlbnRZID0gc291dGggKyBkZWx0YVk7XG4gICAgdmFyIG1hdHJpeFJvdyA9IFtdO1xuICAgIHZhciBwb2ludE1hdHJpeFJvdyA9IFtdO1xuICAgIHZhciBjdXJyZW50WCA9IHdlc3QgKyBkZWx0YVg7XG4gICAgdmFyIGMgPSAwO1xuICAgIHdoaWxlIChjdXJyZW50WCA8PSBlYXN0KSB7XG4gICAgICB2YXIgcHQgPSBwb2ludChbY3VycmVudFgsIGN1cnJlbnRZXSk7XG4gICAgICB2YXIgaXNJbnNpZGVPYnN0YWNsZSA9IGlzSW5zaWRlKHB0LCBvYnN0YWNsZXMpO1xuICAgICAgLy8gZmVlZCBvYnN0YWNsZXMgbWF0cml4XG4gICAgICBtYXRyaXhSb3cucHVzaChpc0luc2lkZU9ic3RhY2xlID8gMCA6IDEpOyAvLyB3aXRoIGphdmFzY3JpcHQtYXN0YXJcbiAgICAgIC8vIG1hdHJpeFJvdy5wdXNoKGlzSW5zaWRlT2JzdGFjbGUgPyAxIDogMCk7IC8vIHdpdGggYXN0YXItYW5kcmVhXG4gICAgICAvLyBtYXAgcG9pbnQncyBjb29yZHNcbiAgICAgIHBvaW50TWF0cml4Um93LnB1c2goY3VycmVudFggKyBcInxcIiArIGN1cnJlbnRZKTtcbiAgICAgIC8vIHNldCBjbG9zZXN0IHBvaW50c1xuICAgICAgdmFyIGRpc3RTdGFydCA9IGRpc3RhbmNlKHB0LCBzdGFydCk7XG4gICAgICAvLyBpZiAoZGlzdFN0YXJ0IDwgbWluRGlzdFN0YXJ0KSB7XG4gICAgICBpZiAoIWlzSW5zaWRlT2JzdGFjbGUgJiYgZGlzdFN0YXJ0IDwgbWluRGlzdFN0YXJ0KSB7XG4gICAgICAgIG1pbkRpc3RTdGFydCA9IGRpc3RTdGFydDtcbiAgICAgICAgY2xvc2VzdFRvU3RhcnQgPSB7IHg6IGMsIHk6IHIgfTtcbiAgICAgIH1cbiAgICAgIHZhciBkaXN0RW5kID0gZGlzdGFuY2UocHQsIGVuZCk7XG4gICAgICAvLyBpZiAoZGlzdEVuZCA8IG1pbkRpc3RFbmQpIHtcbiAgICAgIGlmICghaXNJbnNpZGVPYnN0YWNsZSAmJiBkaXN0RW5kIDwgbWluRGlzdEVuZCkge1xuICAgICAgICBtaW5EaXN0RW5kID0gZGlzdEVuZDtcbiAgICAgICAgY2xvc2VzdFRvRW5kID0geyB4OiBjLCB5OiByIH07XG4gICAgICB9XG4gICAgICBjdXJyZW50WCArPSBjZWxsV2lkdGg7XG4gICAgICBjKys7XG4gICAgfVxuICAgIG1hdHJpeC5wdXNoKG1hdHJpeFJvdyk7XG4gICAgcG9pbnRNYXRyaXgucHVzaChwb2ludE1hdHJpeFJvdyk7XG4gICAgY3VycmVudFkgLT0gY2VsbEhlaWdodDtcbiAgICByKys7XG4gIH1cblxuICAvLyBmaW5kIHBhdGggb24gbWF0cml4IGdyaWRcblxuICAvLyBqYXZhc2NyaXB0LWFzdGFyIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIGdyYXBoID0gbmV3IEdyYXBoKG1hdHJpeCwgeyBkaWFnb25hbDogdHJ1ZSB9KTtcbiAgdmFyIHN0YXJ0T25NYXRyaXggPSBncmFwaC5ncmlkW2Nsb3Nlc3RUb1N0YXJ0LnldW2Nsb3Nlc3RUb1N0YXJ0LnhdO1xuICB2YXIgZW5kT25NYXRyaXggPSBncmFwaC5ncmlkW2Nsb3Nlc3RUb0VuZC55XVtjbG9zZXN0VG9FbmQueF07XG4gIHZhciByZXN1bHQgPSBhc3Rhci5zZWFyY2goZ3JhcGgsIHN0YXJ0T25NYXRyaXgsIGVuZE9uTWF0cml4KTtcblxuICB2YXIgcGF0aCA9IFtzdGFydENvb3JkXTtcbiAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgdmFyIGNvb3JkcyA9IHBvaW50TWF0cml4W2Nvb3JkLnhdW2Nvb3JkLnldLnNwbGl0KFwifFwiKTtcbiAgICBwYXRoLnB1c2goWytjb29yZHNbMF0sICtjb29yZHNbMV1dKTsgLy8gbWFrZSBzdXJlIGNvb3JkcyBhcmUgbnVtYmVyc1xuICB9KTtcbiAgcGF0aC5wdXNoKGVuZENvb3JkKTtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gYXN0YXItYW5kcmVhIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB2YXIgcmVzdWx0ID0gYVN0YXIobWF0cml4LCBbY2xvc2VzdFRvU3RhcnQueCwgY2xvc2VzdFRvU3RhcnQueV0sIFtjbG9zZXN0VG9FbmQueCwgY2xvc2VzdFRvRW5kLnldLCAnRGlhZ29uYWxGcmVlJyk7XG4gIC8vIHZhciBwYXRoID0gW3N0YXJ0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzXTtcbiAgLy8gcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKGNvb3JkKSB7XG4gIC8vICAgICB2YXIgY29vcmRzID0gcG9pbnRNYXRyaXhbY29vcmRbMV1dW2Nvb3JkWzBdXS5zcGxpdCgnfCcpO1xuICAvLyAgICAgcGF0aC5wdXNoKFsrY29vcmRzWzBdLCArY29vcmRzWzFdXSk7IC8vIG1ha2Ugc3VyZSBjb29yZHMgYXJlIG51bWJlcnNcbiAgLy8gfSk7XG4gIC8vIHBhdGgucHVzaChlbmQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICByZXR1cm4gY2xlYW5Db29yZHMobGluZVN0cmluZyhwYXRoKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIFBvaW50IGlzIGluc2lkZSBhbnkgb2YgdGhlIFBvbHlnb25zXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHB0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBwb2x5Z29ucyBmZWF0dXJlc1xuICogQHJldHVybnMge2Jvb2xlYW59IGlmIGluc2lkZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gaXNJbnNpZGUocHQsIHBvbHlnb25zKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbnMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYm9vbGVhblBvaW50SW5Qb2x5Z29uKHB0LCBwb2x5Z29ucy5mZWF0dXJlc1tpXSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNob3J0ZXN0UGF0aDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+shortest-path@6.5.0/node_modules/@turf/shortest-path/dist/es/index.js\n");

/***/ })

};
;
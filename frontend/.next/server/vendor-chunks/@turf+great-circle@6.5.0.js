"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@turf+great-circle@6.5.0";
exports.ids = ["vendor-chunks/@turf+great-circle@6.5.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@turf+great-circle@6.5.0/node_modules/@turf/great-circle/dist/es/index.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@turf+great-circle@6.5.0/node_modules/@turf/great-circle/dist/es/index.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _turf_invariant__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/invariant */ \"(ssr)/./node_modules/.pnpm/@turf+invariant@6.5.0/node_modules/@turf/invariant/dist/es/index.js\");\n\n\nvar D2R = Math.PI / 180;\nvar R2D = 180 / Math.PI;\n\nvar Coord = function (lon, lat) {\n  this.lon = lon;\n  this.lat = lat;\n  this.x = D2R * lon;\n  this.y = D2R * lat;\n};\n\nCoord.prototype.view = function () {\n  return String(this.lon).slice(0, 4) + \",\" + String(this.lat).slice(0, 4);\n};\n\nCoord.prototype.antipode = function () {\n  var anti_lat = -1 * this.lat;\n  var anti_lon = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;\n  return new Coord(anti_lon, anti_lat);\n};\n\nvar LineString = function () {\n  this.coords = [];\n  this.length = 0;\n};\n\nLineString.prototype.move_to = function (coord) {\n  this.length++;\n  this.coords.push(coord);\n};\n\nvar Arc = function (properties) {\n  this.properties = properties || {};\n  this.geometries = [];\n};\n\nArc.prototype.json = function () {\n  if (this.geometries.length <= 0) {\n    return {\n      geometry: { type: \"LineString\", coordinates: null },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  } else if (this.geometries.length === 1) {\n    return {\n      geometry: { type: \"LineString\", coordinates: this.geometries[0].coords },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  } else {\n    var multiline = [];\n    for (var i = 0; i < this.geometries.length; i++) {\n      multiline.push(this.geometries[i].coords);\n    }\n    return {\n      geometry: { type: \"MultiLineString\", coordinates: multiline },\n      type: \"Feature\",\n      properties: this.properties,\n    };\n  }\n};\n\n// TODO - output proper multilinestring\nArc.prototype.wkt = function () {\n  var wkt_string = \"\";\n  var wkt = \"LINESTRING(\";\n  var collect = function (c) {\n    wkt += c[0] + \" \" + c[1] + \",\";\n  };\n  for (var i = 0; i < this.geometries.length; i++) {\n    if (this.geometries[i].coords.length === 0) {\n      return \"LINESTRING(empty)\";\n    } else {\n      var coords = this.geometries[i].coords;\n      coords.forEach(collect);\n      wkt_string += wkt.substring(0, wkt.length - 1) + \")\";\n    }\n  }\n  return wkt_string;\n};\n\n/*\n * http://en.wikipedia.org/wiki/Great-circle_distance\n *\n */\nvar GreatCircle = function (start, end, properties) {\n  if (!start || start.x === undefined || start.y === undefined) {\n    throw new Error(\n      \"GreatCircle constructor expects two args: start and end objects with x and y properties\"\n    );\n  }\n  if (!end || end.x === undefined || end.y === undefined) {\n    throw new Error(\n      \"GreatCircle constructor expects two args: start and end objects with x and y properties\"\n    );\n  }\n  this.start = new Coord(start.x, start.y);\n  this.end = new Coord(end.x, end.y);\n  this.properties = properties || {};\n\n  var w = this.start.x - this.end.x;\n  var h = this.start.y - this.end.y;\n  var z =\n    Math.pow(Math.sin(h / 2.0), 2) +\n    Math.cos(this.start.y) *\n      Math.cos(this.end.y) *\n      Math.pow(Math.sin(w / 2.0), 2);\n  this.g = 2.0 * Math.asin(Math.sqrt(z));\n\n  if (this.g === Math.PI) {\n    throw new Error(\n      \"it appears \" +\n        start.view() +\n        \" and \" +\n        end.view() +\n        \" are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite\"\n    );\n  } else if (isNaN(this.g)) {\n    throw new Error(\n      \"could not calculate great circle between \" + start + \" and \" + end\n    );\n  }\n};\n\n/*\n * http://williams.best.vwh.net/avform.htm#Intermediate\n */\nGreatCircle.prototype.interpolate = function (f) {\n  var A = Math.sin((1 - f) * this.g) / Math.sin(this.g);\n  var B = Math.sin(f * this.g) / Math.sin(this.g);\n  var x =\n    A * Math.cos(this.start.y) * Math.cos(this.start.x) +\n    B * Math.cos(this.end.y) * Math.cos(this.end.x);\n  var y =\n    A * Math.cos(this.start.y) * Math.sin(this.start.x) +\n    B * Math.cos(this.end.y) * Math.sin(this.end.x);\n  var z = A * Math.sin(this.start.y) + B * Math.sin(this.end.y);\n  var lat = R2D * Math.atan2(z, Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)));\n  var lon = R2D * Math.atan2(y, x);\n  return [lon, lat];\n};\n\n/*\n * Generate points along the great circle\n */\nGreatCircle.prototype.Arc = function (npoints, options) {\n  var first_pass = [];\n  if (!npoints || npoints <= 2) {\n    first_pass.push([this.start.lon, this.start.lat]);\n    first_pass.push([this.end.lon, this.end.lat]);\n  } else {\n    var delta = 1.0 / (npoints - 1);\n    for (var i = 0; i < npoints; ++i) {\n      var step = delta * i;\n      var pair = this.interpolate(step);\n      first_pass.push(pair);\n    }\n  }\n  /* partial port of dateline handling from:\n      gdal/ogr/ogrgeometryfactory.cpp\n\n      TODO - does not handle all wrapping scenarios yet\n    */\n  var bHasBigDiff = false;\n  var dfMaxSmallDiffLong = 0;\n  // from http://www.gdal.org/ogr2ogr.html\n  // -datelineoffset:\n  // (starting with GDAL 1.10) offset from dateline in degrees (default long. = +/- 10deg, geometries within 170deg to -170deg will be splited)\n  var dfDateLineOffset = options && options.offset ? options.offset : 10;\n  var dfLeftBorderX = 180 - dfDateLineOffset;\n  var dfRightBorderX = -180 + dfDateLineOffset;\n  var dfDiffSpace = 360 - dfDateLineOffset;\n\n  // https://github.com/OSGeo/gdal/blob/7bfb9c452a59aac958bff0c8386b891edf8154ca/gdal/ogr/ogrgeometryfactory.cpp#L2342\n  for (var j = 1; j < first_pass.length; ++j) {\n    var dfPrevX = first_pass[j - 1][0];\n    var dfX = first_pass[j][0];\n    var dfDiffLong = Math.abs(dfX - dfPrevX);\n    if (\n      dfDiffLong > dfDiffSpace &&\n      ((dfX > dfLeftBorderX && dfPrevX < dfRightBorderX) ||\n        (dfPrevX > dfLeftBorderX && dfX < dfRightBorderX))\n    ) {\n      bHasBigDiff = true;\n    } else if (dfDiffLong > dfMaxSmallDiffLong) {\n      dfMaxSmallDiffLong = dfDiffLong;\n    }\n  }\n\n  var poMulti = [];\n  if (bHasBigDiff && dfMaxSmallDiffLong < dfDateLineOffset) {\n    var poNewLS = [];\n    poMulti.push(poNewLS);\n    for (var k = 0; k < first_pass.length; ++k) {\n      var dfX0 = parseFloat(first_pass[k][0]);\n      if (k > 0 && Math.abs(dfX0 - first_pass[k - 1][0]) > dfDiffSpace) {\n        var dfX1 = parseFloat(first_pass[k - 1][0]);\n        var dfY1 = parseFloat(first_pass[k - 1][1]);\n        var dfX2 = parseFloat(first_pass[k][0]);\n        var dfY2 = parseFloat(first_pass[k][1]);\n        if (\n          dfX1 > -180 &&\n          dfX1 < dfRightBorderX &&\n          dfX2 === 180 &&\n          k + 1 < first_pass.length &&\n          first_pass[k - 1][0] > -180 &&\n          first_pass[k - 1][0] < dfRightBorderX\n        ) {\n          poNewLS.push([-180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        } else if (\n          dfX1 > dfLeftBorderX &&\n          dfX1 < 180 &&\n          dfX2 === -180 &&\n          k + 1 < first_pass.length &&\n          first_pass[k - 1][0] > dfLeftBorderX &&\n          first_pass[k - 1][0] < 180\n        ) {\n          poNewLS.push([180, first_pass[k][1]]);\n          k++;\n          poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n          continue;\n        }\n\n        if (dfX1 < dfRightBorderX && dfX2 > dfLeftBorderX) {\n          // swap dfX1, dfX2\n          var tmpX = dfX1;\n          dfX1 = dfX2;\n          dfX2 = tmpX;\n          // swap dfY1, dfY2\n          var tmpY = dfY1;\n          dfY1 = dfY2;\n          dfY2 = tmpY;\n        }\n        if (dfX1 > dfLeftBorderX && dfX2 < dfRightBorderX) {\n          dfX2 += 360;\n        }\n\n        if (dfX1 <= 180 && dfX2 >= 180 && dfX1 < dfX2) {\n          var dfRatio = (180 - dfX1) / (dfX2 - dfX1);\n          var dfY = dfRatio * dfY2 + (1 - dfRatio) * dfY1;\n          poNewLS.push([\n            first_pass[k - 1][0] > dfLeftBorderX ? 180 : -180,\n            dfY,\n          ]);\n          poNewLS = [];\n          poNewLS.push([\n            first_pass[k - 1][0] > dfLeftBorderX ? -180 : 180,\n            dfY,\n          ]);\n          poMulti.push(poNewLS);\n        } else {\n          poNewLS = [];\n          poMulti.push(poNewLS);\n        }\n        poNewLS.push([dfX0, first_pass[k][1]]);\n      } else {\n        poNewLS.push([first_pass[k][0], first_pass[k][1]]);\n      }\n    }\n  } else {\n    // add normally\n    var poNewLS0 = [];\n    poMulti.push(poNewLS0);\n    for (var l = 0; l < first_pass.length; ++l) {\n      poNewLS0.push([first_pass[l][0], first_pass[l][1]]);\n    }\n  }\n\n  var arc = new Arc(this.properties);\n  for (var m = 0; m < poMulti.length; ++m) {\n    var line = new LineString();\n    arc.geometries.push(line);\n    var points = poMulti[m];\n    for (var j0 = 0; j0 < points.length; ++j0) {\n      line.move_to(points[j0]);\n    }\n  }\n  return arc;\n};\n\n/**\n * Calculate great circles routes as {@link LineString} or {@link MultiLineString}.\n * If the `start` and `end` points span the antimeridian, the resulting feature will\n * be split into a `MultiLineString`.\n *\n * @name greatCircle\n * @param {Coord} start source point feature\n * @param {Coord} end destination point feature\n * @param {Object} [options={}] Optional parameters\n * @param {Object} [options.properties={}] line feature properties\n * @param {number} [options.npoints=100] number of points\n * @param {number} [options.offset=10] offset controls the likelyhood that lines will\n * be split which cross the dateline. The higher the number the more likely.\n * @returns {Feature<LineString | MultiLineString>} great circle line feature\n * @example\n * var start = turf.point([-122, 48]);\n * var end = turf.point([-77, 39]);\n *\n * var greatCircle = turf.greatCircle(start, end, {properties: {name: 'Seattle to DC'}});\n *\n * //addToMap\n * var addToMap = [start, end, greatCircle]\n */\nfunction greatCircle(start, end, options) {\n  // Optional parameters\n  options = options || {};\n  if (typeof options !== \"object\") throw new Error(\"options is invalid\");\n  var properties = options.properties;\n  var npoints = options.npoints;\n  var offset = options.offset;\n\n  start = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.getCoord)(start);\n  end = (0,_turf_invariant__WEBPACK_IMPORTED_MODULE_0__.getCoord)(end);\n  properties = properties || {};\n  npoints = npoints || 100;\n  offset = offset || 10;\n\n  var generator = new GreatCircle(\n    { x: start[0], y: start[1] },\n    { x: end[0], y: end[1] },\n    properties\n  );\n\n  var line = generator.Arc(npoints, { offset: offset });\n\n  return line.json();\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (greatCircle);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrZ3JlYXQtY2lyY2xlQDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi9ncmVhdC1jaXJjbGUvZGlzdC9lcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEyQzs7QUFFM0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVDQUF1QztBQUN6RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrQkFBa0IsNERBQTREO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQiw0QkFBNEI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFpRDtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG9CQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDLGtCQUFrQixJQUFJLHNCQUFzQjtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRLFdBQVc7QUFDOUIsV0FBVyxRQUFRLHNCQUFzQjtBQUN6QyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSx1Q0FBdUM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsYUFBYSx1QkFBdUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLHlEQUFRO0FBQ2xCLFFBQVEseURBQVE7QUFDaEI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwQkFBMEI7QUFDaEMsTUFBTSxzQkFBc0I7QUFDNUI7QUFDQTs7QUFFQSxzQ0FBc0MsZ0JBQWdCOztBQUV0RDtBQUNBOztBQUVBLGlFQUFlLFdBQVcsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL21mdmFsdWUtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvLnBucG0vQHR1cmYrZ3JlYXQtY2lyY2xlQDYuNS4wL25vZGVfbW9kdWxlcy9AdHVyZi9ncmVhdC1jaXJjbGUvZGlzdC9lcy9pbmRleC5qcz9iMTc2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldENvb3JkIH0gZnJvbSAnQHR1cmYvaW52YXJpYW50JztcblxudmFyIEQyUiA9IE1hdGguUEkgLyAxODA7XG52YXIgUjJEID0gMTgwIC8gTWF0aC5QSTtcblxudmFyIENvb3JkID0gZnVuY3Rpb24gKGxvbiwgbGF0KSB7XG4gIHRoaXMubG9uID0gbG9uO1xuICB0aGlzLmxhdCA9IGxhdDtcbiAgdGhpcy54ID0gRDJSICogbG9uO1xuICB0aGlzLnkgPSBEMlIgKiBsYXQ7XG59O1xuXG5Db29yZC5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFN0cmluZyh0aGlzLmxvbikuc2xpY2UoMCwgNCkgKyBcIixcIiArIFN0cmluZyh0aGlzLmxhdCkuc2xpY2UoMCwgNCk7XG59O1xuXG5Db29yZC5wcm90b3R5cGUuYW50aXBvZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhbnRpX2xhdCA9IC0xICogdGhpcy5sYXQ7XG4gIHZhciBhbnRpX2xvbiA9IHRoaXMubG9uIDwgMCA/IDE4MCArIHRoaXMubG9uIDogKDE4MCAtIHRoaXMubG9uKSAqIC0xO1xuICByZXR1cm4gbmV3IENvb3JkKGFudGlfbG9uLCBhbnRpX2xhdCk7XG59O1xuXG52YXIgTGluZVN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jb29yZHMgPSBbXTtcbiAgdGhpcy5sZW5ndGggPSAwO1xufTtcblxuTGluZVN0cmluZy5wcm90b3R5cGUubW92ZV90byA9IGZ1bmN0aW9uIChjb29yZCkge1xuICB0aGlzLmxlbmd0aCsrO1xuICB0aGlzLmNvb3Jkcy5wdXNoKGNvb3JkKTtcbn07XG5cbnZhciBBcmMgPSBmdW5jdGlvbiAocHJvcGVydGllcykge1xuICB0aGlzLnByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IHt9O1xuICB0aGlzLmdlb21ldHJpZXMgPSBbXTtcbn07XG5cbkFyYy5wcm90b3R5cGUuanNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGggPD0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICBnZW9tZXRyeTogeyB0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IG51bGwgfSxcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzLFxuICAgIH07XG4gIH0gZWxzZSBpZiAodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBnZW9tZXRyeTogeyB0eXBlOiBcIkxpbmVTdHJpbmdcIiwgY29vcmRpbmF0ZXM6IHRoaXMuZ2VvbWV0cmllc1swXS5jb29yZHMgfSxcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzLFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdmFyIG11bHRpbGluZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBtdWx0aWxpbmUucHVzaCh0aGlzLmdlb21ldHJpZXNbaV0uY29vcmRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGdlb21ldHJ5OiB7IHR5cGU6IFwiTXVsdGlMaW5lU3RyaW5nXCIsIGNvb3JkaW5hdGVzOiBtdWx0aWxpbmUgfSxcbiAgICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzLFxuICAgIH07XG4gIH1cbn07XG5cbi8vIFRPRE8gLSBvdXRwdXQgcHJvcGVyIG11bHRpbGluZXN0cmluZ1xuQXJjLnByb3RvdHlwZS53a3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB3a3Rfc3RyaW5nID0gXCJcIjtcbiAgdmFyIHdrdCA9IFwiTElORVNUUklORyhcIjtcbiAgdmFyIGNvbGxlY3QgPSBmdW5jdGlvbiAoYykge1xuICAgIHdrdCArPSBjWzBdICsgXCIgXCIgKyBjWzFdICsgXCIsXCI7XG4gIH07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRoaXMuZ2VvbWV0cmllc1tpXS5jb29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gXCJMSU5FU1RSSU5HKGVtcHR5KVwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29vcmRzID0gdGhpcy5nZW9tZXRyaWVzW2ldLmNvb3JkcztcbiAgICAgIGNvb3Jkcy5mb3JFYWNoKGNvbGxlY3QpO1xuICAgICAgd2t0X3N0cmluZyArPSB3a3Quc3Vic3RyaW5nKDAsIHdrdC5sZW5ndGggLSAxKSArIFwiKVwiO1xuICAgIH1cbiAgfVxuICByZXR1cm4gd2t0X3N0cmluZztcbn07XG5cbi8qXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0dyZWF0LWNpcmNsZV9kaXN0YW5jZVxuICpcbiAqL1xudmFyIEdyZWF0Q2lyY2xlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIHByb3BlcnRpZXMpIHtcbiAgaWYgKCFzdGFydCB8fCBzdGFydC54ID09PSB1bmRlZmluZWQgfHwgc3RhcnQueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJHcmVhdENpcmNsZSBjb25zdHJ1Y3RvciBleHBlY3RzIHR3byBhcmdzOiBzdGFydCBhbmQgZW5kIG9iamVjdHMgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcIlxuICAgICk7XG4gIH1cbiAgaWYgKCFlbmQgfHwgZW5kLnggPT09IHVuZGVmaW5lZCB8fCBlbmQueSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJHcmVhdENpcmNsZSBjb25zdHJ1Y3RvciBleHBlY3RzIHR3byBhcmdzOiBzdGFydCBhbmQgZW5kIG9iamVjdHMgd2l0aCB4IGFuZCB5IHByb3BlcnRpZXNcIlxuICAgICk7XG4gIH1cbiAgdGhpcy5zdGFydCA9IG5ldyBDb29yZChzdGFydC54LCBzdGFydC55KTtcbiAgdGhpcy5lbmQgPSBuZXcgQ29vcmQoZW5kLngsIGVuZC55KTtcbiAgdGhpcy5wcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCB7fTtcblxuICB2YXIgdyA9IHRoaXMuc3RhcnQueCAtIHRoaXMuZW5kLng7XG4gIHZhciBoID0gdGhpcy5zdGFydC55IC0gdGhpcy5lbmQueTtcbiAgdmFyIHogPVxuICAgIE1hdGgucG93KE1hdGguc2luKGggLyAyLjApLCAyKSArXG4gICAgTWF0aC5jb3ModGhpcy5zdGFydC55KSAqXG4gICAgICBNYXRoLmNvcyh0aGlzLmVuZC55KSAqXG4gICAgICBNYXRoLnBvdyhNYXRoLnNpbih3IC8gMi4wKSwgMik7XG4gIHRoaXMuZyA9IDIuMCAqIE1hdGguYXNpbihNYXRoLnNxcnQoeikpO1xuXG4gIGlmICh0aGlzLmcgPT09IE1hdGguUEkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIml0IGFwcGVhcnMgXCIgK1xuICAgICAgICBzdGFydC52aWV3KCkgK1xuICAgICAgICBcIiBhbmQgXCIgK1xuICAgICAgICBlbmQudmlldygpICtcbiAgICAgICAgXCIgYXJlICdhbnRpcG9kYWwnLCBlLmcgZGlhbWV0cmljYWxseSBvcHBvc2l0ZSwgdGh1cyB0aGVyZSBpcyBubyBzaW5nbGUgcm91dGUgYnV0IHJhdGhlciBpbmZpbml0ZVwiXG4gICAgKTtcbiAgfSBlbHNlIGlmIChpc05hTih0aGlzLmcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJjb3VsZCBub3QgY2FsY3VsYXRlIGdyZWF0IGNpcmNsZSBiZXR3ZWVuIFwiICsgc3RhcnQgKyBcIiBhbmQgXCIgKyBlbmRcbiAgICApO1xuICB9XG59O1xuXG4vKlxuICogaHR0cDovL3dpbGxpYW1zLmJlc3QudndoLm5ldC9hdmZvcm0uaHRtI0ludGVybWVkaWF0ZVxuICovXG5HcmVhdENpcmNsZS5wcm90b3R5cGUuaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiAoZikge1xuICB2YXIgQSA9IE1hdGguc2luKCgxIC0gZikgKiB0aGlzLmcpIC8gTWF0aC5zaW4odGhpcy5nKTtcbiAgdmFyIEIgPSBNYXRoLnNpbihmICogdGhpcy5nKSAvIE1hdGguc2luKHRoaXMuZyk7XG4gIHZhciB4ID1cbiAgICBBICogTWF0aC5jb3ModGhpcy5zdGFydC55KSAqIE1hdGguY29zKHRoaXMuc3RhcnQueCkgK1xuICAgIEIgKiBNYXRoLmNvcyh0aGlzLmVuZC55KSAqIE1hdGguY29zKHRoaXMuZW5kLngpO1xuICB2YXIgeSA9XG4gICAgQSAqIE1hdGguY29zKHRoaXMuc3RhcnQueSkgKiBNYXRoLnNpbih0aGlzLnN0YXJ0LngpICtcbiAgICBCICogTWF0aC5jb3ModGhpcy5lbmQueSkgKiBNYXRoLnNpbih0aGlzLmVuZC54KTtcbiAgdmFyIHogPSBBICogTWF0aC5zaW4odGhpcy5zdGFydC55KSArIEIgKiBNYXRoLnNpbih0aGlzLmVuZC55KTtcbiAgdmFyIGxhdCA9IFIyRCAqIE1hdGguYXRhbjIoeiwgTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpKTtcbiAgdmFyIGxvbiA9IFIyRCAqIE1hdGguYXRhbjIoeSwgeCk7XG4gIHJldHVybiBbbG9uLCBsYXRdO1xufTtcblxuLypcbiAqIEdlbmVyYXRlIHBvaW50cyBhbG9uZyB0aGUgZ3JlYXQgY2lyY2xlXG4gKi9cbkdyZWF0Q2lyY2xlLnByb3RvdHlwZS5BcmMgPSBmdW5jdGlvbiAobnBvaW50cywgb3B0aW9ucykge1xuICB2YXIgZmlyc3RfcGFzcyA9IFtdO1xuICBpZiAoIW5wb2ludHMgfHwgbnBvaW50cyA8PSAyKSB7XG4gICAgZmlyc3RfcGFzcy5wdXNoKFt0aGlzLnN0YXJ0LmxvbiwgdGhpcy5zdGFydC5sYXRdKTtcbiAgICBmaXJzdF9wYXNzLnB1c2goW3RoaXMuZW5kLmxvbiwgdGhpcy5lbmQubGF0XSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbHRhID0gMS4wIC8gKG5wb2ludHMgLSAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5wb2ludHM7ICsraSkge1xuICAgICAgdmFyIHN0ZXAgPSBkZWx0YSAqIGk7XG4gICAgICB2YXIgcGFpciA9IHRoaXMuaW50ZXJwb2xhdGUoc3RlcCk7XG4gICAgICBmaXJzdF9wYXNzLnB1c2gocGFpcik7XG4gICAgfVxuICB9XG4gIC8qIHBhcnRpYWwgcG9ydCBvZiBkYXRlbGluZSBoYW5kbGluZyBmcm9tOlxuICAgICAgZ2RhbC9vZ3Ivb2dyZ2VvbWV0cnlmYWN0b3J5LmNwcFxuXG4gICAgICBUT0RPIC0gZG9lcyBub3QgaGFuZGxlIGFsbCB3cmFwcGluZyBzY2VuYXJpb3MgeWV0XG4gICAgKi9cbiAgdmFyIGJIYXNCaWdEaWZmID0gZmFsc2U7XG4gIHZhciBkZk1heFNtYWxsRGlmZkxvbmcgPSAwO1xuICAvLyBmcm9tIGh0dHA6Ly93d3cuZ2RhbC5vcmcvb2dyMm9nci5odG1sXG4gIC8vIC1kYXRlbGluZW9mZnNldDpcbiAgLy8gKHN0YXJ0aW5nIHdpdGggR0RBTCAxLjEwKSBvZmZzZXQgZnJvbSBkYXRlbGluZSBpbiBkZWdyZWVzIChkZWZhdWx0IGxvbmcuID0gKy8tIDEwZGVnLCBnZW9tZXRyaWVzIHdpdGhpbiAxNzBkZWcgdG8gLTE3MGRlZyB3aWxsIGJlIHNwbGl0ZWQpXG4gIHZhciBkZkRhdGVMaW5lT2Zmc2V0ID0gb3B0aW9ucyAmJiBvcHRpb25zLm9mZnNldCA/IG9wdGlvbnMub2Zmc2V0IDogMTA7XG4gIHZhciBkZkxlZnRCb3JkZXJYID0gMTgwIC0gZGZEYXRlTGluZU9mZnNldDtcbiAgdmFyIGRmUmlnaHRCb3JkZXJYID0gLTE4MCArIGRmRGF0ZUxpbmVPZmZzZXQ7XG4gIHZhciBkZkRpZmZTcGFjZSA9IDM2MCAtIGRmRGF0ZUxpbmVPZmZzZXQ7XG5cbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL09TR2VvL2dkYWwvYmxvYi83YmZiOWM0NTJhNTlhYWM5NThiZmYwYzgzODZiODkxZWRmODE1NGNhL2dkYWwvb2dyL29ncmdlb21ldHJ5ZmFjdG9yeS5jcHAjTDIzNDJcbiAgZm9yICh2YXIgaiA9IDE7IGogPCBmaXJzdF9wYXNzLmxlbmd0aDsgKytqKSB7XG4gICAgdmFyIGRmUHJldlggPSBmaXJzdF9wYXNzW2ogLSAxXVswXTtcbiAgICB2YXIgZGZYID0gZmlyc3RfcGFzc1tqXVswXTtcbiAgICB2YXIgZGZEaWZmTG9uZyA9IE1hdGguYWJzKGRmWCAtIGRmUHJldlgpO1xuICAgIGlmIChcbiAgICAgIGRmRGlmZkxvbmcgPiBkZkRpZmZTcGFjZSAmJlxuICAgICAgKChkZlggPiBkZkxlZnRCb3JkZXJYICYmIGRmUHJldlggPCBkZlJpZ2h0Qm9yZGVyWCkgfHxcbiAgICAgICAgKGRmUHJldlggPiBkZkxlZnRCb3JkZXJYICYmIGRmWCA8IGRmUmlnaHRCb3JkZXJYKSlcbiAgICApIHtcbiAgICAgIGJIYXNCaWdEaWZmID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRmRGlmZkxvbmcgPiBkZk1heFNtYWxsRGlmZkxvbmcpIHtcbiAgICAgIGRmTWF4U21hbGxEaWZmTG9uZyA9IGRmRGlmZkxvbmc7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBvTXVsdGkgPSBbXTtcbiAgaWYgKGJIYXNCaWdEaWZmICYmIGRmTWF4U21hbGxEaWZmTG9uZyA8IGRmRGF0ZUxpbmVPZmZzZXQpIHtcbiAgICB2YXIgcG9OZXdMUyA9IFtdO1xuICAgIHBvTXVsdGkucHVzaChwb05ld0xTKTtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IGZpcnN0X3Bhc3MubGVuZ3RoOyArK2spIHtcbiAgICAgIHZhciBkZlgwID0gcGFyc2VGbG9hdChmaXJzdF9wYXNzW2tdWzBdKTtcbiAgICAgIGlmIChrID4gMCAmJiBNYXRoLmFicyhkZlgwIC0gZmlyc3RfcGFzc1trIC0gMV1bMF0pID4gZGZEaWZmU3BhY2UpIHtcbiAgICAgICAgdmFyIGRmWDEgPSBwYXJzZUZsb2F0KGZpcnN0X3Bhc3NbayAtIDFdWzBdKTtcbiAgICAgICAgdmFyIGRmWTEgPSBwYXJzZUZsb2F0KGZpcnN0X3Bhc3NbayAtIDFdWzFdKTtcbiAgICAgICAgdmFyIGRmWDIgPSBwYXJzZUZsb2F0KGZpcnN0X3Bhc3Nba11bMF0pO1xuICAgICAgICB2YXIgZGZZMiA9IHBhcnNlRmxvYXQoZmlyc3RfcGFzc1trXVsxXSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBkZlgxID4gLTE4MCAmJlxuICAgICAgICAgIGRmWDEgPCBkZlJpZ2h0Qm9yZGVyWCAmJlxuICAgICAgICAgIGRmWDIgPT09IDE4MCAmJlxuICAgICAgICAgIGsgKyAxIDwgZmlyc3RfcGFzcy5sZW5ndGggJiZcbiAgICAgICAgICBmaXJzdF9wYXNzW2sgLSAxXVswXSA+IC0xODAgJiZcbiAgICAgICAgICBmaXJzdF9wYXNzW2sgLSAxXVswXSA8IGRmUmlnaHRCb3JkZXJYXG4gICAgICAgICkge1xuICAgICAgICAgIHBvTmV3TFMucHVzaChbLTE4MCwgZmlyc3RfcGFzc1trXVsxXV0pO1xuICAgICAgICAgIGsrKztcbiAgICAgICAgICBwb05ld0xTLnB1c2goW2ZpcnN0X3Bhc3Nba11bMF0sIGZpcnN0X3Bhc3Nba11bMV1dKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBkZlgxID4gZGZMZWZ0Qm9yZGVyWCAmJlxuICAgICAgICAgIGRmWDEgPCAxODAgJiZcbiAgICAgICAgICBkZlgyID09PSAtMTgwICYmXG4gICAgICAgICAgayArIDEgPCBmaXJzdF9wYXNzLmxlbmd0aCAmJlxuICAgICAgICAgIGZpcnN0X3Bhc3NbayAtIDFdWzBdID4gZGZMZWZ0Qm9yZGVyWCAmJlxuICAgICAgICAgIGZpcnN0X3Bhc3NbayAtIDFdWzBdIDwgMTgwXG4gICAgICAgICkge1xuICAgICAgICAgIHBvTmV3TFMucHVzaChbMTgwLCBmaXJzdF9wYXNzW2tdWzFdXSk7XG4gICAgICAgICAgaysrO1xuICAgICAgICAgIHBvTmV3TFMucHVzaChbZmlyc3RfcGFzc1trXVswXSwgZmlyc3RfcGFzc1trXVsxXV0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRmWDEgPCBkZlJpZ2h0Qm9yZGVyWCAmJiBkZlgyID4gZGZMZWZ0Qm9yZGVyWCkge1xuICAgICAgICAgIC8vIHN3YXAgZGZYMSwgZGZYMlxuICAgICAgICAgIHZhciB0bXBYID0gZGZYMTtcbiAgICAgICAgICBkZlgxID0gZGZYMjtcbiAgICAgICAgICBkZlgyID0gdG1wWDtcbiAgICAgICAgICAvLyBzd2FwIGRmWTEsIGRmWTJcbiAgICAgICAgICB2YXIgdG1wWSA9IGRmWTE7XG4gICAgICAgICAgZGZZMSA9IGRmWTI7XG4gICAgICAgICAgZGZZMiA9IHRtcFk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRmWDEgPiBkZkxlZnRCb3JkZXJYICYmIGRmWDIgPCBkZlJpZ2h0Qm9yZGVyWCkge1xuICAgICAgICAgIGRmWDIgKz0gMzYwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRmWDEgPD0gMTgwICYmIGRmWDIgPj0gMTgwICYmIGRmWDEgPCBkZlgyKSB7XG4gICAgICAgICAgdmFyIGRmUmF0aW8gPSAoMTgwIC0gZGZYMSkgLyAoZGZYMiAtIGRmWDEpO1xuICAgICAgICAgIHZhciBkZlkgPSBkZlJhdGlvICogZGZZMiArICgxIC0gZGZSYXRpbykgKiBkZlkxO1xuICAgICAgICAgIHBvTmV3TFMucHVzaChbXG4gICAgICAgICAgICBmaXJzdF9wYXNzW2sgLSAxXVswXSA+IGRmTGVmdEJvcmRlclggPyAxODAgOiAtMTgwLFxuICAgICAgICAgICAgZGZZLFxuICAgICAgICAgIF0pO1xuICAgICAgICAgIHBvTmV3TFMgPSBbXTtcbiAgICAgICAgICBwb05ld0xTLnB1c2goW1xuICAgICAgICAgICAgZmlyc3RfcGFzc1trIC0gMV1bMF0gPiBkZkxlZnRCb3JkZXJYID8gLTE4MCA6IDE4MCxcbiAgICAgICAgICAgIGRmWSxcbiAgICAgICAgICBdKTtcbiAgICAgICAgICBwb011bHRpLnB1c2gocG9OZXdMUyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcG9OZXdMUyA9IFtdO1xuICAgICAgICAgIHBvTXVsdGkucHVzaChwb05ld0xTKTtcbiAgICAgICAgfVxuICAgICAgICBwb05ld0xTLnB1c2goW2RmWDAsIGZpcnN0X3Bhc3Nba11bMV1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBvTmV3TFMucHVzaChbZmlyc3RfcGFzc1trXVswXSwgZmlyc3RfcGFzc1trXVsxXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBhZGQgbm9ybWFsbHlcbiAgICB2YXIgcG9OZXdMUzAgPSBbXTtcbiAgICBwb011bHRpLnB1c2gocG9OZXdMUzApO1xuICAgIGZvciAodmFyIGwgPSAwOyBsIDwgZmlyc3RfcGFzcy5sZW5ndGg7ICsrbCkge1xuICAgICAgcG9OZXdMUzAucHVzaChbZmlyc3RfcGFzc1tsXVswXSwgZmlyc3RfcGFzc1tsXVsxXV0pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBhcmMgPSBuZXcgQXJjKHRoaXMucHJvcGVydGllcyk7XG4gIGZvciAodmFyIG0gPSAwOyBtIDwgcG9NdWx0aS5sZW5ndGg7ICsrbSkge1xuICAgIHZhciBsaW5lID0gbmV3IExpbmVTdHJpbmcoKTtcbiAgICBhcmMuZ2VvbWV0cmllcy5wdXNoKGxpbmUpO1xuICAgIHZhciBwb2ludHMgPSBwb011bHRpW21dO1xuICAgIGZvciAodmFyIGowID0gMDsgajAgPCBwb2ludHMubGVuZ3RoOyArK2owKSB7XG4gICAgICBsaW5lLm1vdmVfdG8ocG9pbnRzW2owXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcmM7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZSBncmVhdCBjaXJjbGVzIHJvdXRlcyBhcyB7QGxpbmsgTGluZVN0cmluZ30gb3Ige0BsaW5rIE11bHRpTGluZVN0cmluZ30uXG4gKiBJZiB0aGUgYHN0YXJ0YCBhbmQgYGVuZGAgcG9pbnRzIHNwYW4gdGhlIGFudGltZXJpZGlhbiwgdGhlIHJlc3VsdGluZyBmZWF0dXJlIHdpbGxcbiAqIGJlIHNwbGl0IGludG8gYSBgTXVsdGlMaW5lU3RyaW5nYC5cbiAqXG4gKiBAbmFtZSBncmVhdENpcmNsZVxuICogQHBhcmFtIHtDb29yZH0gc3RhcnQgc291cmNlIHBvaW50IGZlYXR1cmVcbiAqIEBwYXJhbSB7Q29vcmR9IGVuZCBkZXN0aW5hdGlvbiBwb2ludCBmZWF0dXJlXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5wcm9wZXJ0aWVzPXt9XSBsaW5lIGZlYXR1cmUgcHJvcGVydGllc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm5wb2ludHM9MTAwXSBudW1iZXIgb2YgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMub2Zmc2V0PTEwXSBvZmZzZXQgY29udHJvbHMgdGhlIGxpa2VseWhvb2QgdGhhdCBsaW5lcyB3aWxsXG4gKiBiZSBzcGxpdCB3aGljaCBjcm9zcyB0aGUgZGF0ZWxpbmUuIFRoZSBoaWdoZXIgdGhlIG51bWJlciB0aGUgbW9yZSBsaWtlbHkuXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nIHwgTXVsdGlMaW5lU3RyaW5nPn0gZ3JlYXQgY2lyY2xlIGxpbmUgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBzdGFydCA9IHR1cmYucG9pbnQoWy0xMjIsIDQ4XSk7XG4gKiB2YXIgZW5kID0gdHVyZi5wb2ludChbLTc3LCAzOV0pO1xuICpcbiAqIHZhciBncmVhdENpcmNsZSA9IHR1cmYuZ3JlYXRDaXJjbGUoc3RhcnQsIGVuZCwge3Byb3BlcnRpZXM6IHtuYW1lOiAnU2VhdHRsZSB0byBEQyd9fSk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW3N0YXJ0LCBlbmQsIGdyZWF0Q2lyY2xlXVxuICovXG5mdW5jdGlvbiBncmVhdENpcmNsZShzdGFydCwgZW5kLCBvcHRpb25zKSB7XG4gIC8vIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucyBpcyBpbnZhbGlkXCIpO1xuICB2YXIgcHJvcGVydGllcyA9IG9wdGlvbnMucHJvcGVydGllcztcbiAgdmFyIG5wb2ludHMgPSBvcHRpb25zLm5wb2ludHM7XG4gIHZhciBvZmZzZXQgPSBvcHRpb25zLm9mZnNldDtcblxuICBzdGFydCA9IGdldENvb3JkKHN0YXJ0KTtcbiAgZW5kID0gZ2V0Q29vcmQoZW5kKTtcbiAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gIG5wb2ludHMgPSBucG9pbnRzIHx8IDEwMDtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDEwO1xuXG4gIHZhciBnZW5lcmF0b3IgPSBuZXcgR3JlYXRDaXJjbGUoXG4gICAgeyB4OiBzdGFydFswXSwgeTogc3RhcnRbMV0gfSxcbiAgICB7IHg6IGVuZFswXSwgeTogZW5kWzFdIH0sXG4gICAgcHJvcGVydGllc1xuICApO1xuXG4gIHZhciBsaW5lID0gZ2VuZXJhdG9yLkFyYyhucG9pbnRzLCB7IG9mZnNldDogb2Zmc2V0IH0pO1xuXG4gIHJldHVybiBsaW5lLmpzb24oKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ3JlYXRDaXJjbGU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@turf+great-circle@6.5.0/node_modules/@turf/great-circle/dist/es/index.js\n");

/***/ })

};
;